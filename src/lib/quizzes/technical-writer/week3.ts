import type { QuizQuestion } from "../types";

export const week3: Record<string, QuizQuestion[]> = {
  // Lesson 1: HTTP/JSON 基础（面向文档）(8题)
  "tw-w3-1": [
    {
      id: "tw-w3-1-q1",
      question: "HTTP 状态码 200 表示什么含义？",
      options: [
        "请求成功，服务器正常返回了请求的资源",
        "资源已创建",
        "请求被重定向到其他位置",
        "客户端请求格式错误",
      ],
      answer: 0,
      rationale:
        "HTTP 状态码 200 OK 表示请求成功，是最常见的成功响应状态码。",
    },
    {
      id: "tw-w3-1-q2",
      question: "HTTP 状态码 404 和 500 的区别是什么？",
      options: [
        "404 是客户端错误（资源不存在），500 是服务器内部错误",
        "404 表示请求超时，500 表示权限不足",
        "404 是临时错误，500 是永久错误",
        "两者含义相同，只是编号不同",
      ],
      answer: 0,
      rationale:
        "4xx 系列是客户端错误（如 404 Not Found），5xx 系列是服务器错误（如 500 Internal Server Error）。",
    },
    {
      id: "tw-w3-1-q3",
      question: "HTTP GET 和 POST 方法的主要区别是什么？",
      options: [
        "GET 用于获取资源且是幂等的，POST 用于提交数据且非幂等",
        "GET 用于删除资源，POST 用于更新资源",
        "GET 必须带请求体，POST 不需要",
        "GET 只能用于 HTML，POST 只能用于 JSON",
      ],
      answer: 0,
      rationale:
        "GET 是安全且幂等的读取操作，POST 用于创建资源或提交数据，可能改变服务器状态。",
    },
    {
      id: "tw-w3-1-q4",
      question: "JSON 支持哪些基本数据类型？",
      options: [
        "字符串、数字、布尔值、null、对象、数组",
        "只支持字符串和数字",
        "字符串、整数、浮点数、日期、二进制",
        "任何 JavaScript 支持的类型",
      ],
      answer: 0,
      rationale:
        "JSON 支持五种基本值类型：字符串、数字、布尔值、null，以及嵌套的对象和数组。",
    },
    {
      id: "tw-w3-1-q5",
      question: "在 HTTP 响应中，Content-Type 头的作用是什么？",
      options: [
        "告知客户端响应体的媒体类型（如 application/json）",
        "指定请求的认证方式",
        "控制响应的缓存策略",
        "设置跨域访问权限",
      ],
      answer: 0,
      rationale:
        "Content-Type 头告知客户端响应体的 MIME 类型，如 application/json、text/html 等。",
    },
    {
      id: "tw-w3-1-q6",
      question: "HTTP 状态码 401 和 403 的区别是什么？",
      options: [
        "401 表示未认证（需要登录），403 表示已认证但无权限",
        "401 表示服务器错误，403 表示客户端错误",
        "401 是临时性的，403 是永久性的",
        "两者含义完全相同",
      ],
      answer: 0,
      rationale:
        "401 Unauthorized 表示需要认证，403 Forbidden 表示已认证但没有访问权限。",
    },
    {
      id: "tw-w3-1-q7",
      question: "JSON 字符串必须使用什么符号包围？",
      options: [
        "双引号（\"）",
        "单引号（'）",
        "反引号（`）",
        "双引号或单引号均可",
      ],
      answer: 0,
      rationale:
        "JSON 规范要求字符串必须使用双引号包围，单引号不是有效的 JSON 语法。",
    },
    {
      id: "tw-w3-1-q8",
      question: "HTTP 方法中，哪些是幂等的（多次执行结果相同）？",
      options: [
        "GET、PUT、DELETE 是幂等的，POST 不是幂等的",
        "只有 GET 是幂等的",
        "所有方法都是幂等的",
        "没有方法是幂等的",
      ],
      answer: 0,
      rationale:
        "GET、PUT、DELETE 是幂等操作，多次执行产生相同结果；POST 不是幂等的，每次执行可能创建新资源。",
    },
  ],
  // Lesson 2: 命令行与可复现示例 (8题)
  "tw-w3-2": [
    {
      id: "tw-w3-2-q1",
      question: "在编写命令行示例时，最重要的原则是什么？",
      options: [
        "示例必须可复制粘贴并可复现，包含完整的命令和预期输出",
        "命令越短越好",
        "只展示成功的情况",
        "使用尽可能多的高级选项",
      ],
      answer: 0,
      rationale:
        "技术文档中的命令行示例必须可复现，读者应能直接复制粘贴并获得预期结果。",
    },
    {
      id: "tw-w3-2-q2",
      question: "curl 命令中 -o 和 -O 选项的区别是什么？",
      options: [
        "-o 指定自定义文件名保存，-O 使用远程文件的原始名称保存",
        "-o 输出到终端，-O 输出到文件",
        "-o 静默模式，-O 详细模式",
        "两者功能完全相同",
      ],
      answer: 0,
      rationale:
        "curl -o 允许指定保存的文件名，-O 自动使用 URL 中的文件名保存。",
    },
    {
      id: "tw-w3-2-q3",
      question: "管道符（|）在命令行中的作用是什么？",
      options: [
        "将前一个命令的输出作为后一个命令的输入",
        "同时执行两个命令",
        "在后台运行命令",
        "将输出重定向到文件",
      ],
      answer: 0,
      rationale:
        "管道符将左侧命令的标准输出连接到右侧命令的标准输入，实现命令链式处理。",
    },
    {
      id: "tw-w3-2-q4",
      question: "curl -v 选项的作用是什么？",
      options: [
        "输出详细的请求和响应信息，用于调试",
        "验证 SSL 证书",
        "使用 verbose 编码",
        "只显示版本号",
      ],
      answer: 0,
      rationale:
        "curl -v（verbose）输出详细的 HTTP 交互信息，包括请求头、响应头等，用于调试。",
    },
    {
      id: "tw-w3-2-q5",
      question: "在文档中展示命令行示例时，应该包含哪些信息？",
      options: [
        "命令本身、预期输出、必要的环境说明和版本信息",
        "只需要命令本身",
        "只需要输出结果",
        "只需要截图",
      ],
      answer: 0,
      rationale:
        "完整的命令行示例应包含可复制的命令、预期输出，以及必要时的环境要求和版本信息。",
    },
    {
      id: "tw-w3-2-q6",
      question: "curl -X POST -d '{\"key\":\"value\"}' 中 -d 选项的作用是什么？",
      options: [
        "指定要发送的请求体数据",
        "下载数据到本地",
        "启用调试模式",
        "设置超时时间",
      ],
      answer: 0,
      rationale:
        "curl -d 用于发送 POST 请求的数据体，常用于发送 JSON 数据或表单数据。",
    },
    {
      id: "tw-w3-2-q7",
      question: "重定向符号 > 和 >> 的区别是什么？",
      options: [
        "> 覆盖文件内容，>> 追加到文件末尾",
        "> 追加内容，>> 覆盖内容",
        "> 输出到标准输出，>> 输出到标准错误",
        "两者功能相同",
      ],
      answer: 0,
      rationale:
        "> 将输出重定向到文件并覆盖原内容，>> 将输出追加到文件末尾而不覆盖。",
    },
    {
      id: "tw-w3-2-q8",
      question: "环境变量在命令行文档中的重要性是什么？",
      options: [
        "说明命令依赖的环境配置，帮助读者在不同环境中复现",
        "可以忽略，因为所有系统环境相同",
        "只在 Windows 系统中重要",
        "只用于隐藏敏感信息",
      ],
      answer: 0,
      rationale:
        "环境变量会影响命令执行结果，文档应说明必要的环境配置以确保可复现性。",
    },
  ],
  // Lesson 3: 排错文档（Troubleshooting）写法 (7题)
  "tw-w3-3": [
    {
      id: "tw-w3-3-q1",
      question: "排错文档的理想结构是什么？",
      options: [
        "症状描述 → 可能原因 → 诊断步骤 → 解决方案",
        "解决方案 → 原因 → 症状",
        "只列出解决方案即可",
        "按字母顺序排列所有错误",
      ],
      answer: 0,
      rationale:
        "排错文档应从用户观察到的症状开始，然后解释原因，提供诊断步骤，最后给出解决方案。",
    },
    {
      id: "tw-w3-3-q2",
      question: "在排错文档中，错误信息应该如何呈现？",
      options: [
        "完整引用原始错误信息，使用代码块格式，便于用户搜索匹配",
        "用自己的话概括错误",
        "只写错误代码，省略详细信息",
        "翻译成用户的母语",
      ],
      answer: 0,
      rationale:
        "完整引用原始错误信息让用户能通过搜索找到文档，也便于确认是否遇到相同问题。",
    },
    {
      id: "tw-w3-3-q3",
      question: "排错文档中的'快速绕过'（Workaround）应该如何处理？",
      options: [
        "提供快速绕过方案，但同时说明根因和完整修复方法",
        "只提供绕过方案，不需要解释原因",
        "不应该提供绕过方案，只给根本解决方案",
        "绕过方案应该放在文档最后",
      ],
      answer: 0,
      rationale:
        "快速绕过帮助用户先解除阻塞，但也应说明根因和完整修复方法，让用户理解问题本质。",
    },
    {
      id: "tw-w3-3-q4",
      question: "描述复现步骤时，最重要的原则是什么？",
      options: [
        "步骤具体、完整，包含版本信息和环境配置",
        "尽量简短，只写关键步骤",
        "使用技术术语让步骤更专业",
        "只描述成功路径",
      ],
      answer: 0,
      rationale:
        "复现步骤必须足够详细和完整，包括版本、环境等信息，让其他人能够准确重现问题。",
    },
    {
      id: "tw-w3-3-q5",
      question: "排错文档中的日志示例应该如何处理？",
      options: [
        "展示相关的日志片段，高亮关键信息，解释日志含义",
        "展示完整的日志文件",
        "只提供日志文件的路径",
        "不应该在文档中包含日志",
      ],
      answer: 0,
      rationale:
        "展示相关日志片段并解释含义，帮助用户理解如何从日志中诊断问题，而非展示冗长的完整日志。",
    },
    {
      id: "tw-w3-3-q6",
      question: "排错文档的标题应该如何命名？",
      options: [
        "使用用户可能搜索的症状或错误信息作为标题",
        "使用技术内部代码作为标题",
        "使用通用的'故障排除'作为所有标题",
        "使用日期和版本号作为标题",
      ],
      answer: 0,
      rationale:
        "使用用户可能搜索的症状或错误信息作为标题，提高文档的可发现性。",
    },
    {
      id: "tw-w3-3-q7",
      question: "在排错文档中，'预期结果'与'实际结果'的对比有什么作用？",
      options: [
        "帮助用户确认是否遇到相同问题，也帮助支持人员快速理解问题",
        "增加文档的长度显得更专业",
        "只是格式规范的要求",
        "用于统计错误发生率",
      ],
      answer: 0,
      rationale:
        "对比预期和实际结果让用户确认问题，也让支持人员快速理解用户的期望与现实的差距。",
    },
  ],
  // Lesson 4: 图表与示意图（可维护）(7题)
  "tw-w3-4": [
    {
      id: "tw-w3-4-q1",
      question: "Mermaid 图表工具的核心优势是什么？",
      options: [
        "使用 Markdown 风格的文本语法定义图表，可版本控制且易于维护",
        "提供丰富的图形编辑界面",
        "生成的图表文件最小",
        "只支持流程图一种类型",
      ],
      answer: 0,
      rationale:
        "Mermaid 使用文本定义图表，可以用 Git 版本控制，比二进制图片文件更易于维护和协作。",
    },
    {
      id: "tw-w3-4-q2",
      question: "选择使用代码生成图表（如 Mermaid）而非截图的主要原因是什么？",
      options: [
        "代码图表可版本控制、易于更新、且支持自动化生成",
        "代码图表加载速度更快",
        "代码图表更美观",
        "截图无法嵌入到文档中",
      ],
      answer: 0,
      rationale:
        "代码图表可以用 Git 追踪变更，修改时只需编辑文本，且可以集成到 CI/CD 流程自动生成。",
    },
    {
      id: "tw-w3-4-q3",
      question: "Mermaid 支持哪些类型的图表？",
      options: [
        "流程图、时序图、类图、甘特图、实体关系图等 30+ 种类型",
        "只支持流程图",
        "只支持流程图和时序图",
        "只支持简单的框图",
      ],
      answer: 0,
      rationale:
        "Mermaid 支持 30+ 种图表类型，包括流程图、时序图、类图、状态图、甘特图、ER图等。",
    },
    {
      id: "tw-w3-4-q4",
      question: "在技术文档中使用图表的最佳时机是什么？",
      options: [
        "当文字难以清晰表达复杂的流程、架构或关系时",
        "在每个段落后都添加图表",
        "只在文档开头使用图表",
        "图表可以完全替代文字说明",
      ],
      answer: 0,
      rationale:
        "图表应用于补充文字难以表达的内容，如复杂流程、系统架构、数据关系等，而非替代文字说明。",
    },
    {
      id: "tw-w3-4-q5",
      question: "时序图（Sequence Diagram）最适合用于展示什么？",
      options: [
        "多个参与者之间的交互顺序和消息传递",
        "数据的统计分布",
        "项目的进度安排",
        "代码的类继承关系",
      ],
      answer: 0,
      rationale:
        "时序图展示参与者之间按时间顺序的交互过程，适合描述 API 调用流程、系统组件通信等。",
    },
    {
      id: "tw-w3-4-q6",
      question: "图表的替代文本（Alt Text）为什么重要？",
      options: [
        "为视障用户提供无障碍访问，也在图片加载失败时提供信息",
        "用于 SEO 优化",
        "是 Markdown 语法的强制要求",
        "让图表看起来更专业",
      ],
      answer: 0,
      rationale:
        "替代文本是无障碍性的重要组成部分，帮助使用屏幕阅读器的用户理解图表内容。",
    },
    {
      id: "tw-w3-4-q7",
      question: "使用 PlantUML 或 Mermaid 这类工具的可维护性优势是什么？",
      options: [
        "图表定义是文本格式，可以像代码一样进行 diff、review 和版本控制",
        "生成的图片质量更高",
        "支持更多的颜色选项",
        "不需要安装任何工具",
      ],
      answer: 0,
      rationale:
        "文本格式的图表定义可以使用 Git 追踪变更，在 PR 中进行代码审查，比二进制图片更易维护。",
    },
  ],
};
