import type { QuizQuestion } from "../types";

export const week3: Record<string, QuizQuestion[]> = {
  "w3-1": [
    {
      id: "w3-1-q1",
      question: "API Server 的核心职责是？",
      options: [
        "统一入口，负责认证/鉴权/准入校验并持久化对象到 etcd",
        "直接调度 Pod 到节点",
        "拉取镜像并运行容器",
        "提供节点日志收集",
      ],
      answer: 0,
      rationale: "组件概览指出 API Server 是集群前门，处理所有 REST 请求并写入 etcd。",
    },
    {
      id: "w3-1-q2",
      question: "etcd 在集群中的作用是？",
      options: [
        "保存集群期望状态的分布式键值存储，需多数节点保证一致性",
        "作为容器镜像仓库",
        "提供 DNS 服务",
        "替代 kube-proxy 转发流量",
      ],
      answer: 0,
      rationale: "etcd 是唯一存储后端，官方建议奇数节点组成集群以保持 quorum。",
    },
    {
      id: "w3-1-q3",
      question: "kube-controller-manager 主要做什么？",
      options: [
        "运行 Deployment/Node/Job 等控制循环，驱动实际状态收敛到期望",
        "创建容器网络",
        "暴露 Dashboard",
        "负责日志采集",
      ],
      answer: 0,
      rationale: "Controller 模式章节说明它包含多种控制器实现调和循环。",
    },
    {
      id: "w3-1-q4",
      question: "kube-scheduler 的职责是？",
      options: [
        "选择合适节点绑定 Pod（未真正启动容器）",
        "直接拉起容器进程",
        "管理 etcd 备份",
        "生成 Ingress 规则",
      ],
      answer: 0,
      rationale: "调度器只负责绑定决策，具体运行由 kubelet 完成。",
    },
    {
      id: "w3-1-q5",
      question: "kubelet 在节点上做什么？",
      options: [
        "监控 PodSpec，调用容器运行时确保容器按照期望运行",
        "作为集群 DNS",
        "调度其他节点",
        "作为负载均衡器",
      ],
      answer: 0,
      rationale: "组件概览：kubelet 是节点代理，负责容器生命周期与探针上报。",
    },
    {
      id: "w3-1-q6",
      question: "kube-proxy 主要提供什么能力？",
      options: [
        "基于 iptables/ipvs 实现 Service 虚拟 IP 到后端 Pod 的转发",
        "存储镜像",
        "日志采集",
        "Pod 生命周期管理",
      ],
      answer: 0,
      rationale: "Service 文档解释 kube-proxy 监听 Service/Endpoint 并编程数据平面。",
    },
    {
      id: "w3-1-q7",
      question: "Admission Controller 位于哪一层？",
      options: [
        "API Server 内部，在认证/鉴权后对请求做变更或校验",
        "kubelet 插件",
        "etcd 内置功能",
        "kube-proxy 模块",
      ],
      answer: 0,
      rationale: "请求流经认证→鉴权→准入控制→持久化。",
    },
    {
      id: "w3-1-q8",
      question: "节点存活是如何被监测的？",
      options: [
        "kubelet 向 API Server 发送心跳，Node Controller 根据心跳与探活决定 NotReady",
        "依赖 Pod 访问",
        "通过 etcd 直接探测",
        "由 kube-proxy 定期 ping",
      ],
      answer: 0,
      rationale: "Node Controller 监听心跳与状态，心跳缺失会标记 NotReady 并触发驱逐。",
    },
    {
      id: "w3-1-q9",
      question: "CoreDNS 在架构中属于？",
      options: [
        "集群附加组件，通过 Deployment/Service 提供 DNS 解析",
        "控制平面必选组件",
        "容器运行时的一部分",
        "kube-proxy 的子模块",
      ],
      answer: 0,
      rationale: "DNS 是可选附加组件，通常以 Deployment 方式部署。",
    },
    {
      id: "w3-1-q10",
      question: "为什么控制平面通常运行在专用节点？",
      options: [
        "隔离资源与安全，避免工作负载干扰 API/etcd/scheduler",
        "因为需要 GPU",
        "与工作节点网络不兼容",
        "否则 kube-proxy 无法工作",
      ],
      answer: 0,
      rationale: "官方建议分离控制平面以保证可靠性和安全性。",
    },
    {
      id: "w3-1-q11",
      question: "在《Kubernetes Components》文档中，Kubernetes 集群由哪两大部分组成？",
      options: [
        "控制平面（Control Plane）+ 一个或多个工作节点（Worker Nodes）",
        "etcd + Docker",
        "Scheduler + Ingress Controller",
        "Pod + Service",
      ],
      answer: 0,
      rationale: "组件概览指出：A cluster consists of a control plane and one or more worker nodes。",
    },
    {
      id: "w3-1-q12",
      question: "在控制平面组件中，哪个被标注为可选（optional）并用于对接云厂商？",
      options: ["cloud-controller-manager", "kube-apiserver", "kube-scheduler", "etcd"],
      answer: 0,
      rationale: "组件概览：cloud-controller-manager（optional）用于集成底层 cloud provider。",
    },
    {
      id: "w3-1-q13",
      question: "在节点组件中，哪个被标注为可选（optional）并维护网络规则以实现 Service？",
      options: ["kube-proxy", "kubelet", "container runtime", "kube-controller-manager"],
      answer: 0,
      rationale: "组件概览：kube-proxy（optional）维护网络规则以实现 Services。",
    },
    {
      id: "w3-1-q14",
      question: "《Kubernetes Components》对 Node Components 的描述更接近哪一项？",
      options: [
        "运行在每个节点上，维护运行中的 Pods 并提供运行时环境",
        "只运行在控制平面节点上，负责调度",
        "只存储集群状态数据",
        "只负责镜像构建与推送",
      ],
      answer: 0,
      rationale: "组件概览：Node components run on every node, maintaining running pods and providing runtime environment。",
    },
    {
      id: "w3-1-q15",
      question: "组件概览中对 kube-scheduler 的一句话定义是？",
      options: [
        "寻找尚未绑定到节点的 Pod，并为其选择合适的节点",
        "负责所有 REST 请求并写入 etcd",
        "在每个节点上执行容器健康检查",
        "维护网络规则实现 Service",
      ],
      answer: 0,
      rationale: "组件概览：kube-scheduler looks for Pods not yet bound to a node, and assigns each Pod to a suitable node。",
    },
    {
      id: "w3-1-q16",
      question: "组件概览中对 kube-controller-manager 的一句话定义是？",
      options: [
        "运行控制器（controllers）以实现 Kubernetes API 的行为",
        "为集群提供 DNS",
        "负责存储所有 API server 数据",
        "负责为 Pod 分配节点",
      ],
      answer: 0,
      rationale: "组件概览：kube-controller-manager runs controllers to implement Kubernetes API behavior。",
    },
    {
      id: "w3-1-q17",
      question: "组件概览中对 etcd 的描述强调它是？",
      options: [
        "一致且高可用的键值存储，用于保存所有 API server 数据",
        "容器镜像分发系统",
        "节点上的日志采集代理",
        "Service 的四层负载均衡器",
      ],
      answer: 0,
      rationale: "组件概览：etcd 是 a consistent and highly-available key value store for all API server data。",
    },
    {
      id: "w3-1-q18",
      question: "组件概览的 Addons 中，DNS 的主要用途是？",
      options: ["为整个集群提供 DNS 解析", "为容器提供镜像扫描", "为 Pod 分配节点", "为控制平面提供高可用"],
      answer: 0,
      rationale: "Addons 示例：DNS for cluster-wide DNS resolution。",
    },
    {
      id: "w3-1-q19",
      question: "组件概览的 Addons 中，Web UI（Dashboard）的定位是？",
      options: ["通过 Web 界面进行集群管理", "保存容器日志到中心化存储", "实现容器运行时", "调和 Deployment 副本数"],
      answer: 0,
      rationale: "Addons 示例：Web UI（Dashboard）用于通过 Web 界面管理集群。",
    },
    {
      id: "w3-1-q20",
      question: "组件概览的 Addons 中，Container Resource Monitoring 主要用于？",
      options: ["收集并存储容器指标（metrics）", "提供 Pod 网络", "实现 RBAC 鉴权", "生成 kubeconfig"],
      answer: 0,
      rationale: "Addons 示例：Container Resource Monitoring for collecting and storing container metrics。",
    },
    {
      id: "w3-1-q21",
      question: "组件概览的 Addons 中，Cluster-level Logging 主要用于？",
      options: ["将容器日志保存到集中式日志存储", "替代 etcd 保存集群状态", "为节点提供心跳", "为 Pod 做健康检查"],
      answer: 0,
      rationale: "Addons 示例：Cluster-level Logging for saving container logs to a central log store。",
    },
    {
      id: "w3-1-q22",
      question: "《Controllers》文档中对 control loop（控制循环）的定义更接近？",
      options: ["一个不会终止的循环，用于调节系统状态", "一次性执行的初始化脚本", "只在集群启动时运行的任务", "只在故障时触发的中断处理"],
      answer: 0,
      rationale: "Controllers 文档：control loop 是 non-terminating loop that regulates the state of a system。",
    },
    {
      id: "w3-1-q23",
      question: "在 controller pattern 中，Kubernetes 对象的哪个字段代表 desired state？",
      options: ["spec", "status", "metadata", "kind"],
      answer: 0,
      rationale: "Controllers 文档：objects have a spec field that represents the desired state。",
    },
    {
      id: "w3-1-q24",
      question: "在 Kubernetes 中，更常见的控制器收敛方式是？",
      options: [
        "通过与 API server 交互（创建/更新对象）来产生副作用",
        "直接在每个节点上启动容器进程",
        "直接修改 etcd 数据绕过 API server",
        "只写日志，不改任何对象",
      ],
      answer: 0,
      rationale: "Controllers 文档强调：更常见的是 controller 通过 API server 触发一系列副作用以收敛状态。",
    },
    {
      id: "w3-1-q25",
      question: "《Controllers》文档以 Job 为例说明：Job controller 自己会直接运行 Pod/容器吗？",
      options: [
        "不会，它让 API server 创建/删除 Pods，由其他组件调度和运行",
        "会，它在控制器里直接拉起容器进程",
        "会，它直接调用 container runtime 并绕过 kubelet",
        "不会，它只更新 etcd，不会创建 Pods",
      ],
      answer: 0,
      rationale: "Controllers 文档：Job controller 不直接运行 Pods/containers，而是请求 API server 创建/删除 Pods。",
    },
    {
      id: "w3-1-q26",
      question: "Job 完成后，Job controller 通常会如何更新 Job 对象？",
      options: ["更新 Job 对象以标记为 Finished", "删除所有 Node 对象", "把 Pod 直接改成 Succeeded 而不执行任务", "只更新 Service 的 Endpoint"],
      answer: 0,
      rationale: "Controllers 文档：once the work is done, the Job controller updates that Job object to mark it Finished。",
    },
    {
      id: "w3-1-q27",
      question: "《Controllers》文档中提到的 “Direct control” 指的是？",
      options: [
        "控制器直接与集群外部系统通信，把 current state 拉近 desired state",
        "控制器通过 API server 创建对象，让其他控制循环处理",
        "kubelet 直接调度 Pod",
        "etcd 直接重启容器",
      ],
      answer: 0,
      rationale: "Controllers 文档：Direct control 的 controller 需要直接与外部系统交互，并把结果回报给 API server。",
    },
    {
      id: "w3-1-q28",
      question: "为什么《Controllers》文档说集群可能永远达不到稳定状态也没关系？",
      options: [
        "只要控制器在运行并能做出有用的修正，整体状态是否稳定并不关键",
        "因为 etcd 会自动把所有对象变成一致",
        "因为 kubelet 会忽略 spec",
        "因为调度器会停止调度",
      ],
      answer: 0,
      rationale: "Controllers 文档：As long as controllers are running and able to make useful changes, stability doesn't matter。",
    },
    {
      id: "w3-1-q29",
      question: "Controller pattern 中，一个 controller 至少会跟踪（track）什么？",
      options: ["至少一种 Kubernetes 资源类型", "至少一台物理机的温度传感器", "至少一个容器镜像仓库", "至少一个 DNS 服务器"],
      answer: 0,
      rationale: "Controllers 文档：A controller tracks at least one Kubernetes resource type。",
    },
    {
      id: "w3-1-q30",
      question: "《Controllers》文档提到：Pod 一旦被调度（scheduled），Pod 对象会成为哪个组件的 “desired state” 输入？",
      options: ["kubelet", "etcd", "kube-proxy", "coredns"],
      answer: 0,
      rationale: "Controllers 文档括注：Once scheduled, Pod objects become part of the desired state for a kubelet。",
    },
  ],
  "w3-2": [
    {
      id: "w3-2-q1",
      question: "使用 kubeadm init 后通常还需做什么步骤让 Pod 能通信？",
      options: [
        "安装 CNI 插件（如 Flannel/Calico），否则 Pod 处于 Pending",
        "重启全部节点",
        "手动创建 etcd 集群",
        "修改 kubelet.service",
      ],
      answer: 0,
      rationale: "kubeadm 文档要求部署网络插件以提供 Pod 网络。",
    },
    {
      id: "w3-2-q2",
      question: "kubeadm join 默认的 token 有效期是？",
      options: ["24 小时，可通过 kubeadm token create 再生成", "永久有效", "1 小时", "需要手工写入配置文件才有效"],
      answer: 0,
      rationale: "kubeadm 默认 token TTL 24h，过期需重新创建。",
    },
    {
      id: "w3-2-q3",
      question: "高可用控制平面常见的两种 etcd 部署方式是？",
      options: [
        "stacked etcd（与控制平面同节点）或 external etcd（独立集群）",
        "仅单节点 etcd",
        "使用 MySQL 代替 etcd",
        "使用 NFS 共享",
      ],
      answer: 0,
      rationale: "kubeadm HA 指南介绍 stacked 与 external 两种模式。",
    },
    {
      id: "w3-2-q4",
      question: "Kind 创建集群的特点是？",
      options: [
        "节点以容器形式运行，适合本地快速实验",
        "必须使用物理机",
        "仅支持多主多节点生产环境",
        "无法定制 kubelet 参数",
      ],
      answer: 0,
      rationale: "Kind 文档说明基于 Docker 容器模拟节点，便于本地测试。",
    },
    {
      id: "w3-2-q5",
      question: "Minikube 默认提供的是什么类型集群？",
      options: [
        "单节点集群，可选多种驱动（docker/hyperkit/virtualbox 等）",
        "必须三节点",
        "云上托管集群",
        "仅能使用 KVM",
      ],
      answer: 0,
      rationale: "minikube start 默认创建单节点，驱动可配置。",
    },
    {
      id: "w3-2-q6",
      question: "将新控制平面节点加入 kubeadm 集群需要什么？",
      options: [
        "使用 kubeadm join --control-plane 并提供 certificate-key",
        "仅运行 kubelet 即可自动加入",
        "拷贝 /etc/kubernetes/admin.conf 即可",
        "编辑 etcd 数据",
      ],
      answer: 0,
      rationale: "kubeadm HA 文档要求使用 certificate key 保护证书分发。",
    },
    {
      id: "w3-2-q7",
      question: "kubeadm init 默认生成的管理员 kubeconfig 位于？",
      options: ["/etc/kubernetes/admin.conf", "~/.kube/config", "/var/lib/kubelet/kubeconfig", "/etc/hosts"],
      answer: 0,
      rationale: "官方指南使用 admin.conf 拷贝到 ~/.kube/config 以使用 kubectl。",
    },
    {
      id: "w3-2-q8",
      question: "kubeadm reset 的作用是？",
      options: [
        "清理 kubeadm 部署的组件/配置，便于重新初始化",
        "扩容节点",
        "升级集群",
        "仅删除 etcd 数据",
      ],
      answer: 0,
      rationale: "reset 用于回滚节点状态，移除 kubeadm 安装的文件和容器。",
    },
    {
      id: "w3-2-q9",
      question: "kubeadm init --apiserver-advertise-address 用途是？",
      options: [
        "指定 API Server 对外可达的绑定地址",
        "设置 Service CIDR",
        "配置 etcd 监听端口",
        "开启 Ingress",
      ],
      answer: 0,
      rationale: "需指定主机实际 IP 供其他节点访问 API。",
    },
    {
      id: "w3-2-q10",
      question: "缺少 kube-proxy 或未加载 br_netfilter 模块可能导致？",
      options: ["Service/Pod 网络异常，DNS 解析失败", "kubeadm init 直接失败", "etcd 无法启动", "镜像拉取失败"],
      answer: 0,
      rationale: "网络前置条件未满足会导致 Service 不通或 DNS 失败。",
    },
    {
      id: "w3-2-q11",
      question: "kubeadm 文档对 kubeadm 的一句话定位是？",
      options: [
        "创建符合最佳实践的最小可用 Kubernetes 集群（minimum viable cluster）",
        "替代 kubelet 运行容器",
        "把 YAML 直接写入 etcd",
        "只用于管理 Ingress Controller",
      ],
      answer: 0,
      rationale: "kubeadm 文档开篇说明：Using kubeadm, you can create a minimum viable Kubernetes cluster that conforms to best practices。",
    },
    {
      id: "w3-2-q12",
      question: "kubeadm 文档提到 kubeadm 还支持哪些集群生命周期功能？",
      options: ["bootstrap tokens 与集群升级（upgrades）", "自动生成应用日志", "内置 CNI 插件（无需安装网络）", "自动部署 Ingress-NGINX"],
      answer: 0,
      rationale: "kubeadm 文档提到 kubeadm 支持 bootstrap tokens、cluster upgrades 等生命周期能力。",
    },
    {
      id: "w3-2-q13",
      question: "kubeadm 文档认为 kubeadm 适合用来？",
      options: [
        "自动化搭建集群并测试应用（也可作为更大安装器的构建块）",
        "替代容器镜像仓库",
        "替代 Service 的负载均衡",
        "替代 etcd 保存状态",
      ],
      answer: 0,
      rationale: "kubeadm 文档列举的场景包括：试用 Kubernetes、自动化搭建测试集群、作为其他安装器的 building block。",
    },
    {
      id: "w3-2-q14",
      question: "kubeadm 创建集群的 prerequisites 中，控制平面节点建议至少多少 CPU？",
      options: ["至少 2 个 CPU", "至少 1 个 CPU", "至少 8 个 CPU", "CPU 不重要"],
      answer: 0,
      rationale: "kubeadm prerequisites：At least 2 CPUs on the machine that you use as a control-plane node。",
    },
    {
      id: "w3-2-q15",
      question: "kubeadm prerequisites 中对每台机器的内存建议是？",
      options: ["2 GiB 或更多", "256 MiB", "64 GiB", "仅看磁盘，不看内存"],
      answer: 0,
      rationale: "kubeadm prerequisites：2 GiB or more of RAM per machine。",
    },
    {
      id: "w3-2-q16",
      question: "kubeadm 在 host 网络准备阶段，会优先从哪里挑选组件使用的 IP？",
      options: [
        "与默认网关关联的网络接口上的可用 IP（global unicast）",
        "随机选择任意网卡",
        "永远使用 127.0.0.1",
        "必须手工指定网卡名称，否则无法运行",
      ],
      answer: 0,
      rationale: "kubeadm 文档说明：组件会在与 default gateway 相关的接口上选择可用 IP 作为 advertise/listen 地址。",
    },
    {
      id: "w3-2-q17",
      question: "kubeadm 文档建议用哪个命令查看默认路由以判断组件可能选用的 IP？",
      options: ["`ip route show`（寻找以 `default via` 开头的行）", "`ifconfig -a`（只看 lo）", "`route -n | grep kubeadm`", "`kubectl get node -o wide`"],
      answer: 0,
      rationale: "kubeadm network setup 章节给出：ip route show # Look for a line starting with \"default via\"。",
    },
    {
      id: "w3-2-q18",
      question: "如果宿主机存在多个默认网关，kubeadm 文档提醒可能发生什么？",
      options: [
        "组件会尝试使用遇到的第一个具有合适 global unicast IP 的默认网关（顺序可能因 OS/内核不同而变）",
        "kubeadm 会直接拒绝初始化",
        "会自动创建额外的 CNI 网卡",
        "会强制使用最后一个默认网关",
      ],
      answer: 0,
      rationale: "kubeadm 文档 note：多个 default gateways 时，会尝试使用第一个合适的网关，顺序可能因系统而异。",
    },
    {
      id: "w3-2-q19",
      question: "为什么为控制平面组件显式指定 IP 地址（如 advertise address）可能带来后续麻烦？",
      options: [
        "这些 IP 会写入证书的 SAN，变更需要重新签发证书并重启组件",
        "会导致 kube-proxy 自动卸载",
        "会让 Pod 无法拉取镜像",
        "会让 Service CIDR 自动改变",
      ],
      answer: 0,
      rationale: "kubeadm 文档提示：组件 IP 会成为证书 SAN 的一部分，变更会牵涉证书与组件重启。",
    },
    {
      id: "w3-2-q20",
      question: "kubeadm 文档对“给所有组件都配置自定义 IP 地址”给出的建议是？",
      options: [
        "不推荐；更建议把宿主机网络配置好，让默认网关 IP 成为组件自动检测并使用的地址",
        "强烈推荐；这是生产唯一正确做法",
        "必须这么做，否则 etcd 无法启动",
        "只能在 Windows 上这么做",
      ],
      answer: 0,
      rationale: "kubeadm warning：项目不建议为所有组件配置自定义 IP，更推荐把 host network 配置到位。",
    },
    {
      id: "w3-2-q21",
      question: "离线（节点无互联网）初始化集群时，kubeadm 文档建议如何处理组件镜像？",
      options: [
        "使用 kubeadm 的预拉取能力或自定义镜像仓库，提前准备所需镜像",
        "把镜像写入 etcd",
        "让 kubelet 自动从 Docker Hub 下载（不需要网络）",
        "只能手工拷贝每个容器层文件到 /var/lib",
      ],
      answer: 0,
      rationale: "kubeadm 文档：可 pre-pull 所需镜像或配置 custom image repository，以支持无网环境。",
    },
    {
      id: "w3-2-q22",
      question: "kubeadm HA 拓扑中，stacked etcd 的关键特点是？",
      options: [
        "etcd 成员与控制平面组件同机部署，耦合更强但搭建更简单",
        "etcd 运行在独立三节点集群，与控制平面完全解耦",
        "etcd 被替换为 MySQL",
        "无需负载均衡器即可对外暴露 apiserver",
      ],
      answer: 0,
      rationale: "HA topology：stacked control plane nodes 上 colocate etcd，配置更简单但故障耦合更强。",
    },
    {
      id: "w3-2-q23",
      question: "stacked etcd 拓扑的主要风险是什么？",
      options: [
        "单个控制平面节点故障会同时丢失一个 etcd member 和一套控制平面实例，冗余被削弱",
        "网络延迟必然翻倍",
        "Pod 会被固定到同一节点无法漂移",
        "kubeadm join 会永久失效",
      ],
      answer: 0,
      rationale: "HA topology：stacked 拓扑存在 control plane 与 etcd 成员“耦合失效”的风险。",
    },
    {
      id: "w3-2-q24",
      question: "kubeadm HA 文档建议 stacked 控制平面最少运行多少个节点？",
      options: ["至少 3 个控制平面节点", "至少 1 个控制平面节点", "至少 2 个控制平面节点", "至少 10 个控制平面节点"],
      answer: 0,
      rationale: "HA topology：You should therefore run a minimum of three stacked control plane nodes for an HA cluster。",
    },
    {
      id: "w3-2-q25",
      question: "external etcd 拓扑下，文档建议的最小主机数量是？",
      options: ["至少 6 台（3 台控制平面 + 3 台 etcd）", "至少 3 台（都跑控制平面与 etcd）", "至少 4 台", "至少 2 台"],
      answer: 0,
      rationale: "HA topology：external etcd 需要 3 台 control plane + 3 台 etcd hosts 才能形成 HA。",
    },
    {
      id: "w3-2-q26",
      question: "kind 文档中，创建集群最基本的命令是？",
      options: ["`kind create cluster`", "`kind init`", "`kubectl create cluster`", "`kubeadm kind`"],
      answer: 0,
      rationale: "kind Quick Start：Creating a Kubernetes cluster is as simple as `kind create cluster`。",
    },
    {
      id: "w3-2-q27",
      question: "kind 文档中，`kind create cluster --wait 5m` 的作用是？",
      options: [
        "阻塞等待控制平面就绪，直到超时（必须写明时间单位，如 30s/5m）",
        "等待所有 Pod 都处于 Ready，否则无法创建集群",
        "只等待镜像下载完成",
        "只等待 kube-proxy 启动",
      ],
      answer: 0,
      rationale: "kind Quick Start：`--wait` 可让创建命令阻塞直到控制平面 ready，并可设置带单位的超时值。",
    },
    {
      id: "w3-2-q28",
      question: "kind 文档中，默认创建的集群名称/上下文（context）是什么？",
      options: ["`kind`", "`default`", "`kubernetes`", "`minikube`"],
      answer: 0,
      rationale: "kind Quick Start：By default, the cluster will be given the name `kind`（同时也作为默认 context 名称）。",
    },
    {
      id: "w3-2-q29",
      question: "kind 文档提到，如果想关闭 provider 自动探测并显式选择运行时，可用哪个环境变量？",
      options: ["`KIND_EXPERIMENTAL_PROVIDER`", "`KUBECONFIG`", "`KIND_PROVIDER`", "`DOCKER_HOST`"],
      answer: 0,
      rationale: "kind Quick Start：可用 `KIND_EXPERIMENTAL_PROVIDER=docker|podman|nerdctl` 显式选择 provider。",
    },
    {
      id: "w3-2-q30",
      question: "minikube start 文档给出的最低资源需求更接近？",
      options: ["至少 2 CPUs、2GB 内存、20GB 磁盘空间", "至少 8 CPUs、32GB 内存、200GB 磁盘空间", "至少 1 CPU、256MB 内存即可", "必须 GPU 才能启动"],
      answer: 0,
      rationale: "minikube 文档列出：2 CPUs、2GB free memory、20GB free disk space 等基本要求。",
    },
  ],
  "w3-3": [
    {
      id: "w3-3-q1",
      question: "Kubernetes YAML 的基本骨架包含？",
      options: [
        "apiVersion、kind、metadata、spec 四大字段",
        "version、type、name、body",
        "header、payload、footer",
        "仅 metadata 即可",
      ],
      answer: 0,
      rationale: "对象定义都包含 apiVersion/kind/metadata/spec（或 data）。",
    },
    {
      id: "w3-3-q2",
      question: "Reconciliation Loop 的含义是？",
      options: [
        "控制器持续对比期望状态与实际状态，直到收敛",
        "一次性命令式执行",
        "仅在集群启动时运行一次",
        "只针对 Deployment",
      ],
      answer: 0,
      rationale: "控制器模式文档强调声明式与持续调和。",
    },
    {
      id: "w3-3-q3",
      question: "kubectl apply 默认使用什么策略记录上次配置？",
      options: [
        "在对象上写入 last-applied-configuration 注解，便于后续三方合并",
        "不做记录",
        "保存在本地 ~/.kube/cache",
        "写入 etcd 另一个数据库",
      ],
      answer: 0,
      rationale: "kubectl apply 客户端存储 last-applied 注解用于 merge。",
    },
    {
      id: "w3-3-q4",
      question: "kubectl patch --type=json 使用的格式是？",
      options: [
        "JSON Patch（RFC 6902）操作列表",
        "YAML Patch",
        "二进制补丁",
        "策略合并补丁",
      ],
      answer: 0,
      rationale: "kubectl 支持 json/merge/strategic 三种 patch 类型。",
    },
    {
      id: "w3-3-q5",
      question: "kubectl replace 与 kubectl apply 的区别是？",
      options: [
        "replace 会删除重建对象，丢失集群侧修改；apply 进行合并",
        "两者完全相同",
        "replace 只能改 metadata",
        "apply 需要先 delete",
      ],
      answer: 0,
      rationale: "声明式推荐 apply，replace 更接近命令式替换。",
    },
    {
      id: "w3-3-q6",
      question: "labels/selectors 的作用是？",
      options: [
        "为对象分组/筛选，供 Service/Deployment 等选择 Pod",
        "控制节点心跳",
        "定义角色权限",
        "仅用于 UI 展示",
      ],
      answer: 0,
      rationale: "标签选择器是声明式 API 的核心关联机制。",
    },
    {
      id: "w3-3-q7",
      question: "kubectl explain 的用途是？",
      options: [
        "查看字段含义/类型，来自 OpenAPI 模式",
        "生成 RBAC 规则",
        "调试网络",
        "显示日志",
      ],
      answer: 0,
      rationale: "explain 提供文档化的字段说明，便于写 YAML。",
    },
    {
      id: "w3-3-q8",
      question: "server-side apply 的特点是？",
      options: [
        "由 apiserver 负责合并，记录 fieldManager，发生冲突会提示",
        "与客户端 apply 等价",
        "需要 kubelet 支持",
        "仅支持 ConfigMap",
      ],
      answer: 0,
      rationale: "SSA 在 apiserver 进行字段所有权管理，减少客户端冲突。",
    },
    {
      id: "w3-3-q9",
      question: "resourceVersion 在写请求中主要用于？",
      options: [
        "实现乐观锁，防止并发覆盖",
        "定义对象优先级",
        "控制日志级别",
        "标记所属命名空间",
      ],
      answer: 0,
      rationale: "使用 resourceVersion 条件写可避免误覆盖旧状态。",
    },
    {
      id: "w3-3-q10",
      question: "kubectl diff 的作用是？",
      options: [
        "预览本地清单与集群对象差异，不会真正应用",
        "比较两个文件的文本差异",
        "生成审计日志",
        "只能查看 labels 变化",
      ],
      answer: 0,
      rationale: "diff 命令帮助审查变更再 apply。",
    },
    {
      id: "w3-3-q11",
      question: "《Objects In Kubernetes》把 Kubernetes object 描述为“record of intent”意味着？",
      options: [
        "创建对象后，Kubernetes 会持续工作以确保对象存在并趋近你声明的期望状态",
        "对象只在 kubectl 运行时短暂存在",
        "对象只用于日志记录，不影响集群行为",
        "对象只存储在本地 YAML 文件中",
      ],
      answer: 0,
      rationale: "Objects 文档：object 是“意图记录”，创建后系统会持续确保对象存在并收敛到期望状态。",
    },
    {
      id: "w3-3-q12",
      question: "Kubernetes objects 可以描述的内容之一是？",
      options: ["正在运行的容器化应用以及它们运行在哪些节点上", "宿主机 BIOS 设置", "Dockerfile 构建缓存", "VPC 路由表规则（独立于集群）"],
      answer: 0,
      rationale: "Objects 文档列举：objects 可以描述应用运行情况（以及运行在哪些节点）等集群状态。",
    },
    {
      id: "w3-3-q13",
      question: "要创建/修改/删除 Kubernetes objects，权威方式是通过？",
      options: ["Kubernetes API（kubectl 本质上也是在调用 API）", "直接编辑 etcd 数据目录", "只改本地 YAML 文件即可自动生效", "重启 kubelet 即可自动生成对象"],
      answer: 0,
      rationale: "Objects 文档：要操作对象需要通过 Kubernetes API；kubectl 会发起对应的 API 调用。",
    },
    {
      id: "w3-3-q14",
      question: "几乎所有对象都有 spec 与 status，它们的关系是？",
      options: ["spec 描述期望状态，status 由系统组件更新并反映当前状态", "spec 由系统生成，status 由用户手工维护", "spec 与 status 完全等价", "spec 只用于日志，status 才决定行为"],
      answer: 0,
      rationale: "Objects 文档：spec 是 desired state；status 是 current state，由 Kubernetes 系统及组件持续更新。",
    },
    {
      id: "w3-3-q15",
      question: "文档中常说的 manifest（清单）更接近？",
      options: ["描述对象的配置文件（通常 YAML，也可 JSON），kubectl 会把它转换成请求体提交给 API", "Pod 的日志文件", "容器镜像的层列表", "etcd 的快照文件"],
      answer: 0,
      rationale: "Objects 文档：manifest 多为 YAML（也可 JSON），kubectl 会将其转换成 API 请求体提交。",
    },
    {
      id: "w3-3-q16",
      question: "在对象清单中，用于唯一标识对象、最常见且最关键的字段是？",
      options: ["metadata.name", "metadata.creationTimestamp", "metadata.resourceVersion", "metadata.uid（必须手工填写）"],
      answer: 0,
      rationale: "Objects 文档：创建对象时需要提供基本信息（如 name）；UID 由系统分配，不需要手工填写。",
    },
    {
      id: "w3-3-q17",
      question: "从 Kubernetes v1.25 起，API server 提供 server-side field validation，kubectl 用哪个参数设置校验级别？",
      options: ["`--validate`（ignore/warn/strict）", "`--dry-run`", "`--force-conflicts`", "`--field-manager`"],
      answer: 0,
      rationale: "Objects 文档：`kubectl --validate` 可设置 ignore/warn/strict（或 true/false）校验级别。",
    },
    {
      id: "w3-3-q18",
      question: "`kubectl` 默认的字段校验级别更接近？",
      options: ["strict（`--validate=true`）", "ignore（`--validate=false`）", "warn（默认只告警不失败）", "默认不做任何校验"],
      answer: 0,
      rationale: "Objects 文档：kubectl 默认 `--validate=true`，等价于 strict。",
    },
    {
      id: "w3-3-q19",
      question: "当 kubectl 连接到不支持 field validation 的 API server 时会？",
      options: ["回退到 client-side validation", "直接跳过所有校验并静默成功", "自动升级集群到 1.27", "强制改用 server-side apply"],
      answer: 0,
      rationale: "Objects 文档：kubectl 无法连接到支持 field validation 的 API server 时会回退到 client-side validation。",
    },
    {
      id: "w3-3-q20",
      question: "声明式管理文档中，`kubectl apply -f <directory>` 配合 `-R` 的含义是？",
      options: ["递归处理目录中的多个对象清单", "强制替换对象并删除重建", "仅打印对象而不创建", "只对 Namespace 生效"],
      answer: 0,
      rationale: "Declarative config 文档：`-R` 用于递归处理目录；结合 `apply -f <directory>` 批量管理对象。",
    },
    {
      id: "w3-3-q21",
      question: "`kubectl apply` 写入的 `kubectl.kubernetes.io/last-applied-configuration` 注解主要保存？",
      options: [
        "用于创建/更新该对象的配置文件内容（以 JSON 表示）",
        "上一次 kubectl 命令的 stdout",
        "容器日志最后 100 行",
        "etcd 的 key 前缀列表",
      ],
      answer: 0,
      rationale: "Declarative config 文档：该注解包含用于创建对象的配置文件内容（JSON 表示），便于后续合并。",
    },
    {
      id: "w3-3-q22",
      question: "声明式管理文档中，`kubectl diff` 预览差异依赖的机制是？",
      options: ["server-side dry-run（服务端 dry-run 的 apply 请求）", "本地把 YAML 做文本 diff", "读取 etcd 直接对比 key", "只比较 metadata.labels"],
      answer: 0,
      rationale: "Declarative config 文档：`diff` 使用 server-side dry-run（以 dry-run 的 server-side apply 请求预览差异）。",
    },
    {
      id: "w3-3-q23",
      question: "文档提示：`kubectl diff` 因为执行 dry-run 的 server-side apply，通常需要授予哪些权限？",
      options: ["PATCH、CREATE、UPDATE", "GET、LIST", "DELETE", "WATCH（仅 watch 就够）"],
      answer: 0,
      rationale: "Declarative config 文档：`diff` 会发起 server-side apply 的 dry-run 请求，需要 PATCH/CREATE/UPDATE 权限。",
    },
    {
      id: "w3-3-q24",
      question: "声明式管理文档中，使用 `kubectl apply` 更新对象时，对从配置文件中删除的字段会？",
      options: ["在 live configuration 中清理/清空这些字段", "保留集群侧旧值不变", "把字段移动到 metadata.annotations", "直接拒绝更新"],
      answer: 0,
      rationale: "Declarative config 文档：apply 更新会设置文件中出现的字段，并清理从文件中移除的字段。",
    },
    {
      id: "w3-3-q25",
      question: "在 kubectl patch 文档示例中，strategic merge patch 对 `spec.template.spec.containers` 列表的行为通常是？",
      options: ["按 `name` 合并/追加容器条目（merge），而不是整表替换", "无论如何都整表替换", "只能修改镜像 tag", "只能修改 metadata"],
      answer: 0,
      rationale: "kubectl patch 文档：containers 字段有 merge 策略（merge key 为 name），strategic merge patch 会合并列表。",
    },
    {
      id: "w3-3-q26",
      question: "为什么示例中对 `tolerations` 的 strategic merge patch 会“替换整个列表”？",
      options: ["因为该字段没有声明 patchStrategy，默认策略是 replace", "因为 tolerations 只能有 1 条", "因为 YAML 不支持数组合并", "因为 kubeadm 会重写该字段"],
      answer: 0,
      rationale: "kubectl patch 文档：未声明 patchStrategy 的列表字段默认 replace，因此 tolerations 会被整体替换。",
    },
    {
      id: "w3-3-q27",
      question: "在 JSON merge patch（RFC 7386）中，如果要更新列表字段，正确做法是？",
      options: ["提供完整的新列表，新的列表会完全替换旧列表", "只提供要追加的 1 条元素即可自动合并", "使用 `--type strategic` 才能替换列表", "必须先 delete 再 create"],
      answer: 0,
      rationale: "kubectl patch 文档：JSON merge patch 更新列表需要提供完整新列表，并会替换旧列表。",
    },
    {
      id: "w3-3-q28",
      question: "`kubectl patch` 的 `--type` 可选值包含？默认是哪一个？",
      options: ["json / merge / strategic，默认 strategic", "apply / replace / diff，默认 apply", "http / tcp / grpc，默认 http", "create / update / delete，默认 update"],
      answer: 0,
      rationale: "kubectl patch 文档表格：`--type` 支持 json/merge/strategic，默认 strategic。",
    },
    {
      id: "w3-3-q29",
      question: "关于 `--validate=warn` 的行为，哪个说法更准确？",
      options: ["执行字段校验，但把校验错误以 warning 形式暴露，不直接失败请求", "完全跳过字段校验", "遇到未知字段会立刻失败（等同 strict）", "只校验 metadata.name"],
      answer: 0,
      rationale: "Objects 文档：Warn 模式会执行校验，但把错误作为 warning 暴露而非直接失败请求。",
    },
    {
      id: "w3-3-q30",
      question: "kubectl patch 默认使用哪种 patch 类型？",
      options: ["strategic merge patch", "json patch（RFC 6902）", "json merge patch（RFC 7386）", "只能使用一种固定补丁格式"],
      answer: 0,
      rationale: "kubectl patch 文档：`--type` 默认值是 strategic。",
    },
  ],
  "w3-4": [
    {
      id: "w3-4-q1",
      question: "Pod 可能的 Phase 包括？",
      options: [
        "Pending/Running/Succeeded/Failed/Unknown",
        "Starting/Stop/Restart",
        "Created/Destroyed/Paused",
        "Only Running and Failed",
      ],
      answer: 0,
      rationale: "Pod 生命周期文档列出五种 Phase。",
    },
    {
      id: "w3-4-q2",
      question: "Init Containers 的执行特点是？",
      options: [
        "按顺序依次执行，全部成功后才启动主容器",
        "与主容器并行执行",
        "失败会直接忽略",
        "与 liveness 探针相同",
      ],
      answer: 0,
      rationale: "Init 容器必须全部完成，且按声明顺序运行。",
    },
    {
      id: "w3-4-q3",
      question: "Liveness 与 Readiness Probe 的区别是？",
      options: [
        "Liveness 决定是否重启容器，Readiness 决定是否接收流量",
        "两者完全相同",
        "Readiness 更频繁重启容器",
        "Liveness 只能使用 HTTP",
      ],
      answer: 0,
      rationale: "官方文档区分存活与就绪探针职责。",
    },
    {
      id: "w3-4-q4",
      question: "CrashLoopBackOff 表示什么？",
      options: [
        "容器启动后反复崩溃，kubelet 进入指数退避重启",
        "镜像拉取失败",
        "节点宕机",
        "探针超时导致无重启",
      ],
      answer: 0,
      rationale: "当容器异常退出，kubelet 会等待更长时间再重启，状态显示 CrashLoopBackOff。",
    },
    {
      id: "w3-4-q5",
      question: "Pod 终止的默认流程是？",
      options: [
        "发送 SIGTERM 给容器，等待 terminationGracePeriodSeconds，超时后 SIGKILL",
        "直接 SIGKILL",
        "立刻删除 Pod 记录",
        "先关闭 kube-proxy",
      ],
      answer: 0,
      rationale: "终止流程包括预停止 hook、优雅等待后再强杀。",
    },
    {
      id: "w3-4-q6",
      question: "restartPolicy=OnFailure 通常用于哪类工作负载？",
      options: ["Job", "Deployment", "DaemonSet", "StatefulSet"],
      answer: 0,
      rationale: "Job 默认使用 OnFailure 或 Never，Deployment 只能使用 Always。",
    },
    {
      id: "w3-4-q7",
      question: "Readiness Gate 的作用是？",
      options: [
        "允许自定义条件参与 Pod Ready 判定",
        "替代 liveness 探针",
        "控制 HPA",
        "只用于 StatefulSet",
      ],
      answer: 0,
      rationale: "ReadinessGate 允许外部条件（如注入的条件）控制 Ready 状态。",
    },
    {
      id: "w3-4-q8",
      question: "ImagePullBackOff 状态通常意味着？",
      options: [
        "镜像拉取失败（认证/网络/镜像不存在），kubelet 正在退避重试",
        "容器内应用崩溃",
        "节点磁盘满",
        "探针失败",
      ],
      answer: 0,
      rationale: "事件中通常可见 ErrImagePull，需检查 registry 访问或凭证。",
    },
    {
      id: "w3-4-q9",
      question: "Ephemeral Container 用于？",
      options: [
        "调试现有 Pod，不会参与就绪判定，也不会自动重启",
        "提供存储卷",
        "承担主要业务",
        "替代 Init 容器",
      ],
      answer: 0,
      rationale: "调试容器是临时的，只用于排查问题。",
    },
    {
      id: "w3-4-q10",
      question: "PostStart/PreStop Hook 与探针的区别是？",
      options: [
        "Hook 是一次性回调，探针是周期性健康检查",
        "Hook 只在调试时可用",
        "探针只在 Pod 终止时执行",
        "两者完全相同",
      ],
      answer: 0,
      rationale: "生命周期钩子在特定事件触发一次，与周期性探针用途不同。",
    },
    {
      id: "w3-4-q11",
      question: "Pod 在其生命周期内会被重新调度（reschedule）到其他节点吗？",
      options: [
        "不会；Pod 只会被调度一次，若需迁移通常是创建一个新的替代 Pod（UID 不同）",
        "会；scheduler 会定期把 Pod 迁移到更空闲的节点",
        "会；kubelet 会在节点间搬迁 Pod",
        "不会；但 UID 会保持不变并且 Pod 名称必然改变",
      ],
      answer: 0,
      rationale: "Pod lifecycle 文档：Pods are only scheduled once；同一个 UID 的 Pod 不会被 reschedule，只会被新 Pod 替代。",
    },
    {
      id: "w3-4-q12",
      question: "将 Pod 分配到一个具体 Node 的动作在文档中称为？",
      options: ["Binding", "Proxying", "Tainting", "Leasing"],
      answer: 0,
      rationale: "Pod lifecycle 文档：assigning a Pod to a specific node is called binding。",
    },
    {
      id: "w3-4-q13",
      question: "选择要使用哪个 Node 来运行 Pod 的过程称为？",
      options: ["Scheduling", "Binding", "Draining", "Checkpointing"],
      answer: 0,
      rationale: "Pod lifecycle 文档：the process of selecting which node to use is called scheduling。",
    },
    {
      id: "w3-4-q14",
      question: "如果一个 Node 宕机，运行在该 Node 上的 Pod 通常会？",
      options: [
        "被视为不健康并最终被删除，由上层控制器创建新的 Pod 来替代",
        "自动迁移到另一个 Node，UID 不变",
        "继续在 etcd 中运行并提供服务",
        "永远保持 Running 状态",
      ],
      answer: 0,
      rationale: "Pod lifecycle 文档：Node 失败后相关 Pods 会被标记并最终删除，通常由更高层 controller 负责重建替代。",
    },
    {
      id: "w3-4-q15",
      question: "Pod 的 `status` 中包含的一组条件（conditions）主要用于？",
      options: [
        "反映 Pod 的当前状态信号（如 Ready/Initialized 等），供系统与用户判断",
        "声明期望副本数",
        "保存上一次 apply 的清单内容",
        "指定镜像仓库凭证",
      ],
      answer: 0,
      rationale: "Pod lifecycle 文档：Pod status 包含一组 Pod conditions，可用于表达 Ready 等状态信号。",
    },
    {
      id: "w3-4-q16",
      question: "Pod 生命周期文档中提到的容器三种状态是？",
      options: ["Waiting / Running / Terminated", "Pending / Running / Succeeded", "Init / Ready / Live", "Created / Paused / Deleted"],
      answer: 0,
      rationale: "Pod lifecycle 文档：There are three possible container states: Waiting, Running, and Terminated。",
    },
    {
      id: "w3-4-q17",
      question: "容器处于 Waiting 状态时，文档给出的典型原因是？",
      options: ["拉取镜像或应用 Secret 等启动前操作仍在进行", "Service 没有 Endpoint", "kube-scheduler 未安装", "etcd 磁盘满导致容器直接退出"],
      answer: 0,
      rationale: "Pod lifecycle 文档：Waiting 常见原因包括 pulling image、applying Secret data 等启动前操作。",
    },
    {
      id: "w3-4-q18",
      question: "若配置了 `preStop` hook，它会在容器进入哪种状态前执行？",
      options: ["Terminated", "Waiting", "Running", "Pending"],
      answer: 0,
      rationale: "Pod lifecycle 文档：If a container has a preStop hook configured, it runs before the container enters Terminated state。",
    },
    {
      id: "w3-4-q19",
      question: "Pod 生命周期文档描述的 CrashLoopBackOff 退避机制在什么情况下会被重置（reset）？",
      options: [
        "容器稳定运行一段时间后（例如约 10 分钟），新的崩溃会被当作第一次崩溃处理",
        "每次重启都会立即重置",
        "只有手工删除 Pod 才会重置",
        "只要修改镜像就会重置",
      ],
      answer: 0,
      rationale: "Pod lifecycle 文档：容器成功运行一段时间（例如 10 分钟）后，backoff 会被重置。",
    },
    {
      id: "w3-4-q20",
      question: "Readiness Probe 最直接影响的是？",
      options: ["Pod 是否会被加入/移出 Service 的负载均衡后端", "容器是否会被 kubelet 重启", "节点是否会被标记 NotReady", "etcd 的选主速度"],
      answer: 0,
      rationale: "Probes 文档：Readiness 用于判断是否接收流量，不 ready 的 Pod 会从 Service load balancers 移除。",
    },
    {
      id: "w3-4-q21",
      question: "文档中，Pod 的 Ready condition 可能为 false 的原因之一是？",
      options: ["Node 的 Ready condition 不为 true", "容器镜像体积过大", "Deployment 副本数太多", "Service 没有 selector"],
      answer: 0,
      rationale: "Probes 文档：Pod Ready condition 会因 Node Ready 不为 true、readinessGates 为 false 等原因变为 false。",
    },
    {
      id: "w3-4-q22",
      question: "配置了 startupProbe 后，liveness/readiness probes 的启动时机是？",
      options: ["startupProbe 成功之前不会开始执行 liveness/readiness", "三者同时开始执行", "startupProbe 只在 Pod 终止时执行一次", "startupProbe 会替代 readinessProbe"],
      answer: 0,
      rationale: "Probes 文档：配置 startupProbe 后，liveness/readiness probes 会等待 startupProbe 成功后才开始执行。",
    },
    {
      id: "w3-4-q23",
      question: "HTTP 探针（httpGet）判定成功的状态码范围是？",
      options: ["200-399（>=200 且 <400）", "仅 200", "100-199", "400-599"],
      answer: 0,
      rationale: "Probes 文档：HTTP probe 返回码 >=200 且 <400 判定为 success。",
    },
    {
      id: "w3-4-q24",
      question: "为什么文档强调 liveness probes 需要谨慎配置？",
      options: [
        "配置不当可能引发级联故障：高负载下频繁重启、请求失败、剩余 Pod 压力上升",
        "因为 liveness probes 会降低 etcd 一致性",
        "因为 liveness probes 会让 Scheduler 停止工作",
        "因为 liveness probes 会禁止滚动升级",
      ],
      answer: 0,
      rationale: "Probes 文档 note/caution：错误的 liveness 配置可能导致级联故障与更多重启/请求失败。",
    },
    {
      id: "w3-4-q25",
      question: "排查 Pod 问题时，Debug Pods 文档建议首先运行的命令是？",
      options: ["`kubectl describe pods <pod-name>`", "`kubectl delete pod <pod-name>`", "`kubectl reset cluster`", "`docker system prune -a`"],
      answer: 0,
      rationale: "Debug Pods 文档：第一步查看 Pod 状态与事件，建议使用 `kubectl describe pods ${POD_NAME}`。",
    },
    {
      id: "w3-4-q26",
      question: "Pod 长时间处于 Pending 通常意味着？",
      options: ["无法被调度到某个节点（如资源不足、约束条件不满足）", "镜像拉取失败", "容器已启动但探针失败", "已经完成并退出"],
      answer: 0,
      rationale: "Debug Pods 文档：Pending 代表 Pod 不能被调度到节点，常见原因是资源不足或约束导致 FailedScheduling。",
    },
    {
      id: "w3-4-q27",
      question: "Pod 长时间处于 Waiting，Debug Pods 文档指出最常见的原因是？",
      options: ["镜像拉取失败（名称不对/未推送/registry 不可达等）", "Service 没有 Ingress", "etcd leader 选举中", "kubelet 不支持 CNI"],
      answer: 0,
      rationale: "Debug Pods 文档：Waiting 最常见原因是 image pull 失败（检查镜像名、是否推送、网络与认证）。",
    },
    {
      id: "w3-4-q28",
      question: "Pod 卡在 Terminating，Debug Pods 文档提到的一个典型原因是？",
      options: ["Pod 带 finalizer 且集群中某个 admission webhook 阻止移除 finalizer", "Pod 处于 Running", "镜像拉取太慢", "探针成功导致无法删除"],
      answer: 0,
      rationale: "Debug Pods 文档：可能因 finalizer + admission webhook 阻止更新导致控制平面无法删除 Pod 对象。",
    },
    {
      id: "w3-4-q29",
      question: "容器终止信息（termination message）默认写入的文件路径是？",
      options: ["/dev/termination-log", "/var/log/termination.log", "/tmp/termination-log", "/etc/termination-log"],
      answer: 0,
      rationale: "Determine the Reason for Pod Failure 文档：terminationMessagePath 默认是 /dev/termination-log。",
    },
    {
      id: "w3-4-q30",
      question: "将 `terminationMessagePolicy` 设置为 `FallbackToLogsOnError` 的含义是？",
      options: [
        "当终止消息文件为空且容器异常退出时，使用最后一段容器日志作为终止消息回退来源",
        "永远忽略终止消息文件，只读全量日志",
        "只在容器正常退出时才读取日志",
        "把终止消息写回到镜像中",
      ],
      answer: 0,
      rationale: "Determine the Reason for Pod Failure 文档：FallbackToLogsOnError 会在错误退出且文件为空时回退读取最后一段日志作为 message。",
    },
  ],
};