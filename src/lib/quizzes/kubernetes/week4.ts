import type { QuizQuestion } from "../types";

export const week4: Record<string, QuizQuestion[]> = {
  "w4-1": [
    {
      id: "w4-1-q1",
      question: "Deployment 控制的对象是？",
      options: [
        "声明 ReplicaSet 与 Pod 模板，确保副本数与版本符合期望",
        "直接管理节点网络",
        "配置 Ingress 规则",
        "存储镜像",
      ],
      answer: 0,
      rationale: "Deployment 文档说明其负责创建/更新 ReplicaSet 与 Pod。",
    },
    {
      id: "w4-1-q2",
      question: "RollingUpdate 默认的 maxUnavailable 与 maxSurge 是？",
      options: ["25% / 25%", "0 / 0", "50% / 10%", "100% / 100%"],
      answer: 0,
      rationale: "官方默认滚动策略为最多 25% 不可用，最多 25% 额外副本。",
    },
    {
      id: "w4-1-q3",
      question: "progressDeadlineSeconds 默认值是多少？",
      options: ["600 秒", "60 秒", "3600 秒", "无默认值必须设置"],
      answer: 0,
      rationale: "Deployment spec 默认 progressDeadlineSeconds=600。",
    },
    {
      id: "w4-1-q4",
      question: "revisionHistoryLimit 的作用是？",
      options: [
        "限制保留的旧 ReplicaSet 数量",
        "控制探针超时",
        "设置滚动窗口",
        "指定镜像拉取策略",
      ],
      answer: 0,
      rationale: "用于避免历史 RS 无限增长并支持回滚。",
    },
    {
      id: "w4-1-q5",
      question: "如何回滚到上一版本？",
      options: [
        "kubectl rollout undo deployment/<name>",
        "直接编辑 Pod",
        "删除 Deployment 再创建",
        "重启 kubelet",
      ],
      answer: 0,
      rationale: "rollout undo 会切回上一修订并更新 RS。",
    },
    {
      id: "w4-1-q6",
      question: "Recreate 策略的特点是？",
      options: [
        "先删除所有旧 Pod 再创建新 Pod，会短暂中断",
        "与 RollingUpdate 相同",
        "一次只替换一个 Pod",
        "只允许镜像标签改变",
      ],
      answer: 0,
      rationale: "Recreate 会停掉旧版本再启动新版本，导致停机。",
    },
    {
      id: "w4-1-q7",
      question: "minReadySeconds 的作用？",
      options: [
        "新 Pod 连续就绪该时间后才算可用，影响滚动推进",
        "限制镜像下载时间",
        "决定重试次数",
        "控制探针端口",
      ],
      answer: 0,
      rationale: "确保就绪状态稳定一段时间再计入可用副本。",
    },
    {
      id: "w4-1-q8",
      question: "Deployment 如何暂停/恢复滚动？",
      options: [
        "kubectl rollout pause/resume deployment/<name>",
        "必须删除重建",
        "编辑 Pod 模板即可暂停",
        "通过 kube-proxy 控制",
      ],
      answer: 0,
      rationale: "rollout pause/resume 可暂停控制器推进，便于验证。",
    },
    {
      id: "w4-1-q9",
      question: "修改 Pod 模板会导致什么？",
      options: [
        "创建新的 ReplicaSet 并按策略替换旧 Pod",
        "直接在原 Pod 上热更新",
        "不产生任何影响",
        "只更新标签不更新容器",
      ],
      answer: 0,
      rationale: "Deployment 检测模板 hash 变化后新建 RS 进行滚动。",
    },
    {
      id: "w4-1-q10",
      question: "监控滚动进度的命令是？",
      options: [
        "kubectl rollout status deployment/<name>",
        "kubectl get nodes",
        "kubectl top pod",
        "kubectl cluster-info",
      ],
      answer: 0,
      rationale: "rollout status 会显示当前修订及可用副本进度。",
    },
  ],
  "w4-2": [
    {
      id: "w4-2-q1",
      question: "未指定 type 时 Service 默认类型是？",
      options: ["ClusterIP", "NodePort", "LoadBalancer", "ExternalName"],
      answer: 0,
      rationale: "Service type 默认 ClusterIP 仅集群内可访问。",
    },
    {
      id: "w4-2-q2",
      question: "NodePort 服务默认端口范围是？",
      options: ["30000-32767", "1-1023", "20000-29999", "40000-50000"],
      answer: 0,
      rationale: "官方默认 NodePort 范围 30000-32767（可配置）。",
    },
    {
      id: "w4-2-q3",
      question: "LoadBalancer 类型依赖什么能力？",
      options: [
        "云提供商/集群环境的外部负载均衡集成",
        "kube-proxy 自动创建",
        "etcd 提供",
        "kubectl 本地转发",
      ],
      answer: 0,
      rationale: "需要底层 LB 支持，如云厂商或 MetalLB。",
    },
    {
      id: "w4-2-q4",
      question: "kube-proxy iptables 与 ipvs 模式的关系是？",
      options: [
        "两者都是实现 Service 的数据面，ipvs 模式提供更好性能与特性",
        "ipvs 用于外部流量，iptables 仅内部",
        "只能二选一，功能不同",
        "ipvs 不支持会话保持",
      ],
      answer: 0,
      rationale: "kube-proxy 可选择 iptables 或 ipvs 实现，ipvs 更高效。",
    },
    {
      id: "w4-2-q5",
      question: "ExternalTrafficPolicy=Local 的效果是？",
      options: [
        "保持客户端源 IP，只转发到本节点上有后端的 Pod",
        "拒绝所有外部流量",
        "随机转发到任意节点",
        "关闭健康检查",
      ],
      answer: 0,
      rationale: "Local 模式保留源地址但只选本机端点，需配合健康检查。",
    },
    {
      id: "w4-2-q6",
      question: "SessionAffinity: ClientIP 的含义？",
      options: [
        "根据客户端 IP 将会话固定到同一后端 Pod",
        "按 Cookie 做粘性",
        "禁用 Service",
        "只能用于 ExternalName",
      ],
      answer: 0,
      rationale: "Service 支持 ClientIP 粘性会话，默认 None。",
    },
    {
      id: "w4-2-q7",
      question: "将 clusterIP 设为 None 的结果？",
      options: [
        "创建 Headless Service，不分配虚拟 IP，直接返回 Endpoint IP",
        "无法创建 Service",
        "强制创建 NodePort",
        "禁止 DNS 解析",
      ],
      answer: 0,
      rationale: "Headless Service 常用于 StatefulSet 提供直连。",
    },
    {
      id: "w4-2-q8",
      question: "EndpointSlice 的引入解决了什么问题？",
      options: [
        "替代旧 Endpoints，提升大规模服务的可伸缩性与性能",
        "替代 Service",
        "用于持久卷",
        "提供日志聚合",
      ],
      answer: 0,
      rationale: "EndpointSlice 拆分 Endpoint 列表，减少单对象过大。",
    },
    {
      id: "w4-2-q9",
      question: "NodePort 服务能否在未运行 Pod 的节点上访问？",
      options: [
        "可以，kube-proxy 会转发到真实后端",
        "不可以，只能访问有 Pod 的节点",
        "需要额外手工路由",
        "只能在主节点访问",
      ],
      answer: 0,
      rationale: "kube-proxy 在每个节点编程规则，允许任意节点转发。",
    },
    {
      id: "w4-2-q10",
      question: "kube-proxy 如何获知 Service/Endpoint 更新？",
      options: [
        "监听 API Server 的 watch 事件并更新本地规则",
        "定期扫描节点端口",
        "依赖 etcd 直接推送",
        "通过 DNS 查询",
      ],
      answer: 0,
      rationale: "kube-proxy 通过 watch API 实时调整 iptables/ipvs。",
    },
  ],
  "w4-3": [
    {
      id: "w4-3-q1",
      question: "使用 Ingress 需要的前提是？",
      options: [
        "集群中部署了 Ingress Controller（如 ingress-nginx）",
        "只需要创建 Ingress 资源即可自动生效",
        "必须使用 NodePort 服务",
        "需要关闭 kube-proxy",
      ],
      answer: 0,
      rationale: "Ingress 资源需由控制器实现具体数据面。",
    },
    {
      id: "w4-3-q2",
      question: "ingressClassName 字段的作用？",
      options: [
        "指定由哪个 IngressClass/Controller 处理该 Ingress",
        "设置默认后端",
        "控制 TLS 证书",
        "配置副本数",
      ],
      answer: 0,
      rationale: "ingressClassName 绑定到特定控制器实例。",
    },
    {
      id: "w4-3-q3",
      question: "pathType 可选值有哪些？",
      options: ["Prefix、Exact、ImplementationSpecific", "Regex、Prefix", "Only Exact", "Any 字符串"],
      answer: 0,
      rationale: "Ingress v1 定义三种 pathType。",
    },
    {
      id: "w4-3-q4",
      question: "TLS 配置需要什么类型的 Secret？",
      options: [
        "kubernetes.io/tls，包含 tls.crt 与 tls.key",
        "Opaque 任意键值",
        "docker-registry 类型",
        "service-account-token",
      ],
      answer: 0,
      rationale: "TLS 段引用的 Secret 必须是 tls 类型并包含证书与私钥。",
    },
    {
      id: "w4-3-q5",
      question: "未命中任何规则时请求将会？",
      options: [
        "转发到默认后端（若配置），否则返回 404",
        "随机分配到某个 Service",
        "丢弃连接",
        "重定向到 API Server",
      ],
      answer: 0,
      rationale: "Ingress 控制器会使用 default backend 处理未匹配流量。",
    },
    {
      id: "w4-3-q6",
      question: "Ingress 规则中的 backend 指向？",
      options: [
        "具体的 Service 名称和端口（号或名称）",
        "Pod IP",
        "节点 IP",
        "ConfigMap",
      ],
      answer: 0,
      rationale: "每个 path 必须指定 service/name 与 service/port。",
    },
    {
      id: "w4-3-q7",
      question: "在 Minikube 启用 ingress 控制器的命令是？",
      options: ["minikube addons enable ingress", "kubectl apply ingress", "minikube start --ingress-only", "需要手工编译内核"],
      answer: 0,
      rationale: "官方教程通过 addons enable ingress 来启动 ingress-nginx。",
    },
    {
      id: "w4-3-q8",
      question: "Ingress 与 Service 的主要区别？",
      options: [
        "Ingress 提供七层路由/主机名/路径规则，Service 提供四层虚拟 IP",
        "Ingress 也提供四层负载均衡",
        "Service 只能暴露 HTTP",
        "二者完全等价",
      ],
      answer: 0,
      rationale: "Ingress 是 L7 入口，Service 是集群内部 L4 负载均衡。",
    },
    {
      id: "w4-3-q9",
      question: "Nginx Ingress Controller 暴露服务常用的 Service 类型是？",
      options: ["NodePort 或 LoadBalancer", "Headless", "ExternalName", "ClusterIP（外部不可达）"],
      answer: 0,
      rationale: "ingress-nginx 默认以 NodePort/LoadBalancer 暴露 80/443 入口。",
    },
    {
      id: "w4-3-q10",
      question: "为什么建议使用 ingressClass 而非旧版 annotation？",
      options: [
        "ingressClass 是 GA 字段，避免注解歧义并支持多控制器共存",
        "注解性能更低",
        "注解无法被 API Server 解析",
        "ingressClass 会自动创建证书",
      ],
      answer: 0,
      rationale: "Ingress v1 推荐使用 ingressClassName 与 IngressClass 资源替代注解选择控制器。",
    },
  ],
  "w4-4": [
    {
      id: "w4-4-q1",
      question: "Namespace 的主要作用是？",
      options: [
        "提供名称作用域与多租户隔离边界（RBAC/配额等）",
        "隔离网络栈",
        "限制内核版本",
        "提高 Pod 性能",
      ],
      answer: 0,
      rationale: "官方文档：Namespace 用于逻辑隔离资源名和权限。",
    },
    {
      id: "w4-4-q2",
      question: "ResourceQuota 可限制哪些内容？",
      options: [
        "CPU/内存请求与上限、PVC 数量、对象数量等",
        "仅限制 Service",
        "仅限制镜像大小",
        "只能限制 Pod 数量",
      ],
      answer: 0,
      rationale: "ResourceQuota 支持计算资源及对象计数等多种维度。",
    },
    {
      id: "w4-4-q3",
      question: "LimitRange 的作用是？",
      options: [
        "为 Namespace 内的 Pod/Container 设置默认/最小/最大资源值",
        "创建网络策略",
        "管理 RBAC",
        "扩缩容 Deployment",
      ],
      answer: 0,
      rationale: "LimitRange 提供资源上下限与默认值，配合配额使用。",
    },
    {
      id: "w4-4-q4",
      question: "当配额要求声明 requests/limits 而 Pod 未设置时会怎样？",
      options: [
        "API Server 拒绝创建，提示需设置资源请求/限制",
        "自动填充为 0",
        "自动分配最大值",
        "忽略配额继续创建",
      ],
      answer: 0,
      rationale: "配额校验需要 Pod 提供 requests/limits 才能计算使用量。",
    },
    {
      id: "w4-4-q5",
      question: "默认 ServiceAccount 的作用范围是？",
      options: [
        "仅所在 Namespace 有效",
        "全局通用",
        "仅供 kube-system 使用",
        "只能用于 CronJob",
      ],
      answer: 0,
      rationale: "ServiceAccount 作用域为 namespace，默认每个 namespace 创建一个 default SA。",
    },
    {
      id: "w4-4-q6",
      question: "删除 Namespace 会发生什么？",
      options: [
        "触发级联删除其中资源，直到 finalizer 清理完成",
        "仅删除标签，不删除资源",
        "立即清空 etcd",
        "需要手工删除所有 Pod 才能删除 Namespace",
      ],
      answer: 0,
      rationale: "Namespace 带有 finalizer，删除时会级联清理资源。",
    },
    {
      id: "w4-4-q7",
      question: "查看配额使用情况的命令是？",
      options: ["kubectl describe quota", "kubectl get pods", "kubectl get csr", "kubectl top nodes"],
      answer: 0,
      rationale: "describe quota 能展示 hard/used 指标与作用域。",
    },
    {
      id: "w4-4-q8",
      question: "ResourceQuota 的作用范围？",
      options: ["限制单个 Namespace 内的资源使用", "限制整个集群", "限制节点数量", "限制存储类"],
      answer: 0,
      rationale: "配额是 namespace 级别，不影响其他命名空间。",
    },
    {
      id: "w4-4-q9",
      question: "ResourceQuota 可以基于哪些 scope 选择对象？",
      options: [
        "如 Terminating/NotTerminating、BestEffort/NotBestEffort 等 scopeSelector",
        "仅基于标签",
        "只能基于节点",
        "不能选择范围",
      ],
      answer: 0,
      rationale: "配额支持 scopeSelector，限制特定生命周期或 QoS 的对象。",
    },
    {
      id: "w4-4-q10",
      question: "为何建议为不同环境创建独立 Namespace？",
      options: [
        "便于 RBAC、配额与资源隔离，降低相互影响",
        "只是为了更好看",
        "避免使用 kube-proxy",
        "减少 etcd 大小",
      ],
      answer: 0,
      rationale: "将 dev/stage/prod 分离有助于权限与资源隔离，符合最佳实践。",
    },
  ],
};