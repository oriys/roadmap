import type { QuizQuestion } from "../types";

export const week12: Record<string, QuizQuestion[]> = {
  "w12-1": [
    {
      id: "w12-1-q1",
      question: "Kubernetes 官方推荐应用如何输出日志？",
      options: [
        "写到 stdout/stderr，由容器运行时重定向到节点日志文件",
        "直接写本地文件并手工收集",
        "通过 API Server 上传",
        "写入 etcd",
      ],
      answer: 0,
      rationale: "日志最佳实践是输出到标准输出，便于 kubectl logs 与采集。",
    },
    {
      id: "w12-1-q2",
      question: "DaemonSet 日志代理（如 Fluent Bit）的优势？",
      options: [
        "在每个节点收集所有容器日志，集中转发，无需改应用",
        "必须修改应用代码",
        "只能收集一个容器",
        "无法处理轮转",
      ],
      answer: 0,
      rationale: "节点级代理可统一采集，兼容大多数工作负载。",
    },
    {
      id: "w12-1-q3",
      question: "Sidecar 日志收集模式的特点？",
      options: [
        "同 Pod 内的日志代理共享卷读取主容器日志，适合定制处理但会增加资源开销",
        "只能在无 DaemonSet 时使用",
        "默认由 kubelet 创建",
        "无法访问主容器文件",
      ],
      answer: 0,
      rationale: "Sidecar 可处理特定格式/协议，但增加 Pod 复杂度。",
    },
    {
      id: "w12-1-q4",
      question: "kubectl logs 读取的文件路径通常是？",
      options: [
        "/var/log/containers 下的符号链接（指向 /var/log/pods/.../container.log）",
        "/etc/kubernetes/logs",
        "/tmp",
        "/var/lib/docker/images",
      ],
      answer: 0,
      rationale: "日志默认存放在 /var/log/containers，指向真实容器日志。",
    },
    {
      id: "w12-1-q5",
      question: "日志轮转通常由谁负责？",
      options: [
        "容器运行时/kubelet 依据配置（如 containerLogMaxSize/Files）",
        "应用自行删除",
        "etcd 自动清理",
        "需要手工 rm",
      ],
      answer: 0,
      rationale: "kubelet 支持配置日志文件大小/数量进行轮转。",
    },
    {
      id: "w12-1-q6",
      question: "多容器 Pod 内共享日志的方式？",
      options: [
        "使用 emptyDir 等共享卷，主容器写文件，sidecar 读取处理",
        "必须使用 hostPath",
        "无解",
        "需要修改 API Server",
      ],
      answer: 0,
      rationale: "共享卷是 Sidecar 模式常见做法。",
    },
    {
      id: "w12-1-q7",
      question: "集群默认是否提供日志集中存储？",
      options: [
        "否，K8s 只提供接口，需要自建/托管的收集与存储方案",
        "是，etcd 自动存储",
        "是，kube-proxy 存储",
        "是，kubelet 存储 30 天",
      ],
      answer: 0,
      rationale: "官方文档强调日志管道需自建或使用云产品。",
    },
    {
      id: "w12-1-q8",
      question: "短暂 Pod 的日志注意事项？",
      options: [
        "Pod 删除后日志文件可能被清理，需及时收集或使用持久化方案",
        "日志会永久保留",
        "不需要采集",
        "kubectl logs 会自动存档",
      ],
      answer: 0,
      rationale: "短生命周期任务需确保日志及时转存或收集。",
    },
    {
      id: "w12-1-q9",
      question: "Container Runtime Interface 对日志格式的要求？",
      options: [
        "CRI 定义了基本 JSON 行格式（时间/流/日志），kubelet 解析后暴露",
        "无要求",
        "必须是 syslog",
        "要求 protobuf",
      ],
      answer: 0,
      rationale: "CRI 规范了日志输出格式以供 kubelet 处理。",
    },
    {
      id: "w12-1-q10",
      question: "选择 DaemonSet 与 Sidecar 的权衡？",
      options: [
        "DaemonSet 通用且易运维；Sidecar 更灵活但占用资源/需改 Pod 模板",
        "Sidecar 一定更省资源",
        "DaemonSet 无法收集多容器日志",
        "两者完全相同",
      ],
      answer: 0,
      rationale: "官方文档比较两种模式：节点代理 vs 每 Pod Sidecar 各有利弊。",
    },
  ],
  "w12-2": [
    {
      id: "w12-2-q1",
      question: "Loki 的设计与传统日志系统有何不同？",
      options: [
        "仅索引标签（labels），日志内容不建立全文索引以降低成本",
        "完全不存储日志",
        "只支持结构化日志",
        "需要 Elasticsearch 作为后端",
      ],
      answer: 0,
      rationale: "Loki 采用标签索引+块存储策略，强调低成本。",
    },
    {
      id: "w12-2-q2",
      question: "LogQL 基本查询格式是？",
      options: [
        "{label=\"value\", app=~\"api|web\"} |= \"error\"",
        "SELECT * FROM logs",
        "kubectl logs -l app=web",
        "curl /logs",
      ],
      answer: 0,
      rationale: "LogQL 使用 PromQL 类似的标签过滤加管道过滤。",
    },
    {
      id: "w12-2-q3",
      question: "|= 与 |~ 在 LogQL 中的区别？",
      options: [
        "|= 为字符串包含过滤，|~ 为正则匹配",
        "两者都为正则",
        "|= 是赋值",
        "|~ 表示管道",
      ],
      answer: 0,
      rationale: "运算符语义与 Promtail/Loki 文档一致。",
    },
    {
      id: "w12-2-q4",
      question: "将日志转为指标的方式？",
      options: [
        "使用度量查询，如 sum by (level) (rate({app=\"api\"} |= \"error\" [5m]))",
        "仅能全文检索",
        "需要导出到 Prometheus",
        "无法转换",
      ],
      answer: 0,
      rationale: "LogQL 支持 metric queries 基于 log stream 计算率/计数。",
    },
    {
      id: "w12-2-q5",
      question: "避免高基数标签的原因？",
      options: [
        "高基数会导致索引膨胀和查询缓慢",
        "可以提升性能",
        "必须索引每个字段",
        "不会影响性能",
      ],
      answer: 0,
      rationale: "Loki 与 Prometheus 类似，高基数标签成本高。",
    },
    {
      id: "w12-2-q6",
      question: "Promtail 在 Kubernetes 场景常用的 pipeline stage 是？",
      options: [
        "cri/docker 解析、json 解码、labeldrop/replace 等",
        "仅 regex",
        "必须使用 syslog",
        "只支持静态文件",
      ],
      answer: 0,
      rationale: "Promtail 提供丰富 pipeline stage 适配 CRI/Docker 日志与结构化解析。",
    },
    {
      id: "w12-2-q7",
      question: "LogQL 的 limit 参数作用？",
      options: [
        "限制返回的日志行数，默认 1000",
        "限制时间范围",
        "限制标签数",
        "限制文件大小",
      ],
      answer: 0,
      rationale: "limit 可控制返回行数，避免过多输出。",
    },
    {
      id: "w12-2-q8",
      question: "Loki Helm 安装通常包含哪些组件？",
      options: [
        "Loki 本身、Promtail/Agent、Grafana（可选）",
        "仅 Loki",
        "只安装 Prometheus",
        "必须安装 Elasticsearch",
      ],
      answer: 0,
      rationale: "官方 chart 可同时部署 Loki、Promtail、Grafana。",
    },
    {
      id: "w12-2-q9",
      question: "LogQL 支持的时间范围语法？",
      options: [
        "[5m]",
        "LIMIT 5",
        "OFFSET 5",
        "SAMPLE BY 5",
      ],
      answer: 0,
      rationale: "与 PromQL 类似，区间向量使用 [duration] 表示窗口。",
    },
    {
      id: "w12-2-q10",
      question: "使用 | json 管道的目的？",
      options: [
        "将日志行解析为结构化字段，便于后续过滤/格式化",
        "压缩日志",
        "转换为指标",
        "删除标签",
      ],
      answer: 0,
      rationale: "json 管道解析 JSON 日志，方便提取字段进行查询。",
    },
  ],
  "w12-3": [
    {
      id: "w12-3-q1",
      question: "Trace 与 Span 的关系是？",
      options: [
        "Trace 是跨服务调用的完整链路，由多个 Span（操作）组成",
        "Span 包含多个 Trace",
        "二者相同",
        "Span 仅表示日志",
      ],
      answer: 0,
      rationale: "链路追踪模型：Trace = 多个 Span 构成的有向图。",
    },
    {
      id: "w12-3-q2",
      question: "Span Context 通常包含？",
      options: [
        "trace_id、span_id、采样标记、baggage 等用于传播的元数据",
        "用户密码",
        "日志级别",
        "CPU 信息",
      ],
      answer: 0,
      rationale: "上下文携带标识符与可选 baggage 用于跨进程传递。",
    },
    {
      id: "w12-3-q3",
      question: "W3C Trace Context 的 HTTP 头是？",
      options: [
        "traceparent（可选 tracestate）",
        "x-request-id",
        "authorization",
        "content-type",
      ],
      answer: 0,
      rationale: "W3C 标准化 traceparent/tracestate 进行传播。",
    },
    {
      id: "w12-3-q4",
      question: "Head vs Tail Sampling 的区别？",
      options: [
        "Head 在入口决定采样，Tail 根据完成后的特征/错误再决定保留",
        "Tail 在入口采样",
        "两者相同",
        "仅影响日志",
      ],
      answer: 0,
      rationale: "Tail 允许根据结果决定保留，适合低错误率场景。",
    },
    {
      id: "w12-3-q5",
      question: "常见的 Span 属性包括？",
      options: [
        "name、start/end time、attributes、events、status、links",
        "only name",
        "仅日志",
        "仅返回码",
      ],
      answer: 0,
      rationale: "Span 除了时间戳还包含属性/事件/状态等丰富信息。",
    },
    {
      id: "w12-3-q6",
      question: "自动与手动埋点的区别？",
      options: [
        "自动埋点通过框架探针自动生成 Span；手动埋点需要显式创建/传递 context",
        "两者相同",
        "手动埋点性能更差",
        "自动埋点必须修改业务代码",
      ],
      answer: 0,
      rationale: "自动/手动各有优缺点，手动更灵活。",
    },
    {
      id: "w12-3-q7",
      question: "Span 链接（links）的作用？",
      options: [
        "关联并行/消息队列等非父子关系的 Span",
        "必然表示父子关系",
        "仅用于日志",
        "无作用",
      ],
      answer: 0,
      rationale: "links 用于表示因果关系而非直接父子。",
    },
    {
      id: "w12-3-q8",
      question: "跨进程传播上下文需要？",
      options: [
        "在出站请求注入 trace context（HTTP 头、gRPC metadata 等）并在入站提取",
        "仅在进程内存储",
        "依赖数据库",
        "无需任何操作",
      ],
      answer: 0,
      rationale: "传播是分布式追踪的关键，需要在请求链路中传递标识。",
    },
    {
      id: "w12-3-q9",
      question: "采样率过低会导致？",
      options: [
        "缺少重要错误/性能信息，难以分析",
        "性能下降",
        "Span 无限增长",
        "不影响任何数据",
      ],
      answer: 0,
      rationale: "采样权衡数据量与可见度，过低会失去洞察。",
    },
    {
      id: "w12-3-q10",
      question: "追踪数据通常发送到哪些后端？",
      options: [
        "Jaeger/Zipkin/Tempo 等追踪存储与查询系统",
        "Prometheus",
        "Elasticsearch 日志",
        "CoreDNS",
      ],
      answer: 0,
      rationale: "采集 SDK/Collector 将数据导出到兼容追踪后端。",
    },
  ],
  "w12-4": [
    {
      id: "w12-4-q1",
      question: "OpenTelemetry 的关键组件？",
      options: [
        "SDK/Auto-Instrumentation、Collector（接收/处理/导出）、协议 OTLP",
        "仅 Jaeger",
        "只包含日志",
        "必须使用 Zipkin",
      ],
      answer: 0,
      rationale: "OTel 提供规范与实现，包括 SDK 和 Collector 管道。",
    },
    {
      id: "w12-4-q2",
      question: "Collector pipeline 的基本结构？",
      options: [
        "receivers -> processors -> exporters",
        "import -> build -> deploy",
        "producer -> queue -> consumer",
        "source -> sink",
      ],
      answer: 0,
      rationale: "官方配置示例即三段式流水线。",
    },
    {
      id: "w12-4-q3",
      question: "Jaeger UI 能做什么？",
      options: [
        "按服务/操作/标签搜索 Trace，查看 Span 时间线与依赖图",
        "管理 RBAC",
        "调整 kubelet",
        "构建镜像",
      ],
      answer: 0,
      rationale: "Jaeger 提供查询、过滤、可视化 Trace 细节。",
    },
    {
      id: "w12-4-q4",
      question: "OTLP 的优势是？",
      options: [
        "统一指标/日志/追踪的传输协议，减少协议转换",
        "仅适用于日志",
        "需要专有代理",
        "不支持加密",
      ],
      answer: 0,
      rationale: "OTLP 标准化传输，支持 gRPC/HTTP 并可 TLS。",
    },
    {
      id: "w12-4-q5",
      question: "快速试用 Jaeger 的方式？",
      options: [
        "部署 jaeger-all-in-one 或运行官方 demo 示例",
        "必须搭建完整生产集群",
        "只能在本地编译",
        "需要修改内核",
      ],
      answer: 0,
      rationale: "官方提供 all-in-one 镜像用于快速体验。",
    },
    {
      id: "w12-4-q6",
      question: "使用 Collector 进行批处理的 processor 是？",
      options: [
        "batch 处理器，可聚合/限速再导出",
        "memory_limiter",
        "routing",
        "k8sattributes",
      ],
      answer: 0,
      rationale: "batch 处理器是常用组件以提高吞吐和控制导出频率。",
    },
    {
      id: "w12-4-q7",
      question: "配置服务名的常见方式？",
      options: [
        "在 SDK/环境变量（如 OTEL_SERVICE_NAME）中设置",
        "由 Collector 自动生成随机名",
        "只能写在 Jaeger UI",
        "不需要设置",
      ],
      answer: 0,
      rationale: "OTel SDK 与 Collector 支持通过 env 设定服务名。",
    },
    {
      id: "w12-4-q8",
      question: "将 OTLP 数据导出到 Jaeger 的配置思路？",
      options: [
        "Collector 接收 OTLP -> 可选处理 -> 导出到 jaeger exporter/HTTP gRPC 端点",
        "应用直接写数据库",
        "必须使用 Zipkin exporter",
        "只能通过日志",
      ],
      answer: 0,
      rationale: "Collector 支持 jaeger exporter 或 OTLP -> Jaeger 接收端。",
    },
    {
      id: "w12-4-q9",
      question: "Jaeger 组件中负责接收代理流量的是？",
      options: [
        "Jaeger Agent（或采集器接收端）负责接收客户端/SDK 数据",
        "Query 服务",
        "UI",
        "Prometheus",
      ],
      answer: 0,
      rationale: "Agent/Collector 接收并处理数据，Query/UI 供查询展示。",
    },
    {
      id: "w12-4-q10",
      question: "OTel Demo 展示了什么？",
      options: [
        "完整示例应用 + Collector + 后端，演示追踪/指标/日志的接入",
        "仅日志功能",
        "仅指标功能",
        "只包含 CLI",
      ],
      answer: 0,
      rationale: "官方 demo 提供端到端可观测性示例，便于学习。",
    },
  ],
};