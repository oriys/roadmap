import type { QuizQuestion } from "../types";

export const week2: Record<string, QuizQuestion[]> = {
  "w2-1": [
    {
      id: "w2-1-q1",
      question: "Docker CLI 与 Daemon 的通信方式是？",
      options: [
        "通过 REST API（默认 Unix socket /var/run/docker.sock）",
        "直接操作 runc 二进制",
        "写入 etcd",
        "通过 systemd journal",
      ],
      answer: 0,
      rationale: "官方概览描述 CLI 调用 dockerd 暴露的 HTTP API。",
    },
    {
      id: "w2-1-q2",
      question: "dockerd 与 containerd、runc 的关系是？",
      options: [
        "dockerd 作为上层，调用 containerd 管理容器，后者使用 runc 运行 OCI 容器",
        "三者无关联，独立运行",
        "runc 管理 daemon，dockerd 只负责 CLI",
        "containerd 仅用于镜像存储，不运行容器",
      ],
      answer: 0,
      rationale: "Docker 架构图展示 dockerd→containerd→runc 的调用链。",
    },
    {
      id: "w2-1-q3",
      question: "containerd-shim 的作用是？",
      options: [
        "在 daemon 重启时保持容器存活并持有 stdio/状态",
        "负责构建镜像",
        "提供日志采集",
        "作为 kubectl 的代理",
      ],
      answer: 0,
      rationale: "containerd 文档：shim 断开 daemon 依赖，使容器生命周期独立。",
    },
    {
      id: "w2-1-q4",
      question: "镜像与快照在 containerd 中由谁管理？",
      options: [
        "内容存储（content store）和 snapshotter 负责层与文件系统挂载",
        "runc 直接管理镜像",
        "Docker CLI 持久化镜像",
        "etcd 存储镜像元数据",
      ],
      answer: 0,
      rationale: "containerd 架构描述 content store+snapshotter 分别管理 blob 与文件系统视图。",
    },
    {
      id: "w2-1-q5",
      question: "Docker Daemon 还负责哪类功能？",
      options: ["网络/卷管理、日志驱动与安全策略等", "只负责 API 转发", "仅管理 systemd unit", "只管理镜像拉取"],
      answer: 0,
      rationale: "Docker 文档将网络、卷、日志驱动等都归为 dockerd 组件职责。",
    },
    {
      id: "w2-1-q6",
      question: "在 Kubernetes 中直接使用 containerd 时，kubelet 调用接口是？",
      options: ["CRI gRPC 接口，由 containerd-cri 插件提供", "Docker CLI", "systemd DBus", "直接调用 runc 命令"],
      answer: 0,
      rationale: "Kubelet 通过 CRI 与 containerd 交互，而非 Docker API。",
    },
    {
      id: "w2-1-q7",
      question: "runc 的定位是？",
      options: [
        "OCI Runtime 参考实现，负责根据 config.json 创建容器进程",
        "镜像构建器",
        "网络插件",
        "日志采集器",
      ],
      answer: 0,
      rationale: "OCI runtime spec 参考实现正是 runc，用于低层执行。",
    },
    {
      id: "w2-1-q8",
      question: "Docker CLI 发起 docker ps 等查询时，信息来源是？",
      options: ["从 dockerd 获取状态", "直接读取 /var/lib/docker", "查询 etcd", "从内核自动采样"],
      answer: 0,
      rationale: "CLI 通过 API 从 daemon 获取容器状态与元数据。",
    },
    {
      id: "w2-1-q9",
      question: "为什么 dockerd 重启后容器通常不会中断？",
      options: [
        "containerd/shim 维持容器进程与 IO，daemon 重连后继续管理",
        "因为系统会暂停所有容器",
        "镜像层被锁定",
        "runc 会自动重新创建容器",
      ],
      answer: 0,
      rationale: "shim 设计保证容器独立于 dockerd 生命周期。",
    },
    {
      id: "w2-1-q10",
      question: "Containerd 提供哪些接口便于集成？",
      options: [
        "gRPC API 与 ctr/nerdctl 等客户端，可直接管理镜像和容器",
        "只有 REST API",
        "必须通过 docker CLI",
        "仅能通过 systemd 控制",
      ],
      answer: 0,
      rationale: "containerd 官方文档提供 gRPC API，ctr/nerdctl 是常见客户端。",
    },
    {
      id: "w2-1-q11",
      question: "Docker 官方概览指出，Docker client 与 daemon 的部署方式哪项正确？",
      options: [
        "client 与 daemon 可在同一系统运行，也可连接到远程 daemon",
        "必须同机运行，远程连接不支持",
        "必须远程运行，本地不支持",
        "client 必须以容器形式运行，否则无法通信",
      ],
      answer: 0,
      rationale: "Docker 官方概览在 Docker architecture 中说明：client/daemon 可同机，也可连接远程 daemon。",
    },
    {
      id: "w2-1-q12",
      question: "在 Docker 官方概览的架构描述中，哪一个也被称为 “another Docker client”？",
      options: ["Docker Compose", "Docker Hub", "containerd", "runc"],
      answer: 0,
      rationale: "Docker 官方概览在 Docker architecture 段落明确提到：Another Docker client is Docker Compose。",
    },
    {
      id: "w2-1-q13",
      question: "Docker 官方概览中，dockerd 的职责描述最贴近哪项？",
      options: [
        "监听 Docker API 请求并管理 images/containers/networks/volumes 等对象",
        "仅提供 CLI 命令补全与参数解析",
        "只负责运行 OCI runtime（直接替代 runc）",
        "仅存储镜像层，不管理容器生命周期",
      ],
      answer: 0,
      rationale: "Docker 官方概览在 The Docker daemon 部分描述 dockerd 监听 API 并管理 Docker objects。",
    },
    {
      id: "w2-1-q14",
      question: "Docker 官方概览中，关于 Docker registry 的说法哪项正确？",
      options: [
        "Registry 用来存储 Docker images；Docker Hub 是默认的公共 registry，也可以自建私有 registry",
        "Registry 用来存储容器日志与事件",
        "Registry 只在 Kubernetes 中使用，Docker 不需要",
        "Registry 负责运行容器进程（替代 daemon）",
      ],
      answer: 0,
      rationale: "Docker 官方概览在 Docker registries 部分说明：registry 存储镜像，Docker Hub 默认，亦可自建私有 registry。",
    },
    {
      id: "w2-1-q15",
      question: "根据 Docker 官方概览，docker pull / docker run / docker push 与 registry 的关系是？",
      options: [
        "pull/run 会从配置的 registry 拉取所需镜像；push 会把镜像推送到配置的 registry",
        "pull/run 只读本地镜像；push 会从 registry 下载镜像",
        "pull 会删除 registry 中旧镜像；push 会删除本地镜像",
        "三者都只操作 /var/lib/docker，不涉及 registry",
      ],
      answer: 0,
      rationale: "Docker 官方概览明确：docker pull/run 从 registry 拉取，docker push 推送到 registry。",
    },
    {
      id: "w2-1-q16",
      question: "Docker 官方概览对 image 的定义是？",
      options: ["只读模板，包含用于创建容器的指令", "运行中的容器进程本身", "用于替代 Volume 的持久化存储", "用于替代 Network 的虚拟交换机"],
      answer: 0,
      rationale: "Docker 官方概览在 Docker objects 的 Images 小节：image 是 read-only template with instructions。",
    },
    {
      id: "w2-1-q17",
      question: "Docker 官方概览中，关于 Dockerfile 与镜像 layer 的描述哪项正确？",
      options: [
        "Dockerfile 每条指令都会创建一个 layer；重建时通常只重建发生变化的 layers",
        "Dockerfile 只在运行时生效，不影响镜像层",
        "镜像层与 Dockerfile 无关，完全由内核决定",
        "每次 build 都会全量重建所有 layers，无法缓存",
      ],
      answer: 0,
      rationale: "Docker 官方概览提到：Each instruction creates a layer，且 rebuild 时仅变化的 layers 需要重建。",
    },
    {
      id: "w2-1-q18",
      question: "Docker 官方概览对 container 的定义最贴近哪项？",
      options: [
        "image 的可运行实例（runnable instance），可通过 API/CLI 创建、启动、停止与删除",
        "只读文件系统的快照，无法启动",
        "一组 Linux namespaces 的集合但不包含进程",
        "仅用于拉取镜像的缓存对象",
      ],
      answer: 0,
      rationale: "Docker 官方概览在 Containers 小节：container 是 runnable instance of an image，可通过 API/CLI 管理生命周期。",
    },
    {
      id: "w2-1-q19",
      question: "Docker 官方概览提到，默认情况下容器与宿主机/其他容器的隔离关系是？",
      options: [
        "相对隔离；可以控制网络、存储等子系统与宿主/其他容器的隔离程度",
        "完全不隔离，所有容器共享同一网络与文件系统",
        "完全隔离且不可配置，网络/存储隔离无法更改",
        "隔离只由 Dockerfile 决定，与运行参数无关",
      ],
      answer: 0,
      rationale: "Docker 官方概览指出：By default 容器相对隔离，并可控制 network/storage 等子系统的隔离。",
    },
    {
      id: "w2-1-q20",
      question: "Docker 官方概览中，关于容器删除后的数据说法哪项正确？",
      options: [
        "容器被删除后，未写入持久化存储的状态变更会消失",
        "容器被删除后，所有变更都会自动写回镜像",
        "容器被删除后，变更会自动同步到 registry",
        "容器被删除后，变更会永久保留在 host 的 read-only layer",
      ],
      answer: 0,
      rationale: "Docker 官方概览指出：当 container 被 removed，未存入 persistent storage 的状态变更会消失。",
    },
    {
      id: "w2-1-q21",
      question: "在 Docker 官方概览给出的 `docker run -i -t ubuntu /bin/bash` 示例流程中，第一步是什么？",
      options: [
        "如果本地没有 ubuntu 镜像，则从配置的 registry 拉取（等价于先 docker pull）",
        "先创建容器并直接启动网络，再决定是否拉取镜像",
        "先推送镜像到 registry，再从 registry 拉取回来",
        "跳过镜像步骤，直接运行 /bin/bash",
      ],
      answer: 0,
      rationale: "Docker 官方概览在示例步骤 1 说明：若本地无镜像，Docker 会从 registry 拉取。",
    },
    {
      id: "w2-1-q22",
      question: "Docker 官方概览示例中，哪一步解释了运行中的容器为何可以在其文件系统内创建/修改文件？",
      options: [
        "Docker 为容器分配一个可读写的文件系统作为最终 layer（read-write filesystem）",
        "Docker 把镜像的只读层强制改写为可写",
        "Docker 把所有写入重定向到 registry",
        "Docker 通过 systemd-journald 保存写入内容",
      ],
      answer: 0,
      rationale: "Docker 官方概览在示例步骤 3：分配 read-write filesystem 作为最终层，使运行中可写。",
    },
    {
      id: "w2-1-q23",
      question: "Docker 官方概览示例中，关于网络的描述哪项正确？",
      options: [
        "Docker 会创建网络接口把容器连接到默认网络，并为容器分配 IP 地址",
        "容器默认不具备任何网络，必须手工配置才可出网",
        "容器默认使用 hostNetwork，与宿主共享 IP",
        "容器只能访问同一镜像的其他容器，不能访问外网",
      ],
      answer: 0,
      rationale: "Docker 官方概览在示例步骤 4：创建网络接口连接默认网络并分配 IP，默认可通过宿主网络连接外网。",
    },
    {
      id: "w2-1-q24",
      question: "Docker 官方概览示例中，执行 exit 退出 /bin/bash 后容器会怎样？",
      options: [
        "容器停止但不会自动删除，可再次启动或手动删除",
        "容器会被自动删除（等价于 docker run --rm）",
        "容器会转换为镜像并自动 push",
        "容器会保持 running，但 shell 退出不影响",
      ],
      answer: 0,
      rationale: "Docker 官方概览在示例步骤 6：exit 后容器停止但不移除。",
    },
    {
      id: "w2-1-q25",
      question: "Docker 官方概览在 “The underlying technology” 中指出，Docker 利用 Linux 的什么机制为容器提供隔离工作空间？",
      options: ["namespaces（为容器创建一组 namespaces）", "BIOS 虚拟化扩展", "Java 虚拟机字节码隔离", "仅靠 chroot(2) 完成全部隔离"],
      answer: 0,
      rationale: "Docker 官方概览指出 Docker 使用 Linux namespaces，并为每个容器创建一组 namespaces 提供隔离。",
    },
    {
      id: "w2-1-q26",
      question: "containerd 的 PLUGINS.md 提到 Smart Client Model：下列哪项被明确举例为“由 client 完成的高层交互”？",
      options: ["从 tar 包加载镜像（loading an image from tar）", "在 daemon 内部直接编译应用二进制", "在内核中实现 snapshotter", "把容器 stdout 自动写入 registry"],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md 指出：不需要 daemon 的高层功能由 client 完成，示例包含从 tar 加载镜像。",
    },
    {
      id: "w2-1-q27",
      question: "containerd 的 PLUGINS.md 中，External plugins 扩展 containerd 的两种方式分别是？",
      options: [
        "PATH 中提供插件二进制；或通过配置让 containerd proxy 到另一个 gRPC service",
        "修改 kubelet 源码；或修改 Linux 内核",
        "仅支持静态编译进 containerd（二进制方式不支持）",
        "只能通过 Dockerfile 的 ARG/ENV 注入",
      ],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md：External plugins 支持二进制在 PATH 与 proxy gRPC 两种扩展方式。",
    },
    {
      id: "w2-1-q28",
      question: "按照 containerd 的 PLUGINS.md，proxy plugin 当前支持的 type 不包括哪个？",
      options: ["runtime", "snapshot", "content", "diff"],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md 指出 proxy plugin 当前支持 types 为 snapshot/content/diff。",
    },
    {
      id: "w2-1-q29",
      question: "containerd 的 PLUGINS.md 描述了 CRI 下如何选择不同运行时：哪项说法正确？",
      options: [
        "可在 containerd 配置中定义 named runtimes；通过 CRI 的 runtime handler 选择；未指定则用默认 runtime",
        "CRI 不支持多运行时，所有容器固定使用同一个 runtime",
        "只能通过修改镜像 manifest 指定运行时",
        "只能在 runc 的 config.json 内指定运行时",
      ],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md 在 V2 Runtimes 章节说明：CRI 可配置 named runtimes，并通过 runtime handler 选择，默认 runtime 兜底。",
    },
    {
      id: "w2-1-q30",
      question: "containerd 的 PLUGINS.md 提到，想查看当前 containerd 拥有哪些插件，应使用哪个命令？",
      options: ["ctr plugins ls", "docker system info", "kubectl get plugins", "runc list"],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md 在 Built-in Plugins 章节给出：使用 `ctr plugins ls` 查看插件列表与状态。",
    },
  ],
  "w2-2": [
    {
      id: "w2-2-q1",
      question: "多阶段构建的核心收益是？",
      options: [
        "将构建与运行环境分离，减少最终镜像体积与攻击面",
        "让镜像构建更慢",
        "只能用于调试",
        "必须在生产禁用",
      ],
      answer: 0,
      rationale: "官方最佳实践强调使用多阶段拷贝最小产物到最终镜像。",
    },
    {
      id: "w2-2-q2",
      question: "为何要合并 apt-get update 与 install 到同一 RUN？",
      options: [
        "避免缓存过期并减少层数",
        "提升镜像可读性",
        "与安全无关，仅为美观",
        "否则镜像无法启动",
      ],
      answer: 0,
      rationale: "官方建议将更新与安装放同一层，防止缓存失效导致失败。",
    },
    {
      id: "w2-2-q3",
      question: ".dockerignore 的作用是？",
      options: [
        "减少构建上下文大小，避免不必要文件进入镜像",
        "控制容器日志",
        "限制容器网络访问",
        "设置运行时环境变量",
      ],
      answer: 0,
      rationale: "忽略文件可加速构建并减少泄露风险。",
    },
    {
      id: "w2-2-q4",
      question: "使用 COPY --chown 的好处是？",
      options: [
        "在构建阶段即写入正确的文件所有者，避免额外 chown 层",
        "提高镜像拉取速度",
        "只影响运行时权限，不影响文件",
        "必须与 ADD 一起使用",
      ],
      answer: 0,
      rationale: "最佳实践建议在 COPY 时设置权限，减少额外层。",
    },
    {
      id: "w2-2-q5",
      question: "为何推荐固定基础镜像的 tag 或 digest？",
      options: [
        "保证可重复构建与安全可追溯性",
        "让镜像更大",
        "防止 docker build 失败",
        "便于自动删除镜像",
      ],
      answer: 0,
      rationale: "锁定版本避免 latest 漂移导致行为变化。",
    },
    {
      id: "w2-2-q6",
      question: "ADD 与 COPY 的使用建议是？",
      options: [
        "默认用 COPY，只有需要解压本地 tar 或 URL 下载时再用 ADD",
        "总是使用 ADD",
        "两者无差别，随意使用",
        "ADD 必须与 RUN 一起用",
      ],
      answer: 0,
      rationale: "官方最佳实践建议优先 COPY，避免 ADD 的隐式行为。",
    },
    {
      id: "w2-2-q7",
      question: "为什么 ENTRYPOINT/CMD 推荐使用 exec 形式（JSON 数组）？",
      options: [
        "可正确接收信号并避免 shell 展开副作用",
        "写起来更短",
        "能自动开启 TTY",
        "避免 HEALTHCHECK 失败",
      ],
      answer: 0,
      rationale: "exec 形式直接作为 PID1，信号不会被 /bin/sh 截留。",
    },
    {
      id: "w2-2-q8",
      question: "如何利用层缓存加速构建？",
      options: [
        "将变动频繁的步骤放在 Dockerfile 末尾，前面尽量稳定",
        "随机排列指令",
        "频繁清理缓存",
        "禁用 multi-stage",
      ],
      answer: 0,
      rationale: "指令顺序决定缓存命中率，官方建议把易变部分靠后。",
    },
    {
      id: "w2-2-q9",
      question: "为何建议在镜像中设置非 root 用户？",
      options: [
        "减少潜在攻击面并符合最小权限原则",
        "会导致容器无法启动",
        "只为美观",
        "为了让镜像更大",
      ],
      answer: 0,
      rationale: "最佳实践强调使用 USER 降权运行应用。",
    },
    {
      id: "w2-2-q10",
      question: "HEALTHCHECK 指令的作用是？",
      options: [
        "让引擎探测容器健康，失败时可标记为 unhealthy 或配合编排器重启",
        "限制 CPU 使用率",
        "自动扩缩容",
        "替代 ENTRYPOINT",
      ],
      answer: 0,
      rationale: "Dockerfile 文档建议提供健康检查以便上层编排处理异常。",
    },
    {
      id: "w2-2-q11",
      question: "多阶段构建文档指出，每条 FROM 指令的作用是？",
      options: ["开始一个新的 build stage（可使用不同 base image）", "把上一层缓存清空", "只用于声明镜像作者信息", "只在 docker run 时生效"],
      answer: 0,
      rationale: "Multi-stage builds 文档：每条 FROM 指令都会开启一个新的 stage，并且可以使用不同的基础镜像。",
    },
    {
      id: "w2-2-q12",
      question: "多阶段构建文档：如果没有给 stage 命名，COPY --from 应如何引用 stage？",
      options: ["用整数编号引用，从 0 表示第一条 FROM", "只能用镜像 tag 引用", "只能用 stage 的 WORKDIR 引用", "不能引用，只能复制本地文件"],
      answer: 0,
      rationale: "多阶段构建文档说明：默认 stage 不命名时按整数编号引用，第一条 FROM 为 0。",
    },
    {
      id: "w2-2-q13",
      question: "在多阶段构建中，如何给 stage 命名以便后续引用？",
      options: [
        "在 FROM 后使用 `AS <name>`（例如 `FROM golang:1.24 AS build`）",
        "在 RUN 中写 `NAME=build`",
        "在 Dockerfile 顶部写 `STAGE build`",
        "只能通过 docker build 的 -t 命名",
      ],
      answer: 0,
      rationale: "多阶段构建文档：可用 FROM ... AS <NAME> 命名 stage，并在 COPY --from 使用该名称。",
    },
    {
      id: "w2-2-q14",
      question: "多阶段构建文档强调命名 build stage 的主要好处是？",
      options: ["即使 Dockerfile 指令重排，COPY --from=... 也不易因编号变化而失效", "命名后会自动开启多平台构建", "命名后会强制禁用缓存", "命名后会自动生成镜像签名"],
      answer: 0,
      rationale: "多阶段构建文档指出：用名称引用 stage 比编号更稳健，避免重排导致 COPY 断裂。",
    },
    {
      id: "w2-2-q15",
      question: "多阶段构建文档：要在指定 stage 结束构建，应使用哪个命令参数？",
      options: ["`docker build --target <stageName> ...`", "`docker run --target <stageName> ...`", "`docker build --stage <stageName> ...`", "`docker compose up --target <stageName> ...`"],
      answer: 0,
      rationale: "多阶段构建文档示例：`docker build --target build -t hello .` 可停在指定 stage。",
    },
    {
      id: "w2-2-q16",
      question: "多阶段构建文档：`COPY --from` 除了引用前面的 stage，还可以从哪里复制？",
      options: ["从一个外部 image（本地或 registry 上的 tag/ID，例如 `--from=nginx:latest`）", "只能从同一个 stage 内复制", "只能从宿主机 /etc 目录复制", "只能从 Docker Desktop 内置镜像复制"],
      answer: 0,
      rationale: "多阶段构建文档说明：`COPY --from` 也可引用单独的 image；需要时 Docker client 会拉取该 image。",
    },
    {
      id: "w2-2-q17",
      question: "多阶段构建文档：如何“从之前的 stage 继续”创建一个新的 stage？",
      options: ["在新的 FROM 中引用之前的 stage（例如 `FROM builder AS build1`）", "用 `COPY --from` 自动继承所有 RUN 结果", "用 `ARG --from=builder` 指定", "必须把之前 stage 推送到 registry 再拉取"],
      answer: 0,
      rationale: "多阶段构建文档示例展示：可在 FROM 指令中引用之前 stage 作为新 stage 的 base。",
    },
    {
      id: "w2-2-q18",
      question: "多阶段构建文档中，BuildKit 与 legacy builder 的差异哪项正确？",
      options: ["BuildKit 只构建目标 stage 依赖的 stages；legacy builder 会处理到目标前的所有 stages", "BuildKit 总是比 legacy 构建更多 stages", "legacy builder 才支持 --target，BuildKit 不支持", "两者完全一致，没有差异"],
      answer: 0,
      rationale: "多阶段构建文档在 Differences between legacy builder and BuildKit 中说明：BuildKit 会跳过与目标无依赖的 stage。",
    },
    {
      id: "w2-2-q19",
      question: "Dockerfile 最佳实践中，想避免命中构建缓存、强制重新执行指令，应使用哪个 build 选项？",
      options: ["`docker build --no-cache ...`", "`docker build --no-layer-cache ...`", "`docker build --rebuild ...`", "`docker build --fresh ...`"],
      answer: 0,
      rationale: "Dockerfile Best practices 文档：可用 `--no-cache` 避免 cache hits。",
    },
    {
      id: "w2-2-q20",
      question: "最佳实践文档解释：为什么不建议把 `RUN apt-get update` 与后续 `RUN apt-get install` 分开写？",
      options: [
        "容易复用缓存导致 update 不执行，后续 install 可能使用过期索引甚至失败",
        "因为 update 会自动删除已安装包",
        "因为 install 只能在容器运行时执行",
        "因为 update 与 install 会互相抵消",
      ],
      answer: 0,
      rationale: "Best practices 的 apt-get 章节指出：update 单独一层会被缓存，后续 install 复用缓存导致索引过期/失败。",
    },
    {
      id: "w2-2-q21",
      question: "最佳实践文档中，为减少镜像体积，apt-get 安装后通常建议清理哪个目录？",
      options: ["/var/lib/apt/lists", "/var/log", "/usr/src", "/etc/apt/sources.list.d"],
      answer: 0,
      rationale: "Best practices 文档提到移除 /var/lib/apt/lists 可减少镜像层体积（避免把 apt cache 存进 layer）。",
    },
    {
      id: "w2-2-q22",
      question: "最佳实践文档对 ENTRYPOINT 与 CMD 的组合建议更贴近哪项？",
      options: [
        "用 ENTRYPOINT 设置镜像的主命令，用 CMD 提供默认参数/可覆盖参数",
        "CMD 用来设置镜像主命令，ENTRYPOINT 只用于健康检查",
        "ENTRYPOINT 与 CMD 只能二选一，不能同时使用",
        "ENTRYPOINT 必须写成 shell 形式，CMD 必须写成 exec 形式",
      ],
      answer: 0,
      rationale: "Best practices 文档在 ENTRYPOINT 章节：ENTRYPOINT 设定主命令，CMD 作为默认参数（示例 ENTRYPOINT + CMD）。",
    },
    {
      id: "w2-2-q23",
      question: "最佳实践文档对 CMD 的推荐写法是？",
      options: ["通常使用 exec 形式：`CMD [\"executable\", \"param1\", ...]`", "总是使用 shell 形式：`CMD executable param`", "只写参数：`CMD [\"--flag\"]`（不配 ENTRYPOINT）", "必须为空，由运行时注入"],
      answer: 0,
      rationale: "Best practices 文档指出：CMD 应几乎总是使用 JSON 数组的 exec 形式。",
    },
    {
      id: "w2-2-q24",
      question: "最佳实践文档中，若希望容器运行时默认带有某个环境变量，应使用哪条指令？",
      options: ["ENV", "RUN export", "ARG", "LABEL"],
      answer: 0,
      rationale: "Best practices 的 ENV 示例：ENV 写入镜像的默认环境，运行容器仍可见。",
    },
    {
      id: "w2-2-q25",
      question: "最佳实践文档示例：如果只是构建过程中临时用变量且不希望运行时仍存在，更贴近哪种做法？",
      options: ["在同一个 RUN 中 export→使用→unset（不要用 ENV 持久化）", "用 ENV 设置后再在下一条 RUN 里 unset", "把变量写入镜像 label", "在 docker run 时用 --rm 自动清理环境变量"],
      answer: 0,
      rationale: "Best practices 示例说明：ENV 会持久化；临时变量可在同一 RUN 中 export 并在结束前 unset。",
    },
    {
      id: "w2-2-q26",
      question: "最佳实践文档提到，使用 ADD 下载远程 artifact 时，可以用哪个参数做校验？",
      options: ["`ADD --checksum=sha256:<hash> ...`", "`ADD --verify ...`", "`COPY --checksum ...`", "`RUN curl --checksum ...`"],
      answer: 0,
      rationale: "Best practices 的 ADD/COPY 章节给出：ADD 支持 `--checksum=sha256:...` 校验远程下载。",
    },
    {
      id: "w2-2-q27",
      question: "最佳实践文档的 apt-get 示例里，通常推荐加哪个选项以避免安装推荐包、减少体积？",
      options: ["--no-install-recommends", "--with-recommends", "--only-upgrade", "--dry-run"],
      answer: 0,
      rationale: "Best practices 的 apt-get 示例多次使用 `apt-get install -y --no-install-recommends ...` 控制安装体积。",
    },
    {
      id: "w2-2-q28",
      question: "最佳实践文档提到一种 cache busting 的方式是？",
      options: ["在 apt-get install 中指定包版本（版本变化会触发缓存失效并重新执行 update）", "把 Dockerfile 中所有 RUN 都合并成一条", "把所有依赖都写进 ENTRYPOINT", "只要写了 .dockerignore 就会自动 cache bust"],
      answer: 0,
      rationale: "Best practices 的 apt-get 章节提到：通过指定包版本可触发 cache bust，确保安装到新版本。",
    },
    {
      id: "w2-2-q29",
      question: "Docker CI 文档中，为什么推荐在 CI 中用 Docker 容器作为 build/test 环境？",
      options: ["容器提供可复现、隔离的环境，能带来更可预测的构建/测试结果", "因为容器能绕过所有单元测试", "因为 CI 只能在容器里运行", "因为容器会自动生成发布说明"],
      answer: 0,
      rationale: "Docker CI 文档指出：containers 是可复现、隔离的环境，能带来更可预测的结果。",
    },
    {
      id: "w2-2-q30",
      question: "CI 文档中提到的 “Docker in Docker” 指的是？",
      options: ["在容器内运行 Docker 用于构建镜像（把构建环境容器化）", "在容器里运行 Kubernetes 集群", "在镜像里嵌套另一个 Dockerfile", "在 registry 里运行 Docker daemon"],
      answer: 0,
      rationale: "Docker CI 文档说明：在容器化的构建环境里进行 Docker builds，这就是 Docker in Docker。",
    },
  ],
  "w2-3": [
    {
      id: "w2-3-q1",
      question: "Kubernetes 与容器运行时交互的官方接口是？",
      options: ["CRI（Container Runtime Interface）gRPC API", "Docker Remote API", "systemd API", "RESTful CNI"],
      answer: 0,
      rationale: "Dockershim 被移除后，所有运行时需实现 CRI。",
    },
    {
      id: "w2-3-q2",
      question: "Dockershim 在哪个版本被移除？",
      options: ["v1.24 起正式移除", "v1.18 起移除", "尚未移除", "需要手动编译内核才能移除"],
      answer: 0,
      rationale: "K8s 1.24 release notes 宣布移除 dockershim。",
    },
    {
      id: "w2-3-q3",
      question: "containerd 与 CRI-O 的共同点是？",
      options: [
        "均实现 CRI，并依赖 OCI runtime（通常是 runc）执行容器",
        "都依赖 Docker Daemon",
        "不支持 OCI 镜像",
        "仅能运行在 Windows",
      ],
      answer: 0,
      rationale: "二者都是符合 CRI 的运行时，底层调用 runc/OCI 规范。",
    },
    {
      id: "w2-3-q4",
      question: "为什么社区决定弃用 dockershim？",
      options: [
        "维护成本高且与 CRI 重复，鼓励直接使用 OCI 运行时",
        "Docker 镜像不再受支持",
        "安全原因禁用 CRI",
        "因为 kubectl 无法连接 Docker",
      ],
      answer: 0,
      rationale: "官方 FAQ 提到维护负担与重复抽象是主要原因。",
    },
    {
      id: "w2-3-q5",
      question: "Pod Sandbox（pause 容器）的作用是？",
      options: [
        "为同一 Pod 提供共享的网络/IPC/UTS 命名空间",
        "运行业务逻辑",
        "存储镜像层",
        "调试用的临时容器",
      ],
      answer: 0,
      rationale: "CRI 规范定义 sandbox 容器建立共享命名空间环境。",
    },
    {
      id: "w2-3-q6",
      question: "迁移到 containerd 后，镜像格式的影响是？",
      options: [
        "仍支持 OCI/Docker 镜像，无需重新构建",
        "必须重建为 cri 镜像格式",
        "只支持 tar 包",
        "只支持私有镜像仓库",
      ],
      answer: 0,
      rationale: "OCI 镜像兼容 containerd，无需变更构建流程。",
    },
    {
      id: "w2-3-q7",
      question: "CRI gRPC 服务的主要两类 API 是？",
      options: ["RuntimeService 与 ImageService", "Scheduler 与 Controller", "CoreDNS 与 kube-proxy", "CSI 与 CNI"],
      answer: 0,
      rationale: "CRI 定义运行时与镜像管理两组接口。",
    },
    {
      id: "w2-3-q8",
      question: "CRIO/containerd 如何拉取镜像？",
      options: [
        "遵循 OCI Distribution 规范，通过 ImageService 实现镜像拉取与存储",
        "必须依赖 Docker CLI 拉取",
        "只能从本地目录读取",
        "需要在 kubelet 中编写插件",
      ],
      answer: 0,
      rationale: "CRI 镜像服务直接对接 registry，不依赖 Docker Daemon。",
    },
    {
      id: "w2-3-q9",
      question: "kubectl 日志/exec 在 dockershim 移除后依赖什么？",
      options: [
        "kubelet 通过 CRI 提供的 streaming API（如 CRI streaming server）",
        "直接调用 docker logs",
        "访问 etcd",
        "需要安装额外代理",
      ],
      answer: 0,
      rationale: "流式操作由 CRI streaming 端点处理，与 Docker 无关。",
    },
    {
      id: "w2-3-q10",
      question: "运行时必须实现哪个插件才能让 Pod 具备网络？",
      options: ["CNI 插件由 kubelet 调用，与运行时配合完成网络配置", "无需插件，kubelet 自行配置", "CRI 已包含网络能力", "仅需 CSI"],
      answer: 0,
      rationale: "网络仍由 kubelet 调用 CNI 完成，运行时负责容器生命周期。",
    },
    {
      id: "w2-3-q11",
      question: "Dockershim Deprecation FAQ 指出，Kubernetes 1.20 对“使用 Docker 作为 runtime”的变化是什么？",
      options: [
        "kubelet 启动时打印一条警告日志（warning log），除此之外行为不变",
        "立即移除 dockershim，无法再用 Docker runtime",
        "强制把 Docker 镜像转换为 OCI 镜像",
        "必须把所有节点切换到 Windows",
      ],
      answer: 0,
      rationale: "Dockershim FAQ：1.20 的变化是 kubelet 启动时会打印一条 warning log。",
    },
    {
      id: "w2-3-q12",
      question: "Dockershim Deprecation FAQ 中说明 dockershim 被弃用的直接原因之一是？",
      options: [
        "Docker 本身不实现 CRI，Kubernetes 需要通过 dockershim 适配，维护负担大",
        "Docker 镜像格式与 OCI 不兼容",
        "CRI 标准已废弃",
        "containerd 不再维护",
      ],
      answer: 0,
      rationale: "FAQ：CRI 为减轻负担而生，但 Docker 不实现 CRI，导致 dockershim 维护成本高。",
    },
    {
      id: "w2-3-q13",
      question: "Dockershim Deprecation FAQ 对 dockershim 的定位更接近哪项？",
      options: [
        "本来就是临时过渡方案（shim），用于在 CRI 生态成熟前适配 Docker",
        "Kubernetes 永久且唯一推荐的运行时实现",
        "用于把 kubelet 的 gRPC 转换为 HTTP 的长期组件",
        "用于实现 CNI 的网络插件",
      ],
      answer: 0,
      rationale: "FAQ：Dockershim was always intended to be a temporary solution (shim)。",
    },
    {
      id: "w2-3-q14",
      question: "Dockershim Deprecation FAQ 提到，哪些与 dockershim 大量不兼容的特性正在新 CRI runtimes 中实现？",
      options: ["cgroups v2 与 user namespaces", "Helm 与 Operator", "Ingress 与 Service", "etcd watch 与 leader election"],
      answer: 0,
      rationale: "FAQ：提到 cgroups v2 与 user namespaces 等特性在新 CRI runtimes 中实现，移除 dockershim 有利于推进。",
    },
    {
      id: "w2-3-q15",
      question: "CRI-O 官方文档对 CRI-O 的定位更贴近哪项？",
      options: [
        "实现 Kubernetes CRI 的运行时，使用 OCI 兼容 runtime 运行 Pods，作为 Docker runtime 的轻量替代",
        "Kubernetes 的网络插件（CNI）实现",
        "镜像仓库协议（Distribution spec）实现",
        "仅用于 Windows Hyper-V 容器的运行时",
      ],
      answer: 0,
      rationale: "CRI-O 官方站点：CRI-O 是 Kubernetes CRI 的实现，用于使用 OCI 兼容 runtimes 运行 Pods，作为 Docker 的轻量替代。",
    },
    {
      id: "w2-3-q16",
      question: "Dockershim Deprecation FAQ 更新中提到，dockershim 从 Kubernetes 移除后由谁承诺继续维护？",
      options: ["Mirantis 和 Docker", "Canonical 和 VMware", "Red Hat 和 SUSE", "Google 和 Amazon"],
      answer: 0,
      rationale: "FAQ Update：Mirantis and Docker have committed to maintaining the dockershim after it is removed from Kubernetes。",
    },
    {
      id: "w2-3-q17",
      question: "Dockershim Deprecation FAQ：dockershim 移除后，现有通过 `docker build` 构建的镜像会怎样？",
      options: [
        "仍可被所有 CRI 实现运行，镜像不会因此失效",
        "必须全部重建为新的 CRI 镜像格式",
        "只能在 Docker Hub 上运行",
        "只能在 Windows 节点运行",
      ],
      answer: 0,
      rationale: "FAQ：images produced from docker build will work with all CRI implementations。",
    },
    {
      id: "w2-3-q18",
      question: "Dockershim Deprecation FAQ：关于私有镜像（private images）在 CRI runtime 下的拉取，哪项正确？",
      options: [
        "仍可使用 Kubernetes 的 pull secrets（通过 PodSpec 或 ServiceAccount）",
        "必须把私有仓库改造成 Docker Hub",
        "只能通过在节点上手工 docker login",
        "只能关闭镜像鉴权才能拉取",
      ],
      answer: 0,
      rationale: "FAQ：All CRI runtimes support the same pull secrets configuration used in Kubernetes。",
    },
    {
      id: "w2-3-q19",
      question: "Dockershim Deprecation FAQ 对 OCI 的解释里，哪项说法正确？",
      options: [
        "OCI 标准化了镜像与运行时等接口；runc 是 runtime-spec 的实现，也是 containerd/CRI-O 的默认底层 runtime",
        "OCI 是 Kubernetes 专属的网络标准",
        "OCI 只定义 CNI 插件 API",
        "runc 是镜像仓库协议的实现",
      ],
      answer: 0,
      rationale: "FAQ：OCI 维护 image-spec/runtime-spec；runc 实现 runtime-spec，并是 containerd 与 CRI-O 的默认底层 runtime。",
    },
    {
      id: "w2-3-q20",
      question: "Dockershim Deprecation FAQ 给出的“生产中使用其他 runtimes 的例子”中，哪项匹配？",
      options: [
        "OpenShift 4.x 自 2019 年 6 月起在生产使用 CRI-O；kind 长期使用 containerd",
        "Kubernetes 只在生产使用 dockershim，从未验证其他运行时",
        "OpenShift 4.x 使用 Docker Engine 并内置 dockershim",
        "kind 只能使用 Docker Desktop 作为运行时",
      ],
      answer: 0,
      rationale: "FAQ 提到：kind 使用 containerd；OpenShift 4.x 自 2019 年 6 月起在生产使用 CRI-O。",
    },
    {
      id: "w2-3-q21",
      question: "Dockershim Deprecation FAQ 在选择 CRI 实现的建议中提到：如果你现在用 Docker 没问题，迁移到哪个运行时通常更容易？",
      options: ["containerd", "只能继续使用 dockershim", "必须迁移到 Docker Desktop", "必须迁移到 rkt"],
      answer: 0,
      rationale: "FAQ：If Docker is working for you, moving to containerd should be a relatively easy swap。",
    },
    {
      id: "w2-3-q22",
      question: "Dockershim Deprecation FAQ 列出的迁移注意点中，哪一项被明确提到需要评估/调整？",
      options: ["节点脚本是否依赖 docker CLI 或 Docker socket", "必须修改所有 Pod 的 apiVersion", "必须把所有 Deployment 改为 StatefulSet", "必须关闭 RBAC"],
      answer: 0,
      rationale: "FAQ 的迁移注意点列表提到：node provisioning scripts 可能调用 docker 或使用 control socket。",
    },
    {
      id: "w2-3-q23",
      question: "CRI-O 架构说明中，CRI-O 拉取镜像主要使用哪个库？",
      options: ["containers/image", "containerd/content", "Docker Registry V1 client", "etcd clientv3"],
      answer: 0,
      rationale: "CRI-O 官方文档 Architecture：CRI-O uses the containers/image library to pull the image from a container registry。",
    },
    {
      id: "w2-3-q24",
      question: "Dockershim Deprecation FAQ：如果你有系统维护脚本依赖 docker CLI，文档建议用什么工具作为替代？",
      options: ["crictl", "kubectl", "helm", "etcdctl"],
      answer: 0,
      rationale: "FAQ：For system maintenance, you can use the crictl tool as a drop-in replacement。",
    },
    {
      id: "w2-3-q25",
      question: "Dockershim Deprecation FAQ：如果你需要在没有 Docker 的环境里构建镜像，文档列出的可选工具包括？",
      options: ["buildah/kaniko/img 等（不依赖 Docker daemon）", "必须使用 docker build", "只能使用 kubectl apply", "只能使用 runc build"],
      answer: 0,
      rationale: "FAQ 提到：可使用 img、buildah、kaniko、buildkit-cli-for-kubectl 等不依赖 Docker 的构建方案。",
    },
    {
      id: "w2-3-q26",
      question: "Kubelet CRI 文档中，CRI 的定位是？",
      options: ["一个插件接口，使 kubelet 可使用多种运行时而无需重新编译集群组件", "一个新的 CNI 网络模型", "一个替代 etcd 的存储层", "一个用于生成 YAML 的模板语言"],
      answer: 0,
      rationale: "CRI 文档：CRI 是 plugin interface，使 kubelet 可使用多种运行时而无需重新编译集群组件。",
    },
    {
      id: "w2-3-q27",
      question: "CRI 文档指出，kubelet 与容器运行时的通信方式是？",
      options: ["kubelet 作为 gRPC client 连接运行时提供的 endpoint", "kubelet 通过 SSH 执行 docker 命令", "kubelet 通过 HTTP 轮询 registry", "kubelet 直接读写 /var/lib/docker"],
      answer: 0,
      rationale: "CRI 文档：The kubelet acts as a client when connecting to the container runtime via gRPC。",
    },
    {
      id: "w2-3-q28",
      question: "CRI 文档提到，kubelet 通过哪个参数配置容器运行时 endpoint？",
      options: ["--container-runtime-endpoint", "--runtime-class", "--container-runtime", "--cri-endpoint"],
      answer: 0,
      rationale: "CRI 文档：runtime/image service endpoints 可通过 kubelet 的 `--container-runtime-endpoint` 配置。",
    },
    {
      id: "w2-3-q29",
      question: "CRI 文档指出，从 Kubernetes v1.26 起，如果运行时不支持哪一版 CRI API，会导致 kubelet 不注册节点？",
      options: ["v1 CRI API", "v1beta1 CRI API", "v2 CRI API", "HTTP/1.1 CRI API"],
      answer: 0,
      rationale: "CRI 文档：Kubernetes v1.26+ 要求运行时支持 v1 CRI API，否则 kubelet 不会注册节点。",
    },
    {
      id: "w2-3-q30",
      question: "CRI-O 架构中，conmon 进程的作用是？",
      options: [
        "每个容器一个 conmon，用于监控容器、持有 PID1 的 pty、处理日志并记录退出码",
        "用于把镜像 push 到 registry",
        "作为 kubelet 的 gRPC server",
        "作为 CNI 的网络控制器",
      ],
      answer: 0,
      rationale: "CRI-O 官方文档 Architecture：每个容器由独立 conmon 监控，处理日志并记录容器进程退出码。",
    },
  ],
  "w2-4": [
    {
      id: "w2-4-q1",
      question: "OCI Image Specification 主要定义了什么？",
      options: [
        "镜像 manifest/config/layer 的格式与 mediatype",
        "容器运行时的 syscalls 列表",
        "Kubernetes Pod API",
        "系统日志格式",
      ],
      answer: 0,
      rationale: "Image Spec 规定 manifest/config/rootfs 层的描述方式。",
    },
    {
      id: "w2-4-q2",
      question: "OCI Runtime Specification 的核心产物是？",
      options: [
        "config.json 与 rootfs bundle，供 runtime 执行",
        "镜像仓库 API",
        "Helm Chart 定义",
        "CNI 插件列表",
      ],
      answer: 0,
      rationale: "Runtime Spec 描述 bundle 结构与容器进程配置。",
    },
    {
      id: "w2-4-q3",
      question: "OCI Distribution 规范的作用是？",
      options: [
        "定义镜像推送/拉取的 registry HTTP API（兼容 Docker Registry v2）",
        "描述容器日志",
        "提供调度算法",
        "规范 Cgroups",
      ],
      answer: 0,
      rationale: "Distribution 负责 registry 协议，确保镜像分发互操作。",
    },
    {
      id: "w2-4-q4",
      question: "多架构镜像在 OCI 中如何表示？",
      options: [
        "通过 Image Index/Manifest List 聚合不同架构的 manifest",
        "需要单独 tag，无法聚合",
        "使用 Helm Charts",
        "在 config.json 中写多个 os/arch",
      ],
      answer: 0,
      rationale: "Image Index（mediatype application/vnd.oci.image.index.v1+json）用于多架构。",
    },
    {
      id: "w2-4-q5",
      question: "manifest 中的 layer 描述包含哪些字段？",
      options: [
        "mediaType、size、digest 等",
        "CPU/内存限制",
        "容器环境变量",
        "CNI 配置",
      ],
      answer: 0,
      rationale: "Image Spec 定义 layer 描述需包含 mediatype、size、digest。",
    },
    {
      id: "w2-4-q6",
      question: "config.json 的 process 字段主要描述什么？",
      options: [
        "入口命令、环境变量、用户、rlimit 等进程相关配置",
        "镜像仓库地址",
        "日志驱动",
        "Kubernetes Service",
      ],
      answer: 0,
      rationale: "Runtime Spec 的 process 章节涵盖执行参数与权限设置。",
    },
    {
      id: "w2-4-q7",
      question: "OCI 中使用的 digest 通常是哪种算法？",
      options: ["sha256:<hash>", "md5:<hash>", "crc32", "sha1:<hash>"],
      answer: 0,
      rationale: "规范使用 sha256 表达内容寻址。",
    },
    {
      id: "w2-4-q8",
      question: "运行时执行 OCI bundle 的典型步骤是？",
      options: [
        "准备 rootfs，读取 config.json，调用 OCI runtime（如 runc run）创建进程",
        "先推送镜像到 registry 再运行",
        "必须连接 Kubernetes",
        "写入 etcd 后自动运行",
      ],
      answer: 0,
      rationale: "Runtime Spec 描述 runtime 根据 bundle 直接创建容器。",
    },
    {
      id: "w2-4-q9",
      question: "annotations 在 OCI 中的作用是？",
      options: [
        "携带可选元数据键值对，供工具链或平台使用",
        "控制容器 CPU 上限",
        "配置网络策略",
        "替代 manifest 字段",
      ],
      answer: 0,
      rationale: "三大规范均允许 annotations 扩展非标准信息。",
    },
    {
      id: "w2-4-q10",
      question: "为什么 OCI 规范重要？",
      options: [
        "确保镜像、运行时、分发的互操作性，促进生态兼容",
        "用于定义 Kubernetes API",
        "限制容器必须用某个发行版",
        "只为调试用途",
      ],
      answer: 0,
      rationale: "遵循 OCI 使不同工具链可互换，避免厂商锁定。",
    },
    {
      id: "w2-4-q11",
      question: "OCI Image Manifest 规范中，schemaVersion 必须是多少？",
      options: ["2", "1", "3", "由实现自定义"],
      answer: 0,
      rationale: "OCI Image Manifest Specification：schemaVersion MUST be 2。",
    },
    {
      id: "w2-4-q12",
      question: "当 OCI image manifest 显式包含 mediaType 字段时，其值必须是？",
      options: [
        "application/vnd.oci.image.manifest.v1+json",
        "application/vnd.oci.image.index.v1+json",
        "application/vnd.oci.descriptor.v1+json",
        "application/vnd.docker.distribution.manifest.v1+json",
      ],
      answer: 0,
      rationale: "OCI Image Manifest Specification：mediaType 字段（若使用）MUST 为 application/vnd.oci.image.manifest.v1+json。",
    },
    {
      id: "w2-4-q13",
      question: "OCI Image Index 的 mediaType 是？",
      options: [
        "application/vnd.oci.image.index.v1+json",
        "application/vnd.oci.image.manifest.v1+json",
        "application/vnd.oci.image.config.v1+json",
        "application/vnd.oci.descriptor.v1+json",
      ],
      answer: 0,
      rationale: "OCI Image Index Specification：该结构定义的 media type 为 application/vnd.oci.image.index.v1+json。",
    },
    {
      id: "w2-4-q14",
      question: "在 OCI Image Index 的 manifests 条目里，如果提供 platform，对应哪些字段是必需的？",
      options: ["architecture 与 os", "variant 与 features", "os.version 与 os.features", "cpu 与 memory"],
      answer: 0,
      rationale: "OCI Image Index Specification：platform 中 architecture 与 os 为 REQUIRED，其余多为 OPTIONAL/保留字段。",
    },
    {
      id: "w2-4-q15",
      question: "OCI Image Manifest 对 layers 的顺序要求是？",
      options: [
        "layers[0] 必须是 base layer，后续 layers 按堆叠顺序依次排列",
        "layers 顺序无关，运行时会自动排序",
        "layers 必须按大小排序",
        "layers 必须按 digest 字典序排序",
      ],
      answer: 0,
      rationale: "OCI Image Manifest Specification：要求 base layer 在 index 0，后续按 stack order 排列。",
    },
    {
      id: "w2-4-q16",
      question: "OCI Descriptor 规范中，一个 descriptor 的必需字段组合是？",
      options: ["mediaType、digest、size", "name、tag、digest", "url、checksum、size", "platform、os、arch"],
      answer: 0,
      rationale: "OCI Descriptor 规范：mediaType、digest、size 都是 REQUIRED properties。",
    },
    {
      id: "w2-4-q17",
      question: "OCI Descriptor 的 digest 字符串格式要求更贴近哪项？",
      options: ["<algorithm>:<encoded>", "<encoded>@<algorithm>", "<hash>", "<repo>:<tag>"],
      answer: 0,
      rationale: "OCI Descriptor 规范：digest grammar 为 algorithm \":\" encoded。",
    },
    {
      id: "w2-4-q18",
      question: "OCI Descriptor 的 Registered algorithms 中，哪项是实现必须支持用于校验的？",
      options: ["sha256", "sha1", "md5", "crc32"],
      answer: 0,
      rationale: "OCI Descriptor 规范：Implementations MUST implement SHA-256 digest verification。",
    },
    {
      id: "w2-4-q19",
      question: "当算法标识为 sha256 时，digest 的编码部分（encoded）必须满足什么形式？",
      options: ["64 位小写十六进制（[a-f0-9]{64}）", "32 位十六进制（允许大写）", "64 位 base64", "任意长度字符串均可"],
      answer: 0,
      rationale: "OCI Descriptor 规范：sha256 的 encoded MUST match /[a-f0-9]{64}/，且 MUST NOT 使用大写 A-F。",
    },
    {
      id: "w2-4-q20",
      question: "关于 OCI Descriptor 的 data 字段，哪项符合规范的 Embedded Content 说明？",
      options: [
        "data 必须是 base64，解码后内容需与被引用内容一致；registry 不应擅自填充已上传 manifest 的 data 以免改变内容标识",
        "data 用于存放明文密码，运行时自动注入",
        "data 可以是任意 JSON，digest 无需校验",
        "data 只能由 registry 在 pull 时追加，client 不能写",
      ],
      answer: 0,
      rationale: "OCI Descriptor 规范：data 为 base64；registry MUST NOT 随意填充 uploaded manifests 的 data，否则会改变 content identifier。",
    },
    {
      id: "w2-4-q21",
      question: "OCI annotations 的通用规则中，哪项正确？",
      options: [
        "annotations 是 string→string 的 map；键应使用反向域名命名；未知 key 不能导致报错",
        "annotations 只能是数组，元素必须是 URL",
        "annotations 允许重复 key 以表达优先级",
        "annotations 的 value 必须是非空字符串",
      ],
      answer: 0,
      rationale: "OCI Annotations 规范：annotations 为字符串键值对，键唯一；value 可为空；消费者 MUST NOT 因未知 key 报错。",
    },
    {
      id: "w2-4-q22",
      question: "OCI annotations 规范中，哪个前缀是保留给 OCI 规范定义键的，扩展方不得占用？",
      options: ["org.opencontainers", "com.example", "io.kubernetes", "cn.example"],
      answer: 0,
      rationale: "OCI Annotations 规范：前缀 org.opencontainers（以及 org.opencontainers.image 子命名空间）为 OCI 保留。",
    },
    {
      id: "w2-4-q23",
      question: "以下哪个是 OCI 预定义的 annotation key，用于表示镜像构建时间（RFC 3339）？",
      options: [
        "org.opencontainers.image.created",
        "org.opencontainers.image.built_at",
        "org.opencontainers.image.timestamp",
        "org.opencontainers.created",
      ],
      answer: 0,
      rationale: "OCI Annotations 规范：org.opencontainers.image.created 表示镜像构建时间，需符合 RFC 3339。",
    },
    {
      id: "w2-4-q24",
      question: "OCI Image Config 的 Env 字段中，每个条目的格式是？",
      options: ["VARNAME=VARVALUE", "VARNAME:VARVALUE", "export VARNAME VARVALUE", "{\"name\":\"VARNAME\",\"value\":\"VARVALUE\"}"],
      answer: 0,
      rationale: "OCI Image Config 规范：Env entries are in the format of VARNAME=VARVALUE。",
    },
    {
      id: "w2-4-q25",
      question: "OCI Image Config 关于 Cmd/Entrypoint 的语义：如果 Entrypoint 未指定，Cmd 应如何解释？",
      options: ["Cmd 的第一个元素应被视为要执行的可执行文件", "Cmd 会被忽略，必须由运行时指定可执行文件", "Cmd 只能包含环境变量，不能包含命令", "Cmd 必须是单个字符串并由 shell 解析"],
      answer: 0,
      rationale: "OCI Image Config 规范：If an Entrypoint is not specified, first entry of Cmd SHOULD be interpreted as executable to run。",
    },
    {
      id: "w2-4-q26",
      question: "OCI Image Config 的 rootfs.type 必须是什么值？",
      options: ["layers", "overlay", "unionfs", "snapshot"],
      answer: 0,
      rationale: "OCI Image Config 规范：rootfs.type MUST be set to layers，遇到未知值实现 MUST 报错。",
    },
    {
      id: "w2-4-q27",
      question: "OCI Distribution Spec：拉取 manifest 的 URL 形如 `/v2/<name>/manifests/<reference>`，其中 <reference> 必须是？",
      options: ["digest 或 tag", "任意 URL", "仅能是 tag", "仅能是镜像 ID（无算法前缀）"],
      answer: 0,
      rationale: "OCI Distribution Spec：<reference> MUST be either the digest of the manifest or a tag。",
    },
    {
      id: "w2-4-q28",
      question: "OCI Distribution Spec 对拉取 manifest 的内容协商建议是？",
      options: [
        "client 应在 Accept 里声明支持的 manifest 类型；若返回 manifest 含 mediaType 字段，client 应校验其与 Content-Type 一致",
        "client 不应发送 Accept；registry 固定返回一种类型",
        "Content-Type 只用于展示，client 不应校验",
        "manifest 的 mediaType 必须与 Accept 不同以触发降级",
      ],
      answer: 0,
      rationale: "OCI Distribution Spec：client SHOULD include Accept；且 manifest 有 mediaType 时，client SHOULD reject unless it matches Content-Type。",
    },
    {
      id: "w2-4-q29",
      question: "OCI Distribution Spec：对一个存在的 manifest 执行 GET 成功时，响应码与建议返回的 digest 头分别是？",
      options: ["200 OK；Docker-Content-Digest", "201 Created；ETag", "204 No Content；Content-MD5", "302 Found；Location"],
      answer: 0,
      rationale: "OCI Distribution Spec：GET existing manifest MUST return 200 OK，成功响应 SHOULD contain Docker-Content-Digest。",
    },
    {
      id: "w2-4-q30",
      question: "OCI Runtime Spec 的 runtime state 中，status 可能的标准值包括？",
      options: ["creating/created/running/stopped", "pending/succeeded/failed/unknown", "init/ready/terminated", "starting/healthy/unhealthy/stopped"],
      answer: 0,
      rationale: "OCI Runtime Spec：status MAY be one of creating, created, running, stopped（实现也可扩展其他值）。",
    },
  ],
};