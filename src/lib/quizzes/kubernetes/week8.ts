import type { QuizQuestion } from "../types";

export const week8: Record<string, QuizQuestion[]> = {
  "w8-1": [
    {
      id: "w8-1-q1",
      question: "terraform init 的作用是？",
      options: [
        "下载 provider/模块并初始化工作目录",
        "执行计划",
        "销毁资源",
        "生成文档",
      ],
      answer: 0,
      rationale: "init 会安装 provider、初始化 backend 等。",
    },
    {
      id: "w8-1-q2",
      question: "state 文件默认存放在哪里？",
      options: [
        "当前工作目录的 terraform.tfstate（可配置远端后端）",
        "etcd",
        "云厂商自动托管",
        "不存在 state",
      ],
      answer: 0,
      rationale: "默认本地 tfstate，生产常配置 S3/GCS 等远端后端。",
    },
    {
      id: "w8-1-q3",
      question: "查看计划但不执行的命令？",
      options: ["terraform plan", "terraform preview", "terraform show", "terraform fmt"],
      answer: 0,
      rationale: "plan 用于生成并显示执行计划。",
    },
    {
      id: "w8-1-q4",
      question: "HCL 中定义资源的基本语法？",
      options: [
        "resource \"<provider_resource>\" \"<name>\" { ... }",
        "resources: {...}",
        "module {...}",
        "apply {...}",
      ],
      answer: 0,
      rationale: "Terraform 资源块使用 resource 关键字与类型、名称。",
    },
    {
      id: "w8-1-q5",
      question: "变量值的常见传递方式？",
      options: [
        "tfvars 文件、环境变量 TF_VAR_x、命令行 -var/-var-file",
        "只能硬编码",
        "必须在 main.tf 顶部定义",
        "仅支持环境变量",
      ],
      answer: 0,
      rationale: "官方推荐使用 tfvars 或环境变量传递变量值。",
    },
    {
      id: "w8-1-q6",
      question: "terraform apply -auto-approve 的作用？",
      options: [
        "跳过交互确认直接执行计划",
        "生成文档",
        "格式化代码",
        "仅验证语法",
      ],
      answer: 0,
      rationale: "auto-approve 适合 CI 中无人值守执行。",
    },
    {
      id: "w8-1-q7",
      question: "使用远程后端（如 S3 + DynamoDB）能解决什么问题？",
      options: [
        "共享/锁定 state，避免多人并发修改冲突",
        "加速镜像下载",
        "替代 provider",
        "自动创建 IAM",
      ],
      answer: 0,
      rationale: "远端 backend 支持状态锁与集中存储。",
    },
    {
      id: "w8-1-q8",
      question: "data 源块的用途？",
      options: [
        "读取现有资源/信息供配置引用",
        "创建资源",
        "删除资源",
        "生成文档",
      ],
      answer: 0,
      rationale: "data source 用于查询已有资源，如 AMI、VPC 等。",
    },
    {
      id: "w8-1-q9",
      question: ".terraform.lock.hcl 的意义？",
      options: [
        "锁定 provider 版本以保证一致性",
        "存储敏感密钥",
        "保存计划文件",
        "记录资源依赖",
      ],
      answer: 0,
      rationale: "锁文件记录精确 provider 版本，便于可重复构建。",
    },
    {
      id: "w8-1-q10",
      question: "terraform destroy 会做什么？",
      options: [
        "根据 state 计划并销毁所有受管资源",
        "删除代码文件",
        "仅删除本地 state",
        "升级 provider",
      ],
      answer: 0,
      rationale: "destroy 会对 state 中资源执行删除操作。",
    },
  ],
  "w8-2": [
    {
      id: "w8-2-q1",
      question: "创建 EKS/GKE 集群前通常需要哪些底层资源？",
      options: [
        "VPC/子网/安全组（或 GCP 网络与子网）等网络资源",
        "仅需要 IAM 用户",
        "只要 Kubernetes 清单",
        "必须预先创建 Pod",
      ],
      answer: 0,
      rationale: "EKS/GKE 需要网络与 IAM 等基础设施，Terraform 可一并管理。",
    },
    {
      id: "w8-2-q2",
      question: "aws_eks_cluster 创建后工作节点通常由什么管理？",
      options: [
        "托管节点组 aws_eks_node_group 或自管理 ASG",
        "自动创建 Pod",
        "无需节点即可运行",
        "CloudFormation 外部模板",
      ],
      answer: 0,
      rationale: "Terraform 可创建托管节点组或自管 AutoScaling Group。",
    },
    {
      id: "w8-2-q3",
      question: "获取 kubeconfig 的常见做法？",
      options: [
        "使用输出的 endpoint/证书或 aws/gcloud CLI 生成配置",
        "直接 kubectl apply",
        "编辑 state 文件",
        "使用 Helm 生成",
      ],
      answer: 0,
      rationale: "Terraform 输出集群信息，可配合 AWS CLI/GCloud 写入 kubeconfig。",
    },
    {
      id: "w8-2-q4",
      question: "GKE 集群资源名称是？",
      options: ["google_container_cluster", "gke_cluster", "google_kubernetes", "google_cluster_v2"],
      answer: 0,
      rationale: "GCP 提供 google_container_cluster 资源创建 GKE。",
    },
    {
      id: "w8-2-q5",
      question: "EKS 工作节点访问集群 API 需要什么？",
      options: [
        "适当的 IAM 角色/Instance Profile，并在 aws-auth ConfigMap 中映射",
        "不需要 IAM",
        "使用 service account token",
        "修改 kube-proxy",
      ],
      answer: 0,
      rationale: "节点角色需要在 aws-auth 中映射为 system:node。",
    },
    {
      id: "w8-2-q6",
      question: "删除集群时常见的遗留资源是什么？",
      options: [
        "外部 Load Balancer/EBS 卷等，需确认依赖被清理",
        "ConfigMap",
        "Pod 日志",
        "Helm release",
      ],
      answer: 0,
      rationale: "云资源可能因保护策略保留，需要额外销毁。",
    },
    {
      id: "w8-2-q7",
      question: "为什么推荐使用官方模块（如 terraform-aws-eks）？",
      options: [
        "封装了安全/可用性最佳实践，简化配置",
        "无法自定义",
        "只适合测试",
        "会锁死版本",
      ],
      answer: 0,
      rationale: "社区模块减少样板代码并内置合理默认。",
    },
    {
      id: "w8-2-q8",
      question: "配置 Terraform Provider 访问 AWS/GCP 的常见方式？",
      options: [
        "环境变量/共享凭证文件或通过 Cloud SDK 注入的临时凭证",
        "必须写死在代码里",
        "只能使用 kubeconfig",
        "需要本地 etcd",
      ],
      answer: 0,
      rationale: "Provider 支持多种安全的凭证加载方式。",
    },
    {
      id: "w8-2-q9",
      question: "使用 WaitForFirstConsumer 类似的功能在节点组/卷时的意义？",
      options: [
        "确保资源放置与可用区拓扑匹配，避免跨区",
        "提升日志性能",
        "减少 Helm 冲突",
        "避免拉取镜像",
      ],
      answer: 0,
      rationale: "拓扑感知可以避免创建错误区域的资源。",
    },
    {
      id: "w8-2-q10",
      question: "维护 Terraform 与集群内手工变更的关系应？",
      options: [
        "尽量通过 Terraform 管理基础设施，手工改动需导入或避免漂移",
        "随意手工修改",
        "删除 state 即可",
        "完全依赖 kubectl",
      ],
      answer: 0,
      rationale: "手工更改可能导致 state 漂移，需 plan/apply 或 import 修正。",
    },
  ],
  "w8-3": [
    {
      id: "w8-3-q1",
      question: "Ansible Playbook 的基本结构包含？",
      options: [
        "hosts、tasks、vars（可选）、handlers 等",
        "apiVersion、kind、spec",
        "Dockerfile 指令",
        "Makefile 目标",
      ],
      answer: 0,
      rationale: "Playbook 以 YAML 描述任务、目标主机和变量。",
    },
    {
      id: "w8-3-q2",
      question: "Ansible 连接方式的特点？",
      options: [
        "默认使用 SSH 无 Agent，不需在目标主机安装守护进程",
        "需要在目标机安装 Agent",
        "使用 HTTP API",
        "必须有 VPN",
      ],
      answer: 0,
      rationale: "Ansible 无 Agent，依赖 SSH/WinRM 等远程协议。",
    },
    {
      id: "w8-3-q3",
      question: "模块的作用是什么？",
      options: [
        "提供幂等操作单元（如 package/file/service），由任务调用",
        "定义变量",
        "渲染模板",
        "存储日志",
      ],
      answer: 0,
      rationale: "模块是 Ansible 任务的执行单元，强调幂等。",
    },
    {
      id: "w8-3-q4",
      question: "handlers 何时被触发？",
      options: [
        "被任务 notify 时，在 play 末尾或指定时机运行",
        "总是立即运行",
        "随机执行",
        "只能在失败时执行",
      ],
      answer: 0,
      rationale: "handlers 被 notify 触发，常用于重启服务。",
    },
    {
      id: "w8-3-q5",
      question: "gather_facts 的默认行为？",
      options: [
        "默认 true，会在 play 开始收集目标主机事实（硬件/OS 信息）",
        "默认关闭",
        "仅收集网络信息",
        "只在失败时执行",
      ],
      answer: 0,
      rationale: "收集 facts 便于后续任务使用变量。",
    },
    {
      id: "w8-3-q6",
      question: "以不同用户执行任务的方式？",
      options: [
        "使用 become/become_user 提升或切换身份",
        "必须手动 ssh",
        "只能使用 root",
        "通过修改 hosts 文件",
      ],
      answer: 0,
      rationale: "become 提供 sudo 等提权能力。",
    },
    {
      id: "w8-3-q7",
      question: "检查模式（--check）的作用？",
      options: [
        "模拟执行并显示将做的变更，不实际修改",
        "强制执行所有任务",
        "禁用幂等",
        "只运行 handlers",
      ],
      answer: 0,
      rationale: "check mode 用于预览变更，类似 dry-run。",
    },
    {
      id: "w8-3-q8",
      question: "inventory 的作用？",
      options: [
        "定义目标主机和分组，供 play 选择",
        "存储变量",
        "保存日志",
        "管理依赖",
      ],
      answer: 0,
      rationale: "Inventory 列出主机与组，是执行范围的基础。",
    },
    {
      id: "w8-3-q9",
      question: "运行 playbook 的命令示例？",
      options: [
        "ansible-playbook -i inventory site.yml",
        "ansible run site.yml",
        "ansible exec site.yml",
        "kubectl apply -f site.yml",
      ],
      answer: 0,
      rationale: "ansible-playbook 是标准执行入口。",
    },
    {
      id: "w8-3-q10",
      question: "模板渲染使用什么引擎？",
      options: [
        "Jinja2，可通过 template 模块渲染到目标文件",
        "Go template",
        "Mustache",
        "无模板功能",
      ],
      answer: 0,
      rationale: "Ansible 使用 Jinja2 渲染模板和变量。",
    },
  ],
  "w8-4": [
    {
      id: "w8-4-q1",
      question: "Terraform 与 Ansible 组合的常见分工是？",
      options: [
        "Terraform 负责基础设施/云资源，Ansible 负责主机配置与软件部署",
        "两者都只做配置",
        "Ansible 管理云资源，Terraform 管理应用",
        "只能二选一",
      ],
      answer: 0,
      rationale: "基础设施即代码与配置管理分层，避免重复。",
    },
    {
      id: "w8-4-q2",
      question: "如何将 Terraform 产出的主机信息提供给 Ansible？",
      options: [
        "通过 Terraform output（或 remote state）生成动态 inventory/hosts 文件",
        "手动复制到 YAML",
        "只能静态写死",
        "使用 Helm",
      ],
      answer: 0,
      rationale: "输出可被 Ansible 动态 inventory 脚本或插件消费。",
    },
    {
      id: "w8-4-q3",
      question: "常见的流水线顺序是？",
      options: [
        "terraform apply -> 生成/刷新 inventory -> ansible-playbook 部署配置",
        "ansible-playbook -> terraform apply",
        "同时运行两者",
        "先运行 kubectl",
      ],
      answer: 0,
      rationale: "需要先有基础设施再做配置。",
    },
    {
      id: "w8-4-q4",
      question: "为什么需要管理 SSH 密钥或凭证？",
      options: [
        "Ansible 通过 SSH 连接新建节点，需要凭证；Terraform 也可能创建这些密钥",
        "只要有 kubeconfig 即可",
        "Terraform 会自动创建密码",
        "无需凭证",
      ],
      answer: 0,
      rationale: "访问节点必须有 SSH 密钥/密码，通常由 Terraform 创建或预置。",
    },
    {
      id: "w8-4-q5",
      question: "保持状态一致性的最佳实践是？",
      options: [
        "避免手工更改；Terraform state 与 Ansible 期望应保持一致，漂移需修复",
        "手工修改即可",
        "删除 state 文件",
        "频繁重建集群",
      ],
      answer: 0,
      rationale: "漂移会导致不可预测结果，应通过代码更改并更新 state。",
    },
    {
      id: "w8-4-q6",
      question: "如何使用 Ansible 配置 Terraform 创建的 K8s 集群？",
      options: [
        "使用 Ansible k8s/kubectl 模块并引用 Terraform 输出的 kubeconfig/endpoint",
        "必须登录节点手工执行",
        "需要重新创建集群",
        "只能用 Helm",
      ],
      answer: 0,
      rationale: "Ansible 可以消费输出的 kubeconfig 执行 Kubernetes 任务。",
    },
    {
      id: "w8-4-q7",
      question: "Terraform local-exec/provisioner 用于？",
      options: [
        "在资源创建阶段触发本地命令（如生成 inventory/调用 Ansible），但不宜滥用",
        "代替 provider",
        "自动销毁资源",
        "配置 RBAC",
      ],
      answer: 0,
      rationale: "provisioner 可用于轻量衔接，但官方建议尽量保持声明式。",
    },
    {
      id: "w8-4-q8",
      question: "为何推荐使用 Ansible Roles？",
      options: [
        "模块化可复用，便于在 Terraform 创建的不同环境重复应用配置",
        "因为 Terraform 需要",
        "避免使用变量",
        "提升执行速度",
      ],
      answer: 0,
      rationale: "Role 将任务/文件/模板分层，提高复用与维护性。",
    },
    {
      id: "w8-4-q9",
      question: "动态 Inventory 的优势是？",
      options: [
        "自动根据 Terraform state/云 API 生成主机列表，避免手写",
        "更安全的密码存储",
        "提升网络性能",
        "必须配合 Helm",
      ],
      answer: 0,
      rationale: "动态 inventory 确保最新主机信息，减少人为错误。",
    },
    {
      id: "w8-4-q10",
      question: "分离 Terraform 与 Ansible 状态的原因？",
      options: [
        "二者职责不同，Terraform 维护基础设施 state，Ansible 依靠幂等任务而非集中 state",
        "便于加密",
        "为了提升 CI 速度",
        "否则无法使用 Helm",
      ],
      answer: 0,
      rationale: "保持职责分离使各自管理方式与恢复流程清晰。",
    },
  ],
};