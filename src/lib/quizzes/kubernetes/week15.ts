import type { QuizQuestion } from "../types";

export const week15: Record<string, QuizQuestion[]> = {
  "w15-1": [
    {
      id: "w15-1-q1",
      question: "Horizontal Pod Autoscaler (HPA) 的工作原理？",
      options: [
        "基于指标（CPU/内存/自定义/外部）计算期望副本数并调整 Deployment/ReplicaSet",
        "直接创建节点",
        "修改 Service",
        "仅按时间表扩容",
      ],
      answer: 0,
      rationale: "HPA 通过 Metrics API 获取指标计算 desired replicas。",
    },
    {
      id: "w15-1-q2",
      question: "Cluster Autoscaler 的职责是？",
      options: [
        "根据不可调度的 Pod 自动扩容/缩容节点（云提供商节点组）",
        "调度 Pod",
        "管理镜像仓库",
        "执行滚动更新",
      ],
      answer: 0,
      rationale: "CA 监控 pending Pod 与利用率，调整节点池。",
    },
    {
      id: "w15-1-q3",
      question: "HPA 依赖的默认数据源？",
      options: [
        "metrics-server 提供的资源指标 API",
        "kube-proxy",
        "etcd",
        "Prometheus 必须",
      ],
      answer: 0,
      rationale: "资源指标来自 metrics-server；自定义指标需额外适配器。",
    },
    {
      id: "w15-1-q4",
      question: "为什么正确设置 Pod requests 很重要？",
      options: [
        "HPA 计算 CPUUtilization 基于 requests，错误的 requests 会导致扩缩容不准",
        "只影响限流",
        "与 HPA 无关",
        "只影响节点标签",
      ],
      answer: 0,
      rationale: "利用率基于请求值，requests 失真会误导 HPA。",
    },
    {
      id: "w15-1-q5",
      question: "HPA 防抖机制是什么？",
      options: [
        "stabilizationWindowSeconds/cooldown，防止频繁伸缩",
        "通过重启 Pod",
        "依赖 PDB",
        "暂停 HPA",
      ],
      answer: 0,
      rationale: "HPA 提供稳定窗口与增减速率限制。",
    },
    {
      id: "w15-1-q6",
      question: "自定义指标 HPA 需要什么组件？",
      options: [
        "自定义/外部指标适配器（如 Prometheus Adapter）提供 metrics API",
        "只需要 metrics-server",
        "必须修改 kubelet",
        "使用 ConfigMap",
      ],
      answer: 0,
      rationale: "Adapter 将外部指标暴露为 custom.metrics.k8s.io API。",
    },
    {
      id: "w15-1-q7",
      question: "Cluster Autoscaler 缩容前会考虑？",
      options: [
        "PodDisruptionBudget、Pod 优先级、是否可在其他节点调度",
        "只看 CPU 使用率",
        "只看节点名称",
        "忽略 PDB",
      ],
      answer: 0,
      rationale: "CA 避免驱逐受 PDB/不可迁移的 Pod。",
    },
    {
      id: "w15-1-q8",
      question: "HPA 与 CA 的协同方式？",
      options: [
        "HPA 增加副本可能导致 Pod Pending，CA 观察到后扩容节点",
        "两者无关联",
        "CA 控制 Pod 数量",
        "HPA 控制节点数量",
      ],
      answer: 0,
      rationale: "HPA 负责 Pod 层，CA 负责节点层，协作满足资源需求。",
    },
    {
      id: "w15-1-q9",
      question: "水平扩缩容的最小/最大副本由谁定义？",
      options: [
        "HPA spec.minReplicas/maxReplicas",
        "Deployment replicas",
        "kube-scheduler",
        "Service 配置",
      ],
      answer: 0,
      rationale: "HPA 资源定义 min/max 范围。",
    },
    {
      id: "w15-1-q10",
      question: "常见的扩容指标选择建议是？",
      options: [
        "选择与用户体验直接相关的指标（如 QPS、延迟、自定义业务指标），并配合资源指标",
        "只看节点数",
        "仅依赖内存",
        "不需要指标",
      ],
      answer: 0,
      rationale: "业务+系统指标结合能更准确反映负载。",
    },
  ],
  "w15-2": [
    {
      id: "w15-2-q1",
      question: "Knative Serving 的核心资源包含？",
      options: [
        "Service、Route、Configuration、Revision",
        "Deployment、Service、Pod",
        "Job、CronJob",
        "Ingress、Endpoint",
      ],
      answer: 0,
      rationale: "Serving 使用四个 CRD 管理无服务器工作负载与修订。",
    },
    {
      id: "w15-2-q2",
      question: "为什么 Knative 能实现 Scale-to-Zero？",
      options: [
        "Knative Pod Autoscaler (KPA) 基于并发/请求率，Activator 可在无流量时缩到 0 并缓冲新请求",
        "依赖 HPA 仅基于 CPU",
        "通过删除 Deployment",
        "需要手动缩容",
      ],
      answer: 0,
      rationale: "KPA + Activator 支持零流量缩容与冷启动缓冲。",
    },
    {
      id: "w15-2-q3",
      question: "每次配置/镜像变更会生成什么？",
      options: [
        "新的 Revision（不可变），Route 可路由到不同 Revision",
        "覆盖旧 Revision",
        "仅更新 Deployment",
        "更新 Node",
      ],
      answer: 0,
      rationale: "Revision 表示不可变版本，便于流量切分与回滚。",
    },
    {
      id: "w15-2-q4",
      question: "默认网络层实现可以是？",
      options: [
        "Kourier（默认）、Istio、Contour 等",
        "仅 kube-proxy",
        "只能使用 Nginx",
        "必须使用 MetalLB",
      ],
      answer: 0,
      rationale: "Knative 支持多种 Ingress 实现，默认常用 Kourier。",
    },
    {
      id: "w15-2-q5",
      question: "并发度配置使用哪个注解？",
      options: [
        "autoscaling.knative.dev/target 或 container-concurrency",
        "hpa.autoscaling/scale",
        "deployment.kubernetes.io/concurrency",
        "ingress.knative.dev/concurrency",
      ],
      answer: 0,
      rationale: "Knative 可通过 annotations/containerConcurrency 控制每 Pod 并发。",
    },
    {
      id: "w15-2-q6",
      question: "冷启动的影响？",
      options: [
        "从 0 扩容时需要拉起 Pod，会增加首请求延迟",
        "无任何影响",
        "只影响日志",
        "只在 HPA 中出现",
      ],
      answer: 0,
      rationale: "Scale-to-zero 会带来冷启动延迟，需优化镜像/并发缓冲。",
    },
    {
      id: "w15-2-q7",
      question: "Knative Service 默认访问域名格式？",
      options: [
        "<service>.<namespace>.<domain>（由域名配置决定）",
        "固定为 example.com",
        "使用 Pod IP",
        "需要手工配置 DNS 记录",
      ],
      answer: 0,
      rationale: "Knative 会根据域配置生成子域。",
    },
    {
      id: "w15-2-q8",
      question: "自动/手动切流量的方式？",
      options: [
        "在 Route/Service spec 中设置 traffic 百分比到不同 Revision",
        "只能全量切换",
        "通过 HPA",
        "通过 NodePort",
      ],
      answer: 0,
      rationale: "Route 支持按百分比或标签路由到各个 Revision。",
    },
    {
      id: "w15-2-q9",
      question: "Knative Serving 依赖的自动扩缩容类注解有哪些？",
      options: [
        "autoscaling.knative.dev/class（kpa/hpa）、metric、target、minScale/maxScale",
        "podDisruptionBudget",
        "deployment.kubernetes.io/revision",
        "networking.knative.dev/ingress",
      ],
      answer: 0,
      rationale: "Knative 支持 KPA/HPA 类与指标、最小/最大副本注解。",
    },
    {
      id: "w15-2-q10",
      question: "Knative 的 CLI/CRD 观察命令示例？",
      options: [
        "kubectl get ksvc, revisions, routes",
        "kubectl get deployment",
        "helm list",
        "istioctl proxy-status",
      ],
      answer: 0,
      rationale: "Knative 定义了 ksvc/route/configuration/revision CRD，可通过 kubectl 查看。",
    },
  ],
  "w15-3": [
    {
      id: "w15-3-q1",
      question: "Knative Eventing 中 Broker 的作用？",
      options: [
        "作为事件入口/分发枢纽，结合 Trigger 做过滤和路由",
        "存储镜像",
        "控制 HPA",
        "生成日志",
      ],
      answer: 0,
      rationale: "Broker 接收事件并交给 Trigger 转发到 Sink。",
    },
    {
      id: "w15-3-q2",
      question: "Trigger 过滤依据是什么？",
      options: [
        "根据 CloudEvents 属性（type/source/subject 等）匹配，将事件送到指定 Sink",
        "根据 Pod 标签",
        "根据节点",
        "随机发送",
      ],
      answer: 0,
      rationale: "Trigger 使用属性过滤将事件路由到 Knative Service 等。",
    },
    {
      id: "w15-3-q3",
      question: "CloudEvents 规范中的必需属性包括？",
      options: [
        "id、source、type、specversion（可选 subject/time 等）",
        "host、user-agent",
        "namespace、name",
        "checksum",
      ],
      answer: 0,
      rationale: "CloudEvents 定义通用事件元数据。",
    },
    {
      id: "w15-3-q4",
      question: "常见事件源（Source）示例？",
      options: [
        "ApiServerSource、PingSource、KafkaSource 等",
        "Deployment",
        "Service",
        "Node",
      ],
      answer: 0,
      rationale: "Knative 提供多种 Source CRD 接入外部事件。",
    },
    {
      id: "w15-3-q5",
      question: "Channel/Subscription 模型的用途？",
      options: [
        "实现可插拔的中间件（如 Kafka）提供事件持久化/扇出",
        "控制 CPU 使用",
        "配置 HPA",
        "管理域名",
      ],
      answer: 0,
      rationale: "Channel 抽象底层队列，Subscription 把事件送到订阅端。",
    },
    {
      id: "w15-3-q6",
      question: "DeliverySpec（重试/死信队列）配置在哪？",
      options: [
        "Broker/Trigger/Subscription 可设置 retry/backoff 与 deadLetterSink",
        "仅在 Service",
        "必须在 Deployment",
        "不能配置",
      ],
      answer: 0,
      rationale: "Knative 支持可配置的投递重试与死信处理。",
    },
    {
      id: "w15-3-q7",
      question: "Knative Eventing 中事件接收方称为？",
      options: ["Sink（通常是 Knative Service/URL）", "Node", "Ingress", "PodDisruptionBudget"],
      answer: 0,
      rationale: "Sink 是 Trigger/Subscription 投递目标。",
    },
    {
      id: "w15-3-q8",
      question: "CloudEvents HTTP 头的前缀是？",
      options: [
        "ce-（如 ce-type/ce-source/ce-id）",
        "x-cloud-",
        "k8s-",
        "cloudevent-",
      ],
      answer: 0,
      rationale: "CloudEvents 以 ce- 前缀携带属性。",
    },
    {
      id: "w15-3-q9",
      question: "为什么使用 Broker/Trigger 而非直接订阅？",
      options: [
        "提供中心化事件路由与过滤，简化多订阅者场景",
        "性能更差",
        "因为不支持 HTTP",
        "必须依赖 Kafka",
      ],
      answer: 0,
      rationale: "Broker/Trigger 解耦生产者/消费者，提供过滤与统一入口。",
    },
    {
      id: "w15-3-q10",
      question: "PingSource 的作用？",
      options: [
        "按定时触发 CloudEvents（cron 表达式），常用于心跳/测试",
        "监控节点",
        "创建 DNS",
        "执行 HPA",
      ],
      answer: 0,
      rationale: "PingSource 是内置定时事件源。",
    },
  ],
  "w15-4": [
    {
      id: "w15-4-q1",
      question: "Operator 模式的核心组成？",
      options: [
        "自定义资源（CRD）+ 控制器（Reconcile Loop）实现特定领域运维自动化",
        "仅 Deployment",
        "仅脚本",
        "只使用 Helm",
      ],
      answer: 0,
      rationale: "Operator 通过 CRD/Controller 实现知识编码。",
    },
    {
      id: "w15-4-q2",
      question: "Reconcile 的含义是？",
      options: [
        "持续对比期望状态（CR）与实际状态，执行必要操作达到收敛",
        "一次性执行",
        "只在错误时触发",
        "仅在启动时运行",
      ],
      answer: 0,
      rationale: "与 Kubernetes 控制器模式一致，Operator 自定义领域逻辑。",
    },
    {
      id: "w15-4-q3",
      question: "kubebuilder/operator-sdk 提供什么？",
      options: [
        "脚手架/代码生成/测试工具，加速 Operator 开发",
        "镜像仓库",
        "节点管理",
        "日志代理",
      ],
      answer: 0,
      rationale: "工具链生成 CRD/Controller 框架与样板代码。",
    },
    {
      id: "w15-4-q4",
      question: "自定义资源（CR）的作用域可以是？",
      options: [
        "Namespaced 或 Cluster 范围，取决于 CRD 定义",
        "仅 Namespaced",
        "仅 Cluster",
        "必须与 Deployment 同名",
      ],
      answer: 0,
      rationale: "CRD 支持两种 scope，需根据场景选择。",
    },
    {
      id: "w15-4-q5",
      question: "Operator 常见的运维自动化示例？",
      options: [
        "数据库备份/恢复、应用升级、伸缩、配置校验",
        "仅创建 ConfigMap",
        "只监控 CPU",
        "仅创建 Service",
      ],
      answer: 0,
      rationale: "Operator 将专业运维流程编程化。",
    },
    {
      id: "w15-4-q6",
      question: "与 Helm Chart 相比 Operator 的优势？",
      options: [
        "可编排有状态/有序操作并处理反馈（如备份/滚动升级），不仅是模板渲染",
        "部署更简单",
        "完全无代码",
        "不会访问 API Server",
      ],
      answer: 0,
      rationale: "Operator 可在运行时感知状态并执行复杂逻辑。",
    },
    {
      id: "w15-4-q7",
      question: "Controller Watch 的对象通常包括？",
      options: [
        "自定义资源本身以及相关的 Secrets/Deployments/Services 等依赖",
        "仅 CR 自身",
        "仅节点",
        "仅 Pod 日志",
      ],
      answer: 0,
      rationale: "控制器通常 watch 关联资源，触发 reconcile。",
    },
    {
      id: "w15-4-q8",
      question: "编写 Operator 时为什么要保证幂等？",
      options: [
        "reconcile 可能被频繁调用，幂等确保重复执行也能正确收敛",
        "为了加快速度",
        "避免创建 CR",
        "只为调试",
      ],
      answer: 0,
      rationale: "幂等是控制器模式的基本要求。",
    },
    {
      id: "w15-4-q9",
      question: "CRD 版本升级（v1alpha1->v1beta1）需要注意？",
      options: [
        "提供转换/存储版本，或使用 conversion webhook，更新 CR 示例",
        "无需任何处理",
        "删除所有 CR",
        "只能重新创建集群",
      ],
      answer: 0,
      rationale: "CRD 版本迁移需处理存储版本与转换。",
    },
    {
      id: "w15-4-q10",
      question: "Operator 运行时权限如何控制？",
      options: [
        "通过 RBAC 授予最小所需权限（Roles/ClusterRoles/Bindings）",
        "必须 cluster-admin",
        "无需 RBAC",
        "只要节点权限",
      ],
      answer: 0,
      rationale: "遵循最小权限原则，Operator 仅应访问必要资源。",
    },
  ],
};