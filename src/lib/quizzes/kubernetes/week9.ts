import type { QuizQuestion } from "../types";

export const week9: Record<string, QuizQuestion[]> = {
  "w9-1": [
    {
      id: "w9-1-q1",
      question: "持续集成（CI）的核心目标是？",
      options: [
        "每次提交自动构建/测试，尽早发现问题",
        "仅在发布时编译",
        "只在本地运行",
        "替代代码评审",
      ],
      answer: 0,
      rationale: "CI 强调频繁集成与自动化验证。",
    },
    {
      id: "w9-1-q2",
      question: "持续交付与持续部署的区别？",
      options: [
        "持续交付交付到可随时上线的阶段，持续部署则自动上线到生产",
        "两者完全相同",
        "持续交付只做测试",
        "持续部署只在本地",
      ],
      answer: 0,
      rationale: "持续部署进一步自动化发布步骤。",
    },
    {
      id: "w9-1-q3",
      question: "云原生 CI/CD 的常见挑战是？",
      options: [
        "镜像构建、K8s 清单管理、环境隔离与安全扫描",
        "缺少代码仓库",
        "无法使用容器",
        "需要手动部署",
      ],
      answer: 0,
      rationale: "容器/集群带来镜像、配置与安全的额外复杂度。",
    },
    {
      id: "w9-1-q4",
      question: "为什么建议在流水线早期进行安全扫描？",
      options: [
        "Shift Left，可尽早阻断漏洞/合规问题，避免后期返工",
        "为了加快部署",
        "与安全无关",
        "只为生成报告",
      ],
      answer: 0,
      rationale: "提前发现问题成本更低。",
    },
    {
      id: "w9-1-q5",
      question: "容器镜像构建的最佳实践之一是？",
      options: [
        "使用可重复的 Dockerfile 并尽量利用缓存/多阶段构建",
        "只在生产环境构建",
        "使用 latest 标签即可",
        "避免使用版本控制",
      ],
      answer: 0,
      rationale: "可重复构建和缓存提高速度与可追溯性。",
    },
    {
      id: "w9-1-q6",
      question: "流水线触发策略常见有哪些？",
      options: [
        "PR/代码提交触发、定时任务、手动触发",
        "仅手动触发",
        "只能定时",
        "只能在合并后",
      ],
      answer: 0,
      rationale: "CI 系统支持多种触发方式覆盖不同场景。",
    },
    {
      id: "w9-1-q7",
      question: "为什么要将制品推送到集中仓库？",
      options: [
        "便于后续部署、追溯与缓存复用",
        "为了删除本地代码",
        "避免使用版本控制",
        "只为计费",
      ],
      answer: 0,
      rationale: "集中制品库确保环境一致与回滚可行。",
    },
    {
      id: "w9-1-q8",
      question: "在云原生环境中部署配置通常如何管理？",
      options: [
        "声明式清单（Kustomize/Helm）存放在 Git，并由流水线或 GitOps 驱动",
        "手工编辑集群",
        "直接在节点上改文件",
        "使用 FTP",
      ],
      answer: 0,
      rationale: "声明式配置配合版本控制是最佳实践。",
    },
    {
      id: "w9-1-q9",
      question: "流水线中常见的质量门槛有？",
      options: [
        "测试覆盖率、Lint、安全扫描、部署前人工审批等",
        "仅看提交次数",
        "无任何校验",
        "只依赖手工测试",
      ],
      answer: 0,
      rationale: "质量门确保标准达标后才继续后续阶段。",
    },
    {
      id: "w9-1-q10",
      question: "容器化 CI 节点的好处？",
      options: [
        "隔离构建环境、可快速弹性扩缩、便于缓存与复用",
        "增加构建时间",
        "无法访问网络",
        "不支持并行",
      ],
      answer: 0,
      rationale: "容器化执行器提供隔离与可扩展性，适合云原生。",
    },
  ],
  "w9-2": [
    {
      id: "w9-2-q1",
      question: "将镜像推送到注册表前需要做什么？",
      options: [
        "登录目标 registry（如使用 docker/login-action 或 Jenkins 凭证）",
        "删除 Dockerfile",
        "修改 kubeconfig",
        "重启集群",
      ],
      answer: 0,
      rationale: "推送前需认证 registry，否则会被拒绝。",
    },
    {
      id: "w9-2-q2",
      question: "GitHub Actions 构建镜像的常见步骤是？",
      options: [
        "actions/checkout -> 设置 Buildx/登录 -> docker build/push -> 输出 digest",
        "仅运行 npm install",
        "直接 kubectl apply",
        "修改 etcd",
      ],
      answer: 0,
      rationale: "官方示例使用 checkout、buildx、login、build-push 动作。",
    },
    {
      id: "w9-2-q3",
      question: "为何推荐使用唯一 tag（如 commit SHA）推送镜像？",
      options: [
        "保证可追溯与幂等部署，避免 latest 漂移",
        "减小镜像体积",
        "避免需要登录",
        "防止缓存命中",
      ],
      answer: 0,
      rationale: "唯一 tag 便于回滚与追踪。",
    },
    {
      id: "w9-2-q4",
      question: "Jenkins Pipeline 推镜像常用的语法是？",
      options: [
        "docker.build(...).push() 或使用 withCredentials 登录后 push",
        "kubectl push",
        "git push 镜像",
        "helm push",
      ],
      answer: 0,
      rationale: "Jenkins 支持 Docker Pipeline 插件进行 build/push。",
    },
    {
      id: "w9-2-q5",
      question: "为什么在 CI 中启用 BuildKit/Buildx？",
      options: [
        "获得缓存、并行、多架构构建等能力",
        "减少安全性",
        "只能在本地使用",
        "会禁用多阶段",
      ],
      answer: 0,
      rationale: "Buildx 提供高性能和多架构支持。",
    },
    {
      id: "w9-2-q6",
      question: "如何保护 registry 凭证？",
      options: [
        "存放在 CI 的 Secret/凭证管理中，避免写入仓库",
        "直接写在 Dockerfile",
        "提交到 Git",
        "硬编码到镜像",
      ],
      answer: 0,
      rationale: "敏感信息应存储在安全的 Secret 管理器。",
    },
    {
      id: "w9-2-q7",
      question: "构建完成后通常需要产出什么供后续阶段使用？",
      options: [
        "镜像 tag/digest、制品元数据（artifact）",
        "Pod YAML",
        "etcd 备份",
        "SSH 密钥",
      ],
      answer: 0,
      rationale: "后续部署/扫描需要知道镜像标识与工件路径。",
    },
    {
      id: "w9-2-q8",
      question: "GitHub Actions 中缓存依赖的常用方式？",
      options: [
        "actions/cache 或 buildx cache-from/cache-to",
        "禁用缓存",
        "手写文件",
        "使用 Helm",
      ],
      answer: 0,
      rationale: "缓存可显著缩短构建时间。",
    },
    {
      id: "w9-2-q9",
      question: "在流水线中使用 docker layer 缓存的前提？",
      options: [
        "稳定的构建上下文与合理的 Dockerfile 指令顺序",
        "关闭缓存",
        "必须使用 root",
        "只能在 Jenkins 使用",
      ],
      answer: 0,
      rationale: "缓存命中取决于上下文未变化与层顺序。",
    },
    {
      id: "w9-2-q10",
      question: "推送镜像失败常见原因？",
      options: [
        "未登录/权限不足、网络不可达、tag 冲突或 registry 地址错误",
        "Dockerfile 缺少 FROM",
        "Pod 重启",
        "kube-proxy 版本过低",
      ],
      answer: 0,
      rationale: "需检查认证、网络与仓库地址/权限。",
    },
  ],
  "w9-3": [
    {
      id: "w9-3-q1",
      question: "Trivy 可以扫描哪些对象？",
      options: [
        "容器镜像、文件系统、Git repo/制品等",
        "仅镜像",
        "只能扫描主机",
        "只能扫描 Pod",
      ],
      answer: 0,
      rationale: "Trivy 支持 image/fs/repo 等多种目标。",
    },
    {
      id: "w9-3-q2",
      question: "在 CI 中希望发现高危漏洞就失败，通常怎么配置？",
      options: [
        "设置 severity/exit-code（如 --severity HIGH,CRITICAL --exit-code 1）",
        "只打印日志",
        "修改 kubelet",
        "无法配置",
      ],
      answer: 0,
      rationale: "Trivy 提供 severity 和 exit-code 控制流水线是否失败。",
    },
    {
      id: "w9-3-q3",
      question: "为什么要缓存 Trivy 数据库？",
      options: [
        "减少每次更新漏洞数据库的时间，加快扫描",
        "提升安全性",
        "避免扫描",
        "为了删除镜像",
      ],
      answer: 0,
      rationale: "缓存 DB 可显著减少扫描时延。",
    },
    {
      id: "w9-3-q4",
      question: "Trivy GitHub Action 的常用配置参数包括？",
      options: [
        "image/ref、severity、vuln-type、ignore-unfixed、format 等",
        "podSelector、policyTypes",
        "helmVersion",
        "kubeconfig",
      ],
      answer: 0,
      rationale: "Action 支持指定目标镜像、漏洞类型、输出格式等。",
    },
    {
      id: "w9-3-q5",
      question: "扫描结果的处理最佳实践是？",
      options: [
        "输出报告/工件供审计，并与基线比较修复后再继续部署",
        "忽略所有输出",
        "只在生产扫描",
        "删除 state",
      ],
      answer: 0,
      rationale: "报告应保留并驱动修复流程。",
    },
    {
      id: "w9-3-q6",
      question: "Trivy 可以检测的类型包含？",
      options: [
        "OS 包漏洞与应用依赖（如 npm/pip），还支持 misconfiguration",
        "仅 OS 包",
        "仅配置错误",
        "只能扫描 Dockerfile",
      ],
      answer: 0,
      rationale: "Trivy 支持多类型扫描，包括 IaC 配置。",
    },
    {
      id: "w9-3-q7",
      question: "在流水线中通常把安全扫描放在哪个阶段？",
      options: [
        "构建镜像后、部署前（或作为质量门）",
        "部署完成后再扫描",
        "只在开发机",
        "不需要扫描",
      ],
      answer: 0,
      rationale: "构建后扫描能阻断高危镜像进入生产。",
    },
    {
      id: "w9-3-q8",
      question: "忽略未修复漏洞的参数是？",
      options: [
        "--ignore-unfixed",
        "--skip-files",
        "--timeout",
        "--light",
      ],
      answer: 0,
      rationale: "ignore-unfixed 可过滤暂未有补丁的漏洞。",
    },
    {
      id: "w9-3-q9",
      question: "为什么要在 CI 中固定 Trivy 版本？",
      options: [
        "确保结果可复现，避免版本变动影响扫描策略",
        "为了增加漏洞数量",
        "不需要固定",
        "减少网络流量",
      ],
      answer: 0,
      rationale: "固定工具版本是可重复性的常见做法。",
    },
    {
      id: "w9-3-q10",
      question: "Trivy 失败的常见原因？",
      options: [
        "无法拉取镜像、网络访问数据库失败、权限不足或格式参数错误",
        "Helm 安装失败",
        "kubelet 崩溃",
        "PodNotReady",
      ],
      answer: 0,
      rationale: "需检查镜像可达性、网络与参数配置。",
    },
  ],
  "w9-4": [
    {
      id: "w9-4-q1",
      question: "GitOps 的核心思想是？",
      options: [
        "以 Git 作为单一事实源，集群状态通过控制器与仓库声明保持一致",
        "直接在集群上改配置",
        "手动 SSH 部署",
        "仅用于备份",
      ],
      answer: 0,
      rationale: "GitOps 强调声明式配置与自动调和。",
    },
    {
      id: "w9-4-q2",
      question: "Push 与 Pull 模式的区别？",
      options: [
        "Push 由 CI 直接部署到集群，Pull 由集群内控制器从 Git 拉取/调和",
        "Pull 需要人工确认",
        "Push 更安全",
        "两者相同",
      ],
      answer: 0,
      rationale: "ArgoCD/Flux 采用 Pull 模式，CI 触发或 Webhook 通知。",
    },
    {
      id: "w9-4-q3",
      question: "GitOps 带来的好处包括？",
      options: [
        "审计可追溯、易回滚、减少手工漂移",
        "部署速度必然变慢",
        "无需权限控制",
        "消除测试需求",
      ],
      answer: 0,
      rationale: "版本控制与自动调和带来可追溯性与一致性。",
    },
    {
      id: "w9-4-q4",
      question: "为什么要避免直接在集群内手动改对象？",
      options: [
        "会造成漂移，GitOps 控制器会回滚或冲突，且无法审计",
        "更安全",
        "无法修改",
        "因为会影响 kube-proxy",
      ],
      answer: 0,
      rationale: "手动修改与 Git 源脱节，影响一致性和审计。",
    },
    {
      id: "w9-4-q5",
      question: "触发 GitOps 同步的常见方式？",
      options: [
        "轮询 Git/仓库 Webhook 或手动 Sync",
        "仅在节点重启时",
        "只能手动 SSH",
        "通过 kubelet 重启",
      ],
      answer: 0,
      rationale: "控制器支持定期拉取或接收 Webhook 触发同步。",
    },
    {
      id: "w9-4-q6",
      question: "GitOps 声明文件通常包含？",
      options: [
        "Kubernetes 清单/Helm/Kustomize 配置",
        "仅二进制镜像",
        "数据库快照",
        "etcd 配置",
      ],
      answer: 0,
      rationale: "Git 里保存声明式配置，控制器据此部署。",
    },
    {
      id: "w9-4-q7",
      question: "常见 GitOps 工具有？",
      options: ["ArgoCD、Flux", "Helm 和 Kustomize", "Jenkins 和 Git", "kubectl 和 kubeadm"],
      answer: 0,
      rationale: "ArgoCD/Flux 是 GitOps 控制器代表。",
    },
    {
      id: "w9-4-q8",
      question: "GitOps 如何实现回滚？",
      options: [
        "回退 Git 提交，控制器自动同步到旧版本",
        "手动删除资源",
        "修改节点标签",
        "重启 kubelet",
      ],
      answer: 0,
      rationale: "Git 历史即版本控制，控制器调和到对应状态。",
    },
    {
      id: "w9-4-q9",
      question: "为避免越权访问，GitOps Controller 通常使用？",
      options: [
        "最小权限的 ServiceAccount/RBAC，限制仅能管理目标命名空间/资源",
        "集群管理员账户",
        "root 用户",
        "无需凭证",
      ],
      answer: 0,
      rationale: "遵循最小权限原则降低风险。",
    },
    {
      id: "w9-4-q10",
      question: "将应用声明与集群基座配置分仓的好处？",
      options: [
        "降低耦合，便于团队分工与权限控制",
        "减少 Git 文件数量",
        "避免使用 CI",
        "使回滚更困难",
      ],
      answer: 0,
      rationale: "分层仓库便于职责划分与独立演进。",
    },
  ],
};