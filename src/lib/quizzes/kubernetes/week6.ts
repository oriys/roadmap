import type { QuizQuestion } from "../types";

export const week6: Record<string, QuizQuestion[]> = {
  "w6-1": [
    {
      id: "w6-1-q1",
      question: "nodeSelector 与 nodeAffinity 的主要区别？",
      options: [
        "nodeAffinity 支持表达式/优先级，nodeSelector 仅简单键值匹配",
        "两者完全相同",
        "nodeSelector 只能在 StatefulSet 使用",
        "nodeAffinity 只能写在注解中",
      ],
      answer: 0,
      rationale: "Node Affinity 提供 matchExpressions 与软/硬要求，替代简单 nodeSelector。",
    },
    {
      id: "w6-1-q2",
      question: "requiredDuringSchedulingIgnoredDuringExecution 表示？",
      options: [
        "调度时必须满足，调度后即使标签变化也不驱逐",
        "调度时可以不满足",
        "运行时也会强制驱逐",
        "仅影响探针",
      ],
      answer: 0,
      rationale: "名字即含义：调度阶段强约束，执行阶段忽略变化。",
    },
    {
      id: "w6-1-q3",
      question: "preferredDuringSchedulingIgnoredDuringExecution 的特点？",
      options: [
        "软亲和性，调度器按权重倾向满足但可回退",
        "与 required 相同",
        "用于强制驱逐",
        "只支持单个 label",
      ],
      answer: 0,
      rationale: "preferred 提供加分项，不满足也可调度。",
    },
    {
      id: "w6-1-q4",
      question: "PodAntiAffinity 常用来？",
      options: [
        "避免同一应用副本落在同一拓扑（如节点/机架）上",
        "强制全部副本集中同一节点",
        "取代 HPA",
        "控制网络策略",
      ],
      answer: 0,
      rationale: "Pod 反亲和用于分散部署，提高容错。",
    },
    {
      id: "w6-1-q5",
      question: "topologyKey 在 PodAffinity/AntiAffinity 中的作用？",
      options: [
        "定义亲和/反亲和计算的拓扑域（如 kubernetes.io/hostname）",
        "设置 Service 类型",
        "指定探针端口",
        "决定 CPU 亲和",
      ],
      answer: 0,
      rationale: "topologyKey 控制在何种粒度上判定同/不同拓扑。",
    },
    {
      id: "w6-1-q6",
      question: "nodeAffinity 使用的标签来自哪里？",
      options: [
        "节点对象的 labels",
        "Pod labels",
        "ConfigMap",
        "镜像标签",
      ],
      answer: 0,
      rationale: "节点亲和性匹配 Node 的 labels。",
    },
    {
      id: "w6-1-q7",
      question: "PodAffinity 与 PodAntiAffinity 的选择对象是？",
      options: [
        "其他 Pod 的标签（通过 podSelector + topologyKey）",
        "节点标签",
        "Service 名称",
        "Namespace 名称",
      ],
      answer: 0,
      rationale: "Pod 亲和性根据其他 Pod 标签与拓扑决定调度。",
    },
    {
      id: "w6-1-q8",
      question: "若同时指定多个 requiredDuringScheduling 的 terms，会如何评估？",
      options: [
        "必须全部满足（AND），每个 term 内的 matchExpressions 也按 AND 处理",
        "只需满足任意一个（OR）",
        "随机选择一个",
        "忽略后续 term",
      ],
      answer: 0,
      rationale: "亲和性条目默认 AND 组合。",
    },
    {
      id: "w6-1-q9",
      question: "PodAntiAffinity 使用 topologyKey=“kubernetes.io/hostname” 的效果？",
      options: [
        "避免匹配的 Pod 落在同一节点",
        "禁止 Pod 调度到任意节点",
        "仅允许同一节点",
        "无效配置",
      ],
      answer: 0,
      rationale: "指定 hostname 可实现节点级别分散。",
    },
    {
      id: "w6-1-q10",
      question: "与 topologySpreadConstraints 的区别是？",
      options: [
        "affinity 是基于匹配/排斥，spreadConstraints 关注副本分布均衡",
        "两者完全等价",
        "spreadConstraints 只能在 StatefulSet 用",
        "affinity 只能在节点层面",
      ],
      answer: 0,
      rationale: "亲和/反亲和与均衡约束关注点不同，可配合使用。",
    },
  ],
  "w6-2": [
    {
      id: "w6-2-q1",
      question: "Taint 的三种 Effect 是？",
      options: [
        "NoSchedule、PreferNoSchedule、NoExecute",
        "Allow、Deny、Block",
        "Read、Write、Exec",
        "Schedule、Execute、Evict",
      ],
      answer: 0,
      rationale: "官方文档定义三种效果，分别对应禁止/倾向/驱逐。",
    },
    {
      id: "w6-2-q2",
      question: "NoExecute 与 NoSchedule 的区别？",
      options: [
        "NoExecute 会驱逐已在节点上但不容忍的 Pod，NoSchedule 仅影响新调度",
        "两者完全相同",
        "NoExecute 只影响 DaemonSet",
        "NoSchedule 只影响 PodAntiAffinity",
      ],
      answer: 0,
      rationale: "NoExecute 同时阻止调度并驱逐不容忍的已有 Pod。",
    },
    {
      id: "w6-2-q3",
      question: "tolerationSeconds 适用于哪种情况？",
      options: [
        "仅针对 NoExecute taint，控制可容忍的驱逐延迟",
        "适用于所有 taint",
        "控制 Pod 生命周期",
        "控制探针超时",
      ],
      answer: 0,
      rationale: "tolerationSeconds 用于 NoExecute 延迟驱逐。",
    },
    {
      id: "w6-2-q4",
      question: "以下哪个格式是合法 taint？",
      options: [
        "kubectl taint nodes node1 key=value:NoSchedule",
        "kubectl taint node1 key NoSchedule",
        "kubectl taint nodes key:Prefer",
        "kubectl taint nodes key=value:Allow",
      ],
      answer: 0,
      rationale: "命令格式 key[=value]:Effect。",
    },
    {
      id: "w6-2-q5",
      question: "默认控制平面节点的 taint 是？",
      options: [
        "node-role.kubernetes.io/control-plane=:NoSchedule（或 node-role.kubernetes.io/master）",
        "node.kubernetes.io/memory-pressure",
        "node.cloudprovider.kubernetes.io/uninitialized",
        "无默认 taint",
      ],
      answer: 0,
      rationale: "控制平面有 NoSchedule taint 以阻止普通工作负载。",
    },
    {
      id: "w6-2-q6",
      question: "Pod 定义了多个 tolerations 时，调度判定是？",
      options: [
        "需要满足节点上所有 taint（否则无法调度）",
        "只要匹配一个即可",
        "忽略所有 taint",
        "只检查 PreferNoSchedule",
      ],
      answer: 0,
      rationale: "未被 Pod 容忍的 taint 会阻止调度或驱逐。",
    },
    {
      id: "w6-2-q7",
      question: "Toleration 只能允许调度，不能？",
      options: [
        "强制调度到带 taint 的节点，仍需其它调度条件满足",
        "改变节点标签",
        "调整资源请求",
        "影响网络策略",
      ],
      answer: 0,
      rationale: "容忍只是去除 taint 的阻止作用，不保证调度成功。",
    },
    {
      id: "w6-2-q8",
      question: "operator: Exists 的作用？",
      options: [
        "无需指定值，只要匹配 key 即可容忍该 taint",
        "要求值完全匹配",
        "只容忍 PreferNoSchedule",
        "禁止匹配任何 taint",
      ],
      answer: 0,
      rationale: "Exists 可容忍指定 key 的任意值 taint。",
    },
    {
      id: "w6-2-q9",
      question: "移除 taint 的命令示例？",
      options: [
        "kubectl taint nodes node1 key:NoSchedule-",
        "kubectl taint nodes node1 key:Remove",
        "kubectl delete taint key",
        "kubectl cordon node1",
      ],
      answer: 0,
      rationale: "在命令末尾加 - 号移除。",
    },
    {
      id: "w6-2-q10",
      question: "节点存在多个 taint 时，Pod 需要？",
      options: [
        "对所有 effect=NoSchedule/NoExecute taint 提供容忍才可调度和存活",
        "只容忍一个即可",
        "忽略 PreferNoSchedule",
        "由 kube-proxy 自动处理",
      ],
      answer: 0,
      rationale: "未容忍的阻断 taint 任一存在都会阻止/驱逐 Pod。",
    },
  ],
  "w6-3": [
    {
      id: "w6-3-q1",
      question: "没有任何 NetworkPolicy 时的默认行为是？",
      options: [
        "默认允许所有进出流量",
        "默认拒绝所有流量",
        "仅允许 DNS",
        "只允许同命名空间",
      ],
      answer: 0,
      rationale: "NetworkPolicy 为白名单模型，未定义时全放行。",
    },
    {
      id: "w6-3-q2",
      question: "NetworkPolicy 中 podSelector 的作用是？",
      options: [
        "选择被此策略作用的 Pod（目标）",
        "选择允许通信的来源",
        "选择 Service",
        "选择节点",
      ],
      answer: 0,
      rationale: "podSelector 定义策略适用的 Pod 集合。",
    },
    {
      id: "w6-3-q3",
      question: "policyTypes 未指定时默认包含？",
      options: [
        "根据规则自动推断，若仅有 ingress 则为 Ingress，若有 egress 则含 Egress",
        "总是 Ingress+Egress",
        "仅 Ingress",
        "仅 Egress",
      ],
      answer: 0,
      rationale: "未指定时由规则推断，官方文档说明默认行为。",
    },
    {
      id: "w6-3-q4",
      question: "要实现默认拒绝 ingress，需要？",
      options: [
        "创建选择目标 Pod 的策略，ingress 规则为空（或不包含允许），只允许同策略定义的流量",
        "删除 Service",
        "修改 kube-proxy",
        "开启 RBAC",
      ],
      answer: 0,
      rationale: "白名单策略定义后未允许的流量被拒绝。",
    },
    {
      id: "w6-3-q5",
      question: "NetworkPolicy 生效的前提是？",
      options: [
        "CNI 插件实现了 NetworkPolicy（如 Calico/Cilium）",
        "仅需安装 kube-proxy",
        "安装 CoreDNS",
        "使用 StatefulSet",
      ],
      answer: 0,
      rationale: "需使用支持策略的网络插件，否则策略被忽略。",
    },
    {
      id: "w6-3-q6",
      question: "namespaceSelector 与 podSelector 同时使用时的关系是？",
      options: [
        "常用作组合：筛选命名空间后再选其中 Pod，条件按 AND 应用",
        "按 OR 合并",
        "随机选择",
        "两者不能同时使用",
      ],
      answer: 0,
      rationale: "peer 条目可包含 namespaceSelector+podSelector 共同约束。",
    },
    {
      id: "w6-3-q7",
      question: "ipBlock 的 except 字段作用？",
      options: [
        "从允许的 CIDR 中排除部分子网/地址",
        "定义 DNS 名称",
        "指定 Pod 标签",
        "控制端口协议",
      ],
      answer: 0,
      rationale: "ipBlock 用于基于 CIDR 控制，except 做差集。",
    },
    {
      id: "w6-3-q8",
      question: "NetworkPolicy 是否会影响未被 podSelector 选中的 Pod？",
      options: [
        "不会，未被选中 Pod 仍遵循默认全放行行为",
        "会默认拒绝",
        "会自动允许",
        "取决于节点 taint",
      ],
      answer: 0,
      rationale: "策略只作用于被选中目标，其他 Pod 不受限。",
    },
    {
      id: "w6-3-q9",
      question: "要允许 DNS 出站通常需要？",
      options: [
        "在 egress 规则中放行 UDP/TCP 53 到 DNS 服务（如 kube-dns/CoreDNS IP）",
        "无需特殊处理",
        "在 Service 添加注解",
        "通过 RBAC 授权",
      ],
      answer: 0,
      rationale: "默认拒绝 Egress 时需显式放行 DNS 查询。",
    },
    {
      id: "w6-3-q10",
      question: "多个 NetworkPolicy 作用于同一 Pod 时如何处理？",
      options: [
        "规则累加（最严格生效），必须同时满足所有策略的允许条件",
        "按创建时间覆盖",
        "随机选择一个",
        "只取最后一个",
      ],
      answer: 0,
      rationale: "NetworkPolicy 是白名单叠加，需同时满足才能通信。",
    },
  ],
  "w6-4": [
    {
      id: "w6-4-q1",
      question: "CNI 规范规定插件需要实现哪些命令？",
      options: [
        "ADD/DEL（以及可选 CHECK），由 kubelet 调用配置容器网络",
        "start/stop",
        "apply/delete",
        "init/reset",
      ],
      answer: 0,
      rationale: "CNI 插件通过可执行文件响应 ADD/DEL 请求。",
    },
    {
      id: "w6-4-q2",
      question: "Flannel 默认使用哪种网络模式？",
      options: [
        "Overlay（VXLAN 或 host-gw）提供简单 L3 互通",
        "BGP 路由",
        "仅 L2 交换不需要隧道",
        "需要硬件 LB",
      ],
      answer: 0,
      rationale: "Flannel 以 VXLAN/host-gw 等模式封装 Pod 流量。",
    },
    {
      id: "w6-4-q3",
      question: "Calico 默认的路由模式是？",
      options: [
        "BGP 分发路由（也可配置 IPIP/VXLAN 封装）",
        "仅支持 VXLAN",
        "只支持 host-gw",
        "基于 HTTP 代理",
      ],
      answer: 0,
      rationale: "Calico 可用 BGP 原生路由，也能用隧道封装兼容环境。",
    },
    {
      id: "w6-4-q4",
      question: "NetworkPolicy 支持情况：",
      options: [
        "Calico 原生支持 NetworkPolicy，Flannel 需额外策略插件或不支持",
        "两者都不支持",
        "Flannel 完全支持，Calico 不支持",
        "与 CNI 无关",
      ],
      answer: 0,
      rationale: "Calico 提供策略引擎；Flannel 默认仅提供连通性。",
    },
    {
      id: "w6-4-q5",
      question: "CNI 配置文件通常位于？",
      options: ["/etc/cni/net.d", "/etc/kubernetes/cni", "/var/lib/cni", "/usr/local/cni/conf"],
      answer: 0,
      rationale: "kubelet 默认从 /etc/cni/net.d 读取网络配置。",
    },
    {
      id: "w6-4-q6",
      question: "kubelet 何时调用 CNI 插件？",
      options: [
        "在创建/删除 Pod 的 sandbox 时配置/回收网络",
        "在 API Server 写入对象时",
        "由 kube-proxy 调用",
        "仅节点启动时",
      ],
      answer: 0,
      rationale: "kubelet 在为 Pod 创建 sandBox 时执行 CNI ADD，删除时执行 DEL。",
    },
    {
      id: "w6-4-q7",
      question: "使用 overlay 网络的常见副作用是？",
      options: [
        "MTU 减少，可能导致大包分片或丢弃",
        "CPU 占用降低",
        "无需路由",
        "提高磁盘性能",
      ],
      answer: 0,
      rationale: "VXLAN/IPIP 封装会占用额外头部，需调整 MTU。",
    },
    {
      id: "w6-4-q8",
      question: "Calico 可以使用哪种数据存储？",
      options: [
        "Kubernetes API Server（Datastore）或独立 etcd",
        "仅支持本地文件",
        "必须使用 MySQL",
        "依赖 CoreDNS",
      ],
      answer: 0,
      rationale: "Calico 支持 K8s API Datastore 与外部 etcd 两种模式。",
    },
    {
      id: "w6-4-q9",
      question: "Flannel 组件 flanneld 的职责是？",
      options: [
        "分配子网给节点并配置后端（VXLAN/host-gw 等）",
        "提供 DNS",
        "运行 kube-proxy",
        "管理存储卷",
      ],
      answer: 0,
      rationale: "flanneld 负责分配网络与维护后端隧道配置。",
    },
    {
      id: "w6-4-q10",
      question: "CNI 插件返回的结果中最重要的是？",
      options: [
        "分配的 Pod IP/路由与接口信息",
        "镜像标签",
        "节点 CPU 数量",
        "Pod 调度日志",
      ],
      answer: 0,
      rationale: "CNI 需返回 IP/接口配置供 kubelet 写入容器网络命名空间。",
    },
  ],
};