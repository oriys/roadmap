import type { QuizQuestion } from "../types";

export const week7: Record<string, QuizQuestion[]> = {
  "w7-1": [
    {
      id: "w7-1-q1",
      question: "Role 与 ClusterRole 的区别？",
      options: [
        "Role 作用于单个 Namespace，ClusterRole 可跨命名空间或集群级资源",
        "ClusterRole 只能用于节点",
        "两者完全相同",
        "Role 只能绑定用户，ClusterRole 只能绑定 ServiceAccount",
      ],
      answer: 0,
      rationale: "RBAC 文档定义作用域不同：Role 为 namespace 内，ClusterRole 可跨 namespace。",
    },
    {
      id: "w7-1-q2",
      question: "RoleBinding vs ClusterRoleBinding？",
      options: [
        "RoleBinding 作用于命名空间，可绑定 Role/ClusterRole；ClusterRoleBinding 跨全局",
        "RoleBinding 只能绑定 ClusterRole",
        "ClusterRoleBinding 只能绑定用户",
        "二者无差异",
      ],
      answer: 0,
      rationale: "绑定决定权限作用范围。",
    },
    {
      id: "w7-1-q3",
      question: "RBAC 规则中的动词 verbs 示例有？",
      options: [
        "get/list/watch/create/update/patch/delete",
        "allow/deny",
        "read/write/execute",
        "open/close",
      ],
      answer: 0,
      rationale: "RBAC verbs 与 API 操作对应。",
    },
    {
      id: "w7-1-q4",
      question: "subjects 可以包含哪些类型？",
      options: [
        "User、Group、ServiceAccount（以及外部用户标识）",
        "只有用户",
        "只有 ServiceAccount",
        "仅节点",
      ],
      answer: 0,
      rationale: "RoleBinding 支持多种主体类型。",
    },
    {
      id: "w7-1-q5",
      question: "授予某 namespace 内 default ServiceAccount 查看 Pod 权限的方式？",
      options: [
        "kubectl create rolebinding viewer --clusterrole=view --serviceaccount=<ns>:default -n <ns>",
        "编辑 kubelet 配置",
        "修改 CoreDNS",
        "创建 ConfigMap",
      ],
      answer: 0,
      rationale: "通过 RoleBinding 绑定内置 view ClusterRole 到 SA。",
    },
    {
      id: "w7-1-q6",
      question: "RBAC 权限是如何组合的？",
      options: [
        "基于允许列表累加，多条绑定叠加权限",
        "采用最小权限交集",
        "按绑定创建时间覆盖",
        "随机选择一条",
      ],
      answer: 0,
      rationale: "RBAC 是允许即通过的累加模型，不存在显式拒绝。",
    },
    {
      id: "w7-1-q7",
      question: "resourceNames 的用途？",
      options: [
        "将规则限定到特定资源名称集合",
        "指定命名空间",
        "定义节点名",
        "控制副本数",
      ],
      answer: 0,
      rationale: "resourceNames 细化到具体对象名称。",
    },
    {
      id: "w7-1-q8",
      question: "内置聚合角色（aggregate-to-admin 等）的作用？",
      options: [
        "通过标签自动聚合到 admin/edit/view 等高阶角色",
        "只在 kube-system 可用",
        "用于节点权限",
        "提供审计日志",
      ],
      answer: 0,
      rationale: "带聚合标签的 ClusterRole 会自动并入目标聚合角色。",
    },
    {
      id: "w7-1-q9",
      question: "Node Authorizer 授权的主体通常是？",
      options: [
        "kubelet 使用的节点证书（system:node:<nodename>）",
        "任意用户",
        "仅管理员",
        "只允许匿名",
      ],
      answer: 0,
      rationale: "节点证书请求由 Node Authorizer 检查并授予有限权限。",
    },
    {
      id: "w7-1-q10",
      question: "检查请求的 RBAC 决策可以使用？",
      options: [
        "kubectl auth can-i <verb> <resource> [--as user]",
        "kubectl get rbac",
        "查看 etcd 日志",
        "需要访问控制平面主机",
      ],
      answer: 0,
      rationale: "auth can-i 是官方提供的快速自测命令。",
    },
  ],
  "w7-2": [
    {
      id: "w7-2-q1",
      question: "Pod 未指定 serviceAccountName 时默认使用？",
      options: [
        "所在 Namespace 的 default ServiceAccount",
        "无法启动",
        "自动创建一个新的 ServiceAccount",
        "集群级 admin 账户",
      ],
      answer: 0,
      rationale: "API Server 会注入 default SA（除非被修改）。",
    },
    {
      id: "w7-2-q2",
      question: "automountServiceAccountToken: false 的效果？",
      options: [
        "阻止将 API 令牌自动挂载到 Pod",
        "加密令牌",
        "自动刷新令牌",
        "强制使用 root 用户",
      ],
      answer: 0,
      rationale: "可在 Pod 或 ServiceAccount 层关闭自动挂载，提升安全性。",
    },
    {
      id: "w7-2-q3",
      question: "Bound Service Account Token 的特性是？",
      options: [
        "短周期、可撤销、与具体 Pod 绑定并投射为投影卷",
        "长期不过期",
        "存储在 Secret 对象中",
        "只能在 kube-system 使用",
      ],
      answer: 0,
      rationale: "新式 Token 通过 TokenRequest API 获取，具备过期时间。",
    },
    {
      id: "w7-2-q4",
      question: "ServiceAccount 令牌包含哪些关键信息？",
      options: [
        "Bearer Token + 集群 CA 证书 + API Server 地址",
        "用户密码",
        "etcd 密钥",
        "容器镜像",
      ],
      answer: 0,
      rationale: "投射卷中包含 token、ca.crt、namespace 文件供客户端访问 API。",
    },
    {
      id: "w7-2-q5",
      question: "imagePullSecrets 通常挂在哪个对象上？",
      options: [
        "ServiceAccount 或 Pod，用于拉取私有镜像",
        "ConfigMap",
        "Node 对象",
        "Deployment 的 spec.selector",
      ],
      answer: 0,
      rationale: "可在 SA 上统一配置镜像拉取凭证。",
    },
    {
      id: "w7-2-q6",
      question: "如何为特定 Pod 指定 ServiceAccount？",
      options: [
        "在 Pod spec.serviceAccountName 写入目标 SA 名称",
        "通过标签自动匹配",
        "只能用注解",
        "无法更改",
      ],
      answer: 0,
      rationale: "Pod spec.serviceAccountName 控制使用的 SA。",
    },
    {
      id: "w7-2-q7",
      question: "kubectl create token <sa>（1.24+）的作用？",
      options: [
        "基于 TokenRequest API 获取短期令牌",
        "创建 ServiceAccount",
        "刷新 kubeconfig",
        "创建 Secret",
      ],
      answer: 0,
      rationale: "该命令调用 TokenRequest 生成可短期使用的 Bearer Token。",
    },
    {
      id: "w7-2-q8",
      question: "ServiceAccount 的作用域是？",
      options: [
        "命名空间级，不能跨 Namespace 使用",
        "集群级，可任意使用",
        "节点级",
        "仅 Pod 级",
      ],
      answer: 0,
      rationale: "每个 SA 属于一个 Namespace，需要跨命名空间需重新创建/绑定。",
    },
    {
      id: "w7-2-q9",
      question: "关闭 SA 自动挂载的常见场景？",
      options: [
        "无须访问 API 的作业/sidecar 以减少凭证暴露",
        "所有 Pod 都应关闭",
        "必须开启才能访问 DNS",
        "与 RBAC 无关",
      ],
      answer: 0,
      rationale: "安全最佳实践：不需要访问 API 的工作负载可禁用令牌挂载。",
    },
    {
      id: "w7-2-q10",
      question: "旧版基于 Secret 的长效 Token 问题是？",
      options: [
        "默认不过期且易被滥用，已被 Bound Token 替代",
        "性能过低",
        "无法在命名空间使用",
        "需要重启 kubelet",
      ],
      answer: 0,
      rationale: "旧 token 长期有效，安全性差，新版本引入可撤销的投射 token。",
    },
  ],
  "w7-3": [
    {
      id: "w7-3-q1",
      question: "Helm Chart 的核心文件/目录有哪些？",
      options: [
        "Chart.yaml、values.yaml、templates/、charts/",
        "Dockerfile、Makefile",
        "package.json、index.ts",
        "config.json、pods/",
      ],
      answer: 0,
      rationale: "Chart 结构文档列出必需文件与模板目录。",
    },
    {
      id: "w7-3-q2",
      question: "安装一个 Chart 的命令示例？",
      options: [
        "helm install <release-name> <chart>",
        "kubectl apply -f chart",
        "helm create",
        "helm push",
      ],
      answer: 0,
      rationale: "helm install 创建一个 release。",
    },
    {
      id: "w7-3-q3",
      question: "Release 名称的作用域？",
      options: [
        "在同一命名空间内唯一，不同 namespace 可重复",
        "全局唯一",
        "与 Chart 名相同即可",
        "必须与 Service 名一致",
      ],
      answer: 0,
      rationale: "Helm 将 release 归属于 namespace，名称局部唯一。",
    },
    {
      id: "w7-3-q4",
      question: "覆盖默认 values 的方式？",
      options: [
        "使用 -f/--values 指定文件或 --set/--set-file 设置键值",
        "只能修改 Chart.yaml",
        "必须编辑模板",
        "不支持覆盖",
      ],
      answer: 0,
      rationale: "Helm 支持文件与命令行覆盖 values。",
    },
    {
      id: "w7-3-q5",
      question: "helm upgrade --install 的作用？",
      options: [
        "存在则升级，不存在则安装（幂等部署）",
        "只升级，不安装",
        "只安装，不升级",
        "删除后再安装",
      ],
      answer: 0,
      rationale: "常用模式确保命令可重入。",
    },
    {
      id: "w7-3-q6",
      question: "查看已安装 release 的命令？",
      options: ["helm list", "helm status all", "kubectl get releases", "helm repo list"],
      answer: 0,
      rationale: "helm list 显示当前命名空间的 release。",
    },
    {
      id: "w7-3-q7",
      question: "回滚到某个修订版本的命令？",
      options: [
        "helm rollback <release> <revision>",
        "kubectl rollout undo",
        "helm undo",
        "helm reset",
      ],
      answer: 0,
      rationale: "Helm 提供 rollback 命令恢复历史版本。",
    },
    {
      id: "w7-3-q8",
      question: "helm template 的作用？",
      options: [
        "本地渲染模板并输出 Kubernetes 清单而不安装",
        "创建 Chart",
        "校验语法",
        "管理仓库索引",
      ],
      answer: 0,
      rationale: "helm template 便于查看渲染结果用于调试。",
    },
    {
      id: "w7-3-q9",
      question: "Chart.yaml 中 appVersion 与 version 的区别？",
      options: [
        "version 是 Chart 本身版本，appVersion 表示打包应用版本",
        "两者完全相同",
        "appVersion 控制依赖",
        "version 仅供显示",
      ],
      answer: 0,
      rationale: "Helm 文档区分 Chart 版本与应用版本。",
    },
    {
      id: "w7-3-q10",
      question: "添加远程仓库后需执行？",
      options: [
        "helm repo update 以刷新索引",
        "helm upgrade",
        "kubectl apply",
        "删除本地缓存",
      ],
      answer: 0,
      rationale: "更新仓库索引后才能拉取最新 Chart。",
    },
  ],
  "w7-4": [
    {
      id: "w7-4-q1",
      question: "Helm 模板使用的语言/函数来源是？",
      options: [
        "Go template + Sprig 函数库",
        "Jinja2",
        "Mustache",
        "Lua",
      ],
      answer: 0,
      rationale: "Helm 使用 Go 模板并内置 Sprig 函数。",
    },
    {
      id: "w7-4-q2",
      question: "_helpers.tpl 通常存放什么？",
      options: [
        "命名模板/局部函数（如 fullname、labels）供其他模板复用",
        "镜像列表",
        "RBAC 规则",
        "测试用例",
      ],
      answer: 0,
      rationale: "Helm 官方推荐在 _helpers.tpl 定义可复用模板片段。",
    },
    {
      id: "w7-4-q3",
      question: "values 文件与 --set 的优先级？",
      options: [
        "命令行 --set 优先级最高，覆盖 values 文件",
        "values 文件覆盖 --set",
        "无优先级，随机",
        "由 Chart 决定",
      ],
      answer: 0,
      rationale: "Helm 按 CLI > values 文件 > Chart 默认的顺序合并。",
    },
    {
      id: "w7-4-q4",
      question: "helm lint 的作用？",
      options: [
        "静态检查 Chart 结构与模板常见问题",
        "渲染模板",
        "安装依赖",
        "生成证书",
      ],
      answer: 0,
      rationale: "lint 可提前发现常见错误。",
    },
    {
      id: "w7-4-q5",
      question: "helm test 的用途？",
      options: [
        "运行 chart 定义的测试 hook（如 Pod）验证部署",
        "执行单元测试框架",
        "升级 Chart",
        "生成文档",
      ],
      answer: 0,
      rationale: "helm test 会运行带 test hook 的资源，常用于验收。",
    },
    {
      id: "w7-4-q6",
      question: "Helm hook 的常见事件包括？",
      options: [
        "pre-install、post-install、pre-upgrade、post-upgrade 等",
        "pre-run、post-run",
        "before-apply、after-apply",
        "只有 install",
      ],
      answer: 0,
      rationale: "Helm 支持多种生命周期 hook。",
    },
    {
      id: "w7-4-q7",
      question: "Library Chart 的作用？",
      options: [
        "提供可复用的模板函数/片段，不会单独渲染资源",
        "提供公共镜像仓库",
        "自动生成 values",
        "必须与子 Chart 同名",
      ],
      answer: 0,
      rationale: "Library chart 仅供依赖引用复用模板。",
    },
    {
      id: "w7-4-q8",
      question: "管理 Chart 依赖的命令是？",
      options: [
        "helm dependency update/build",
        "helm repo list",
        "kubectl apply -k",
        "helm sync",
      ],
      answer: 0,
      rationale: "依赖信息在 Chart.yaml，需用 dependency update/build 下载。",
    },
    {
      id: "w7-4-q9",
      question: "values.schema.json 用途是？",
      options: [
        "为 values 提供 JSON Schema 校验，帮助发现配置错误",
        "存储默认值",
        "生成 RBAC",
        "控制发布策略",
      ],
      answer: 0,
      rationale: "Helm 支持根据 schema 校验 values。",
    },
    {
      id: "w7-4-q10",
      question: "调试渲染输出并查看渲染值可以使用？",
      options: [
        "helm template --debug 或 helm install --dry-run --debug",
        "kubectl describe",
        "helm render-only",
        "必须部署后查看",
      ],
      answer: 0,
      rationale: "dry-run+debug 可输出渲染模板与使用的 values。",
    },
  ],
};