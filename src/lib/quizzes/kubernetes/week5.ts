import type { QuizQuestion } from "../types";

export const week5: Record<string, QuizQuestion[]> = {
  "w5-1": [
    {
      id: "w5-1-q1",
      question: "ConfigMap 与 Secret 的主要区别是？",
      options: [
        "Secret 以 base64 方式存储敏感数据，API 默认限制输出；ConfigMap 用于非敏感配置",
        "两者完全相同",
        "Secret 只能挂载为环境变量",
        "ConfigMap 需要加密才能使用",
      ],
      answer: 0,
      rationale: "Secret 专为敏感信息设计，ConfigMap 适合普通配置。",
    },
    {
      id: "w5-1-q2",
      question: "通过环境变量注入 ConfigMap/Secret 有何特点？",
      options: [
        "值在容器启动时固定，后续更新不会自动刷新",
        "会自动热更新",
        "仅支持 Secret，不支持 ConfigMap",
        "必须配合 subPath",
      ],
      answer: 0,
      rationale: "Env 注入在容器启动时解析，后续变更不会更新已有进程环境。",
    },
    {
      id: "w5-1-q3",
      question: "作为 Volume 挂载 ConfigMap/Secret 的更新行为是？",
      options: [
        "挂载点会在短暂延迟后自动刷新内容（使用 subPath 则不会）",
        "永不更新，必须重启 Pod",
        "只在节点重启时刷新",
        "需要手动执行 kubectl rollout",
      ],
      answer: 0,
      rationale: "投射卷由 kubelet 周期刷新，subPath 会阻断更新。",
    },
    {
      id: "w5-1-q4",
      question: "单个 ConfigMap/Secret 官方建议的大小上限是？",
      options: ["约 1 MiB", "10 MiB", "无限制", "64 KiB"],
      answer: 0,
      rationale: "文档建议控制在 1MiB 内，超大对象应改用存储卷。",
    },
    {
      id: "w5-1-q5",
      question: "Secret 默认是否加密存储？",
      options: [
        "默认只做 base64 编码，需启用 EncryptionConfiguration 才加密",
        "默认开启强加密",
        "存储在 Pod 本地文件",
        "自动存入 HashiCorp Vault",
      ],
      answer: 0,
      rationale: "etcd 默认不加密 Secret，需要显式配置加密提供者。",
    },
    {
      id: "w5-1-q6",
      question: "docker-registry 登录凭证应使用哪种 Secret 类型？",
      options: [
        "kubernetes.io/dockerconfigjson",
        "Opaque",
        "tls",
        "service-account-token",
      ],
      answer: 0,
      rationale: "拉取私有镜像需 dockerconfigjson 类型 Secret。",
    },
    {
      id: "w5-1-q7",
      question: "ConfigMap 支持存储二进制内容吗？",
      options: [
        "支持，通过 binaryData 字段存放 base64 编码的二进制",
        "不支持，只能存文本",
        "需要转成 Secret",
        "只能用 CSI 驱动",
      ],
      answer: 0,
      rationale: "从 v1.10 起 ConfigMap 提供 binaryData 字段。",
    },
    {
      id: "w5-1-q8",
      question: "使用 subPath 挂载 ConfigMap/Secret 时的注意事项？",
      options: [
        "内容不会自动更新，需重新创建 Pod",
        "更新会自动同步",
        "只能挂载整个目录，不能单文件",
        "必须 root 权限",
      ],
      answer: 0,
      rationale: "subPath 将文件复制到宿主路径，不会随源更新。",
    },
    {
      id: "w5-1-q9",
      question: "以 Volume 挂载时如何控制文件权限？",
      options: [
        "通过 defaultMode 设置八进制文件模式",
        "只能用 chmod 处理",
        "权限固定为 777",
        "必须配合 Init 容器",
      ],
      answer: 0,
      rationale: "投射卷支持 defaultMode 字段控制文件权限。",
    },
    {
      id: "w5-1-q10",
      question: "创建 ConfigMap 的命令示例正确的是？",
      options: [
        "kubectl create configmap app-config --from-literal=key=value",
        "kubectl new cm app-config key=value",
        "kubectl apply secret app-config",
        "kubectl create cm --file-only",
      ],
      answer: 0,
      rationale: "官方示例使用 create configmap 并可用 --from-literal/--from-file。",
    },
  ],
  "w5-2": [
    {
      id: "w5-2-q1",
      question: "PersistentVolume（PV）的作用域与阶段是？",
      options: [
        "集群级资源，阶段包括 Available/Bound/Released/Failed",
        "命名空间内资源，仅有 Created/Deleted 阶段",
        "仅供 StatefulSet 使用",
        "必须与 Node 一一对应",
      ],
      answer: 0,
      rationale: "PV 是集群资源，生命周期包含多个阶段以反映绑定状态。",
    },
    {
      id: "w5-2-q2",
      question: "常见的访问模式包含？",
      options: [
        "ReadWriteOnce、ReadOnlyMany、ReadWriteMany",
        "ReadNever、WriteNever",
        "ReadWriteOnePerNodeOnly",
        "仅 RWX",
      ],
      answer: 0,
      rationale: "官方定义三种基础访问模式。",
    },
    {
      id: "w5-2-q3",
      question: "PVC 与 PV 的绑定关系是？",
      options: [
        "一对一绑定，PVC 绑定后只能使用一个 PV",
        "PVC 可同时绑定多个 PV",
        "PV 可绑定多个 PVC 共享",
        "绑定后仍保持 Available 状态",
      ],
      answer: 0,
      rationale: "每个 PVC 仅绑定一个 PV，PV 状态变为 Bound。",
    },
    {
      id: "w5-2-q4",
      question: "ReclaimPolicy 的取值及含义？",
      options: [
        "Retain/Recycle/Delete，决定 PVC 删除后底层卷如何处理",
        "Only Retain",
        "仅控制访问模式",
        "只影响动态供给",
      ],
      answer: 0,
      rationale: "策略控制释放后是否保留、简单清理或删除后端资源。",
    },
    {
      id: "w5-2-q5",
      question: "Pod 如何使用 PVC？",
      options: [
        "在 volume 中引用 persistentVolumeClaim.claimName，再挂载到容器",
        "直接写 PV 名称",
        "写入 StorageClass 名称即可",
        "通过 ConfigMap 引用",
      ],
      answer: 0,
      rationale: "Pod 需要通过 volume 声明 PVC，再在容器 mount。",
    },
    {
      id: "w5-2-q6",
      question: "PVC 与 StorageClass 的关系是？",
      options: [
        "PVC 指定 storageClassName，可匹配静态 PV 或触发动态供给",
        "必须为空",
        "只能指定一个固定值 default",
        "仅 PV 需要设置",
      ],
      answer: 0,
      rationale: "PVC 通过 storageClassName 选择合适 PV/SC。",
    },
    {
      id: "w5-2-q7",
      question: "PV/PVC 的命名空间分别是？",
      options: [
        "PV 是集群级无 namespace，PVC 属于某个 namespace",
        "两者都是集群级",
        "两者都在同一 namespace",
        "PV 属于节点",
      ],
      answer: 0,
      rationale: "PVC 与 Pod 同属 namespace，PV 为全局资源。",
    },
    {
      id: "w5-2-q8",
      question: "删除 PVC 后 PV 的行为取决于？",
      options: [
        "PV 的 reclaimPolicy（Retain/Recycle/Delete）",
        "StorageClass 名称",
        "节点数量",
        "探针类型",
      ],
      answer: 0,
      rationale: "回收策略决定释放后的处理方式。",
    },
    {
      id: "w5-2-q9",
      question: "PVC 请求的访问模式和容量必须？",
      options: [
        "与 PV 兼容且不超过 PV 容量",
        "可以大于 PV 容量",
        "访问模式可随意填写",
        "只需容量匹配，模式不影响",
      ],
      answer: 0,
      rationale: "绑定要求访问模式和容量满足 PV 能力。",
    },
    {
      id: "w5-2-q10",
      question: "回收策略 Retain 的效果是？",
      options: [
        "保留底层卷和数据，手动回收后方可再次使用",
        "立即删除底层卷",
        "格式化底层卷后重新绑定",
        "无任何作用",
      ],
      answer: 0,
      rationale: "Retain 需要管理员手工清理再重用或删除 PV。",
    },
  ],
  "w5-3": [
    {
      id: "w5-3-q1",
      question: "StorageClass 的核心字段是？",
      options: [
        "provisioner（驱动名称）与 parameters（传递给 provisioner 的配置）",
        "apiVersion 与 kind",
        "nodeSelector",
        "Replica 数量",
      ],
      answer: 0,
      rationale: "StorageClass 指定 provisioner 及参数来动态创建卷。",
    },
    {
      id: "w5-3-q2",
      question: "volumeBindingMode=WaitForFirstConsumer 的作用？",
      options: [
        "等待 Pod 调度到节点后再选择/创建卷，避免跨可用区问题",
        "立即创建 PV",
        "只适用于 NFS",
        "阻止卷绑定",
      ],
      answer: 0,
      rationale: "该模式确保调度考虑拓扑，再选择卷位置。",
    },
    {
      id: "w5-3-q3",
      question: "allowVolumeExpansion=true 的意义？",
      options: [
        "允许已绑定的 PVC 在线扩容（需底层存储支持）",
        "自动缩容卷",
        "允许动态删除卷",
        "启用快照",
      ],
      answer: 0,
      rationale: "StorageClass 打开扩容开关，PVC 才能扩容。",
    },
    {
      id: "w5-3-q4",
      question: "动态供给的 PV 默认 ReclaimPolicy 是？",
      options: ["Delete", "Retain", "Recycle", "None"],
      answer: 0,
      rationale: "未指定时动态创建的 PV 默认 Delete。",
    },
    {
      id: "w5-3-q5",
      question: "PVC 未指定 storageClassName 且无默认存储类时会？",
      options: [
        "保持 Pending，等待匹配的 PV 或默认类",
        "自动选择任意 StorageClass",
        "创建本地临时卷",
        "被立即拒绝",
      ],
      answer: 0,
      rationale: "没有默认 StorageClass 且未指定时不会自动供给。",
    },
    {
      id: "w5-3-q6",
      question: "storageclass.kubernetes.io/is-default-class=true 的作用？",
      options: [
        "标记该 StorageClass 为默认，PVC 未指定时选用",
        "禁止该类被使用",
        "指定回收策略",
        "强制使用 WaitForFirstConsumer",
      ],
      answer: 0,
      rationale: "官方注解用于声明默认存储类。",
    },
    {
      id: "w5-3-q7",
      question: "使用 CSI 驱动动态供给时，需要什么组件？",
      options: [
        "部署对应 CSI Controller/Node 插件及 StorageClass",
        "仅创建 StorageClass 即可",
        "必须使用 hostPath",
        "需要修改 kube-proxy",
      ],
      answer: 0,
      rationale: "CSI 需控制器与节点插件配合才能创建/挂载卷。",
    },
    {
      id: "w5-3-q8",
      question: "PV 选择具体节点/可用区的常见方式是？",
      options: [
        "结合 Topology（如 zone 标签）与 WaitForFirstConsumer，或使用 NodeAffinity",
        "手工在 Pod 里指定 nodeName",
        "通过 ConfigMap 绑定",
        "只能随机选择",
      ],
      answer: 0,
      rationale: "StorageClass/CSI 支持拓扑感知，或 PV 的 nodeAffinity 限制节点。",
    },
    {
      id: "w5-3-q9",
      question: "若需对 PVC 启用快照/克隆，应使用？",
      options: [
        "支持 VolumeSnapshot/Clone 的 CSI 驱动和相应 CRD",
        "ConfigMap",
        "ResourceQuota",
        "Admission Webhook",
      ],
      answer: 0,
      rationale: "快照/克隆功能由 CSI 扩展提供，并需 CRD 支持。",
    },
    {
      id: "w5-3-q10",
      question: "为什么 WaitForFirstConsumer 能避免跨区调度失败？",
      options: [
        "先确定 Pod 目标节点/可用区，再创建同区域的卷",
        "会忽略拓扑直接使用多区存储",
        "因为卷可自动跨区挂载",
        "与调度无关",
      ],
      answer: 0,
      rationale: "先调度后供给确保卷与 Pod 位于同一拓扑约束内。",
    },
  ],
  "w5-4": [
    {
      id: "w5-4-q1",
      question: "StatefulSet 赋予每个 Pod 的特性是？",
      options: [
        "稳定的网络身份（有序名称）与持久存储绑定",
        "随机名称且无顺序",
        "与 Deployment 完全一致",
        "自动横向扩容",
      ],
      answer: 0,
      rationale: "StatefulSet 通过有序 Pod 名与 Headless Service 提供稳定标识。",
    },
    {
      id: "w5-4-q2",
      question: "volumeClaimTemplates 的作用？",
      options: [
        "为每个副本自动创建独立的 PVC/PV",
        "共享同一个 PVC",
        "仅定义临时卷",
        "限制副本数",
      ],
      answer: 0,
      rationale: "模板按序生成 PVC，为每个 Pod 保留专属存储。",
    },
    {
      id: "w5-4-q3",
      question: "StatefulSet 默认的 Pod 启动顺序？",
      options: [
        "OrderedReady：按序创建并等待前一个就绪",
        "并行创建所有 Pod",
        "随机顺序",
        "由节点决定",
      ],
      answer: 0,
      rationale: "默认 OrderedReady，需设置 podManagementPolicy=Parallel 才并行。",
    },
    {
      id: "w5-4-q4",
      question: "RollingUpdate + partition 对 StatefulSet 的影响？",
      options: [
        "仅更新序号大于等于 partition 的 Pod，低序号保持旧版本",
        "更新全部 Pod",
        "停止更新",
        "只更新 PVC",
      ],
      answer: 0,
      rationale: "partition 可实现金丝雀/分批更新。",
    },
    {
      id: "w5-4-q5",
      question: "OnDelete 更新策略意味着？",
      options: [
        "不会自动滚动更新，需要手动删除 Pod 触发新版本",
        "立即删除全部 Pod 再重建",
        "与 RollingUpdate 相同",
        "阻止扩容",
      ],
      answer: 0,
      rationale: "OnDelete 要求运维手工删除以应用新模板。",
    },
    {
      id: "w5-4-q6",
      question: "StatefulSet Pod 名称格式通常是？",
      options: [
        "<statefulsetname>-<ordinal>",
        "<statefulsetname>-<random>",
        "node-<id>",
        "固定为 0-1-2 不含前缀",
      ],
      answer: 0,
      rationale: "官方示例：web-0、web-1 等，反映有序身份。",
    },
    {
      id: "w5-4-q7",
      question: "Headless Service 在 StatefulSet 中的作用是？",
      options: [
        "为每个 Pod 提供稳定的 DNS 记录（如 podname.servicename）",
        "提供负载均衡 VIP",
        "绑定节点亲和",
        "自动创建 PV",
      ],
      answer: 0,
      rationale: "clusterIP=None 的 Headless Service 使 Pod 有稳定解析。",
    },
    {
      id: "w5-4-q8",
      question: "缩容 StatefulSet 时 PVC 会怎样？",
      options: [
        "默认保留，不会自动删除 PVC",
        "与 Pod 一起删除",
        "自动回收并格式化",
        "迁移到其他 Pod",
      ],
      answer: 0,
      rationale: "PVC 需手动删除，防止数据丢失。",
    },
    {
      id: "w5-4-q9",
      question: "podManagementPolicy=Parallel 的效果？",
      options: [
        "允许并行创建/删除 Pod，不再等待有序就绪",
        "禁止扩容",
        "仅更新一个 Pod",
        "启用自动扩缩容",
      ],
      answer: 0,
      rationale: "Parallel 模式跳过有序限制，加快扩缩容。",
    },
    {
      id: "w5-4-q10",
      question: "StatefulSet 对 serviceName 字段的要求？",
      options: [
        "必须指定一个 Headless Service 名作为网络身份基础",
        "可以为空",
        "仅用于显示",
        "用于选择节点",
      ],
      answer: 0,
      rationale: "serviceName 提供 DNS 后缀与端点，必须存在。",
    },
  ],
};