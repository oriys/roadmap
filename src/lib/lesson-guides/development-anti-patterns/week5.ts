import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week5Guides: Record<string, LessonGuide> = {
    "ap-5-1": {
        lessonId: "ap-5-1",
        background: [
            "【分布式单体定义】Distributed Monolith 是微服务架构的反模式，指表面上拆分为独立服务，但实际上服务间紧密耦合、相互依赖，保留了单体架构的缺点。",
            "【最糟糕的状态】'A distributed monolith is the worst of all worlds'——既有单体的笨重和不灵活，又有微服务的复杂性，却几乎没有任何一种架构的好处。",
            "【耦合类型】紧耦合的三种形式：(1) 行为耦合——需要依赖可用才能完成任务；(2) 时间耦合——需要快速低延迟的通信；(3) 实现耦合——改变一个服务需要同时改变多个服务。",
            "【共享数据库反模式】多个服务共享同一个数据库是分布式单体的典型信号。这破坏了服务的自治性，任何数据库 schema 变更都需要协调多个服务。",
            "【Database per Service 模式】微服务的正确做法是每个服务拥有自己的数据存储，服务间通过 API 而非数据库直接通信。"
        ],
        keyDifficulties: [
            "【识别分布式单体】信号：服务启动时间长；故障从一个容器级联到下一个；小改动需要重新部署整个应用；每次部署需要同时更新多个服务。",
            "【性能更差】'Distributed monolith always performs worse than monolith and microservices'——分布式单体的性能比纯单体或正确的微服务都差，因为增加了网络开销却没有获得独立扩展的好处。",
            "【从单体迁移的陷阱】将单体'切块'但保持原有依赖关系只会创建分布式单体。需要重新设计服务边界和通信模式，而非简单拆分代码。",
            "【同步通信的风险】服务间过度依赖同步 HTTP 调用会创建时间耦合。一个服务的延迟或故障会传播到整个调用链。"
        ],
        handsOnPath: [
            "审计当前微服务架构：绘制服务依赖图，识别哪些服务必须同时部署。",
            "检查数据存储：有多少服务共享同一个数据库？共享数据库的表被多少服务访问？",
            "分析通信模式：统计同步 vs 异步调用的比例，识别同步调用链的深度。",
            "模拟故障：如果某个服务不可用，多少其他服务会受影响？影响范围多大？",
            "设计解耦策略：选择一对紧耦合的服务，设计使用事件驱动或 API 契约解耦的方案。"
        ],
        selfCheck: [
            "什么是分布式单体？为什么说它是'最糟糕的状态'？",
            "紧耦合的三种形式分别是什么？",
            "共享数据库反模式的危害是什么？Database per Service 模式如何解决这个问题？",
            "如何识别你的微服务架构是否是分布式单体？",
            "为什么分布式单体的性能比单体和微服务都差？",
            "将单体'切块'迁移到微服务时常见的陷阱是什么？"
        ],
        extensions: [
            "阅读 Sam Newman 的《Monolith to Microservices》了解正确的迁移策略。",
            "研究事件驱动架构和异步通信如何帮助解耦服务。",
            "学习领域驱动设计(DDD)如何帮助定义正确的服务边界。",
            "探索 CQRS 和事件溯源模式如何支持服务自治。"
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/database-per-service.html",
            "https://martinfowler.com/books/monolith-to-microservices.html",
            "https://gremlin.com/blog/is-your-microservice-a-distributed-monolith"
        ]
    },
    "ap-5-2": {
        lessonId: "ap-5-2",
        background: [
            "【喋喋不休服务】Chatty Services 反模式指服务间进行过多的细粒度调用，每个操作都需要大量往返通信，导致网络延迟累积和系统脆弱性增加。",
            "【API 粒度问题】API 设计过于细粒度时，完成一个业务操作需要调用多个端点。这在分布式环境中尤其有害，因为每次调用都有网络开销。",
            "【BFF 模式】Backend for Frontend (BFF) 模式为不同的前端创建专门的后端服务，聚合多个下游服务的调用，减少前端与后端间的往返次数。",
            "【gRPC vs REST】gRPC 使用二进制协议和 HTTP/2，比 JSON/REST 更高效。但选择通信协议时应考虑场景：内部服务间通信可用 gRPC，对外 API 可能仍需 REST。",
            "【批量操作】设计 API 时应支持批量操作而非只有单项操作。例如，一次获取多个资源而非循环调用单个资源的端点。"
        ],
        keyDifficulties: [
            "【网络不可靠】分布式系统第一谬论：网络是可靠的。喋喋不休的服务放大了网络问题的影响——更多调用意味着更多失败点。",
            "【延迟放大】每个服务调用都增加延迟。如果完成一个请求需要调用 10 个服务，即使每个只有 10ms，累积就是 100ms，还不算可能的排队和重试。",
            "【粒度权衡】API 粒度需要权衡：太细导致喋喋不休，太粗导致传输不必要的数据和耦合。没有通用答案，需要根据使用场景设计。",
            "【缓存策略】缓存是减少服务间调用的有效手段，但引入缓存一致性问题。需要明确缓存失效策略和可接受的数据过时程度。"
        ],
        handsOnPath: [
            "分析请求链路：使用分布式追踪工具(如 Jaeger、Zipkin)追踪一个用户请求触发多少服务调用。",
            "识别热点调用：哪些服务间的调用最频繁？这些调用是否可以聚合或缓存？",
            "评估 BFF 需求：不同的客户端(Web、Mobile、Partner)是否有不同的数据需求？是否值得创建专门的 BFF？",
            "设计批量 API：选择一个频繁的 N+1 调用模式，设计批量获取的替代 API。",
            "评估缓存机会：哪些数据是相对静态的？可以在服务边界处缓存以减少下游调用？"
        ],
        selfCheck: [
            "什么是喋喋不休服务反模式？它的危害是什么？",
            "API 粒度过细会导致什么问题？",
            "BFF 模式是什么？它如何减少客户端与服务器的往返次数？",
            "gRPC 相比 REST 有什么优势？什么场景适合使用？",
            "为什么喋喋不休的服务在分布式系统中特别有害？",
            "缓存如何帮助减少服务间调用？引入什么新问题？"
        ],
        extensions: [
            "学习 gRPC 和 Protocol Buffers，了解高效的服务间通信。",
            "研究 GraphQL 如何通过让客户端指定所需字段来减少往返。",
            "探索服务网格(Service Mesh)如何提供透明的重试、超时和断路器。",
            "阅读《Designing Data-Intensive Applications》中关于数据一致性和缓存的章节。"
        ],
        sourceUrls: [
            "https://grpc.io/docs/what-is-grpc/introduction/",
            "https://samnewman.io/patterns/architectural/bff/",
            "https://dataintensive.net/"
        ]
    },
    "ap-5-3": {
        lessonId: "ap-5-3",
        background: [
            "【资源过度配置】Over-provisioning 指分配远超实际需求的计算资源。在云环境中，这直接转化为成本浪费，因为按使用付费。",
            "【自动扩展误用】Auto-scaling 配置不当会导致资源震荡（快速扩缩导致不稳定）或响应过慢（业务高峰已过才扩容完成）。",
            "【可观测性三支柱】现代可观测性包括三个支柱：日志(Logs)——离散事件记录；指标(Metrics)——聚合的数值测量；追踪(Traces)——请求的端到端路径。",
            "【OpenTelemetry】OpenTelemetry 是可观测性的开放标准，提供统一的 API 来收集日志、指标和追踪数据，避免供应商锁定。",
            "【SRE 容量规划】Google SRE 方法论强调基于数据的容量规划：理解服务的资源需求、增长趋势和峰值特征，而非凭直觉分配资源。"
        ],
        keyDifficulties: [
            "【可观测性缺失的代价】没有可观测性，你不知道系统实际使用多少资源、哪里是瓶颈、问题根因是什么。过度配置往往是对这种不确定性的'安全'响应。",
            "【云成本失控】云的按需付费模式意味着资源浪费直接反映在账单上。很多组织的云成本超出预期 50%以上。",
            "【指标 vs 日志 vs 追踪】三者互补而非替代：日志适合排查具体问题；指标适合趋势分析和告警；追踪适合理解分布式系统中的请求流。",
            "【观测数据过载】收集太多观测数据也是问题：存储成本高、噪音多、难以找到有用信息。需要有策略地选择收集什么。"
        ],
        handsOnPath: [
            "审计云资源使用：使用云提供商的成本分析工具，识别利用率低于 20%的资源。",
            "建立基础可观测性：为关键服务部署日志聚合、指标收集和分布式追踪。",
            "实践容量规划：分析历史数据，预测未来 3 个月的资源需求，与当前配置对比。",
            "配置合理的自动扩展：基于实际负载模式设置扩缩阈值和冷却期，避免震荡。",
            "建立成本异常告警：当云成本超出预期时及时通知，避免账单惊喜。"
        ],
        selfCheck: [
            "什么是资源过度配置？在云环境中它的代价是什么？",
            "可观测性的三支柱分别是什么？各自适合什么场景？",
            "为什么可观测性缺失往往导致资源过度配置？",
            "OpenTelemetry 是什么？它解决什么问题？",
            "自动扩展配置不当会导致什么问题？",
            "如何平衡收集足够的观测数据与避免数据过载？"
        ],
        extensions: [
            "学习 Google SRE Workbook 中关于容量规划的章节。",
            "研究 FinOps 实践——如何优化云成本。",
            "探索 OpenTelemetry 的架构和最佳实践。",
            "了解 AWS/GCP/Azure 的成本优化工具和建议。"
        ],
        sourceUrls: [
            "https://sre.google/workbook/table-of-contents/",
            "https://opentelemetry.io/",
            "https://aws.amazon.com/builders-library/"
        ]
    }
}

export const week5Quizzes: Record<string, QuizQuestion[]> = {
    "ap-5-1": [
        {
            id: "ap-5-1-q1",
            question: "什么是分布式单体(Distributed Monolith)？",
            options: [
                "一种高效的微服务架构",
                "表面上拆分为独立服务，但实际上服务间紧密耦合、相互依赖的反模式",
                "一种单体应用部署方式",
                "分布式数据库架构"
            ],
            answer: 1,
            rationale: "分布式单体是微服务架构的反模式，指表面上拆分为独立服务，但保留了单体架构的紧耦合和依赖特性。"
        },
        {
            id: "ap-5-1-q2",
            question: "为什么说分布式单体是'最糟糕的状态'？",
            options: [
                "因为成本最高",
                "因为既有单体的笨重不灵活，又有微服务的复杂性，却几乎没有任何好处",
                "因为最难部署",
                "因为团队规模最大"
            ],
            answer: 1,
            rationale: "'A distributed monolith is the worst of all worlds'——既有单体的缺点，又有微服务的复杂性，却享受不到任何一种架构的好处。"
        },
        {
            id: "ap-5-1-q3",
            question: "紧耦合的三种形式不包括以下哪个？",
            options: [
                "行为耦合——需要依赖可用才能完成任务",
                "时间耦合——需要快速低延迟通信",
                "数据耦合——共享相同的数据结构",
                "实现耦合——改变一个服务需要同时改变多个服务"
            ],
            answer: 2,
            rationale: "三种耦合形式是：行为耦合、时间耦合、实现耦合。数据耦合不在这个分类中，但共享数据库是另一个相关的反模式。"
        },
        {
            id: "ap-5-1-q4",
            question: "共享数据库反模式的危害是什么？",
            options: [
                "数据库成本增加",
                "破坏服务自治性，任何 schema 变更需要协调多个服务",
                "查询性能下降",
                "存储空间不足"
            ],
            answer: 1,
            rationale: "共享数据库破坏了服务的自治性，任何数据库 schema 变更都需要协调多个服务，导致部署耦合和变更风险传播。"
        },
        {
            id: "ap-5-1-q5",
            question: "识别分布式单体的信号不包括以下哪个？",
            options: [
                "服务启动时间长",
                "故障从一个容器级联到下一个",
                "每个服务可以独立部署和扩展",
                "小改动需要重新部署整个应用"
            ],
            answer: 2,
            rationale: "分布式单体的信号包括：启动慢、故障级联、小改动需要全量部署。每个服务可独立部署是正确微服务的特征，不是分布式单体。"
        },
        {
            id: "ap-5-1-q6",
            question: "Database per Service 模式的核心原则是什么？",
            options: [
                "所有服务使用同一个数据库集群",
                "每个服务拥有自己的数据存储，服务间通过 API 通信",
                "每个数据库表对应一个服务",
                "使用分布式数据库"
            ],
            answer: 1,
            rationale: "Database per Service 模式要求每个服务拥有自己的数据存储，服务间通过 API 而非数据库直接通信，保证服务自治。"
        },
        {
            id: "ap-5-1-q7",
            question: "为什么分布式单体的性能通常比纯单体更差？",
            options: [
                "因为使用了更多的服务器",
                "因为增加了网络开销却没有获得独立扩展的好处",
                "因为代码更复杂",
                "因为使用了更多内存"
            ],
            answer: 1,
            rationale: "分布式单体增加了网络通信开销（服务间调用），但由于紧耦合无法获得独立扩展和部署的好处，性能反而更差。"
        },
        {
            id: "ap-5-1-q8",
            question: "避免分布式单体的策略不包括以下哪个？",
            options: [
                "使用异步通信",
                "定义清晰的 API 契约",
                "所有服务共享同一个数据库以保持一致性",
                "实施事件驱动架构"
            ],
            answer: 2,
            rationale: "避免分布式单体应该：使用异步通信、定义清晰 API 契约、分离数据存储、实施事件驱动架构。共享数据库恰恰是应该避免的。"
        },
        {
            id: "ap-5-1-q9",
            question: "从单体迁移到微服务时常见的陷阱是什么？",
            options: [
                "迁移太慢",
                "简单'切块'但保持原有依赖关系，创建分布式单体",
                "使用了错误的编程语言",
                "团队规模太小"
            ],
            answer: 1,
            rationale: "将单体'切块'但保持原有依赖关系只会创建分布式单体。需要重新设计服务边界和通信模式，而非简单拆分代码。"
        },
        {
            id: "ap-5-1-q10",
            question: "同步通信在微服务中的风险是什么？",
            options: [
                "实现更复杂",
                "一个服务的延迟或故障会传播到整个调用链（时间耦合）",
                "成本更高",
                "安全性更低"
            ],
            answer: 1,
            rationale: "服务间过度依赖同步调用会创建时间耦合。一个服务的延迟或故障会传播到整个调用链，降低系统弹性。"
        },
        {
            id: "ap-5-1-q11",
            question: "事件驱动架构如何帮助避免分布式单体？",
            options: [
                "通过加快处理速度",
                "通过异步通信和事件总线解耦服务，避免直接依赖",
                "通过减少代码量",
                "通过使用更少的服务器"
            ],
            answer: 1,
            rationale: "事件驱动架构中服务通过事件总线异步发送和接收事件，避免了服务间的直接调用依赖，实现解耦。"
        },
        {
            id: "ap-5-1-q12",
            question: "如何评估服务间的耦合程度？",
            options: [
                "计算代码行数",
                "分析部署依赖——如果某个服务故障多少其他服务受影响",
                "统计团队人数",
                "测量内存使用量"
            ],
            answer: 1,
            rationale: "评估耦合程度可以分析部署依赖：如果某个服务不可用，多少其他服务会受影响？需要同时部署的服务有多少？"
        }
    ],
    "ap-5-2": [
        {
            id: "ap-5-2-q1",
            question: "什么是喋喋不休服务(Chatty Services)反模式？",
            options: [
                "服务发送太多日志",
                "服务间进行过多细粒度调用，完成操作需要大量往返通信",
                "服务返回太多数据",
                "服务间聊天式的通知机制"
            ],
            answer: 1,
            rationale: "Chatty Services 指服务间进行过多的细粒度调用，每个操作都需要大量往返通信，导致网络延迟累积和系统脆弱性增加。"
        },
        {
            id: "ap-5-2-q2",
            question: "API 粒度过细会导致什么问题？",
            options: [
                "代码更难编写",
                "完成一个业务操作需要调用多个端点，增加网络开销和延迟",
                "安全性降低",
                "存储空间不足"
            ],
            answer: 1,
            rationale: "API 设计过于细粒度时，完成一个业务操作需要调用多个端点。在分布式环境中，每次调用都有网络开销，累积成显著延迟。"
        },
        {
            id: "ap-5-2-q3",
            question: "BFF(Backend for Frontend)模式的目的是什么？",
            options: [
                "为前端提供更好的用户界面",
                "为不同前端创建专门的后端服务，聚合多个下游调用，减少往返次数",
                "加快前端渲染速度",
                "减少前端代码量"
            ],
            answer: 1,
            rationale: "BFF 模式为不同的前端（Web、Mobile 等）创建专门的后端服务，聚合多个下游服务的调用，减少前端与后端间的往返次数。"
        },
        {
            id: "ap-5-2-q4",
            question: "gRPC 相比 REST 的主要优势是什么？",
            options: [
                "更容易学习",
                "使用二进制协议和 HTTP/2，更高效",
                "浏览器原生支持",
                "不需要定义 schema"
            ],
            answer: 1,
            rationale: "gRPC 使用二进制协议（Protocol Buffers）和 HTTP/2，比 JSON/REST 更高效，适合内部服务间的高性能通信。"
        },
        {
            id: "ap-5-2-q5",
            question: "分布式系统第一谬论是什么？它与喋喋不休服务的关系是什么？",
            options: [
                "网络是安全的——更多调用意味着更多安全风险",
                "网络是可靠的——更多调用意味着更多失败点",
                "延迟是零——更多调用意味着更多延迟",
                "带宽是无限的——更多调用意味着更多带宽消耗"
            ],
            answer: 1,
            rationale: "分布式系统第一谬论是'网络是可靠的'。喋喋不休的服务放大了网络问题的影响——更多调用意味着更多失败点。"
        },
        {
            id: "ap-5-2-q6",
            question: "批量 API 设计的好处是什么？",
            options: [
                "减少代码复杂度",
                "一次请求获取多个资源，避免循环调用单个资源的 N+1 问题",
                "提高安全性",
                "减少存储空间"
            ],
            answer: 1,
            rationale: "批量 API 允许一次请求获取多个资源，而非循环调用单个资源的端点，避免 N+1 问题，显著减少网络往返次数。"
        },
        {
            id: "ap-5-2-q7",
            question: "缓存策略在减少服务间调用方面的作用和挑战是什么？",
            options: [
                "缓存完全消除了服务间调用的需要",
                "缓存有效减少调用，但引入缓存一致性问题",
                "缓存只能用于静态内容",
                "缓存会增加服务间调用"
            ],
            answer: 1,
            rationale: "缓存是减少服务间调用的有效手段，但引入缓存一致性问题。需要明确缓存失效策略和可接受的数据过时程度。"
        },
        {
            id: "ap-5-2-q8",
            question: "延迟放大效应是什么？",
            options: [
                "网络延迟随时间增长",
                "每个服务调用都增加延迟，多个串行调用累积成显著延迟",
                "服务响应越来越慢",
                "内存使用导致延迟"
            ],
            answer: 1,
            rationale: "延迟放大：每个服务调用都增加延迟。如果完成请求需要调用 10 个服务，即使每个只有 10ms，累积就是 100ms。"
        },
        {
            id: "ap-5-2-q9",
            question: "API 粒度设计的权衡是什么？",
            options: [
                "简单 vs 复杂",
                "太细导致喋喋不休，太粗导致传输不必要数据和耦合",
                "安全 vs 性能",
                "成本 vs 功能"
            ],
            answer: 1,
            rationale: "API 粒度需要权衡：太细导致喋喋不休（过多调用）；太粗导致传输不必要的数据和功能耦合。需要根据使用场景设计。"
        },
        {
            id: "ap-5-2-q10",
            question: "什么工具可以帮助分析请求链路和服务调用？",
            options: [
                "代码编辑器",
                "分布式追踪工具如 Jaeger、Zipkin",
                "数据库管理工具",
                "版本控制系统"
            ],
            answer: 1,
            rationale: "分布式追踪工具（如 Jaeger、Zipkin）可以追踪一个用户请求触发多少服务调用，帮助识别喋喋不休的调用模式。"
        },
        {
            id: "ap-5-2-q11",
            question: "GraphQL 如何帮助解决喋喋不休服务问题？",
            options: [
                "通过加快网络速度",
                "通过让客户端指定所需字段，一次请求获取所有需要的数据",
                "通过减少服务数量",
                "通过使用更快的数据库"
            ],
            answer: 1,
            rationale: "GraphQL 允许客户端在一次请求中精确指定需要的字段和关联数据，避免了多次往返获取数据的问题。"
        },
        {
            id: "ap-5-2-q12",
            question: "服务网格(Service Mesh)如何帮助处理服务间通信问题？",
            options: [
                "通过消除服务间通信",
                "通过提供透明的重试、超时和断路器功能",
                "通过减少服务数量",
                "通过加快网络速度"
            ],
            answer: 1,
            rationale: "服务网格在应用层透明地提供重试、超时、断路器等功能，帮助处理服务间通信的可靠性问题，而无需修改应用代码。"
        }
    ],
    "ap-5-3": [
        {
            id: "ap-5-3-q1",
            question: "什么是资源过度配置(Over-provisioning)？",
            options: [
                "配置了太多的功能",
                "分配远超实际需求的计算资源，在云环境中直接转化为成本浪费",
                "配置了太多的用户",
                "配置了太多的数据库"
            ],
            answer: 1,
            rationale: "资源过度配置指分配远超实际需求的计算资源。在云环境中，按使用付费意味着这直接转化为成本浪费。"
        },
        {
            id: "ap-5-3-q2",
            question: "可观测性的三支柱分别是什么？",
            options: [
                "CPU、内存、磁盘",
                "日志、指标、追踪",
                "开发、测试、生产",
                "前端、后端、数据库"
            ],
            answer: 1,
            rationale: "现代可观测性包括三个支柱：日志(Logs)——离散事件记录；指标(Metrics)——聚合数值测量；追踪(Traces)——请求端到端路径。"
        },
        {
            id: "ap-5-3-q3",
            question: "为什么可观测性缺失往往导致资源过度配置？",
            options: [
                "因为不知道需要什么资源",
                "因为不知道实际使用多少资源，过度配置是对不确定性的'安全'响应",
                "因为管理层要求更多资源",
                "因为云提供商推荐"
            ],
            answer: 1,
            rationale: "没有可观测性，你不知道系统实际使用多少资源、哪里是瓶颈。过度配置往往是对这种不确定性的'安全'响应。"
        },
        {
            id: "ap-5-3-q4",
            question: "OpenTelemetry 是什么？",
            options: [
                "一种数据库",
                "可观测性的开放标准，提供统一 API 收集日志、指标和追踪",
                "一种编程语言",
                "一种云服务"
            ],
            answer: 1,
            rationale: "OpenTelemetry 是可观测性的开放标准，提供统一的 API 来收集日志、指标和追踪数据，避免供应商锁定。"
        },
        {
            id: "ap-5-3-q5",
            question: "自动扩展配置不当会导致什么问题？",
            options: [
                "服务完全停止",
                "资源震荡（快速扩缩不稳定）或响应过慢（高峰已过才扩容完成）",
                "数据丢失",
                "安全漏洞"
            ],
            answer: 1,
            rationale: "自动扩展配置不当会导致资源震荡（快速扩缩导致不稳定）或响应过慢（业务高峰已过才扩容完成）。"
        },
        {
            id: "ap-5-3-q6",
            question: "日志、指标、追踪各自最适合什么场景？",
            options: [
                "日志适合告警，指标适合排查，追踪适合趋势分析",
                "日志适合排查具体问题，指标适合趋势分析和告警，追踪适合理解请求流",
                "三者完全相同，可互换使用",
                "日志适合追踪请求，指标适合排查，追踪适合告警"
            ],
            answer: 1,
            rationale: "三者互补：日志适合排查具体问题；指标适合趋势分析和告警；追踪适合理解分布式系统中的请求流。"
        },
        {
            id: "ap-5-3-q7",
            question: "云成本失控的常见原因是什么？",
            options: [
                "使用了太新的技术",
                "资源利用率低、过度配置、缺乏成本监控",
                "团队规模太大",
                "使用了开源软件"
            ],
            answer: 1,
            rationale: "云成本失控的常见原因包括：资源利用率低、过度配置、缺乏成本监控和告警，很多组织的云成本超出预期 50%以上。"
        },
        {
            id: "ap-5-3-q8",
            question: "Google SRE 方法论对容量规划的核心建议是什么？",
            options: [
                "尽可能多配置资源",
                "基于数据的容量规划：理解资源需求、增长趋势和峰值特征",
                "让开发者自行决定",
                "使用最便宜的资源"
            ],
            answer: 1,
            rationale: "Google SRE 强调基于数据的容量规划：理解服务的资源需求、增长趋势和峰值特征，而非凭直觉分配资源。"
        },
        {
            id: "ap-5-3-q9",
            question: "观测数据过载的问题是什么？",
            options: [
                "系统运行更快",
                "存储成本高、噪音多、难以找到有用信息",
                "安全性提高",
                "团队效率提高"
            ],
            answer: 1,
            rationale: "收集太多观测数据也是问题：存储成本高、噪音多、难以找到有用信息。需要有策略地选择收集什么数据。"
        },
        {
            id: "ap-5-3-q10",
            question: "如何审计云资源使用情况？",
            options: [
                "手动检查每台服务器",
                "使用云提供商的成本分析工具，识别利用率低的资源",
                "询问开发团队",
                "查看代码库"
            ],
            answer: 1,
            rationale: "可以使用云提供商的成本分析工具（如 AWS Cost Explorer、GCP Cost Management）识别利用率低于 20%的资源。"
        },
        {
            id: "ap-5-3-q11",
            question: "FinOps 是什么？",
            options: [
                "一种编程语言",
                "云成本优化的实践方法论",
                "一种数据库",
                "一种安全协议"
            ],
            answer: 1,
            rationale: "FinOps（Financial Operations）是云成本优化的实践方法论，帮助组织理解和管理云支出，平衡成本、速度和质量。"
        },
        {
            id: "ap-5-3-q12",
            question: "配置合理自动扩展需要考虑什么？",
            options: [
                "只需要设置最大实例数",
                "基于实际负载模式设置扩缩阈值和冷却期，避免震荡",
                "只需要设置最小实例数",
                "随机设置参数"
            ],
            answer: 1,
            rationale: "配置合理的自动扩展需要：基于实际负载模式设置扩缩阈值，设置合适的冷却期（避免快速扩缩震荡），考虑预热时间。"
        }
    ]
}
