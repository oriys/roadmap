import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week7Guides: Record<string, LessonGuide> = {
    "ap-7-1": {
        lessonId: "ap-7-1",
        background: [
            "【SonarQube 平台】SonarQube 是领先的代码质量和安全分析平台，提供静态分析、代码异味检测、安全漏洞扫描、技术债务量化等功能。",
            "【ESLint 生态】ESLint 是 JavaScript/TypeScript 生态最流行的静态分析工具，通过可配置的规则集检测代码问题。可扩展的插件系统支持自定义规则。",
            "【Google 工程实践】Google Engineering Practices 文档分享了 Google 的代码评审标准和最佳实践，强调代码评审的目的是提高代码质量而非找茬。",
            "【代码评审清单】结构化的代码评审应覆盖：功能正确性、代码设计、复杂度、测试覆盖、命名可读性、注释必要性、风格一致性、安全考虑。",
            "【TDD 循环】测试驱动开发的红-绿-重构循环：先写失败的测试（红），再写最小代码让测试通过（绿），最后重构改进设计。TDD 帮助预防而非事后修复反模式。"
        ],
        keyDifficulties: [
            "【工具配置复杂度】静态分析工具的规则配置需要平衡：太严格导致大量误报和开发者疲劳；太宽松则漏过真正的问题。需要根据项目特点调整。",
            "【代码评审效率】代码评审可能成为瓶颈。Google 建议：小批量提交、快速响应、聚焦关键问题、信任作者的判断。",
            "【技术债务可视化】技术债务往往是隐性的。SonarQube 等工具将其量化（如'偿还需要 X 小时'），但这只是估算，实际影响可能更大或更小。",
            "【持续改进 vs 完美主义】追求完美会阻碍进度。目标是'逐步改善'而非'一步到位'。每次提交让代码比之前稍好就是成功。"
        ],
        handsOnPath: [
            "在项目中配置 SonarQube 或 ESLint，建立代码质量基线，识别现有的主要问题。",
            "建立代码评审清单：基于项目特点定制评审关注点，在评审时系统性地检查。",
            "设置 CI/CD 质量关卡：代码必须通过静态分析才能合并，但允许逐步提高标准。",
            "实践 TDD：选择一个新功能或 bug 修复，尝试先写测试再写实现。",
            "量化技术债务：使用工具生成技术债务报告，与团队讨论优先级和偿还策略。"
        ],
        selfCheck: [
            "SonarQube 提供哪些类型的代码分析功能？",
            "Google 工程实践文档对代码评审的核心建议是什么？",
            "结构化代码评审应该覆盖哪些方面？",
            "TDD 的红-绿-重构循环是什么？它如何帮助预防反模式？",
            "静态分析工具规则配置的权衡是什么？",
            "如何在追求代码质量和保持开发效率之间取得平衡？"
        ],
        extensions: [
            "阅读 Google Engineering Practices 的完整代码评审指南。",
            "研究不同编程语言的主流静态分析工具：Python (pylint, mypy)、Java (SpotBugs, PMD)、Go (golangci-lint)。",
            "学习如何编写自定义的 ESLint 规则或 SonarQube 规则。",
            "探索变异测试(Mutation Testing)如何评估测试质量。"
        ],
        sourceUrls: [
            "https://www.sonarsource.com/products/sonarqube/",
            "https://eslint.org/",
            "https://google.github.io/eng-practices/"
        ]
    },
    "ap-7-2": {
        lessonId: "ap-7-2",
        background: [
            "【重构目录】Martin Fowler 的 Refactoring Catalog 收录了系统化的重构技术，每个重构都有动机、机制和示例说明。常见重构包括：Extract Method、Move Method、Extract Class、Inline Method 等。",
            "【Strangler Fig 模式】绞杀者无花果模式是一种渐进式系统替换策略：新功能用新系统实现，逐步将流量从旧系统迁移到新系统，最终旧系统被完全替换。",
            "【技术债务象限】Martin Fowler 的技术债务象限按两个维度分类：有意/无意、谨慎/鲁莽。(1) 谨慎+有意：'我们必须现在发布，之后处理后果'；(2) 鲁莽+有意：'我们没时间做设计'；(3) 谨慎+无意：'现在我们知道应该怎么做了'；(4) 鲁莽+无意：'什么是分层？'",
            "【渐进式重构】避免大爆炸式重构（一次性重写整个系统），采用小步骤、持续的改进。每次变更都应该是可验证的、可回滚的。",
            "【重构与功能的平衡】重构不应该在单独的'重构冲刺'中进行，而应该融入日常开发。在添加功能或修复 bug 时顺便改进相关代码。"
        ],
        keyDifficulties: [
            "【大爆炸重构的风险】一次性重写整个系统的风险：时间估算不准、范围蔓延、旧系统和新系统同时维护的负担、用户迁移的挑战。",
            "【识别重构时机】何时重构？添加功能前（让添加更容易）、修复 bug 时（理解代码过程中）、代码评审时（发现可改进之处）。",
            "【衡量重构价值】重构的价值难以直接衡量（减少了未来的问题），但可以通过指标间接评估：代码复杂度、变更频率、bug 密度等。",
            "【团队协调】重构可能影响多人的工作。需要沟通协调，避免重构中的冲突和重复工作。"
        ],
        handsOnPath: [
            "识别重构机会：使用代码复杂度工具找出最复杂的模块，评估重构优先级。",
            "实践 Strangler Fig：选择一个遗留功能，用新实现替换，通过特性开关或路由控制流量迁移。",
            "应用技术债务象限：对现有技术债务分类，识别哪些是'谨慎有意'（可接受）vs '鲁莽'（需要立即处理）。",
            "建立重构节奏：每个迭代分配一定比例时间（如 10-20%）用于技术改进。",
            "记录重构决策：使用 ADR（架构决策记录）记录为什么重构、选择什么方案、预期效果。"
        ],
        selfCheck: [
            "Strangler Fig 模式的核心思想是什么？它如何避免大爆炸式重构的风险？",
            "Martin Fowler 的技术债务象限如何分类？四个象限分别是什么？",
            "渐进式重构与大爆炸式重构相比有什么优势？",
            "识别重构时机的原则是什么？何时应该重构？",
            "如何衡量重构的价值？有哪些可用的指标？",
            "重构应该在单独的'重构冲刺'中进行吗？为什么？"
        ],
        extensions: [
            "阅读 Martin Fowler 的《Refactoring》完整书籍。",
            "研究 Michael Feathers 的《Working Effectively with Legacy Code》了解遗留代码的改进策略。",
            "学习 Branch by Abstraction 模式——另一种渐进式重构策略。",
            "探索如何使用 IDE 的自动重构功能安全地进行重构。"
        ],
        sourceUrls: [
            "https://refactoring.com/catalog/",
            "https://martinfowler.com/bliki/StranglerFigApplication.html",
            "https://martinfowler.com/bliki/TechnicalDebtQuadrant.html"
        ]
    }
}

export const week7Quizzes: Record<string, QuizQuestion[]> = {
    "ap-7-1": [
        {
            id: "ap-7-1-q1",
            question: "SonarQube 提供哪些类型的分析功能？",
            options: [
                "只有代码格式检查",
                "静态分析、代码异味检测、安全漏洞扫描、技术债务量化",
                "只有性能分析",
                "只有运行时监控"
            ],
            answer: 1,
            rationale: "SonarQube 提供静态分析、代码异味检测、安全漏洞扫描、技术债务量化等全面的代码质量和安全分析功能。"
        },
        {
            id: "ap-7-1-q2",
            question: "Google 工程实践对代码评审的核心建议是什么？",
            options: [
                "找出所有可能的问题",
                "代码评审的目的是提高代码质量而非找茬",
                "评审时间越长越好",
                "只有专家才能做代码评审"
            ],
            answer: 1,
            rationale: "Google Engineering Practices 强调代码评审的目的是提高代码质量而非找茬，应该聚焦关键问题、信任作者的判断。"
        },
        {
            id: "ap-7-1-q3",
            question: "TDD 的红-绿-重构循环是什么？",
            options: [
                "红色代码、绿色代码、蓝色代码",
                "先写失败的测试(红)，再写代码让测试通过(绿)，最后重构改进设计",
                "先写代码、再写测试、最后部署",
                "先设计、再实现、最后测试"
            ],
            answer: 1,
            rationale: "TDD 的红-绿-重构循环：先写失败的测试（红），再写最小代码让测试通过（绿），最后重构改进设计（保持测试通过）。"
        },
        {
            id: "ap-7-1-q4",
            question: "结构化代码评审应该覆盖哪些方面？",
            options: [
                "只检查代码格式",
                "功能正确性、代码设计、复杂度、测试覆盖、命名、注释、风格、安全",
                "只检查性能",
                "只检查注释数量"
            ],
            answer: 1,
            rationale: "结构化代码评审应覆盖：功能正确性、代码设计、复杂度、测试覆盖、命名可读性、注释必要性、风格一致性、安全考虑。"
        },
        {
            id: "ap-7-1-q5",
            question: "静态分析工具规则配置的权衡是什么？",
            options: [
                "规则越多越好",
                "太严格导致大量误报和疲劳，太宽松则漏过真正问题，需要根据项目调整",
                "使用默认配置最好",
                "关闭所有规则"
            ],
            answer: 1,
            rationale: "规则配置需要平衡：太严格导致大量误报和开发者疲劳；太宽松则漏过真正的问题。需要根据项目特点调整。"
        },
        {
            id: "ap-7-1-q6",
            question: "Google 对代码评审效率的建议是什么？",
            options: [
                "每个评审至少花一天时间",
                "小批量提交、快速响应、聚焦关键问题、信任作者判断",
                "所有代码都需要多人评审",
                "评审越详细越好"
            ],
            answer: 1,
            rationale: "Google 建议：小批量提交、快速响应（通常一个工作日内）、聚焦关键问题、信任作者的判断，避免代码评审成为瓶颈。"
        },
        {
            id: "ap-7-1-q7",
            question: "SonarQube 如何量化技术债务？",
            options: [
                "不量化技术债务",
                "估算偿还所需时间（如'偿还需要 X 小时'）",
                "计算代码行数",
                "统计 bug 数量"
            ],
            answer: 1,
            rationale: "SonarQube 将技术债务量化为估算的偿还时间（如'偿还需要 X 小时'），帮助团队理解债务的规模和优先级。"
        },
        {
            id: "ap-7-1-q8",
            question: "ESLint 的特点是什么？",
            options: [
                "只支持 Python",
                "通过可配置规则检测代码问题，可扩展的插件系统支持自定义规则",
                "只能检查语法错误",
                "不支持自定义规则"
            ],
            answer: 1,
            rationale: "ESLint 是 JavaScript/TypeScript 生态最流行的静态分析工具，通过可配置的规则集检测问题，可扩展的插件系统支持自定义规则。"
        },
        {
            id: "ap-7-1-q9",
            question: "TDD 如何帮助预防反模式？",
            options: [
                "TDD 不能预防反模式",
                "先写测试强制思考接口设计，小步骤迭代避免过度复杂，持续重构保持代码质量",
                "TDD 只能发现 bug",
                "TDD 会增加反模式"
            ],
            answer: 1,
            rationale: "TDD 通过先写测试强制思考接口设计、小步骤迭代避免过度复杂、持续重构保持代码质量，帮助预防而非事后修复反模式。"
        },
        {
            id: "ap-7-1-q10",
            question: "代码质量与开发效率的平衡原则是什么？",
            options: [
                "质量优先，效率不重要",
                "目标是'逐步改善'而非'一步到位'，每次提交让代码比之前稍好",
                "效率优先，质量不重要",
                "必须同时达到完美质量和最高效率"
            ],
            answer: 1,
            rationale: "追求完美会阻碍进度。目标是'逐步改善'而非'一步到位'。每次提交让代码比之前稍好就是成功。"
        },
        {
            id: "ap-7-1-q11",
            question: "CI/CD 质量关卡的最佳实践是什么？",
            options: [
                "一开始就设置最严格的标准",
                "代码必须通过静态分析才能合并，但允许逐步提高标准",
                "不设置任何质量关卡",
                "只在发布时检查质量"
            ],
            answer: 1,
            rationale: "CI/CD 质量关卡最佳实践：代码必须通过静态分析才能合并，但允许逐步提高标准，而非一开始就设置无法达到的高标准。"
        },
        {
            id: "ap-7-1-q12",
            question: "团队如何有效使用技术债务报告？",
            options: [
                "忽略技术债务报告",
                "与团队讨论优先级和偿还策略，将其纳入规划",
                "立即偿还所有债务",
                "只关注新增债务"
            ],
            answer: 1,
            rationale: "使用工具生成技术债务报告后，应与团队讨论优先级和偿还策略，将技术债务偿还纳入迭代规划。"
        }
    ],
    "ap-7-2": [
        {
            id: "ap-7-2-q1",
            question: "Strangler Fig(绞杀者无花果)模式的核心思想是什么？",
            options: [
                "一次性重写整个系统",
                "新功能用新系统实现，逐步将流量从旧系统迁移，最终完全替换旧系统",
                "永远保留旧系统",
                "同时维护两个系统"
            ],
            answer: 1,
            rationale: "Strangler Fig 模式是渐进式系统替换策略：新功能用新系统实现，逐步将流量从旧系统迁移到新系统，最终旧系统被完全替换。"
        },
        {
            id: "ap-7-2-q2",
            question: "Martin Fowler 技术债务象限中'谨慎+有意'象限的描述是什么？",
            options: [
                "'什么是分层？'",
                "'我们没时间做设计'",
                "'我们必须现在发布，之后处理后果'",
                "'现在我们知道应该怎么做了'"
            ],
            answer: 2,
            rationale: "谨慎+有意象限的典型表述是'我们必须现在发布，之后处理后果'——明知有债务但有意识地接受，计划之后偿还。"
        },
        {
            id: "ap-7-2-q3",
            question: "大爆炸式重构的风险有哪些？",
            options: [
                "太快完成",
                "时间估算不准、范围蔓延、新旧系统同时维护的负担、用户迁移挑战",
                "太简单",
                "没有风险"
            ],
            answer: 1,
            rationale: "大爆炸式重构的风险：时间估算不准、范围蔓延、旧系统和新系统同时维护的负担、用户迁移的挑战。"
        },
        {
            id: "ap-7-2-q4",
            question: "渐进式重构与大爆炸式重构相比有什么优势？",
            options: [
                "更快完成",
                "每次变更可验证可回滚，风险更小，可以持续交付价值",
                "更简单",
                "不需要测试"
            ],
            answer: 1,
            rationale: "渐进式重构的优势：每次变更都是可验证的、可回滚的，风险更小，可以在重构过程中持续交付价值。"
        },
        {
            id: "ap-7-2-q5",
            question: "识别重构时机的原则是什么？",
            options: [
                "只在专门的重构时间",
                "添加功能前、修复 bug 时、代码评审时",
                "只在项目结束后",
                "从不重构"
            ],
            answer: 1,
            rationale: "重构时机：添加功能前（让添加更容易）、修复 bug 时（理解代码过程中）、代码评审时（发现可改进之处）。"
        },
        {
            id: "ap-7-2-q6",
            question: "重构应该在单独的'重构冲刺'中进行吗？",
            options: [
                "是的，应该有专门的重构冲刺",
                "不，重构应该融入日常开发，在添加功能或修复 bug 时顺便改进",
                "重构不重要",
                "只在年底重构"
            ],
            answer: 1,
            rationale: "重构不应在单独的'重构冲刺'中进行，而应该融入日常开发。在添加功能或修复 bug 时顺便改进相关代码。"
        },
        {
            id: "ap-7-2-q7",
            question: "技术债务象限中'鲁莽+无意'象限的描述是什么？",
            options: [
                "'我们必须现在发布'",
                "'我们没时间做设计'",
                "'什么是分层？'——不知道最佳实践而产生的债务",
                "'现在我们知道应该怎么做了'"
            ],
            answer: 2,
            rationale: "'鲁莽+无意'象限的典型表述是'什么是分层？'——由于不知道最佳实践而产生的债务，甚至不知道自己在欠债。"
        },
        {
            id: "ap-7-2-q8",
            question: "如何衡量重构的价值？",
            options: [
                "无法衡量",
                "通过指标间接评估：代码复杂度、变更频率、bug 密度等",
                "计算代码行数减少",
                "统计重构花费的时间"
            ],
            answer: 1,
            rationale: "重构的价值难以直接衡量，但可以通过指标间接评估：代码复杂度降低、变更频率、bug 密度下降等。"
        },
        {
            id: "ap-7-2-q9",
            question: "Refactoring Catalog 中的 Extract Method 重构是什么？",
            options: [
                "删除一个方法",
                "将代码片段提取为独立的方法",
                "合并多个方法",
                "重命名方法"
            ],
            answer: 1,
            rationale: "Extract Method 是将代码片段提取为独立的方法，是最常用的重构技术之一，用于改善代码的可读性和可重用性。"
        },
        {
            id: "ap-7-2-q10",
            question: "建立重构节奏的建议做法是什么？",
            options: [
                "不分配专门时间给重构",
                "每个迭代分配一定比例时间（如 10-20%）用于技术改进",
                "只在空闲时重构",
                "一年重构一次"
            ],
            answer: 1,
            rationale: "建立重构节奏的建议：每个迭代分配一定比例时间（如 10-20%）用于技术改进，确保持续偿还技术债务。"
        },
        {
            id: "ap-7-2-q11",
            question: "技术债务象限中'谨慎+无意'象限的描述是什么？",
            options: [
                "'我们必须现在发布'",
                "'我们没时间做设计'",
                "'什么是分层？'",
                "'现在我们知道应该怎么做了'——事后才发现更好的方法"
            ],
            answer: 3,
            rationale: "'谨慎+无意'象限的典型表述是'现在我们知道应该怎么做了'——事后才发现更好的方法，是学习过程中不可避免的债务。"
        },
        {
            id: "ap-7-2-q12",
            question: "ADR（架构决策记录）在重构中的作用是什么？",
            options: [
                "只是文档，没有实际用途",
                "记录为什么重构、选择什么方案、预期效果，便于追溯和沟通",
                "用于审批重构",
                "替代代码评审"
            ],
            answer: 1,
            rationale: "ADR（架构决策记录）记录为什么重构、选择什么方案、预期效果，便于追溯决策原因、与团队沟通、未来参考。"
        }
    ]
}
