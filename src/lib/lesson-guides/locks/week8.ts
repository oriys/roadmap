import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week8Guides: Record<string, LessonGuide> = {
    "w8-1": {
        lessonId: "w8-1",
        background: [
            "【锁粒度概念】数据库锁的粒度从粗到细：表锁 → 页锁 → 行锁。粒度越细并发越高，但锁管理开销越大。",
            "【行锁（Record Lock）】MySQL InnoDB：'A record lock is a lock on an index record'——锁定索引记录，允许其他事务操作同表的其他行。",
            "【表锁（Table Lock）】锁定整个表，并发度最低但开销最小。MyISAM 只支持表锁；InnoDB 在特定场景会升级为表锁。",
            "【页锁（Page Lock）】锁定数据页（通常 16KB），粒度介于行锁和表锁之间。BDB 存储引擎使用页锁。",
            "【锁升级（Lock Escalation）】当事务持有过多行锁时，可能升级为表锁以减少内存开销。SQL Server 有此机制，InnoDB 没有。",
        ],
        keyDifficulties: [
            "【行锁依赖索引】InnoDB 行锁是加在索引上的。如果查询没有使用索引，会锁定全表（表锁效果）。",
            "【锁定范围】UPDATE/DELETE 通过索引定位时锁定相关索引记录；通过全表扫描时锁定所有扫描到的行。",
            "【选择困难】行锁并发高但管理开销大；表锁开销小但并发低。需要根据业务特点选择。",
            "【隐式锁与显式锁】InnoDB 在修改数据时自动加行锁（隐式），也可以用 LOCK TABLES 显式加表锁。",
        ],
        handsOnPath: [
            "在 MySQL 中执行 UPDATE，用 SHOW ENGINE INNODB STATUS 查看锁信息。",
            "对比有索引和无索引的 UPDATE 语句的锁范围。",
            "使用 LOCK TABLES ... READ/WRITE 显式加表锁。",
            "模拟大量行锁导致的内存压力（查看 lock_data_size）。",
            "在 PostgreSQL 中使用 pg_locks 视图查看锁信息。",
        ],
        selfCheck: [
            "行锁、页锁、表锁的粒度从细到粗如何排列？",
            "为什么说 InnoDB 的行锁是加在索引上的？",
            "如果 UPDATE 语句没有使用索引，会发生什么？",
            "什么是锁升级？MySQL InnoDB 有锁升级机制吗？",
            "MyISAM 和 InnoDB 的锁机制有什么不同？",
        ],
        extensions: [
            "研究 InnoDB 行锁的内部数据结构（lock_t）。",
            "学习 PostgreSQL 的行锁实现（tuple lock）。",
            "了解 SQL Server 的锁升级策略和阈值配置。",
            "研究在线 DDL 如何避免长时间持有表锁。",
        ],
        sourceUrls: [
            "https://www.postgresql.org/docs/current/explicit-locking.html",
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html",
            "https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide",
        ],
    },
    "w8-2": {
        lessonId: "w8-2",
        background: [
            "【意向锁定义】意向锁是表级锁，表明事务打算在表的某些行上加共享锁（IS）或排他锁（IX）。",
            "【意向锁目的】避免在加表锁时逐行检查是否有行锁冲突。只需检查意向锁即可判断兼容性。",
            "【IS 锁】意向共享锁：事务打算对某些行加 S 锁。SELECT ... FOR SHARE 会先获取 IS 锁。",
            "【IX 锁】意向排他锁：事务打算对某些行加 X 锁。SELECT ... FOR UPDATE、UPDATE、DELETE 会先获取 IX 锁。",
            "【锁兼容矩阵】定义了不同锁之间是否兼容（可同时持有）。意向锁之间通常兼容，但与表级 X/S 锁可能冲突。",
        ],
        keyDifficulties: [
            "【自动管理】意向锁由 InnoDB 自动管理，应用代码无需显式操作。但理解它有助于诊断锁问题。",
            "【层级加锁协议】在加行锁前必须先获得表的意向锁。这是多粒度锁协议的要求。",
            "【IX 与 X 的区别】IX 是「打算在行上加 X 锁」，X 是「对整个表加排他锁」。IX 之间兼容，但 IX 与 X 不兼容。",
            "【诊断用途】通过 performance_schema.data_locks 可以看到意向锁，帮助诊断锁等待问题。",
        ],
        handsOnPath: [
            "执行 SELECT FOR UPDATE，查看 performance_schema.data_locks 中的意向锁。",
            "尝试在一个会话持有行锁时，另一个会话对表加 LOCK TABLES ... WRITE。",
            "画出 InnoDB 的锁兼容矩阵：S/X/IS/IX 之间的兼容关系。",
            "使用 SHOW ENGINE INNODB STATUS 查看 LOCK WAIT 信息。",
            "对比 PostgreSQL 的锁模式（AccessShareLock、RowExclusiveLock 等）。",
        ],
        selfCheck: [
            "什么是意向锁？它解决什么问题？",
            "IS 锁和 IX 锁分别在什么时候获取？",
            "为什么意向锁之间是兼容的？",
            "意向锁与表级 X 锁是否兼容？为什么？",
            "如何查看数据库中当前的意向锁？",
        ],
        extensions: [
            "研究多粒度锁协议（MGL）的理论基础。",
            "学习 PostgreSQL 的 8 种锁模式及其兼容关系。",
            "了解意向锁在分布式数据库中的应用。",
            "研究 Oracle 的 TM/TX 锁模型。",
        ],
        sourceUrls: [
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-intention-locks",
            "https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-TABLES",
            "https://www.postgresql.org/docs/current/explicit-locking.html#EXPLICIT-LOCKING",
        ],
    },
    "w8-3": {
        lessonId: "w8-3",
        background: [
            "【间隙锁定义】Gap Lock：锁定索引记录之间的间隙，防止其他事务在间隙中插入新行。",
            "【间隙锁目的】防止幻读：锁定范围查询覆盖的间隙，其他事务不能插入新行进入该范围。",
            "【Next-Key Lock】Record Lock + Gap Lock 的组合，锁定索引记录及其前面的间隙。InnoDB 默认使用。",
            "【插入意向锁】Insert Intention Lock：特殊的间隙锁，表示打算在某间隙插入。多个插入意向锁在不同位置不冲突。",
            "【只在 RR 级别】间隙锁主要在 Repeatable Read 隔离级别下使用。Read Committed 下通常禁用。",
        ],
        keyDifficulties: [
            "【间隙范围确定】间隙由索引记录决定。如记录 id=10,20,30，间隙包括 (-∞,10)、(10,20)、(20,30)、(30,+∞)。",
            "【唯一索引优化】唯一索引的等值查询只加记录锁，不加间隙锁（因为不可能有重复值插入）。",
            "【死锁风险】间隙锁之间不冲突（都是防止插入），但与插入意向锁冲突，可能导致死锁。",
            "【性能影响】间隙锁扩大了锁定范围，可能导致不必要的锁等待。需要权衡隔离性和并发性。",
        ],
        handsOnPath: [
            "在 RR 隔离级别下执行范围查询 SELECT ... FOR UPDATE WHERE id > 10，观察间隙锁。",
            "尝试在被锁定的间隙中 INSERT 新行，观察阻塞。",
            "对比唯一索引和非唯一索引的锁行为差异。",
            "切换到 Read Committed 级别，观察间隙锁是否消失。",
            "构造间隙锁导致的死锁场景并分析。",
        ],
        selfCheck: [
            "什么是间隙锁？它锁定的是什么？",
            "Next-Key Lock 是什么？为什么是 InnoDB 的默认行为？",
            "间隙锁如何防止幻读？",
            "唯一索引的等值查询为什么不需要间隙锁？",
            "间隙锁可能导致什么并发问题？",
        ],
        extensions: [
            "研究 InnoDB 间隙锁的内部实现（lock_rec_lock_gap）。",
            "学习 PostgreSQL 如何通过 SSI 而非间隙锁防止幻读。",
            "了解间隙锁在高并发 INSERT 场景的性能影响。",
            "研究自增列对间隙锁的影响（AUTO-INC 锁）。",
        ],
        sourceUrls: [
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-gap-locks",
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-next-key-locks",
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html",
        ],
    },
    "w8-4": {
        lessonId: "w8-4",
        background: [
            "【自动死锁检测】InnoDB 自动检测死锁：'InnoDB automatically detects transaction deadlocks and rolls back one of the transactions'。",
            "【等待图算法】InnoDB 使用等待图（wait-for graph）检测死锁：图中存在环则有死锁。",
            "【牺牲者选择】检测到死锁后，InnoDB 选择回滚「代价最小」的事务（如修改行数最少）作为牺牲者。",
            "【死锁日志】SHOW ENGINE INNODB STATUS 的 LATEST DETECTED DEADLOCK 部分显示最近的死锁信息。",
            "【超时机制】innodb_lock_wait_timeout 设置锁等待超时（默认 50 秒），超时后回滚当前语句（非整个事务）。",
        ],
        keyDifficulties: [
            "【死锁不可完全避免】只能通过好的设计减少死锁概率：固定锁顺序、小事务、合理索引。",
            "【诊断困难】死锁可能偶发，日志只保留最后一次。建议开启 innodb_print_all_deadlocks 记录所有死锁。",
            "【索引影响】缺少合适索引会导致锁定范围扩大，增加死锁概率。",
            "【重试策略】应用层应该准备好处理死锁异常（错误码 1213）并重试事务。",
        ],
        handsOnPath: [
            "构造两个事务互相等待的死锁场景，观察自动检测和回滚。",
            "用 SHOW ENGINE INNODB STATUS 分析死锁日志。",
            "开启 innodb_print_all_deadlocks 将死锁记录到错误日志。",
            "设置不同的 innodb_lock_wait_timeout 值，测试超时行为。",
            "通过添加索引优化锁定范围，减少死锁风险。",
        ],
        selfCheck: [
            "InnoDB 如何检测死锁？",
            "检测到死锁后，InnoDB 如何选择要回滚的事务？",
            "如何查看最近的死锁信息？",
            "应用层如何处理死锁异常？",
            "哪些设计实践可以减少死锁风险？",
        ],
        extensions: [
            "研究 InnoDB 死锁检测的源码实现。",
            "学习 PostgreSQL 的死锁检测机制。",
            "了解分布式数据库的死锁检测挑战。",
            "研究死锁预测和预防的学术研究。",
        ],
        sourceUrls: [
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-detection.html",
            "https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-DEADLOCKS",
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-example.html",
        ],
    },
}

export const week8Quizzes: Record<string, QuizQuestion[]> = {
    "w8-1": [
        {
            id: "w8-1-q1",
            question: "数据库锁粒度从细到粗的顺序是什么？",
            options: [
                "表锁 → 页锁 → 行锁",
                "行锁 → 页锁 → 表锁",
                "页锁 → 行锁 → 表锁",
                "行锁 → 表锁 → 页锁",
            ],
            answer: 1,
            rationale: "锁粒度从细到粗：行锁（最细，并发最高）→ 页锁 → 表锁（最粗，并发最低）。",
        },
        {
            id: "w8-1-q2",
            question: "InnoDB 的行锁是加在什么上的？",
            options: [
                "数据页",
                "索引记录",
                "表头",
                "数据文件",
            ],
            answer: 1,
            rationale: "InnoDB 的行锁是加在索引记录上的：'A record lock is a lock on an index record'。",
        },
        {
            id: "w8-1-q3",
            question: "如果 UPDATE 语句没有使用索引，InnoDB 会怎样加锁？",
            options: [
                "不加锁",
                "只锁一行",
                "锁定全表扫描到的所有行（相当于表锁效果）",
                "自动创建索引",
            ],
            answer: 2,
            rationale: "没有索引时，InnoDB 需要全表扫描来找到目标行，会锁定扫描过程中的所有行，实际上相当于表锁。",
        },
        {
            id: "w8-1-q4",
            question: "MyISAM 存储引擎支持什么级别的锁？",
            options: [
                "只支持行锁",
                "只支持表锁",
                "支持行锁和表锁",
                "不支持任何锁",
            ],
            answer: 1,
            rationale: "MyISAM 只支持表锁，不支持行锁。这是它不适合高并发写入场景的原因之一。",
        },
        {
            id: "w8-1-q5",
            question: "什么是锁升级（Lock Escalation）？",
            options: [
                "提高锁的优先级",
                "当持有过多行锁时，升级为更粗粒度的表锁以减少内存开销",
                "锁的版本升级",
                "增加锁的数量",
            ],
            answer: 1,
            rationale: "锁升级是指当事务持有大量行锁时，数据库将其升级为表锁以减少锁管理的内存和 CPU 开销。",
        },
        {
            id: "w8-1-q6",
            question: "MySQL InnoDB 有锁升级机制吗？",
            options: [
                "有，超过 1000 个行锁时升级",
                "没有，InnoDB 不支持锁升级",
                "有，但可以配置",
                "只在 8.0 版本有",
            ],
            answer: 1,
            rationale: "InnoDB 没有锁升级机制。即使持有大量行锁，也不会自动升级为表锁。SQL Server 有锁升级。",
        },
        {
            id: "w8-1-q7",
            question: "行锁相比表锁的优势是什么？",
            options: [
                "实现更简单",
                "内存占用更少",
                "并发度更高，只锁定需要的行",
                "不会死锁",
            ],
            answer: 2,
            rationale: "行锁只锁定需要操作的行，其他行可以被其他事务访问，并发度远高于锁定整个表的表锁。",
        },
        {
            id: "w8-1-q8",
            question: "如何在 MySQL 中查看当前的锁信息？",
            options: [
                "SHOW LOCKS",
                "SHOW ENGINE INNODB STATUS 或查询 performance_schema.data_locks",
                "SELECT * FROM locks",
                "DESCRIBE LOCKS",
            ],
            answer: 1,
            rationale: "SHOW ENGINE INNODB STATUS 显示锁等待信息；MySQL 8.0 的 performance_schema.data_locks 提供详细的锁信息。",
        },
        {
            id: "w8-1-q9",
            question: "表锁相比行锁的优势是什么？",
            options: [
                "并发度高",
                "锁管理开销小，适合全表操作",
                "支持事务",
                "可以部分回滚",
            ],
            answer: 1,
            rationale: "表锁只需要一个锁对象，管理开销小。当需要操作大量行或全表时，表锁可能比大量行锁更高效。",
        },
        {
            id: "w8-1-q10",
            question: "如何显式给 MySQL 表加读锁？",
            options: [
                "LOCK TABLE t FOR READ",
                "LOCK TABLES t READ",
                "TABLE t LOCK READ",
                "READ LOCK t",
            ],
            answer: 1,
            rationale: "MySQL 使用 LOCK TABLES t READ 显式加读锁，LOCK TABLES t WRITE 加写锁。",
        },
        {
            id: "w8-1-q11",
            question: "为什么说好的索引设计对锁性能很重要？",
            options: [
                "索引越多越好",
                "合适的索引让查询只锁定必要的行，减少锁范围",
                "索引可以防止死锁",
                "索引可以加速锁释放",
            ],
            answer: 1,
            rationale: "有合适索引时，UPDATE/DELETE 只锁定索引定位到的行；没有索引则可能锁定全表，严重影响并发。",
        },
        {
            id: "w8-1-q12",
            question: "PostgreSQL 中查看锁信息的系统视图是什么？",
            options: [
                "pg_stat_locks",
                "pg_locks",
                "pg_lock_info",
                "pg_lock_status",
            ],
            answer: 1,
            rationale: "PostgreSQL 的 pg_locks 视图显示当前持有的锁和等待的锁，可以用于诊断锁问题。",
        },
    ],
    "w8-2": [
        {
            id: "w8-2-q1",
            question: "意向锁（Intention Lock）的作用是什么？",
            options: [
                "替代行锁",
                "表明事务打算在表的某些行上加锁，避免加表锁时逐行检查",
                "锁定意图",
                "提高锁优先级",
            ],
            answer: 1,
            rationale: "意向锁是表级锁，表明事务的意图。加表锁时只需检查意向锁是否兼容，无需逐行检查是否有行锁。",
        },
        {
            id: "w8-2-q2",
            question: "IS 锁（意向共享锁）表示什么？",
            options: [
                "已对表加共享锁",
                "事务打算对表的某些行加共享锁",
                "索引共享",
                "插入共享",
            ],
            answer: 1,
            rationale: "IS（Intention Shared）锁表示事务打算在表的某些行上加 S 锁（共享锁）。",
        },
        {
            id: "w8-2-q3",
            question: "IX 锁（意向排他锁）在什么操作时获取？",
            options: [
                "普通 SELECT",
                "SELECT FOR UPDATE、UPDATE、DELETE",
                "INSERT 只",
                "DDL 操作",
            ],
            answer: 1,
            rationale: "SELECT FOR UPDATE、UPDATE、DELETE 都需要对行加 X 锁，因此会先获取表的 IX 锁。",
        },
        {
            id: "w8-2-q4",
            question: "两个 IX 锁之间是否兼容（可同时持有）？",
            options: [
                "不兼容",
                "兼容，因为它们可能锁定不同的行",
                "取决于事务",
                "只在 InnoDB 中兼容",
            ],
            answer: 1,
            rationale: "IX 锁之间兼容，因为两个事务可能打算锁定表的不同行。实际冲突由行级锁决定。",
        },
        {
            id: "w8-2-q5",
            question: "IX 锁与表级 X 锁（LOCK TABLES WRITE）是否兼容？",
            options: [
                "兼容",
                "不兼容，表级 X 锁需要排他访问整个表",
                "取决于锁顺序",
                "只在特定版本兼容",
            ],
            answer: 1,
            rationale: "表级 X 锁需要独占整个表，与 IX 锁不兼容。必须等待所有行级锁释放。",
        },
        {
            id: "w8-2-q6",
            question: "意向锁是由谁管理的？",
            options: [
                "应用程序",
                "InnoDB 自动管理",
                "DBA 手动设置",
                "操作系统",
            ],
            answer: 1,
            rationale: "意向锁由 InnoDB 自动管理，应用程序不需要（也不能）显式操作意向锁。",
        },
        {
            id: "w8-2-q7",
            question: "在哪里可以查看 MySQL 的意向锁信息？",
            options: [
                "SHOW VARIABLES",
                "performance_schema.data_locks",
                "information_schema.TABLES",
                "mysql.locks",
            ],
            answer: 1,
            rationale: "MySQL 8.0 的 performance_schema.data_locks 表显示所有锁信息，包括意向锁（LOCK_MODE 为 IX 或 IS）。",
        },
        {
            id: "w8-2-q8",
            question: "PostgreSQL 对应 IX 锁的锁模式是什么？",
            options: [
                "ExclusiveLock",
                "RowExclusiveLock",
                "AccessShareLock",
                "ShareLock",
            ],
            answer: 1,
            rationale: "PostgreSQL 的 RowExclusiveLock 类似于 IX 锁，由 UPDATE、DELETE、INSERT 获取。",
        },
        {
            id: "w8-2-q9",
            question: "IS 锁与表级 S 锁是否兼容？",
            options: [
                "不兼容",
                "兼容，都是共享类型的锁",
                "只有 MySQL 兼容",
                "取决于隔离级别",
            ],
            answer: 1,
            rationale: "IS 锁与表级 S 锁兼容，因为都表示读操作的意图，不冲突。",
        },
        {
            id: "w8-2-q10",
            question: "为什么多粒度锁协议需要意向锁？",
            options: [
                "提高性能",
                "在加粗粒度锁时能快速判断是否与细粒度锁冲突",
                "减少死锁",
                "兼容旧版本",
            ],
            answer: 1,
            rationale: "没有意向锁，加表锁前需要逐行检查是否有行锁。意向锁让这个检查变成 O(1) 操作。",
        },
        {
            id: "w8-2-q11",
            question: "InnoDB 的锁兼容矩阵中，S 锁与 IX 锁是否兼容？",
            options: [
                "兼容",
                "不兼容",
                "只在 RR 级别兼容",
                "取决于事务",
            ],
            answer: 1,
            rationale: "S 锁（表级共享锁）与 IX 锁不兼容。因为 IX 表示要修改某些行，与整表共享锁冲突。",
        },
        {
            id: "w8-2-q12",
            question: "意向锁本身会阻止什么操作？",
            options: [
                "行级操作",
                "不阻止行级操作，只影响表级锁的获取",
                "所有操作",
                "SELECT 操作",
            ],
            answer: 1,
            rationale: "意向锁不直接阻止行级操作，它只影响其他事务获取表级锁。实际的行级冲突由行锁决定。",
        },
    ],
    "w8-3": [
        {
            id: "w8-3-q1",
            question: "间隙锁（Gap Lock）锁定的是什么？",
            options: [
                "单个索引记录",
                "索引记录之间的间隙（不包括记录本身）",
                "整个表",
                "数据页",
            ],
            answer: 1,
            rationale: "间隙锁锁定索引记录之间的间隙，防止其他事务在该间隙中插入新行，但不锁定记录本身。",
        },
        {
            id: "w8-3-q2",
            question: "间隙锁的主要目的是什么？",
            options: [
                "提高性能",
                "防止幻读",
                "防止脏读",
                "防止死锁",
            ],
            answer: 1,
            rationale: "间隙锁防止其他事务在范围查询的间隙中插入新行，从而防止幻读。",
        },
        {
            id: "w8-3-q3",
            question: "Next-Key Lock 是什么？",
            options: [
                "下一个记录的锁",
                "记录锁 + 记录前面间隙的锁的组合",
                "键值锁",
                "表锁",
            ],
            answer: 1,
            rationale: "Next-Key Lock = Record Lock + Gap Lock，锁定索引记录及其前面的间隙。是 InnoDB 在 RR 级别的默认行为。",
        },
        {
            id: "w8-3-q4",
            question: "在什么隔离级别下，InnoDB 使用间隙锁？",
            options: [
                "所有级别",
                "主要在 Repeatable Read 级别",
                "只在 Serializable 级别",
                "只在 Read Committed 级别",
            ],
            answer: 1,
            rationale: "间隙锁主要在 Repeatable Read 级别下使用。在 Read Committed 级别下，间隙锁通常被禁用。",
        },
        {
            id: "w8-3-q5",
            question: "唯一索引的等值查询（如 WHERE id = 5）是否需要间隙锁？",
            options: [
                "需要",
                "不需要，只加记录锁（如果记录存在）",
                "取决于数据量",
                "取决于版本",
            ],
            answer: 1,
            rationale: "唯一索引等值查询只需锁定唯一的记录，不可能有其他行插入相同值，所以不需要间隙锁。",
        },
        {
            id: "w8-3-q6",
            question: "两个间隙锁之间是否冲突？",
            options: [
                "总是冲突",
                "不冲突，间隙锁之间兼容",
                "取决于间隙大小",
                "只在 RR 级别冲突",
            ],
            answer: 1,
            rationale: "间隙锁之间兼容（都是防止插入），所以多个事务可以同时持有重叠间隙的间隙锁。",
        },
        {
            id: "w8-3-q7",
            question: "间隙锁与什么锁冲突？",
            options: [
                "其他间隙锁",
                "插入意向锁（Insert Intention Lock）",
                "共享锁",
                "不与任何锁冲突",
            ],
            answer: 1,
            rationale: "间隙锁与插入意向锁冲突。当有间隙锁时，试图在该间隙插入的事务会被阻塞。",
        },
        {
            id: "w8-3-q8",
            question: "什么是插入意向锁？",
            options: [
                "准备获取意向锁",
                "特殊的间隙锁，表示打算在某间隙插入",
                "INSERT 后的锁",
                "锁升级的前兆",
            ],
            answer: 1,
            rationale: "插入意向锁是一种特殊的间隙锁，表示事务打算在间隙中的某个位置插入行。不同位置的插入意向锁不冲突。",
        },
        {
            id: "w8-3-q9",
            question: "如何查看 MySQL 中的间隙锁？",
            options: [
                "SHOW GAP LOCKS",
                "查看 performance_schema.data_locks，LOCK_MODE 包含 GAP",
                "SELECT * FROM gap_locks",
                "无法查看",
            ],
            answer: 1,
            rationale: "在 performance_schema.data_locks 中，LOCK_MODE 为 'X,GAP' 或 'S,GAP' 表示间隙锁。",
        },
        {
            id: "w8-3-q10",
            question: "间隙锁可能导致什么问题？",
            options: [
                "数据丢失",
                "扩大锁定范围，可能导致不必要的阻塞和死锁",
                "内存泄漏",
                "索引损坏",
            ],
            answer: 1,
            rationale: "间隙锁锁定的范围可能比实际需要的大，导致其他事务的 INSERT 被不必要地阻塞，也可能增加死锁风险。",
        },
        {
            id: "w8-3-q11",
            question: "如何减少间隙锁的影响？",
            options: [
                "使用更多索引",
                "使用 Read Committed 隔离级别，或使用唯一索引等值查询",
                "增加内存",
                "重启数据库",
            ],
            answer: 1,
            rationale: "Read Committed 级别禁用间隙锁；唯一索引等值查询不需要间隙锁。合理设计可以减少间隙锁的范围。",
        },
        {
            id: "w8-3-q12",
            question: "索引记录 id=10,20,30 时，SELECT ... WHERE id > 15 FOR UPDATE 会锁定哪些间隙？",
            options: [
                "只锁 (15,20)",
                "(15,20]、(20,30]、(30,+∞) 及对应记录",
                "只锁 id=20,30 的记录",
                "全表锁",
            ],
            answer: 1,
            rationale: "范围条件会锁定满足条件的记录及其间隙。这里会锁定 (15,20]、(20,30]、(30,+∞) 的 Next-Key Lock。",
        },
    ],
    "w8-4": [
        {
            id: "w8-4-q1",
            question: "InnoDB 如何检测死锁？",
            options: [
                "定时扫描",
                "使用等待图（wait-for graph）检测环",
                "依赖超时",
                "不检测，等待用户发现",
            ],
            answer: 1,
            rationale: "InnoDB 使用等待图算法：当事务请求锁时检查是否形成环，有环则存在死锁。",
        },
        {
            id: "w8-4-q2",
            question: "检测到死锁后，InnoDB 如何选择要回滚的事务？",
            options: [
                "随机选择",
                "选择回滚代价最小的事务（如修改行数最少）",
                "回滚最老的事务",
                "回滚所有事务",
            ],
            answer: 1,
            rationale: "InnoDB 选择「代价最小」的事务作为牺牲者回滚，通常是修改行数最少的事务。",
        },
        {
            id: "w8-4-q3",
            question: "死锁被回滚的事务会收到什么错误？",
            options: [
                "错误 1205 (超时)",
                "错误 1213 (Deadlock found)",
                "错误 1062 (重复键)",
                "无错误",
            ],
            answer: 1,
            rationale: "被选为死锁牺牲者的事务会收到错误 1213：'Deadlock found when trying to get lock; try restarting transaction'。",
        },
        {
            id: "w8-4-q4",
            question: "如何查看 MySQL 最近的死锁信息？",
            options: [
                "SHOW DEADLOCKS",
                "SHOW ENGINE INNODB STATUS 的 LATEST DETECTED DEADLOCK 部分",
                "SELECT * FROM deadlocks",
                "在错误日志中",
            ],
            answer: 1,
            rationale: "SHOW ENGINE INNODB STATUS 输出中有 LATEST DETECTED DEADLOCK 部分，显示最近一次死锁的详细信息。",
        },
        {
            id: "w8-4-q5",
            question: "innodb_lock_wait_timeout 参数的作用是什么？",
            options: [
                "设置死锁检测超时",
                "设置锁等待超时时间，超时后回滚当前语句",
                "设置事务超时",
                "设置查询超时",
            ],
            answer: 1,
            rationale: "innodb_lock_wait_timeout 设置等待锁的最长时间（默认 50 秒），超时后回滚当前语句（错误 1205）。",
        },
        {
            id: "w8-4-q6",
            question: "应用程序如何正确处理死锁？",
            options: [
                "忽略错误",
                "捕获错误 1213 并重试整个事务",
                "增加超时时间",
                "关闭自动提交",
            ],
            answer: 1,
            rationale: "应用应该捕获死锁错误（1213）并重试事务。死锁是正常现象，不应该只是报错给用户。",
        },
        {
            id: "w8-4-q7",
            question: "哪种做法有助于减少死锁？",
            options: [
                "使用更长的事务",
                "以固定顺序访问表和行",
                "删除索引",
                "增加并发数",
            ],
            answer: 1,
            rationale: "固定的访问顺序避免循环等待。如：所有事务都先锁表 A 再锁表 B，就不会形成 A→B→A 的环。",
        },
        {
            id: "w8-4-q8",
            question: "如何让 MySQL 记录所有死锁到错误日志？",
            options: [
                "开启慢查询日志",
                "SET GLOBAL innodb_print_all_deadlocks = ON",
                "开启 general log",
                "默认就会记录",
            ],
            answer: 1,
            rationale: "innodb_print_all_deadlocks = ON 让所有死锁信息写入错误日志，而不是只保留最后一次。",
        },
        {
            id: "w8-4-q9",
            question: "为什么好的索引设计能减少死锁？",
            options: [
                "索引更快",
                "减少锁定范围，降低不同事务锁冲突的概率",
                "索引能检测死锁",
                "索引可以预防死锁",
            ],
            answer: 1,
            rationale: "有合适索引时，每个事务只锁定需要的少量行；没有索引时锁定范围扩大，与其他事务冲突概率增加。",
        },
        {
            id: "w8-4-q10",
            question: "短事务为什么有助于减少死锁？",
            options: [
                "短事务更快",
                "持锁时间短，与其他事务形成死锁的时间窗口小",
                "短事务不加锁",
                "短事务优先级高",
            ],
            answer: 1,
            rationale: "事务越短，持有锁的时间越短，与其他事务产生冲突并形成死锁的概率越低。",
        },
        {
            id: "w8-4-q11",
            question: "PostgreSQL 检测死锁的默认超时是多少？",
            options: [
                "立即检测",
                "1 秒（deadlock_timeout 参数）",
                "不检测",
                "与 MySQL 相同",
            ],
            answer: 1,
            rationale: "PostgreSQL 的 deadlock_timeout 默认是 1 秒。等待超过这个时间后才开始检测死锁，避免频繁检测的开销。",
        },
        {
            id: "w8-4-q12",
            question: "死锁检测对性能有什么影响？",
            options: [
                "无影响",
                "检测本身有开销，但能快速发现并解决死锁",
                "严重影响性能",
                "提高性能",
            ],
            answer: 1,
            rationale: "死锁检测有一定开销，但相比让事务无限等待，快速检测并回滚牺牲者更有利于系统整体吞吐量。",
        },
    ],
}
