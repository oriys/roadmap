import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week10Guides: Record<string, LessonGuide> = {
    "w10-1": {
        lessonId: "w10-1",
        background: [
            "【ZooKeeper 定位】Apache 官方定义：'A centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services'。",
            "【ZAB 协议】ZooKeeper 使用 ZAB（ZooKeeper Atomic Broadcast）协议，类似 Paxos/Raft，保证写操作的全局顺序和数据一致性。",
            "【节点类型】ZooKeeper 的 znode 分为：持久节点、临时节点（会话断开自动删除）、顺序节点（自动追加递增序号）。",
            "【会话机制】客户端与 ZooKeeper 建立会话，通过心跳保持。会话超时后临时节点自动删除，实现锁的自动释放。",
            "【Watch 机制】客户端可以在 znode 上设置 watch，节点变化时收到通知。用于实现锁的等待和唤醒。",
        ],
        keyDifficulties: [
            "【临时顺序节点】分布式锁的核心：创建临时顺序节点，序号最小的获得锁。客户端崩溃后临时节点自动删除，锁自动释放。",
            "【羊群效应】如果所有等待者都 watch 锁节点，锁释放时大量通知涌入（thundering herd）。应该只 watch 前一个节点。",
            "【会话超时】网络问题可能导致会话超时，临时节点被删除，锁丢失。但客户端可能不知道。需要重新检查锁状态。",
            "【读写分离】ZooKeeper 集群中，写操作由 leader 处理，读操作可以由任何节点处理。可能读到旧数据（除非用 sync）。",
        ],
        handsOnPath: [
            "搭建 ZooKeeper 集群（3 节点），理解 leader 选举。",
            "用 zkCli 创建临时节点、顺序节点，观察其行为。",
            "实现基于临时顺序节点的分布式锁原型。",
            "测试客户端断开后临时节点的自动删除。",
            "实现 watch 机制，观察只 watch 前一节点如何避免羊群效应。",
        ],
        selfCheck: [
            "ZooKeeper 的 ZAB 协议提供什么保证？",
            "临时节点和持久节点的区别是什么？",
            "为什么分布式锁使用临时顺序节点？",
            "什么是羊群效应？如何避免？",
            "会话超时对分布式锁有什么影响？",
        ],
        extensions: [
            "阅读 ZAB 协议论文，理解其与 Paxos/Raft 的区别。",
            "研究 ZooKeeper 的 leader 选举算法。",
            "了解 ZooKeeper 3.5+ 的新特性（如动态配置）。",
            "研究 ZooKeeper 在 Kafka、HBase 中的应用。",
        ],
        sourceUrls: [
            "https://zookeeper.apache.org/doc/current/zookeeperOver.html",
            "https://zookeeper.apache.org/doc/current/recipes.html#sc_recipes_Locks",
            "https://www.usenix.org/legacy/event/atc10/tech/full_papers/Hunt.pdf",
        ],
    },
    "w10-2": {
        lessonId: "w10-2",
        background: [
            "【Curator 定位】Apache Curator 是 ZooKeeper 的高级客户端库：'A Java/JVM client library for Apache ZooKeeper, providing high-level APIs and recipes'。",
            "【InterProcessMutex】Curator 的分布式互斥锁实现：可重入、公平、自动处理连接问题。封装了临时顺序节点的复杂逻辑。",
            "【InterProcessReadWriteLock】分布式读写锁：多读单写，读锁之间兼容，写锁互斥。适合读多写少场景。",
            "【连接状态管理】Curator 处理连接断开和重连，提供 ConnectionStateListener 通知应用连接状态变化。",
            "【重试策略】Curator 内置多种重试策略：ExponentialBackoffRetry（指数退避）、RetryNTimes、RetryForever 等。",
        ],
        keyDifficulties: [
            "【连接丢失处理】连接丢失时锁状态不确定。Curator 会尝试重连，但应用需要检查锁是否仍然有效。",
            "【会话过期】会话过期意味着所有临时节点被删除，锁丢失。应用需要监听 LOST 状态并重新获取锁。",
            "【可重入实现】InterProcessMutex 在 JVM 内存中跟踪重入次数，结合 ZooKeeper 节点的线程 ID 信息实现可重入。",
            "【超时设置】acquire(timeout) 的超时是等待获取锁的时间，不是锁的持有时间。锁一旦获取，直到 release 或会话过期。",
        ],
        handsOnPath: [
            "用 Curator 的 InterProcessMutex 实现分布式锁。",
            "测试可重入：同一线程多次 acquire 和 release。",
            "使用 InterProcessReadWriteLock 实现读写锁场景。",
            "模拟 ZooKeeper 连接断开，观察 Curator 的重连行为。",
            "实现 ConnectionStateListener，处理会话过期事件。",
        ],
        selfCheck: [
            "Curator 相比原生 ZooKeeper 客户端有什么优势？",
            "InterProcessMutex 如何实现可重入？",
            "连接丢失（LOST）和连接断开（SUSPENDED）有什么区别？",
            "会话过期后应用应该怎么做？",
            "Curator 的重试策略有哪些？如何选择？",
        ],
        extensions: [
            "研究 Curator 的 LeaderSelector 和 LeaderLatch。",
            "学习 Curator 的 PathChildrenCache 和 TreeCache。",
            "了解 Curator 的屏障（Barrier）和信号量（Semaphore）。",
            "研究 Curator 5.x 的新 API 和改进。",
        ],
        sourceUrls: [
            "https://curator.apache.org/docs/about",
            "https://curator.apache.org/docs/recipes-shared-lock",
            "https://www.baeldung.com/apache-curator",
        ],
    },
    "w10-3": {
        lessonId: "w10-3",
        background: [
            "【etcd 定位】CoreOS 开发的分布式键值存储：'A distributed, reliable key-value store for the most critical data of a distributed system'。",
            "【Raft 共识】etcd 使用 Raft 协议保证一致性，比 ZAB 更易理解。所有写操作经过 leader，日志复制到多数节点后提交。",
            "【租约（Lease）】etcd 的租约机制：创建租约（有 TTL）→ 将 key 绑定到租约 → 租约过期时 key 自动删除。类似 ZooKeeper 的临时节点。",
            "【原子事务】etcd 支持事务（Txn）：IF ... THEN ... ELSE，原子地检查条件并执行操作。是实现分布式锁的基础。",
            "【Watch 机制】etcd 的 watch 是基于版本的流式 API，可以从特定版本开始 watch，不会丢失事件。",
        ],
        keyDifficulties: [
            "【租约续期】客户端需要定期调用 KeepAlive 续期租约，否则租约过期，锁自动释放。类似 Redis 的看门狗。",
            "【Revision 顺序】etcd 的每次修改都有全局递增的 revision。可以用 revision 实现公平锁：revision 最小的获得锁。",
            "【前缀 watch】可以 watch 一个前缀下的所有 key，适合实现锁队列。watch 返回的事件包含完整的变更信息。",
            "【线性一致读】etcd 默认是线性一致读，但可以选择 serializable 读（更快但可能读到旧数据）。锁操作应该用线性一致读。",
        ],
        handsOnPath: [
            "搭建 etcd 集群，理解 Raft leader 选举。",
            "用 etcdctl 创建租约、绑定 key、测试过期行为。",
            "用 etcd 的 Txn API 实现基本的分布式锁。",
            "实现租约续期（KeepAlive）机制。",
            "用 go.etcd.io/etcd/client/v3/concurrency 包的 Mutex 实现锁。",
        ],
        selfCheck: [
            "etcd 的租约（Lease）机制如何工作？",
            "etcd 的事务（Txn）如何用于实现锁？",
            "revision 在分布式锁中起什么作用？",
            "租约过期和主动删除有什么区别？",
            "etcd watch 与 ZooKeeper watch 有什么不同？",
        ],
        extensions: [
            "研究 etcd 的 MVCC 存储引擎。",
            "学习 Kubernetes 如何使用 etcd 存储集群状态。",
            "了解 etcd 的压缩（compaction）和碎片整理（defragment）。",
            "研究 etcd 与 Consul 的对比。",
        ],
        sourceUrls: [
            "https://etcd.io/docs/v3.5/learning/",
            "https://etcd.io/docs/v3.5/dev-guide/api_concurrency_reference_v3/",
            "https://pkg.go.dev/go.etcd.io/etcd/client/v3/concurrency",
        ],
    },
    "w10-4": {
        lessonId: "w10-4",
        background: [
            "【CAP 权衡】Redis 选择 AP（可用性+分区容忍），ZooKeeper/etcd 选择 CP（一致性+分区容忍）。决定了锁的强度。",
            "【性能对比】Redis 性能最高（单机 10 万+ QPS），ZooKeeper 中等（万级），etcd 略低于 ZooKeeper。但一致性保证不同。",
            "【运维复杂度】单机 Redis 最简单，集群 Redis 复杂度中等，ZooKeeper/etcd 需要专门运维，etcd 相对轻量。",
            "【生态系统】Redis 生态最丰富，ZooKeeper 是 Java 生态标准，etcd 是 Kubernetes/Go 生态首选。",
            "【故障恢复】Redis 主从切换可能丢数据，ZooKeeper/etcd 保证已提交数据不丢失（多数节点确认）。",
        ],
        keyDifficulties: [
            "【场景匹配】效率锁（防重复）→ Redis；正确性锁（数据一致）→ ZooKeeper/etcd。错误选择会导致问题。",
            "【成本考量】ZooKeeper/etcd 需要独立集群，增加运维成本。如果已有 Redis，复用 Redis 更经济（接受其限制）。",
            "【混合方案】某些场景可以混合：用 Redis 做快速的粗粒度锁，用 ZooKeeper/etcd 做关键操作的细粒度锁。",
            "【锁粒度设计】锁的粒度影响并发度和复杂度。粒度太粗并发低，太细复杂度高。需要根据业务设计。",
        ],
        handsOnPath: [
            "benchmark 对比 Redis/ZooKeeper/etcd 锁的获取和释放性能。",
            "设计一个场景：分别用三种方案实现，比较代码复杂度。",
            "模拟各种故障（网络分区、节点宕机），观察不同方案的行为。",
            "为实际业务场景选择锁方案，写出决策理由。",
            "实现混合锁方案：Redis 粗粒度 + ZooKeeper 细粒度。",
        ],
        selfCheck: [
            "Redis 锁和 ZooKeeper 锁的本质区别是什么？",
            "什么场景下必须使用 ZooKeeper/etcd 而不是 Redis？",
            "选择分布式锁方案时需要考虑哪些因素？",
            "如何评估分布式锁的性能需求？",
            "锁粒度设计的原则是什么？",
        ],
        extensions: [
            "研究 Google Chubby 论文和设计思想。",
            "了解 Consul 的锁实现和与 etcd 的对比。",
            "学习 TiKV 等 NewSQL 数据库的分布式锁支持。",
            "研究无锁设计模式如何减少对分布式锁的依赖。",
        ],
        sourceUrls: [
            "https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html",
            "https://static.googleusercontent.com/media/research.google.com/en//archive/chubby-osdi06.pdf",
            "https://www.consul.io/docs/dynamic-app-config/sessions",
        ],
    },
}

export const week10Quizzes: Record<string, QuizQuestion[]> = {
    "w10-1": [
        {
            id: "w10-1-q1",
            question: "ZooKeeper 使用什么协议保证数据一致性？",
            options: [
                "Paxos",
                "ZAB（ZooKeeper Atomic Broadcast）",
                "Raft",
                "2PC",
            ],
            answer: 1,
            rationale: "ZooKeeper 使用自己设计的 ZAB 协议，是一种类似 Paxos 的原子广播协议，保证写操作的全局顺序。",
        },
        {
            id: "w10-1-q2",
            question: "ZooKeeper 的临时节点有什么特点？",
            options: [
                "永久存在",
                "客户端会话断开后自动删除",
                "只能存储数字",
                "不能有子节点",
            ],
            answer: 1,
            rationale: "临时节点（ephemeral node）的生命周期与客户端会话绑定。会话结束（正常断开或超时）后自动删除。",
        },
        {
            id: "w10-1-q3",
            question: "ZooKeeper 分布式锁为什么使用临时顺序节点？",
            options: [
                "性能最好",
                "临时节点保证锁自动释放，顺序节点保证公平性",
                "ZooKeeper 只支持这种类型",
                "存储空间最小",
            ],
            answer: 1,
            rationale: "临时节点在客户端崩溃后自动删除，实现锁的自动释放；顺序节点的序号决定获取锁的顺序，实现公平锁。",
        },
        {
            id: "w10-1-q4",
            question: "什么是羊群效应（thundering herd）？如何避免？",
            options: [
                "锁获取太快",
                "所有等待者 watch 同一节点，释放时大量通知。应该只 watch 前一个节点",
                "ZooKeeper 过载",
                "客户端太多",
            ],
            answer: 1,
            rationale: "如果 N 个客户端都 watch 锁节点，锁释放时 N 个通知同时发出。正确做法是每个客户端只 watch 前一个节点。",
        },
        {
            id: "w10-1-q5",
            question: "ZooKeeper 会话超时对分布式锁有什么影响？",
            options: [
                "无影响",
                "临时节点被删除，锁自动释放，但客户端可能不知道",
                "锁永不释放",
                "会话自动续期",
            ],
            answer: 1,
            rationale: "会话超时后，该会话创建的所有临时节点被删除，锁被释放。但网络问题时客户端可能还在运行，不知道锁已丢失。",
        },
        {
            id: "w10-1-q6",
            question: "ZooKeeper 的 watch 机制有什么特点？",
            options: [
                "持续监听",
                "一次性触发，需要重新注册",
                "只能 watch 数据变化",
                "不能 watch 子节点",
            ],
            answer: 1,
            rationale: "ZooKeeper 的 watch 是一次性的：触发后需要重新注册。这避免了重复通知，但需要正确处理。",
        },
        {
            id: "w10-1-q7",
            question: "ZooKeeper 集群中写操作由谁处理？",
            options: [
                "任意节点",
                "Leader 节点",
                "所有节点同时",
                "客户端指定的节点",
            ],
            answer: 1,
            rationale: "所有写操作都由 Leader 处理。Follower 收到写请求会转发给 Leader。这保证了写操作的全局顺序。",
        },
        {
            id: "w10-1-q8",
            question: "ZooKeeper 的 znode 最大数据大小是多少？",
            options: [
                "无限制",
                "默认 1MB",
                "默认 1KB",
                "默认 1GB",
            ],
            answer: 1,
            rationale: "ZooKeeper 设计用于存储小量协调数据，默认限制 znode 数据大小为 1MB。不适合存储大数据。",
        },
        {
            id: "w10-1-q9",
            question: "ZooKeeper 如何保证读操作的一致性？",
            options: [
                "默认就是强一致的",
                "读可能返回旧数据，需要调用 sync() 确保读到最新",
                "只能读 Leader",
                "使用版本号",
            ],
            answer: 1,
            rationale: "ZooKeeper 的读可以由任何节点处理，可能读到旧数据。如果需要读最新数据，先调用 sync() 同步。",
        },
        {
            id: "w10-1-q10",
            question: "ZooKeeper 集群需要多少个节点？",
            options: [
                "至少 2 个",
                "建议奇数个，至少 3 个",
                "必须 5 个",
                "1 个就够",
            ],
            answer: 1,
            rationale: "ZooKeeper 需要多数节点存活才能工作。奇数个节点（3、5、7）在相同容错能力下更经济。最少 3 个。",
        },
        {
            id: "w10-1-q11",
            question: "获取 ZooKeeper 分布式锁的步骤是什么？",
            options: [
                "直接创建锁节点",
                "创建临时顺序节点 → 获取子节点列表 → 判断是否最小 → 是则获得锁/否则 watch 前一个",
                "发送 lock 命令",
                "创建持久节点",
            ],
            answer: 1,
            rationale: "标准流程：在锁路径下创建临时顺序节点，获取所有子节点，如果自己序号最小则获得锁，否则 watch 前一个节点。",
        },
        {
            id: "w10-1-q12",
            question: "相比 Redis 锁，ZooKeeper 锁的主要优势是什么？",
            options: [
                "性能更高",
                "实现更简单",
                "强一致性保证，不会因为主从切换丢锁",
                "支持更多数据类型",
            ],
            answer: 2,
            rationale: "ZooKeeper 使用 ZAB 协议，写操作在多数节点确认后才成功。即使 Leader 切换，已确认的锁不会丢失。",
        },
    ],
    "w10-2": [
        {
            id: "w10-2-q1",
            question: "Apache Curator 是什么？",
            options: [
                "ZooKeeper 的替代品",
                "ZooKeeper 的高级客户端库，提供高层 API 和 recipes",
                "分布式数据库",
                "消息队列",
            ],
            answer: 1,
            rationale: "Curator 是 Apache 项目，为 ZooKeeper 提供高级 API，封装了分布式锁、选举、缓存等常用功能（recipes）。",
        },
        {
            id: "w10-2-q2",
            question: "Curator 的 InterProcessMutex 有什么特点？",
            options: [
                "不可重入",
                "可重入、公平、自动处理连接问题",
                "只支持单机",
                "需要手动续期",
            ],
            answer: 1,
            rationale: "InterProcessMutex 是可重入的分布式互斥锁，按序获取（公平），自动处理连接断开和重连。",
        },
        {
            id: "w10-2-q3",
            question: "Curator 的 ConnectionState.LOST 表示什么？",
            options: [
                "连接正常",
                "会话过期，所有临时节点被删除",
                "连接暂时断开",
                "ZooKeeper 重启",
            ],
            answer: 1,
            rationale: "LOST 表示会话过期，与之关联的所有临时节点（包括锁）被删除。应用必须重新获取锁。",
        },
        {
            id: "w10-2-q4",
            question: "Curator 的 InterProcessReadWriteLock 的读锁和写锁有什么关系？",
            options: [
                "完全独立",
                "多个读锁可以同时持有，写锁与任何锁互斥",
                "读锁和写锁不能同时存在",
                "写锁可以降级为读锁",
            ],
            answer: 1,
            rationale: "读锁之间兼容（多读并发），但读锁与写锁互斥，写锁与写锁也互斥（单写）。适合读多写少场景。",
        },
        {
            id: "w10-2-q5",
            question: "Curator 的 ExponentialBackoffRetry 重试策略是什么？",
            options: [
                "固定间隔重试",
                "每次重试间隔指数增长",
                "立即重试",
                "永不重试",
            ],
            answer: 1,
            rationale: "ExponentialBackoffRetry 每次重试的等待时间指数增长（如 1s, 2s, 4s...），减少频繁重试对服务的压力。",
        },
        {
            id: "w10-2-q6",
            question: "Curator 的 acquire(long time, TimeUnit unit) 的 time 参数是什么意思？",
            options: [
                "锁的持有时间",
                "等待获取锁的最长时间",
                "重试间隔",
                "会话超时",
            ],
            answer: 1,
            rationale: "time 是等待获取锁的最长时间。如果在这个时间内获取到锁返回 true，超时返回 false。锁本身没有 TTL。",
        },
        {
            id: "w10-2-q7",
            question: "如何正确处理 Curator 的连接状态变化？",
            options: [
                "不需要处理",
                "实现 ConnectionStateListener，在 LOST 时重新获取锁",
                "忽略所有事件",
                "重启应用",
            ],
            answer: 1,
            rationale: "应该监听连接状态变化。特别是 LOST 状态表示会话过期，必须重新检查业务状态并重新获取锁。",
        },
        {
            id: "w10-2-q8",
            question: "Curator 的 InterProcessMutex 如何实现可重入？",
            options: [
                "在 ZooKeeper 中记录",
                "在 JVM 内存中跟踪重入次数，结合节点信息",
                "不支持重入",
                "每次创建新节点",
            ],
            answer: 1,
            rationale: "Curator 在本地内存中维护线程与锁节点的映射和重入计数。ZooKeeper 节点包含线程信息用于验证。",
        },
        {
            id: "w10-2-q9",
            question: "Curator 的 LeaderSelector 用于什么场景？",
            options: [
                "分布式锁",
                "Leader 选举，当选后执行任务，结束后重新选举",
                "数据同步",
                "配置管理",
            ],
            answer: 1,
            rationale: "LeaderSelector 用于 Leader 选举。当选的节点执行 takeLeadership() 方法，方法返回后释放 leadership，重新选举。",
        },
        {
            id: "w10-2-q10",
            question: "使用 Curator 锁时，如何避免忘记释放锁？",
            options: [
                "设置锁超时",
                "使用 try-finally 确保 release()，或使用 try-with-resources",
                "依赖 GC",
                "不需要释放",
            ],
            answer: 1,
            rationale: "必须在 finally 块中调用 release()。Curator 的某些新 API 支持 try-with-resources 自动释放。",
        },
        {
            id: "w10-2-q11",
            question: "SUSPENDED 和 LOST 连接状态的区别是什么？",
            options: [
                "没有区别",
                "SUSPENDED 是暂时断开可能恢复，LOST 是会话过期",
                "LOST 可以恢复",
                "SUSPENDED 更严重",
            ],
            answer: 1,
            rationale: "SUSPENDED 表示连接暂时断开，可能恢复（锁可能还有效）。LOST 表示会话过期，临时节点已删除。",
        },
        {
            id: "w10-2-q12",
            question: "Curator 的 Shared 系列（SharedLock、SharedCount 等）有什么用途？",
            options: [
                "共享锁实现",
                "在多个 JVM 间共享状态的高级原语",
                "共享内存",
                "文件共享",
            ],
            answer: 1,
            rationale: "Shared 系列提供跨 JVM 共享状态的原语：SharedLock（分布式锁）、SharedCount（分布式计数器）、SharedBarrier 等。",
        },
    ],
    "w10-3": [
        {
            id: "w10-3-q1",
            question: "etcd 使用什么共识协议？",
            options: [
                "Paxos",
                "ZAB",
                "Raft",
                "2PC",
            ],
            answer: 2,
            rationale: "etcd 使用 Raft 协议保证数据一致性。Raft 比 Paxos 更易理解和实现，是工业界的流行选择。",
        },
        {
            id: "w10-3-q2",
            question: "etcd 的租约（Lease）机制是什么？",
            options: [
                "永久存储",
                "有 TTL 的租约，key 绑定租约后，租约过期时 key 自动删除",
                "只用于锁",
                "备份机制",
            ],
            answer: 1,
            rationale: "租约有一个 TTL，多个 key 可以绑定到同一租约。租约过期时，所有绑定的 key 自动删除。类似 ZooKeeper 临时节点。",
        },
        {
            id: "w10-3-q3",
            question: "如何保持 etcd 租约不过期？",
            options: [
                "设置无限 TTL",
                "定期调用 KeepAlive 续期",
                "租约自动续期",
                "不需要处理",
            ],
            answer: 1,
            rationale: "客户端需要定期调用 KeepAlive 向 etcd 发送心跳续期。客户端库通常提供自动续期功能。",
        },
        {
            id: "w10-3-q4",
            question: "etcd 的事务（Txn）API 有什么用？",
            options: [
                "数据备份",
                "原子的 IF-THEN-ELSE 操作，用于实现 CAS 和锁",
                "批量读取",
                "日志记录",
            ],
            answer: 1,
            rationale: "Txn 支持原子的条件操作：IF 条件成立 THEN 执行操作 ELSE 执行其他操作。是实现分布式锁的基础。",
        },
        {
            id: "w10-3-q5",
            question: "etcd 的 revision 是什么？",
            options: [
                "版本号",
                "全局递增的修改序号，每次写操作 +1",
                "集群 ID",
                "节点编号",
            ],
            answer: 1,
            rationale: "revision 是 etcd 全局的修改序号，每次写操作都会增加。可以用于实现公平锁（revision 最小的获得锁）。",
        },
        {
            id: "w10-3-q6",
            question: "etcd concurrency 包的 Mutex 如何使用？",
            options: [
                "直接 Lock/Unlock",
                "创建 Session（管理租约）→ 创建 Mutex → Lock → 业务 → Unlock",
                "发送命令",
                "调用 API",
            ],
            answer: 1,
            rationale: "Session 管理租约和续期，Mutex 基于 Session 实现锁。使用流程：NewSession → NewMutex → Lock → Unlock。",
        },
        {
            id: "w10-3-q7",
            question: "etcd 的 watch 与 ZooKeeper 的 watch 有什么不同？",
            options: [
                "完全相同",
                "etcd watch 是持续的流式 API，可以从指定 revision 开始，不会丢事件",
                "etcd 不支持 watch",
                "ZooKeeper 更强大",
            ],
            answer: 1,
            rationale: "ZooKeeper watch 是一次性的；etcd watch 是持续的流，可以从历史 revision 开始，保证不丢失事件。",
        },
        {
            id: "w10-3-q8",
            question: "etcd 的线性一致读（linearizable read）有什么特点？",
            options: [
                "最快",
                "保证读到最新已提交数据，但需要额外的一致性检查",
                "只能读 Leader",
                "不保证一致性",
            ],
            answer: 1,
            rationale: "线性一致读确保读到最新数据，但需要确认 Leader 是否仍是 Leader（ReadIndex 协议）。比 serializable 读慢但更一致。",
        },
        {
            id: "w10-3-q9",
            question: "etcd 适合存储什么类型的数据？",
            options: [
                "大文件",
                "小型配置数据、元数据、协调信息",
                "日志",
                "图片",
            ],
            answer: 1,
            rationale: "etcd 设计用于存储关键的小型数据：配置、服务发现、分布式锁等。不适合大数据，有请求大小限制（默认 1.5MB）。",
        },
        {
            id: "w10-3-q10",
            question: "Kubernetes 如何使用 etcd？",
            options: [
                "不使用 etcd",
                "存储所有集群状态和配置，是 Kubernetes 的「大脑」",
                "只用于日志",
                "只用于网络",
            ],
            answer: 1,
            rationale: "Kubernetes 的所有集群状态（Pod、Service、ConfigMap 等）都存储在 etcd 中。etcd 的一致性保证了 K8s 的可靠性。",
        },
        {
            id: "w10-3-q11",
            question: "etcd 租约过期时会发生什么？",
            options: [
                "什么都不发生",
                "所有绑定到该租约的 key 自动删除",
                "租约自动续期",
                "只删除租约",
            ],
            answer: 1,
            rationale: "租约过期时，etcd 自动删除所有绑定到该租约的 key。这是实现分布式锁自动释放的基础。",
        },
        {
            id: "w10-3-q12",
            question: "etcd 的前缀 watch（watch with prefix）有什么用？",
            options: [
                "监控 CPU",
                "监听一个前缀下所有 key 的变化，适合实现锁队列",
                "监控网络",
                "监控磁盘",
            ],
            answer: 1,
            rationale: "前缀 watch 可以监听 /locks/ 下所有 key 的变化，适合实现锁队列，监控谁获得了锁、谁在等待。",
        },
    ],
    "w10-4": [
        {
            id: "w10-4-q1",
            question: "Redis、ZooKeeper、etcd 在 CAP 中的选择分别是什么？",
            options: [
                "都选择 CP",
                "Redis 选择 AP，ZooKeeper/etcd 选择 CP",
                "都选择 AP",
                "Redis 选择 CP",
            ],
            answer: 1,
            rationale: "Redis（单机/主从）优先可用性（AP），主从切换可能丢数据。ZooKeeper/etcd 优先一致性（CP），保证数据不丢失。",
        },
        {
            id: "w10-4-q2",
            question: "从性能角度，三种方案的排序（从高到低）通常是？",
            options: [
                "etcd > ZooKeeper > Redis",
                "Redis > ZooKeeper > etcd",
                "ZooKeeper > Redis > etcd",
                "性能相同",
            ],
            answer: 1,
            rationale: "Redis 单机性能最高（10 万+ QPS），ZooKeeper 中等（万级），etcd 略低。但一致性保证不同。",
        },
        {
            id: "w10-4-q3",
            question: "什么场景下应该选择 ZooKeeper/etcd 而不是 Redis？",
            options: [
                "性能要求高时",
                "需要强一致性保证，不能容忍锁丢失时",
                "数据量大时",
                "单机部署时",
            ],
            answer: 1,
            rationale: "当锁失效会导致严重后果（如数据不一致、资金损失）时，应该选择 CP 系统（ZooKeeper/etcd），不是 AP 系统（Redis）。",
        },
        {
            id: "w10-4-q4",
            question: "选择分布式锁方案时需要考虑哪些因素？",
            options: [
                "只考虑性能",
                "一致性要求、性能需求、运维成本、现有基础设施",
                "只考虑成本",
                "只考虑团队熟悉度",
            ],
            answer: 1,
            rationale: "综合考虑：业务对一致性的要求、性能需求、团队运维能力、现有基础设施（已有 Redis 还是需要新建集群）等。",
        },
        {
            id: "w10-4-q5",
            question: "Google Chubby 论文对分布式锁的主要贡献是什么？",
            options: [
                "发明了 Redis",
                "提出了分布式锁服务的设计理念，影响了 ZooKeeper 等后续系统",
                "发明了 Raft",
                "提出了 CAP 定理",
            ],
            answer: 1,
            rationale: "Chubby 是 Google 内部的分布式锁服务，其设计思想（基于 Paxos、粗粒度锁、会话语义）影响了 ZooKeeper 等开源系统。",
        },
        {
            id: "w10-4-q6",
            question: "如果已有 Redis 基础设施，什么情况下应该单独部署 ZooKeeper/etcd？",
            options: [
                "永远不需要",
                "业务有强一致性要求，Redis 锁的局限性不可接受时",
                "永远需要",
                "Redis 性能不够时",
            ],
            answer: 1,
            rationale: "如果业务对锁的正确性要求高（如金融交易），Redis 的异步复制风险不可接受，应该投入成本部署 ZooKeeper/etcd。",
        },
        {
            id: "w10-4-q7",
            question: "混合锁方案（Redis + ZooKeeper）的思路是什么？",
            options: [
                "完全替代",
                "Redis 做快速的粗粒度锁，ZooKeeper 做关键操作的细粒度锁",
                "只用 Redis",
                "只用 ZooKeeper",
            ],
            answer: 1,
            rationale: "可以用 Redis 做高频的效率锁（如防重复提交），用 ZooKeeper 做低频但关键的正确性锁（如订单状态变更）。",
        },
        {
            id: "w10-4-q8",
            question: "锁粒度设计的原则是什么？",
            options: [
                "越粗越好",
                "越细越好",
                "粒度太粗降低并发，太细增加复杂度，需要平衡",
                "固定粒度",
            ],
            answer: 2,
            rationale: "粗粒度锁简单但并发度低；细粒度锁并发高但复杂度高、开销大。需要根据业务的实际冲突情况设计。",
        },
        {
            id: "w10-4-q9",
            question: "etcd 相比 ZooKeeper 的优势是什么？",
            options: [
                "性能更高",
                "更轻量、运维更简单、Go 生态原生支持",
                "一致性更强",
                "功能更多",
            ],
            answer: 1,
            rationale: "etcd 相对轻量，运维更简单，是 Kubernetes/Go 生态的原生选择。ZooKeeper 是 Java 生态标准，但运维更复杂。",
        },
        {
            id: "w10-4-q10",
            question: "无锁设计（lock-free design）如何减少对分布式锁的依赖？",
            options: [
                "不可能",
                "通过幂等设计、乐观并发控制、最终一致性等减少锁需求",
                "使用更多锁",
                "只在单机使用",
            ],
            answer: 1,
            rationale: "好的系统设计尽量减少对分布式锁的依赖：幂等操作、乐观锁（版本号）、最终一致性、避免共享状态等。",
        },
        {
            id: "w10-4-q11",
            question: "Consul 的分布式锁与 etcd 有什么不同？",
            options: [
                "完全相同",
                "Consul 用 Session 机制，集成服务发现，更偏向服务网格",
                "Consul 不支持锁",
                "etcd 不支持锁",
            ],
            answer: 1,
            rationale: "Consul 用 Session 实现锁，与其服务发现功能紧密集成，更偏向服务网格场景。etcd 更通用，是 K8s 标配。",
        },
        {
            id: "w10-4-q12",
            question: "在选择分布式锁方案时，「足够好」的原则是什么意思？",
            options: [
                "追求完美",
                "理解各方案的权衡，选择满足业务需求的最简单方案",
                "随便选一个",
                "选最贵的",
            ],
            answer: 1,
            rationale: "没有完美的方案，只有适合的方案。理解业务需求（一致性、性能、成本），选择满足需求的最简单方案。",
        },
    ],
}
