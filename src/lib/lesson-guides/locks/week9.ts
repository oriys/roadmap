import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week9Guides: Record<string, LessonGuide> = {
    "w9-1": {
        lessonId: "w9-1",
        background: [
            "【分布式锁需求】单机锁（如 Mutex）只能在一个进程内生效。分布式系统中需要跨进程、跨机器的锁来协调资源访问。",
            "【Redis SETNX】SET if Not eXists：'Set key to hold string value if key does not exist'——key 不存在时才设置，返回是否成功。",
            "【原子性保证】Redis 的 SET NX PX 命令原子地：设置 key、设置过期时间。避免了 SETNX + EXPIRE 两步操作的非原子性问题。",
            "【过期时间必要性】锁必须有过期时间，防止客户端崩溃后锁永远不释放（死锁）。但过期时间的选择是个权衡。",
            "【唯一标识符】释放锁时需要验证是自己持有的锁。通常用 UUID 作为锁的值，释放前先比较。",
        ],
        keyDifficulties: [
            "【锁过期问题】如果业务执行时间超过锁的过期时间，锁会自动释放，其他客户端可能获取锁，导致并发问题。",
            "【释放别人的锁】如果不检查锁的持有者，客户端 A 可能释放客户端 B 持有的锁。必须用 Lua 脚本原子检查并删除。",
            "【时钟漂移】分布式环境下，不同机器的时钟可能有偏差。依赖过期时间的锁受时钟漂移影响。",
            "【单点故障】单 Redis 实例挂掉，锁服务不可用。主从切换时可能丢失锁状态。",
        ],
        handsOnPath: [
            "用 SET key value NX PX 30000 实现基础的分布式锁获取。",
            "用 Lua 脚本实现原子的「检查并释放」操作。",
            "实现带重试的锁获取（带退避策略）。",
            "测试锁过期后的行为：模拟业务执行时间超过过期时间。",
            "实现锁续期（watchdog）机制的原型。",
        ],
        selfCheck: [
            "为什么 SETNX + EXPIRE 两条命令不够安全？",
            "锁的值为什么要用唯一标识符？",
            "释放锁时为什么需要用 Lua 脚本？",
            "锁过期时间设置太短或太长分别有什么问题？",
            "什么是看门狗（watchdog）机制？它解决什么问题？",
        ],
        extensions: [
            "研究 Redisson 的看门狗实现原理。",
            "学习 Redis 的 Lua 脚本执行机制。",
            "了解 Redis 主从复制的异步性对锁的影响。",
            "研究 Redis 7.0 的 Function 特性如何改进分布式锁。",
        ],
        sourceUrls: [
            "https://redis.io/docs/latest/commands/set/",
            "https://redis.io/docs/latest/develop/use/patterns/distributed-locks/",
            "https://redisson.org/glossary/java-distributed-lock.html",
        ],
    },
    "w9-2": {
        lessonId: "w9-2",
        background: [
            "【Redlock 提出】Redis 作者 antirez 提出的分布式锁算法，旨在解决单 Redis 实例的单点故障问题。",
            "【算法核心】使用 N 个独立的 Redis 实例（建议 5 个），客户端需要在大多数（N/2+1）实例上成功获取锁。",
            "【时间约束】获取所有锁的总时间必须小于锁的过期时间，否则视为失败。这保证了即使部分实例时钟漂移，锁仍然有效。",
            "【失败重试】如果获取锁失败，必须在所有实例上释放已获取的锁，然后随机延迟后重试。",
            "【争议与讨论】Martin Kleppmann 对 Redlock 提出质疑，引发了关于分布式锁正确性的著名讨论。",
        ],
        keyDifficulties: [
            "【时钟假设】Redlock 假设进程不会暂停太长时间（如 GC），且时钟漂移在可接受范围内。这些假设可能被违反。",
            "【Martin Kleppmann 的质疑】如果客户端在获取锁后发生长时间 GC，锁可能过期，但客户端不知道。恢复后继续操作会破坏互斥性。",
            "【fencing token】Kleppmann 建议使用单调递增的 fencing token，资源端检查 token 顺序，拒绝旧 token 的操作。",
            "【运维复杂性】需要维护多个独立的 Redis 实例，且它们不能有复制关系。增加了运维成本。",
        ],
        handsOnPath: [
            "阅读 Redlock 算法的原始描述，理解每一步的目的。",
            "用 Redisson 或其他库实现 Redlock，测试其行为。",
            "模拟部分 Redis 实例宕机，验证算法的容错性。",
            "实现简化版的 fencing token 机制。",
            "benchmark 对比 Redlock 和单实例锁的性能差异。",
        ],
        selfCheck: [
            "Redlock 为什么需要多个 Redis 实例？",
            "为什么获取锁的总时间要小于过期时间？",
            "Martin Kleppmann 对 Redlock 的主要质疑是什么？",
            "什么是 fencing token？它如何增强安全性？",
            "Redlock 在什么场景下不适用？",
        ],
        extensions: [
            "阅读 Martin Kleppmann 的博客文章「How to do distributed locking」。",
            "阅读 antirez 的回应「Is Redlock safe?」。",
            "研究 TLA+ 对分布式锁算法的形式化验证。",
            "了解 Raft/Paxos 与 Redlock 的本质区别。",
        ],
        sourceUrls: [
            "https://redis.io/docs/latest/develop/use/patterns/distributed-locks/",
            "https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html",
            "http://antirez.com/news/101",
        ],
    },
    "w9-3": {
        lessonId: "w9-3",
        background: [
            "【效率锁 vs 正确性锁】Martin Kleppmann 区分：效率锁防止重复工作（容忍偶尔失效）；正确性锁保证数据正确性（不能容忍任何失效）。",
            "【Redis 锁的定位】Redis 分布式锁适合效率锁场景：如防止定时任务重复执行、限制并发请求数。不适合需要强一致性的场景。",
            "【异步复制问题】Redis 主从复制是异步的。主节点写入锁后宕机，从节点提升为主但没有锁数据，导致锁丢失。",
            "【网络分区】网络分区时，客户端可能与部分 Redis 实例通信，导致多个客户端同时认为自己持有锁。",
            "【GC 暂停问题】任何基于租约（lease）的锁都面临客户端暂停问题：客户端 GC 期间锁过期，恢复后误以为仍持有锁。",
        ],
        keyDifficulties: [
            "【租约的本质限制】租约（有过期时间的锁）无法完全解决分布式系统的异步性。总有时间窗口可能出现问题。",
            "【「足够好」的权衡】很多业务场景可以接受极低概率的锁失效。重要的是理解风险并做好监控和补偿。",
            "【幂等性设计】假设锁可能失效，业务操作应该设计为幂等的，即使重复执行也不会导致错误结果。",
            "【监控告警】无法完全避免问题，但可以快速发现：监控锁的获取/释放、业务执行时间、锁过期事件。",
        ],
        handsOnPath: [
            "设计一个场景：模拟 Redis 主从切换导致的锁丢失。",
            "实现业务操作的幂等性改造。",
            "添加锁相关的监控指标：获取耗时、持有时长、续期次数。",
            "测试不同 GC 配置对锁持有的影响。",
            "设计锁失效的补偿机制（如最终一致性对账）。",
        ],
        selfCheck: [
            "效率锁和正确性锁的区别是什么？Redis 锁属于哪种？",
            "Redis 主从复制为什么会导致锁丢失？",
            "为什么任何租约机制都无法完全解决 GC 暂停问题？",
            "幂等性设计如何帮助应对锁失效？",
            "什么场景下不应该使用 Redis 分布式锁？",
        ],
        extensions: [
            "研究 Redis Sentinel 和 Cluster 模式下锁的行为。",
            "学习 ZooKeeper/etcd 如何通过共识算法避免这些问题。",
            "了解 Google Chubby 论文中的锁服务设计。",
            "研究 AWS ElastiCache 的分布式锁最佳实践。",
        ],
        sourceUrls: [
            "https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html",
            "https://redis.io/docs/latest/operate/oss_and_stack/management/replication/",
            "https://jepsen.io/analyses/redis-raft",
        ],
    },
    "w9-4": {
        lessonId: "w9-4",
        background: [
            "【Redisson】Java 生态最流行的 Redis 客户端，提供完善的分布式锁实现，包括看门狗自动续期。",
            "【看门狗机制】Redisson 的 watchdog：后台线程定期检查锁是否仍被持有，自动续期。默认 30 秒过期，每 10 秒续期。",
            "【可重入锁】Redisson 的 RLock 支持可重入：同一线程可以多次获取同一把锁，需要相同次数的 unlock 才能释放。",
            "【公平锁】RFairLock：按请求顺序获取锁，避免饥饿。通过 Redis 的有序集合实现排队。",
            "【红锁实现】Redisson 提供 RedissonRedLock，封装了 Redlock 算法的实现。",
        ],
        keyDifficulties: [
            "【锁泄漏】如果忘记 unlock 且看门狗一直续期，锁永远不会释放。必须用 try-finally 确保释放。",
            "【线程中断】如果持有锁的线程被中断，看门狗可能停止续期，锁会过期。需要正确处理中断。",
            "【连接断开】如果 Redis 连接断开，看门狗无法续期。Redisson 有重连机制，但期间锁可能过期。",
            "【性能考量】看门狗增加了 Redis 的负载。高并发场景需要评估续期请求的影响。",
        ],
        handsOnPath: [
            "用 Redisson 实现分布式锁，测试看门狗行为。",
            "测试可重入锁：同一线程多次 lock/unlock。",
            "测试公平锁：多个线程竞争，观察获取顺序。",
            "模拟 Redis 连接断开，观察锁的行为。",
            "配置锁的过期时间和看门狗参数，找到适合业务的配置。",
        ],
        selfCheck: [
            "Redisson 的看门狗机制如何工作？默认配置是什么？",
            "如果指定了 leaseTime，看门狗还会工作吗？",
            "可重入锁如何实现？有什么注意事项？",
            "公平锁和非公平锁的区别是什么？什么时候用公平锁？",
            "如何避免锁泄漏？",
        ],
        extensions: [
            "研究 Redisson 的联锁（MultiLock）和红锁实现。",
            "学习 Redisson 的读写锁（RReadWriteLock）。",
            "了解 Redisson 的信号量（RSemaphore）和闭锁（RCountDownLatch）。",
            "研究 Spring Integration 的 LockRegistry 抽象。",
        ],
        sourceUrls: [
            "https://redisson.org/glossary/java-distributed-lock.html",
            "https://github.com/redisson/redisson/wiki/8.-Distributed-locks-and-synchronizers",
            "https://www.baeldung.com/redis-redisson",
        ],
    },
}

export const week9Quizzes: Record<string, QuizQuestion[]> = {
    "w9-1": [
        {
            id: "w9-1-q1",
            question: "为什么 SETNX + EXPIRE 两条命令实现分布式锁不够安全？",
            options: [
                "太慢了",
                "两条命令之间客户端可能崩溃，导致锁没有过期时间",
                "Redis 不支持这两个命令",
                "会覆盖已有的锁",
            ],
            answer: 1,
            rationale: "SETNX 成功后、EXPIRE 之前客户端崩溃，锁就没有过期时间，会导致死锁。应该用 SET NX PX 原子命令。",
        },
        {
            id: "w9-1-q2",
            question: "Redis SET 命令的 NX 和 PX 参数分别是什么意思？",
            options: [
                "NX=新建，PX=像素",
                "NX=仅当 key 不存在时设置，PX=过期时间（毫秒）",
                "NX=下一个，PX=前一个",
                "NX=不执行，PX=执行",
            ],
            answer: 1,
            rationale: "NX = Not eXists，只有 key 不存在时才设置。PX = 过期时间，单位毫秒（EX 是秒）。",
        },
        {
            id: "w9-1-q3",
            question: "为什么分布式锁的值应该用唯一标识符（如 UUID）？",
            options: [
                "方便调试",
                "防止释放锁时误删其他客户端持有的锁",
                "提高性能",
                "Redis 要求必须使用 UUID",
            ],
            answer: 1,
            rationale: "锁过期后可能被其他客户端获取。如果不检查锁的值，原客户端可能删除新持有者的锁。UUID 用于验证身份。",
        },
        {
            id: "w9-1-q4",
            question: "释放 Redis 分布式锁时为什么要用 Lua 脚本？",
            options: [
                "Lua 更快",
                "保证「检查值」和「删除 key」两步操作的原子性",
                "Redis 只支持 Lua",
                "Lua 语法更简单",
            ],
            answer: 1,
            rationale: "需要先检查锁的值是否是自己的，再删除。如果分成两条命令，中间可能发生竞态。Lua 脚本在 Redis 中原子执行。",
        },
        {
            id: "w9-1-q5",
            question: "锁的过期时间设置太短会有什么问题？",
            options: [
                "性能下降",
                "业务未完成锁就过期，其他客户端可能同时操作",
                "Redis 内存不足",
                "网络延迟增加",
            ],
            answer: 1,
            rationale: "如果业务执行时间超过锁的过期时间，锁会自动释放。其他客户端可以获取锁，导致多个客户端同时操作资源。",
        },
        {
            id: "w9-1-q6",
            question: "什么是看门狗（watchdog）机制？",
            options: [
                "监控 Redis 健康状态",
                "后台线程定期续期锁的过期时间",
                "检测死锁",
                "防止恶意访问",
            ],
            answer: 1,
            rationale: "看门狗是后台线程，在锁持有期间定期延长锁的过期时间，防止业务执行时间超过预期导致锁意外释放。",
        },
        {
            id: "w9-1-q7",
            question: "单 Redis 实例的分布式锁面临什么最大风险？",
            options: [
                "性能瓶颈",
                "单点故障，Redis 宕机导致锁服务不可用",
                "数据类型限制",
                "内存限制",
            ],
            answer: 1,
            rationale: "单实例的最大风险是单点故障。如果 Redis 宕机，整个锁服务不可用。主从切换时也可能丢失锁。",
        },
        {
            id: "w9-1-q8",
            question: "以下哪个是正确的 Redis 分布式锁获取命令？",
            options: [
                "SETNX key value",
                "SET key value NX PX 30000",
                "LOCK key 30000",
                "ACQUIRE key value",
            ],
            answer: 1,
            rationale: "SET key value NX PX 30000 原子地：设置 key（如果不存在）+ 设置 30 秒过期时间。是推荐的方式。",
        },
        {
            id: "w9-1-q9",
            question: "如果客户端在持有锁期间崩溃，会发生什么？",
            options: [
                "锁永远不释放",
                "锁在过期时间到达后自动释放",
                "Redis 自动检测并释放",
                "其他客户端无法获取锁",
            ],
            answer: 1,
            rationale: "这就是为什么锁必须有过期时间。即使客户端崩溃无法主动释放，锁也会在过期后自动释放。",
        },
        {
            id: "w9-1-q10",
            question: "Redis 主从复制对分布式锁有什么影响？",
            options: [
                "无影响",
                "异步复制可能导致主节点写入的锁在切换后丢失",
                "从节点可以释放主节点的锁",
                "锁会自动同步到所有节点",
            ],
            answer: 1,
            rationale: "Redis 主从复制是异步的。如果主节点写入锁后立即宕机，从节点提升为主但可能没有这个锁，导致锁丢失。",
        },
        {
            id: "w9-1-q11",
            question: "锁续期的典型实现方式是什么？",
            options: [
                "每次操作前手动续期",
                "后台线程定期执行 PEXPIRE 延长过期时间",
                "设置无限过期时间",
                "Redis 自动续期",
            ],
            answer: 1,
            rationale: "典型实现是后台守护线程（看门狗），在锁过期前执行 PEXPIRE 命令延长过期时间，如每 10 秒续期到 30 秒。",
        },
        {
            id: "w9-1-q12",
            question: "为什么需要在获取锁时设置过期时间而不是之后设置？",
            options: [
                "Redis 要求",
                "保证获取锁和设置过期的原子性，避免锁没有过期时间",
                "性能更好",
                "可以覆盖已有的锁",
            ],
            answer: 1,
            rationale: "分开设置时，如果第一步成功第二步失败（网络问题、崩溃），锁就没有过期时间。SET NX PX 是原子的。",
        },
    ],
    "w9-2": [
        {
            id: "w9-2-q1",
            question: "Redlock 算法使用多少个 Redis 实例？",
            options: [
                "2 个",
                "建议 5 个，至少 3 个奇数",
                "必须 10 个",
                "1 个就够",
            ],
            answer: 1,
            rationale: "Redlock 建议使用 5 个独立的 Redis 实例，需要在大多数（N/2+1，即 3 个）上获取锁才算成功。",
        },
        {
            id: "w9-2-q2",
            question: "Redlock 算法中，获取锁成功的条件是什么？",
            options: [
                "在所有实例上获取成功",
                "在大多数实例（N/2+1）上获取成功，且总时间小于过期时间",
                "在任意一个实例上获取成功",
                "在第一个实例上获取成功",
            ],
            answer: 1,
            rationale: "需要在大多数实例上成功获取锁，且获取锁的总时间必须小于锁的过期时间，否则锁可能已经过期。",
        },
        {
            id: "w9-2-q3",
            question: "如果 Redlock 获取锁失败，应该怎么做？",
            options: [
                "立即重试",
                "在所有实例上释放已获取的锁，随机延迟后重试",
                "只在失败的实例上重试",
                "放弃获取",
            ],
            answer: 1,
            rationale: "失败后必须在所有实例上释放（即使某些实例没获取成功），然后随机延迟后重试，避免多个客户端同时重试冲突。",
        },
        {
            id: "w9-2-q4",
            question: "Martin Kleppmann 对 Redlock 的主要质疑是什么？",
            options: [
                "算法太复杂",
                "客户端暂停（如 GC）期间锁可能过期，但客户端不知道",
                "Redis 性能不够",
                "需要太多实例",
            ],
            answer: 1,
            rationale: "Kleppmann 指出：如果客户端在获取锁后发生长时间 GC，锁可能过期被其他客户端获取，但原客户端恢复后不知道这一点。",
        },
        {
            id: "w9-2-q5",
            question: "什么是 fencing token？",
            options: [
                "防火墙令牌",
                "单调递增的数字，资源端用于拒绝旧 token 的操作",
                "加密令牌",
                "访问令牌",
            ],
            answer: 1,
            rationale: "fencing token 是每次获取锁时分配的单调递增数字。资源（如数据库）检查 token，拒绝比当前更小的 token 的操作。",
        },
        {
            id: "w9-2-q6",
            question: "Redlock 的 Redis 实例之间应该是什么关系？",
            options: [
                "主从复制",
                "完全独立，不能有复制关系",
                "集群模式",
                "哨兵模式",
            ],
            answer: 1,
            rationale: "Redlock 要求 N 个实例完全独立，不能有复制关系。复制会导致锁状态不一致，破坏算法的容错性。",
        },
        {
            id: "w9-2-q7",
            question: "为什么获取锁的总时间必须小于过期时间？",
            options: [
                "Redis 要求",
                "如果获取太慢，先获取的锁可能已经过期",
                "提高性能",
                "减少网络请求",
            ],
            answer: 1,
            rationale: "假设过期时间 30 秒，获取花了 25 秒。剩余有效时间只有 5 秒，可能不够完成业务，且期间锁可能被其他人获取。",
        },
        {
            id: "w9-2-q8",
            question: "Redlock 算法假设什么条件成立？",
            options: [
                "网络完全可靠",
                "进程不会暂停太久，时钟漂移在可接受范围",
                "Redis 永不宕机",
                "所有客户端同步",
            ],
            answer: 1,
            rationale: "Redlock 假设进程不会有太长的暂停（如 GC），且机器的时钟漂移在可接受范围内。这些假设可能被违反。",
        },
        {
            id: "w9-2-q9",
            question: "antirez（Redis 作者）如何回应 Kleppmann 的质疑？",
            options: [
                "承认 Redlock 不安全",
                "认为在实际场景中假设足够合理，fencing token 不现实",
                "修改了 Redlock 算法",
                "没有回应",
            ],
            answer: 1,
            rationale: "antirez 认为 Redlock 的假设在实际场景中是合理的，而 fencing token 需要资源端配合，很多场景无法实现。",
        },
        {
            id: "w9-2-q10",
            question: "在 5 个 Redis 实例的 Redlock 中，最多允许几个实例宕机？",
            options: [
                "0 个",
                "2 个（只要大多数 3 个可用）",
                "4 个",
                "所有都不能宕机",
            ],
            answer: 1,
            rationale: "只需要在大多数（5/2+1=3）实例上获取锁成功即可，所以最多允许 2 个实例宕机。",
        },
        {
            id: "w9-2-q11",
            question: "Redlock 中为什么要随机延迟后重试？",
            options: [
                "减少 Redis 负载",
                "避免多个客户端同时重试导致的活锁",
                "等待网络恢复",
                "Redis 要求",
            ],
            answer: 1,
            rationale: "如果所有失败的客户端同时重试，可能再次冲突。随机延迟错开重试时间，提高获取锁的成功率。",
        },
        {
            id: "w9-2-q12",
            question: "与单实例 Redis 锁相比，Redlock 的主要优势是什么？",
            options: [
                "性能更高",
                "容忍部分实例故障，避免单点失败",
                "实现更简单",
                "过期时间更准确",
            ],
            answer: 1,
            rationale: "Redlock 使用多个独立实例，即使部分实例宕机，只要大多数可用就能正常工作，避免了单点故障。",
        },
    ],
    "w9-3": [
        {
            id: "w9-3-q1",
            question: "Martin Kleppmann 定义的「效率锁」和「正确性锁」有什么区别？",
            options: [
                "效率锁更快",
                "效率锁容忍偶尔失效，正确性锁不能容忍任何失效",
                "正确性锁更复杂",
                "没有区别",
            ],
            answer: 1,
            rationale: "效率锁防止重复工作（偶尔失效只是浪费资源）；正确性锁保证数据正确性（失效可能导致数据损坏）。",
        },
        {
            id: "w9-3-q2",
            question: "Redis 分布式锁更适合哪种场景？",
            options: [
                "银行转账",
                "防止定时任务重复执行",
                "分布式事务",
                "强一致性要求的场景",
            ],
            answer: 1,
            rationale: "Redis 锁适合效率锁场景：如防止重复执行、限流等。不适合需要强一致性保证的场景（如金融交易）。",
        },
        {
            id: "w9-3-q3",
            question: "Redis 异步复制如何导致锁丢失？",
            options: [
                "复制太慢",
                "主节点写入锁后宕机，从节点提升但没有锁数据",
                "从节点可以覆盖锁",
                "复制会删除锁",
            ],
            answer: 1,
            rationale: "主节点设置锁后还没复制到从节点就宕机。从节点提升为主，但它没有这个锁，其他客户端可以再次获取。",
        },
        {
            id: "w9-3-q4",
            question: "GC 暂停如何影响分布式锁？",
            options: [
                "GC 会删除锁",
                "GC 期间客户端无法续期，锁可能过期但客户端不知道",
                "GC 会让锁永不过期",
                "GC 与锁无关",
            ],
            answer: 1,
            rationale: "长时间 GC 暂停期间，客户端无法续期，锁可能过期被其他客户端获取。GC 结束后，原客户端不知道锁已丢失。",
        },
        {
            id: "w9-3-q5",
            question: "为什么幂等性设计能帮助应对锁失效？",
            options: [
                "提高性能",
                "即使操作重复执行也不会导致错误结果",
                "减少锁使用",
                "加速锁获取",
            ],
            answer: 1,
            rationale: "如果业务操作是幂等的，即使锁失效导致重复执行，结果也是正确的。这是一种防御性设计。",
        },
        {
            id: "w9-3-q6",
            question: "网络分区对 Redis 锁有什么影响？",
            options: [
                "无影响",
                "客户端可能无法访问持有锁的 Redis，或多个客户端认为自己持有锁",
                "锁自动释放",
                "锁永不过期",
            ],
            answer: 1,
            rationale: "网络分区时，客户端可能与 Redis 断开，无法续期导致锁过期。或者分区双侧的客户端各自认为持有锁。",
        },
        {
            id: "w9-3-q7",
            question: "租约（lease）机制的本质限制是什么？",
            options: [
                "性能差",
                "无法完全解决分布式系统的异步性问题",
                "实现复杂",
                "不支持续期",
            ],
            answer: 1,
            rationale: "租约依赖时间来判断有效性，但分布式系统是异步的（网络延迟、进程暂停不确定），总有时间窗口可能出问题。",
        },
        {
            id: "w9-3-q8",
            question: "什么场景下绝对不应该使用 Redis 分布式锁？",
            options: [
                "高并发场景",
                "需要强一致性保证、数据损坏不可接受的场景",
                "单机部署",
                "短时间锁",
            ],
            answer: 1,
            rationale: "当锁失效会导致严重后果（如资金损失、数据不一致）时，不应该依赖 Redis 锁，应该用 ZooKeeper/etcd 等强一致性方案。",
        },
        {
            id: "w9-3-q9",
            question: "如何监控 Redis 分布式锁的健康状态？",
            options: [
                "不需要监控",
                "监控锁获取耗时、持有时长、过期事件、续期失败",
                "只监控 Redis 内存",
                "只监控网络延迟",
            ],
            answer: 1,
            rationale: "应该监控：锁获取成功率和耗时、锁持有时长、意外过期事件、续期失败次数等，及时发现问题。",
        },
        {
            id: "w9-3-q10",
            question: "补偿机制在 Redis 锁失效场景中的作用是什么？",
            options: [
                "防止锁失效",
                "在锁失效导致问题后，通过对账等方式修复数据",
                "自动重试",
                "加速锁获取",
            ],
            answer: 1,
            rationale: "假设锁可能失效，设计补偿机制（如定期对账、最终一致性校验）来发现和修复因锁失效导致的数据问题。",
        },
        {
            id: "w9-3-q11",
            question: "Redis Sentinel 能解决分布式锁的单点问题吗？",
            options: [
                "完全解决",
                "部分解决，但主从切换时仍可能丢锁",
                "使问题更严重",
                "Sentinel 与锁无关",
            ],
            answer: 1,
            rationale: "Sentinel 提供自动故障转移，提高可用性。但主从复制是异步的，切换时仍可能丢失还未复制的锁。",
        },
        {
            id: "w9-3-q12",
            question: "「足够好」的分布式锁设计原则是什么？",
            options: [
                "追求完美的正确性",
                "理解风险，接受极低概率的失效，做好监控和补偿",
                "完全不使用锁",
                "只用本地锁",
            ],
            answer: 1,
            rationale: "很多业务可以接受极低概率的锁失效。重要的是理解风险、做好监控和补偿，而不是追求不可能的完美。",
        },
    ],
    "w9-4": [
        {
            id: "w9-4-q1",
            question: "Redisson 的看门狗默认配置是什么？",
            options: [
                "10 秒过期，5 秒续期",
                "30 秒过期，每 10 秒续期",
                "60 秒过期，每 30 秒续期",
                "不自动续期",
            ],
            answer: 1,
            rationale: "Redisson 默认 lockWatchdogTimeout=30 秒，看门狗每 10 秒（1/3 过期时间）检查并续期。",
        },
        {
            id: "w9-4-q2",
            question: "如果指定了 leaseTime 参数，Redisson 的看门狗会怎样？",
            options: [
                "仍然续期",
                "不会启动，锁在 leaseTime 后过期",
                "更频繁地续期",
                "报错",
            ],
            answer: 1,
            rationale: "指定 leaseTime 表示用户明确知道锁的最大持有时间，看门狗不会启动。锁会在指定时间后过期。",
        },
        {
            id: "w9-4-q3",
            question: "Redisson 的 RLock 支持什么特性？",
            options: [
                "只支持基本锁",
                "支持可重入，同一线程可多次获取同一把锁",
                "不支持超时",
                "不支持异步",
            ],
            answer: 1,
            rationale: "RLock 是可重入锁：同一线程可以多次 lock()，内部维护计数器，需要相同次数的 unlock() 才能完全释放。",
        },
        {
            id: "w9-4-q4",
            question: "Redisson 的公平锁（RFairLock）有什么特点？",
            options: [
                "随机分配锁",
                "按请求顺序获取锁，避免饥饿",
                "性能最好",
                "不支持续期",
            ],
            answer: 1,
            rationale: "公平锁按照请求的先后顺序分配锁，先请求的先获取，避免某些线程一直等待（饥饿）。通过 Redis 有序集合实现排队。",
        },
        {
            id: "w9-4-q5",
            question: "如何避免 Redisson 的锁泄漏？",
            options: [
                "不需要担心",
                "使用 try-finally 确保 unlock，或指定 leaseTime",
                "多调用几次 unlock",
                "重启应用",
            ],
            answer: 1,
            rationale: "必须在 finally 块中调用 unlock()，或指定 leaseTime 让锁自动过期。否则看门狗会一直续期，锁永不释放。",
        },
        {
            id: "w9-4-q6",
            question: "Redisson 如何实现可重入锁？",
            options: [
                "每次获取创建新锁",
                "用 Hash 存储锁信息，value 是线程标识和重入次数",
                "不记录重入次数",
                "用多个 key",
            ],
            answer: 1,
            rationale: "Redisson 用 Redis Hash 存储：field 是线程标识，value 是重入次数。每次 lock +1，unlock -1，归零时删除。",
        },
        {
            id: "w9-4-q7",
            question: "Redisson 的 tryLock(waitTime, leaseTime, unit) 方法的 waitTime 参数是什么意思？",
            options: [
                "锁的有效时间",
                "最多等待多长时间获取锁",
                "续期间隔",
                "重试次数",
            ],
            answer: 1,
            rationale: "waitTime 是等待获取锁的最长时间。如果在 waitTime 内获取到锁返回 true，超时返回 false。",
        },
        {
            id: "w9-4-q8",
            question: "持有锁的线程被中断会发生什么？",
            options: [
                "锁立即释放",
                "看门狗可能停止续期，锁会在过期后释放",
                "抛出异常",
                "锁永不释放",
            ],
            answer: 1,
            rationale: "线程中断可能导致看门狗线程也受影响。如果续期停止，锁会在过期时间到达后自动释放。",
        },
        {
            id: "w9-4-q9",
            question: "Redisson 的 RedissonRedLock 是什么？",
            options: [
                "红色主题的锁",
                "Redlock 算法的封装，使用多个 Redis 实例",
                "只读锁",
                "本地锁",
            ],
            answer: 1,
            rationale: "RedissonRedLock 封装了 Redlock 算法，可以传入多个 RLock（来自不同 Redis 实例），内部实现大多数获取逻辑。",
        },
        {
            id: "w9-4-q10",
            question: "Redisson 的 RReadWriteLock 提供什么功能？",
            options: [
                "只有读锁",
                "读写分离的锁，多读互斥写",
                "只有写锁",
                "与普通锁相同",
            ],
            answer: 1,
            rationale: "RReadWriteLock 提供分布式读写锁：多个读锁可以同时持有，写锁是排他的。适合读多写少的场景。",
        },
        {
            id: "w9-4-q11",
            question: "Redis 连接断开对 Redisson 锁有什么影响？",
            options: [
                "无影响",
                "看门狗无法续期，锁可能过期",
                "锁立即释放",
                "锁永不过期",
            ],
            answer: 1,
            rationale: "连接断开期间，看门狗无法向 Redis 发送续期命令。如果断开时间超过锁的剩余有效期，锁会过期。",
        },
        {
            id: "w9-4-q12",
            question: "Redisson 锁的 unlock() 在什么情况下会抛异常？",
            options: [
                "任何时候都不会",
                "尝试释放不是自己持有的锁时",
                "Redis 连接正常时",
                "锁未过期时",
            ],
            answer: 1,
            rationale: "如果尝试 unlock() 一个不是当前线程持有的锁，Redisson 会抛 IllegalMonitorStateException。",
        },
    ],
}
