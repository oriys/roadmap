import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week1Guides: Record<string, LessonGuide> = {
    "w1-1": {
        lessonId: "w1-1",
        background: [
            "【核心概念】OSTEP 教材指出：'A thread is very much like a separate process, except for one difference: they share the same address space and thus can access the same data.'——线程与进程的关键区别在于地址空间共享。",
            "【设计原理】Rob Pike 在 Go Concurrency Patterns 中阐述：'Concurrency is about composition of independently executing computations'——并发的本质是独立执行的计算的组合，而非简单的并行。",
            "【Go 哲学】Go 语言倡导 'Don't communicate by sharing memory, share memory by communicating'——通过通信共享内存，而非通过共享内存通信，这颠覆了传统线程模型。",
            "【Goroutine 特性】Go 官方文档：Goroutine 是 'very cheap threads'，拥有动态增长的栈，可以创建数百万个，由 Go 运行时调度到 OS 线程上。",
            "【进程隔离代价】进程间隔离提供了安全性，但进程间通信（IPC）开销大；线程共享内存高效但需要同步；协程是用户态调度，更轻量。",
        ],
        keyDifficulties: [
            "【概念混淆】并发（Concurrency）与并行（Parallelism）是不同概念：并发是结构设计，并行是执行方式。单核 CPU 上的并发程序无法并行，但设计良好的并发程序可在多核上高效并行。",
            "【共享内存风险】OSTEP 警告：'The heart of the problem is uncontrolled scheduling'——调度的不确定性是共享内存编程困难的根源。",
            "【选择困难】何时用进程、线程、协程？进程适合隔离性要求高的场景；线程适合需要共享大量数据的 CPU 密集任务；协程适合 I/O 密集的高并发场景。",
            "【Go 特殊性】Go 的 Goroutine 不是真正的线程，而是 M:N 调度模型——M 个 goroutine 复用 N 个 OS 线程，由 Go 运行时管理。",
        ],
        handsOnPath: [
            "创建一个简单的多线程程序，观察不同线程访问共享变量时的行为差异。",
            "用 Go 编写 goroutine 示例：`go func() { ... }()`，体会 goroutine 的轻量特性。",
            "实现 Generator 模式：函数返回 channel，goroutine 持续生产数据。",
            "用 Fan-In 模式合并多个 channel 的输出到单一 channel。",
            "对比进程创建、线程创建、goroutine 创建的开销（用 time 测量）。",
        ],
        selfCheck: [
            "什么是并发？什么是并行？它们的区别是什么？",
            "为什么说 'Don't communicate by sharing memory, share memory by communicating'？",
            "Goroutine 与 OS 线程有什么区别？为什么 goroutine 更轻量？",
            "进程、线程、协程各自的优缺点是什么？分别适合什么场景？",
            "什么是 M:N 调度模型？Go 运行时如何调度 goroutine？",
        ],
        extensions: [
            "阅读 OSTEP 第 26 章 'Concurrency: An Introduction'，深入理解线程抽象。",
            "学习 Go 的 GPM 调度模型（Goroutine、Processor、Machine）。",
            "研究 Erlang 的 Actor 模型与 Go Channel 的异同。",
            "了解 Linux 内核的进程/线程实现（clone 系统调用）。",
        ],
        sourceUrls: [
            "https://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf",
            "https://www.kernel.org/doc/html/latest/admin-guide/mm/concepts.html",
            "https://go.dev/talks/2012/concurrency.slide",
        ],
    },
    "w1-2": {
        lessonId: "w1-2",
        background: [
            "【官方定义】CWE-362 定义：'A race condition occurs within concurrent environments, and it is effectively a property of a code sequence'——竞态条件是并发环境中代码序列的属性。",
            "【核心属性】竞态条件破坏两个关键属性：Exclusivity（排他性，其他代码不能修改共享资源）和 Atomicity（原子性，不能有其他线程同时执行相同指令）。",
            "【数据竞争定义】Go 官方：'A data race occurs when two goroutines access the same variable concurrently and at least one of the accesses is a write'——数据竞争需要三个条件同时满足。",
            "【安全后果】CWE 警告：竞态条件可导致 Availability（资源耗尽、崩溃）、Integrity（数据损坏）、Confidentiality（未授权访问）问题。",
            "【经典案例】CWE 提供的电商转账案例：两个并发请求可能都读取 $100 余额后各自转出 $40，导致总余额错误。",
        ],
        keyDifficulties: [
            "【TOCTOU 陷阱】Time-of-Check Time-of-Use 是常见竞态模式：检查条件和使用结果之间有时间窗口，攻击者可在此窗口修改状态。",
            "【看似原子的操作】Go 文档警告：即使简单的 `i++` 也不是原子操作，它包含读取、递增、写入三步，任何一步都可能被中断。",
            "【隐蔽性】数据竞争可能在测试中从不出现，但在生产环境高并发下爆发。ThreadSanitizer 等工具只能发现运行时实际发生的竞争。",
            "【循环变量捕获】Go 文档中的经典错误：`for i := 0; i < 5; i++ { go func() { fmt.Println(i) }() }`——goroutine 捕获的是变量 i 的引用而非值。",
        ],
        handsOnPath: [
            "用 Go 编写一个有数据竞争的计数器，运行多次观察不一致的结果。",
            "使用 `go run -race` 或 `go test -race` 检测数据竞争，分析输出报告。",
            "修复竞态问题：尝试用 sync.Mutex 和 atomic 两种方式。",
            "编译 C++ 程序时添加 `-fsanitize=thread` 选项，运行 ThreadSanitizer。",
            "模拟 TOCTOU 漏洞：先检查文件权限再读取，中间插入恶意修改。",
        ],
        selfCheck: [
            "数据竞争的三个必要条件是什么？",
            "为什么 `i++` 不是原子操作？它包含哪些步骤？",
            "TOCTOU 漏洞是什么？举一个例子说明。",
            "Go 的 race detector 如何工作？它能发现所有数据竞争吗？",
            "如何正确捕获循环变量到 goroutine 中？",
        ],
        extensions: [
            "研究 CWE-367 (TOCTOU) 的详细案例和防护措施。",
            "了解 Helgrind（Valgrind 的线程错误检测器）的原理。",
            "学习静态分析工具如何检测竞态条件。",
            "研究现实世界的竞态条件漏洞案例（如 CVE）。",
        ],
        sourceUrls: [
            "https://cwe.mitre.org/data/definitions/362.html",
            "https://go.dev/doc/articles/race_detector",
            "https://clang.llvm.org/docs/ThreadSanitizer.html",
        ],
    },
    "w1-3": {
        lessonId: "w1-3",
        background: [
            "【Java 内存模型】JLS 17.4 定义：'If a program has no data races, then all executions of the program will appear to be sequentially consistent'——无数据竞争的程序看起来是顺序一致的。",
            "【Happens-Before 定义】Happens-before 是偏序关系，定义了操作之间的可见性保证：如果 hb(x, y)，则 x 的结果对 y 可见。",
            "【Go 内存模型】Go 官方：'If you must read the rest of this document to understand the behavior of your program, you are being too clever. Don't be clever.'——强调避免依赖微妙的内存顺序。",
            "【DRF-SC 保证】Go 文档：Data-Race-Free 程序以顺序一致的方式执行——goroutine 看起来像是在单处理器上多路复用。",
            "【编译器重排序】Java 内存模型允许编译器在单线程内重排序指令，这可能导致多线程程序看到「不可能」的执行顺序。",
        ],
        keyDifficulties: [
            "【可见性问题】Java 文档示例：非 volatile 的 `while (!this.done)` 可能永远循环，因为编译器可能将 done 缓存到寄存器中，看不到其他线程的修改。",
            "【Happens-Before 规则】Java 的核心规则：synchronized 解锁 happens-before 后续加锁；volatile 写 happens-before 后续读；线程启动 happens-before 其第一个操作。",
            "【虚假唤醒】Java 和 Go 都警告：wait() 可能在没有 notify() 的情况下返回（spurious wakeup），必须在 while 循环中检查条件。",
            "【Double-Checked Locking 陷阱】Go 内存模型明确指出：观察到 `done == true` 不保证能观察到 `a = \"hello\"`，这是双重检查锁定失败的原因。",
        ],
        handsOnPath: [
            "编写一个 Java 程序，用非 volatile 变量做线程间通信，观察可见性问题。",
            "将变量改为 volatile，验证可见性得到保证。",
            "用 synchronized 块建立 happens-before 关系，确保共享状态的可见性。",
            "实现一个生产者-消费者模式，正确使用 wait/notify，处理虚假唤醒。",
            "用 Go 的 sync.Mutex 或 channel 建立同步关系，用 race detector 验证。",
        ],
        selfCheck: [
            "什么是 happens-before 关系？它解决了什么问题？",
            "Java 中 volatile 关键字提供了哪些保证？",
            "为什么 double-checked locking 在没有 volatile 的情况下是不安全的？",
            "什么是虚假唤醒（spurious wakeup）？如何正确处理？",
            "Go 的 DRF-SC 保证是什么意思？",
        ],
        extensions: [
            "深入阅读 JSR-133（Java Memory Model）规范。",
            "学习 C++11 内存模型与 Java/Go 的异同。",
            "研究 CPU 缓存一致性协议（MESI）如何影响内存可见性。",
            "了解 Linux 内核的内存屏障（memory barrier）机制。",
        ],
        sourceUrls: [
            "https://docs.oracle.com/javase/specs/jls/se21/html/jls-17.html#jls-17.4",
            "https://go.dev/ref/mem",
            "https://en.cppreference.com/w/cpp/language/memory_model",
        ],
    },
    "w1-4": {
        lessonId: "w1-4",
        background: [
            "【原子操作定义】C++ Reference：std::atomic 提供原子操作，'guarantees well-defined behavior when one thread writes to an atomic object while another thread reads from it'——消除数据竞争的未定义行为。",
            "【Java Atomic 包】Oracle 文档：java.util.concurrent.atomic 提供 'lock-free, thread-safe programming on single variables'——基于硬件原子指令的无锁编程。",
            "【Go sync/atomic】Go 官方：'These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package.'",
            "【CAS 原理】Compare-And-Swap 是原子操作的核心：比较内存值与期望值，相等则更新为新值，整个过程不可中断。",
            "【内存顺序】C++ 定义了多种 memory_order：relaxed（无同步）、acquire/release（单向屏障）、seq_cst（全序一致，默认最强）。",
        ],
        keyDifficulties: [
            "【非原子操作陷阱】Go 文档示例对比：`++acnt`（atomic）是线程安全的，`++cnt`（非 atomic）会丢失更新——10 个线程各递增 10000 次，非原子计数器可能只有 69696。",
            "【long/double 原子性】Java 规范：非 volatile 的 long/double 可能被写为两个 32 位操作，读取时可能看到中间状态。解决方案：使用 volatile 或 AtomicLong。",
            "【内存顺序选择】relaxed 性能最好但无同步保证；seq_cst 最安全但可能有性能开销。错误的内存顺序选择可能导致微妙的并发 bug。",
            "【原子类型限制】C++ 要求原子类型必须是 TriviallyCopyable；Go 要求原子类型在首次使用后不能被复制。",
        ],
        handsOnPath: [
            "用 Java AtomicInteger 实现线程安全计数器：`counter.incrementAndGet()`。",
            "用 Go atomic.Int64 实现相同功能：`counter.Add(1)`。",
            "用 C++ std::atomic<int> 实现并对比性能。",
            "实现 CAS 循环：读取旧值，计算新值，尝试 CAS 更新，失败则重试。",
            "测试不同并发度下原子操作 vs 互斥锁的性能差异。",
        ],
        selfCheck: [
            "什么是 CAS（Compare-And-Swap）操作？它如何保证原子性？",
            "为什么简单的 `i++` 不是线程安全的，而 AtomicInteger.incrementAndGet() 是？",
            "C++ 的 memory_order_relaxed 和 memory_order_seq_cst 有什么区别？",
            "Java 中为什么推荐使用 AtomicLong 而非 volatile long？",
            "Go 的 atomic 包为什么建议大多数情况下使用 channel 或 sync 包？",
        ],
        extensions: [
            "研究 x86 的 LOCK 前缀指令和 CMPXCHG 指令的实现。",
            "学习 ARM 的 LL/SC（Load-Linked/Store-Conditional）原子操作。",
            "了解 Java VarHandle API（Java 9+）提供的底层原子访问。",
            "研究 C++ std::atomic_ref（C++20）的用途。",
        ],
        sourceUrls: [
            "https://en.cppreference.com/w/cpp/atomic/atomic",
            "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/atomic/package-summary.html",
            "https://pkg.go.dev/sync/atomic",
        ],
    },
}

export const week1Quizzes: Record<string, QuizQuestion[]> = {
    "w1-1": [
        {
            id: "w1-1-q1",
            question: "根据 Rob Pike 的定义，并发（Concurrency）的本质是什么？",
            options: [
                "多个任务同时执行",
                "独立执行的计算的组合（composition of independently executing computations）",
                "使用多核 CPU 提高性能",
                "避免阻塞的编程技术",
            ],
            answer: 1,
            rationale: "Rob Pike 在 Go Concurrency Patterns 中明确指出：'Concurrency is about composition of independently executing computations'，并发是关于结构设计，而非简单的并行执行。",
        },
        {
            id: "w1-1-q2",
            question: "Go 语言的并发哲学是什么？",
            options: [
                "通过共享内存通信",
                "使用全局锁保护数据",
                "通过通信共享内存（share memory by communicating）",
                "避免使用并发",
            ],
            answer: 2,
            rationale: "Go 官方倡导 'Don't communicate by sharing memory, share memory by communicating'——这颠覆了传统的线程模型，用 channel 代替锁进行同步。",
        },
        {
            id: "w1-1-q3",
            question: "Goroutine 与 OS 线程相比，主要优势是什么？",
            options: [
                "更安全，不会发生数据竞争",
                "非常轻量（very cheap），可以创建数百万个",
                "自动分布到多核 CPU",
                "不需要同步原语",
            ],
            answer: 1,
            rationale: "Go 文档描述 goroutine 为 'very cheap threads'——拥有动态增长的栈，由 Go 运行时调度，创建开销远小于 OS 线程。",
        },
        {
            id: "w1-1-q4",
            question: "以下哪个是 Go select 语句的正确行为？",
            options: [
                "按顺序检查各个 case",
                "所有 channel 同时评估，随机选择一个就绪的",
                "总是选择第一个就绪的 channel",
                "阻塞直到所有 channel 都就绪",
            ],
            answer: 1,
            rationale: "Go 文档说明：select 语句 'All channels are evaluated simultaneously'，如果多个 channel 就绪，'pseudo-randomly chooses one'。",
        },
        {
            id: "w1-1-q5",
            question: "Fan-In 模式的作用是什么？",
            options: [
                "将一个 channel 分发到多个 goroutine",
                "将多个输入 channel 合并到一个输出 channel",
                "在多个 goroutine 间广播消息",
                "关闭不再需要的 channel",
            ],
            answer: 1,
            rationale: "Fan-In（扇入）模式用于将多个独立的输入 channel 复用到单一 channel，这是 Go 并发模式中的经典模式。",
        },
        {
            id: "w1-1-q6",
            question: "线程与进程的主要区别是什么？",
            options: [
                "线程不能访问文件系统",
                "线程共享同一地址空间，进程有独立地址空间",
                "进程比线程更轻量",
                "线程不能并行执行",
            ],
            answer: 1,
            rationale: "OSTEP 指出：'A thread is very much like a separate process, except for one difference: they share the same address space'——地址空间共享是关键区别。",
        },
        {
            id: "w1-1-q7",
            question: "Go 的超时模式如何实现？",
            options: [
                "在 channel 上设置超时参数",
                "使用 time.Sleep 主动等待",
                "在 select 中使用 time.After channel",
                "调用 goroutine 的 Cancel 方法",
            ],
            answer: 2,
            rationale: "Go 文档展示了超时模式：在 select 中添加 `case <-time.After(duration)` 分支，与其他 channel 竞争，实现超时控制。",
        },
        {
            id: "w1-1-q8",
            question: "根据 Go Concurrency Patterns，以下哪项不是 Go 并发编程的优势？",
            options: [
                "不需要锁、条件变量或回调",
                "简单的转换就能将顺序程序变为并发程序",
                "goroutine 之间不可能发生数据竞争",
                "能自然地表达独立、交互的组件",
            ],
            answer: 2,
            rationale: "Go 的并发模型避免了很多传统锁的复杂性，但 goroutine 之间仍然可能发生数据竞争——需要正确使用 channel 或 sync 包来避免。",
        },
        {
            id: "w1-1-q9",
            question: "Generator 模式中，函数返回的是什么？",
            options: [
                "一个普通的值",
                "一个 channel",
                "一个 goroutine 的引用",
                "一个 sync.WaitGroup",
            ],
            answer: 1,
            rationale: "Generator 模式中，函数返回一个 channel，内部启动 goroutine 持续向该 channel 发送数据，调用者通过读取 channel 获取结果。",
        },
        {
            id: "w1-1-q10",
            question: "Go 并发模型的历史渊源是什么？",
            options: [
                "Java 线程模型",
                "POSIX 线程标准",
                "Hoare 的 CSP（Communicating Sequential Processes）",
                "Actor 模型",
            ],
            answer: 2,
            rationale: "Go 文档指出其并发模型源自 Hoare's CSP (1978)，经过 Occam、Newsqueak、Alef 等语言的演进，最终形成 Go 的 channel 设计。",
        },
        {
            id: "w1-1-q11",
            question: "在 Google Search 3.0 示例中，使用 Replication 模式的目的是什么？",
            options: [
                "提高搜索结果的准确性",
                "返回最快响应的服务器的结果，降低延迟",
                "增加搜索结果的数量",
                "实现负载均衡",
            ],
            answer: 1,
            rationale: "Replication 模式向多个副本服务器发起请求，返回最先响应的结果（First 函数），从而降低整体延迟。",
        },
        {
            id: "w1-1-q12",
            question: "为什么 Go 更推荐使用 channel 而非 sync 包中的锁？",
            options: [
                "channel 性能更好",
                "channel 不会发生死锁",
                "对于复杂的并发交互，channel 更容易组合和推理",
                "sync 包已被废弃",
            ],
            answer: 2,
            rationale: "Rob Pike 指出 'Goroutines/channels for complex interactions; sync/atomic for simpler locking'——channel 更适合表达复杂的并发交互，而 sync 包适合简单场景。",
        },
    ],
    "w1-2": [
        {
            id: "w1-2-q1",
            question: "根据 CWE-362，竞态条件破坏的两个核心属性是什么？",
            options: [
                "安全性和可用性",
                "排他性（Exclusivity）和原子性（Atomicity）",
                "一致性和隔离性",
                "可见性和有序性",
            ],
            answer: 1,
            rationale: "CWE-362 明确指出竞态条件破坏 Exclusivity（其他代码不能修改共享资源）和 Atomicity（不能有其他线程同时执行相同指令）。",
        },
        {
            id: "w1-2-q2",
            question: "Go 中数据竞争发生的三个条件是什么？",
            options: [
                "两个线程、同一进程、读操作",
                "两个 goroutine 访问同一变量、并发、至少一个是写操作",
                "使用全局变量、无锁、多核 CPU",
                "共享内存、非原子操作、无同步",
            ],
            answer: 1,
            rationale: "Go 官方定义：'A data race occurs when two goroutines access the same variable concurrently and at least one of the accesses is a write'。",
        },
        {
            id: "w1-2-q3",
            question: "以下 Go 代码有什么问题？\n```go\nfor i := 0; i < 5; i++ {\n    go func() { fmt.Println(i) }()\n}\n```",
            options: [
                "语法错误",
                "goroutine 捕获了循环变量的引用，可能打印相同的值",
                "channel 没有正确关闭",
                "没有问题，输出 0-4",
            ],
            answer: 1,
            rationale: "Go race detector 文档中的经典错误：goroutine 捕获的是变量 i 的引用而非值，可能在循环结束后所有 goroutine 都看到 i=5。",
        },
        {
            id: "w1-2-q4",
            question: "如何正确修复上题的循环变量捕获问题？",
            options: [
                "使用 sync.Mutex 保护 i",
                "将 i 作为参数传递给闭包",
                "使用 atomic.Int32",
                "使用 channel 传递 i",
            ],
            answer: 1,
            rationale: "Go 文档推荐的修复方式：`go func(j int) { fmt.Println(j) }(i)`——将 i 作为参数传递，创建值的副本。",
        },
        {
            id: "w1-2-q5",
            question: "ThreadSanitizer 检测数据竞争时的性能开销大约是多少？",
            options: [
                "无性能开销",
                "2-3 倍",
                "5-15 倍时间，5-10 倍内存",
                "100 倍以上",
            ],
            answer: 2,
            rationale: "ThreadSanitizer 文档明确指出：'Typical slowdown is about 5x-15x. Typical memory overhead is about 5x-10x'。",
        },
        {
            id: "w1-2-q6",
            question: "什么是 TOCTOU（Time-of-Check Time-of-Use）漏洞？",
            options: [
                "检查和使用发生在同一原子操作中",
                "检查条件和使用结果之间有时间窗口，攻击者可在此窗口修改状态",
                "检查失败后重试的漏洞",
                "超时导致的安全问题",
            ],
            answer: 1,
            rationale: "CWE 和安全文档描述：TOCTOU 攻击利用检查和使用之间的时间窗口，攻击者可以在此期间修改被检查的资源。",
        },
        {
            id: "w1-2-q7",
            question: "以下哪种方法可以保护 Go 中对 map 的并发访问？",
            options: [
                "map 本身是线程安全的，无需保护",
                "使用 sync.Mutex 或 sync.RWMutex 保护",
                "使用 atomic 包操作 map",
                "复制 map 到每个 goroutine",
            ],
            answer: 1,
            rationale: "Go race detector 文档示例展示：使用 sync.Mutex 保护对 map 的并发访问，调用前 Lock()，完成后 Unlock()。",
        },
        {
            id: "w1-2-q8",
            question: "CWE-362 描述的竞态条件可能导致哪些后果？",
            options: [
                "仅导致程序崩溃",
                "仅导致数据不一致",
                "可用性、完整性、机密性都可能受影响",
                "仅影响性能",
            ],
            answer: 2,
            rationale: "CWE-362 警告竞态条件可影响：Availability（资源耗尽、崩溃）、Integrity（数据损坏）、Confidentiality（未授权访问）。",
        },
        {
            id: "w1-2-q9",
            question: "为什么 ThreadSanitizer 不适合在生产环境使用？",
            options: [
                "只能检测 C++ 程序",
                "可能影响程序的安全性，运行时不是为安全敏感场景设计的",
                "无法检测所有竞态条件",
                "需要 root 权限",
            ],
            answer: 1,
            rationale: "ThreadSanitizer 文档警告：'ThreadSanitizer's runtime was not developed with security-sensitive constraints in mind and may compromise the security of the resulting executable'。",
        },
        {
            id: "w1-2-q10",
            question: "Go 的 `go test -race` 命令的局限性是什么？",
            options: [
                "只能检测测试代码中的竞争",
                "只能发现运行时实际发生的数据竞争，需要充分的测试覆盖",
                "不支持并发测试",
                "会修改程序行为导致假阳性",
            ],
            answer: 1,
            rationale: "Go 文档强调：race detector 只能发现运行时实际执行路径上的数据竞争，因此需要 'adequate test coverage' 和 'realistic workloads'。",
        },
        {
            id: "w1-2-q11",
            question: "在 CWE 提供的电商案例中，两个并发转账请求如何导致余额错误？",
            options: [
                "网络延迟导致请求丢失",
                "数据库事务回滚",
                "两个请求都读取初始余额后各自扣款，导致少扣",
                "加密算法错误",
            ],
            answer: 2,
            rationale: "CWE-362 案例说明：两个并发请求可能都读取 $100 余额，然后各自转出金额，最终余额只反映一次扣款而非两次。",
        },
        {
            id: "w1-2-q12",
            question: "如何在 Go 中使用 atomic 包保护对整数的并发访问？",
            options: [
                "使用 atomic.Lock() 和 atomic.Unlock()",
                "使用 atomic.LoadInt64() 读取，atomic.StoreInt64() 写入",
                "将变量声明为 atomic int64",
                "使用 atomic.Wait() 等待",
            ],
            answer: 1,
            rationale: "Go race detector 文档示例：使用 atomic.StoreInt64() 写入，atomic.LoadInt64() 读取，确保对原始类型的原子访问。",
        },
    ],
    "w1-3": [
        {
            id: "w1-3-q1",
            question: "根据 Java 内存模型，无数据竞争的程序具有什么保证？",
            options: [
                "最高性能",
                "顺序一致性（sequentially consistent）",
                "无锁执行",
                "自动垃圾回收",
            ],
            answer: 1,
            rationale: "JLS 17.4 明确声明：'If a program has no data races, then all executions of the program will appear to be sequentially consistent'。",
        },
        {
            id: "w1-3-q2",
            question: "Java 中 volatile 变量提供了什么保证？",
            options: [
                "原子性和可见性",
                "对该变量的写 happens-before 所有后续读",
                "完全的线程安全",
                "防止死锁",
            ],
            answer: 1,
            rationale: "Java 内存模型规定：'A write to a volatile variable happens-before all subsequent reads of that variable'——这是 volatile 的核心语义。",
        },
        {
            id: "w1-3-q3",
            question: "为什么 `while (!this.done) Thread.sleep(1000);` 可能永远循环？",
            options: [
                "sleep 方法有 bug",
                "编译器可能将 done 缓存到寄存器，看不到其他线程的修改",
                "循环条件语法错误",
                "线程优先级问题",
            ],
            answer: 1,
            rationale: "Java 内存模型文档示例：对非 volatile 变量的读取可能被编译器缓存，导致看不到其他线程的写入。解决方案是将 done 声明为 volatile。",
        },
        {
            id: "w1-3-q4",
            question: "以下哪项是 Java 的 happens-before 规则？",
            options: [
                "所有写操作 happens-before 所有读操作",
                "synchronized 块的解锁 happens-before 后续对同一监视器的加锁",
                "main 方法 happens-before 所有其他方法",
                "静态变量的访问 happens-before 实例变量",
            ],
            answer: 1,
            rationale: "Java 内存模型核心规则之一：'An unlock on a monitor m happens-before all subsequent locks on m'。",
        },
        {
            id: "w1-3-q5",
            question: "Go 内存模型对开发者的建议是什么？",
            options: [
                "尽量使用低级原子操作提高性能",
                "如果需要阅读内存模型文档才能理解程序行为，说明代码太复杂了",
                "总是使用 channel 而非 mutex",
                "避免使用并发",
            ],
            answer: 1,
            rationale: "Go 内存模型明确建议：'If you must read the rest of this document to understand the behavior of your program, you are being too clever. Don't be clever.'",
        },
        {
            id: "w1-3-q6",
            question: "什么是虚假唤醒（spurious wakeup）？",
            options: [
                "notify 调用失败",
                "线程在没有 notify/notifyAll 的情况下从 wait 返回",
                "死锁的一种形式",
                "线程被错误地终止",
            ],
            answer: 1,
            rationale: "Java 和 Go 文档都警告：wait() 可能在没有 notify() 的情况下返回（spurious wakeup），必须在 while 循环中检查条件。",
        },
        {
            id: "w1-3-q7",
            question: "为什么 double-checked locking 在没有 volatile 的情况下可能失败？",
            options: [
                "检查两次浪费性能",
                "对象可能在构造完成前就被其他线程看到（部分构造）",
                "synchronized 块不能嵌套",
                "Java 不支持双重检查",
            ],
            answer: 1,
            rationale: "Go 内存模型示例说明：观察到 `done == true` 不保证能观察到相关的写入完成。类似地，Java 中需要 volatile 来建立 happens-before 关系。",
        },
        {
            id: "w1-3-q8",
            question: "Go 中 channel 操作的 happens-before 关系是什么？",
            options: [
                "读取 happens-before 发送",
                "发送 happens-before 对应的接收完成",
                "关闭 happens-before 发送",
                "创建 happens-before 所有操作",
            ],
            answer: 1,
            rationale: "Go 内存模型规定：'A send on a channel is synchronized before the completion of the corresponding receive from that channel'。",
        },
        {
            id: "w1-3-q9",
            question: "Java 中 final 字段提供了什么线程安全保证？",
            options: [
                "final 字段可以被多线程同时修改",
                "其他线程看到对象引用时，保证能看到 final 字段的正确值",
                "final 字段不需要同步就能修改",
                "final 字段自动变成 volatile",
            ],
            answer: 1,
            rationale: "Java 内存模型示例：'A thread seeing a reference to a completely initialized object is guaranteed to see correct values of final fields'——final 字段实现了安全发布。",
        },
        {
            id: "w1-3-q10",
            question: "为什么 Java 非 volatile 的 long/double 可能不是原子操作？",
            options: [
                "Java 不支持 64 位类型",
                "可能被写为两个 32 位操作，读取时可能看到中间状态",
                "long/double 太大无法放入缓存",
                "JVM 的 bug",
            ],
            answer: 1,
            rationale: "Java 规范允许：非 volatile 的 long/double 可能被实现为两个 32 位写操作，读取时可能看到只写了一半的值。",
        },
        {
            id: "w1-3-q11",
            question: "Go 中使用 sync.Once 的 happens-before 保证是什么？",
            options: [
                "Once.Do 的第一次调用 happens-before 所有后续调用",
                "f() 的单次执行 happens-before 任何 once.Do(f) 返回",
                "Once 的创建 happens-before Do 调用",
                "没有 happens-before 保证",
            ],
            answer: 1,
            rationale: "Go 内存模型规定：'The completion of a single call of f() from once.Do(f) is synchronized before the return of any call of once.Do(f)'。",
        },
        {
            id: "w1-3-q12",
            question: "以下哪个 Go 代码片段是正确使用 sync.Mutex 建立 happens-before 的？",
            options: [
                "不使用 Lock/Unlock，直接访问共享变量",
                "在一个 goroutine 中 Lock，在另一个中 Unlock",
                "写入共享变量后 Unlock，读取前 Lock",
                "只在读取时 Lock",
            ],
            answer: 2,
            rationale: "Go 内存模型示例展示：对于 sync.Mutex，'call n of l.Unlock() is synchronized before call m of l.Lock()'，必须配对使用。",
        },
    ],
    "w1-4": [
        {
            id: "w1-4-q1",
            question: "C++ std::atomic 的核心保证是什么？",
            options: [
                "完全避免锁的使用",
                "当一个线程写入原子对象而另一个读取时，行为是明确定义的",
                "自动并行化代码",
                "零性能开销的同步",
            ],
            answer: 1,
            rationale: "C++ Reference 明确：std::atomic 'guarantees well-defined behavior when one thread writes to an atomic object while another thread reads from it'。",
        },
        {
            id: "w1-4-q2",
            question: "Java atomic 包提供的编程模型是什么？",
            options: [
                "基于锁的同步",
                "无锁、线程安全的单变量编程（lock-free, thread-safe programming）",
                "事务内存",
                "软件事务内存",
            ],
            answer: 1,
            rationale: "Oracle 文档描述：java.util.concurrent.atomic 提供 'lock-free, thread-safe programming on single variables'。",
        },
        {
            id: "w1-4-q3",
            question: "CAS（Compare-And-Swap）操作的语义是什么？",
            options: [
                "交换两个变量的值",
                "比较内存值与期望值，相等则更新为新值，整个过程原子执行",
                "创建变量的原子副本",
                "同步两个线程的执行",
            ],
            answer: 1,
            rationale: "Go 和 Java 文档都描述 CAS 语义：`if *addr == old { *addr = new; return true } return false`，整个操作不可中断。",
        },
        {
            id: "w1-4-q4",
            question: "Go sync/atomic 文档对其使用的建议是什么？",
            options: [
                "应该在所有并发场景中使用",
                "仅用于特殊的底层应用，大多数情况下应使用 channel 或 sync 包",
                "是 Go 推荐的主要同步方式",
                "性能比 channel 差，应避免使用",
            ],
            answer: 1,
            rationale: "Go 官方建议：'Except for special, low-level applications, synchronization is better done with channels or the facilities of the sync package'。",
        },
        {
            id: "w1-4-q5",
            question: "以下 Go 代码的问题是什么？\n```go\nvar cnt int\nfor n := 0; n < 10000; n++ {\n    go func() { cnt++ }()\n}\n```",
            options: [
                "语法错误",
                "cnt++ 不是原子操作，存在数据竞争",
                "goroutine 数量太多",
                "缺少 return 语句",
            ],
            answer: 1,
            rationale: "Go atomic 文档示例对比：`++cnt`（非原子）会丢失更新，10 个线程各递增 10000 次可能得到远小于 100000 的结果。应使用 atomic.Int64。",
        },
        {
            id: "w1-4-q6",
            question: "C++ memory_order_seq_cst 提供什么保证？",
            options: [
                "最弱的同步保证，最高性能",
                "最强的顺序一致性保证（sequential consistency）",
                "仅保证单线程内的顺序",
                "仅保证释放语义",
            ],
            answer: 1,
            rationale: "C++ Reference 说明 memory_order_seq_cst 是默认且最强的内存顺序，提供全局的顺序一致性保证。",
        },
        {
            id: "w1-4-q7",
            question: "Java AtomicStampedReference 解决了什么问题？",
            options: [
                "性能问题",
                "ABA 问题（通过版本号/stamp 追踪）",
                "内存泄漏",
                "类型安全问题",
            ],
            answer: 1,
            rationale: "Java atomic 包文档说明：AtomicStampedReference 提供 'Reference + integer stamp'，用于追踪版本，解决 CAS 的 ABA 问题。",
        },
        {
            id: "w1-4-q8",
            question: "Go 1.19+ 推荐使用哪种方式进行原子操作？",
            options: [
                "继续使用函数式 API 如 atomic.AddInt64(&x, 1)",
                "使用类型化的值如 atomic.Int64，调用 x.Add(1)",
                "使用 sync.Mutex 代替",
                "使用 channel 代替",
            ],
            answer: 1,
            rationale: "Go 文档推荐现代用法：'Use typed values instead of function pointers'——`var x atomic.Int64; x.Add(1)` 更符合人体工程学且类型安全。",
        },
        {
            id: "w1-4-q9",
            question: "std::atomic<T> 对类型 T 有什么要求？",
            options: [
                "T 必须是基本类型",
                "T 必须是 TriviallyCopyable（平凡可复制）",
                "T 必须有默认构造函数",
                "T 不能是结构体",
            ],
            answer: 1,
            rationale: "C++ Reference 明确要求：std::atomic<T> 的 T 必须满足 TriviallyCopyable、CopyConstructible、CopyAssignable 等条件。",
        },
        {
            id: "w1-4-q10",
            question: "atomic.Value 的 Store/Load 对值类型有什么限制？",
            options: [
                "只能存储基本类型",
                "所有 Store 调用必须使用相同的具体类型",
                "每次 Store 可以使用不同类型",
                "只能存储指针类型",
            ],
            answer: 1,
            rationale: "Go atomic 文档警告：'All calls to Store must use values of the same concrete type'——类型不一致会 panic。",
        },
        {
            id: "w1-4-q11",
            question: "Java 中 LongAdder 相比 AtomicLong 的优势是什么？",
            options: [
                "支持更多操作",
                "在高竞争场景下有更好的性能（减少争用）",
                "占用更少内存",
                "支持任意类型",
            ],
            answer: 1,
            rationale: "Java atomic 包说明 LongAdder/LongAccumulator 用于 'high-performance numeric accumulation'——通过分散竞争降低争用。",
        },
        {
            id: "w1-4-q12",
            question: "C++ atomic 的 compare_exchange_weak 和 compare_exchange_strong 有什么区别？",
            options: [
                "weak 版本不提供原子保证",
                "weak 版本可能虚假失败（spurious failure），但在循环中可能更高效",
                "strong 版本性能更好",
                "它们完全相同",
            ],
            answer: 1,
            rationale: "C++ Reference 说明：compare_exchange_weak 可能虚假失败，但在某些平台上循环使用时性能更好；strong 保证只在值不匹配时失败。",
        },
    ],
}
