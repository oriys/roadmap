import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week7Guides: Record<string, LessonGuide> = {
    "w7-1": {
        lessonId: "w7-1",
        background: [
            "【ACID 定义】事务的四大特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。",
            "【原子性】事务中的操作要么全部成功，要么全部失败回滚。不会出现部分完成的状态。",
            "【一致性】事务将数据库从一个一致状态转换到另一个一致状态，满足所有约束条件。",
            "【隔离性】并发事务之间相互隔离，一个事务的中间状态对其他事务不可见（程度取决于隔离级别）。",
            "【持久性】事务一旦提交，其结果永久保存，即使系统崩溃也不会丢失。通过 WAL（Write-Ahead Logging）实现。",
        ],
        keyDifficulties: [
            "【一致性的两层含义】数据库一致性（满足约束）vs 应用一致性（业务逻辑正确）。数据库只保证前者。",
            "【CAP 与 ACID】分布式系统中 CAP 定理限制了 ACID 的实现。很多分布式数据库提供「最终一致性」而非严格 ACID。",
            "【性能权衡】严格的 ACID 保证需要更多的锁和日志，可能影响性能。需要根据业务需求权衡。",
            "【事务边界】事务应该尽量短，长事务持有锁时间长，影响并发性能且增加死锁风险。",
        ],
        handsOnPath: [
            "在 MySQL 中创建事务：BEGIN; 执行 SQL; COMMIT; 或 ROLLBACK;",
            "模拟原子性：转账操作中间步骤失败时自动回滚。",
            "测试持久性：提交事务后立即断电，重启后验证数据是否保存。",
            "用 SHOW ENGINE INNODB STATUS 查看事务状态和锁信息。",
            "对比自动提交（autocommit）和显式事务的行为差异。",
        ],
        selfCheck: [
            "ACID 的四个特性分别是什么意思？",
            "事务的原子性是如何实现的？",
            "什么是 WAL（Write-Ahead Logging）？它如何保证持久性？",
            "为什么说事务应该尽量短？",
            "一致性在数据库层面和应用层面有什么区别？",
        ],
        extensions: [
            "研究 MySQL InnoDB 的 undo log 和 redo log 机制。",
            "学习 PostgreSQL 的事务实现与 MySQL 的异同。",
            "了解分布式事务协议：2PC、3PC、Saga。",
            "研究 NewSQL 数据库（如 CockroachDB）如何在分布式环境实现 ACID。",
        ],
        sourceUrls: [
            "https://en.wikipedia.org/wiki/ACID",
            "https://www.postgresql.org/docs/current/tutorial-transactions.html",
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-model.html",
        ],
    },
    "w7-2": {
        lessonId: "w7-2",
        background: [
            "【四种隔离级别】SQL 标准定义：Read Uncommitted（最低）→ Read Committed → Repeatable Read → Serializable（最高）。",
            "【脏读】事务读取到其他未提交事务的修改。Read Uncommitted 允许，其他级别禁止。",
            "【不可重复读】同一事务内两次读取同一行，结果不同（被其他已提交事务修改）。Read Committed 允许，Repeatable Read 禁止。",
            "【幻读】同一事务内两次范围查询，结果集不同（有新行被插入或删除）。只有 Serializable 完全禁止。",
            "【MySQL 默认级别】InnoDB 默认使用 Repeatable Read，但通过 MVCC 和间隙锁部分解决了幻读。",
        ],
        keyDifficulties: [
            "【隔离级别选择】级别越高越安全但性能越差。大多数应用使用 Read Committed 或 Repeatable Read。",
            "【实现差异】不同数据库对同一隔离级别的实现可能不同。如 MySQL RR 和 PostgreSQL RR 行为有差异。",
            "【快照读 vs 当前读】MVCC 下普通 SELECT 是快照读（读历史版本），SELECT FOR UPDATE 是当前读（读最新并加锁）。",
            "【Serializable 的代价】真正的串行化可能需要锁定大量数据或检测冲突后回滚，性能开销大。",
        ],
        handsOnPath: [
            "用 SET TRANSACTION ISOLATION LEVEL 设置不同隔离级别。",
            "模拟脏读：在 Read Uncommitted 下读取未提交数据。",
            "模拟不可重复读：在 Read Committed 下两次读取同一行，中间有其他事务提交。",
            "模拟幻读：在 Repeatable Read 下执行范围查询，观察是否出现新行。",
            "对比 MySQL 和 PostgreSQL 在相同隔离级别下的行为差异。",
        ],
        selfCheck: [
            "四种隔离级别从低到高是什么？",
            "什么是脏读、不可重复读、幻读？",
            "为什么大多数应用不使用 Serializable？",
            "MySQL 的 Repeatable Read 能完全防止幻读吗？",
            "如何查看和设置当前会话的隔离级别？",
        ],
        extensions: [
            "研究 PostgreSQL 的 SSI（Serializable Snapshot Isolation）实现。",
            "学习 SQL:2011 标准中的隔离级别定义。",
            "了解 ANSI SQL 隔离级别的批评和 Snapshot Isolation 的提出。",
            "研究 TiDB 等 NewSQL 数据库的隔离级别实现。",
        ],
        sourceUrls: [
            "https://www.postgresql.org/docs/current/transaction-iso.html",
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html",
            "https://en.wikipedia.org/wiki/Isolation_(database_systems)",
        ],
    },
    "w7-3": {
        lessonId: "w7-3",
        background: [
            "【MVCC 定义】多版本并发控制：每行数据保存多个版本，读操作读取符合其事务快照的版本，无需阻塞写操作。",
            "【读不阻塞写】MVCC 的核心优势：读操作看到一致的历史快照，写操作创建新版本，两者互不干扰。",
            "【版本链】MySQL InnoDB 通过 undo log 实现版本链：每次修改生成新版本，旧版本通过 roll_pointer 链接。",
            "【Read View】事务开始时创建 Read View，记录当时活跃的事务 ID，决定哪些版本对当前事务可见。",
            "【PostgreSQL 实现】PostgreSQL 在表中直接存储多版本（xmin/xmax），通过 VACUUM 清理过期版本。",
        ],
        keyDifficulties: [
            "【版本可见性规则】版本对事务可见的条件：创建该版本的事务 ID < 当前事务 ID，且创建事务已提交。",
            "【undo log 膨胀】长事务会导致 undo log 无法清理，占用大量空间。需要及时提交事务。",
            "【MVCC 不解决所有问题】MVCC 主要优化读性能，写-写冲突仍需要锁来解决。",
            "【当前读绕过 MVCC】SELECT FOR UPDATE、UPDATE、DELETE 等是当前读，读取最新数据并加锁，不使用 MVCC。",
        ],
        handsOnPath: [
            "在两个会话中开启事务，观察一个事务的修改对另一个事务的可见性。",
            "用 MySQL 的 information_schema.innodb_trx 查看活跃事务。",
            "故意创建长事务，观察 undo log 增长（history list length）。",
            "对比 SELECT 和 SELECT FOR UPDATE 在并发修改场景下的行为。",
            "在 PostgreSQL 中使用 txid_current() 和 xmin/xmax 理解版本机制。",
        ],
        selfCheck: [
            "MVCC 如何实现读不阻塞写？",
            "什么是 Read View？它如何决定版本可见性？",
            "MySQL 和 PostgreSQL 的 MVCC 实现有什么区别？",
            "为什么长事务对 MVCC 系统有害？",
            "什么情况下会「绕过」MVCC 直接读取最新版本？",
        ],
        extensions: [
            "研究 MySQL 8.0 的新 undo log 架构。",
            "学习 PostgreSQL 的 HOT（Heap-Only Tuple）优化。",
            "了解 MVCC 的历史：从 Oracle 到现代数据库的演进。",
            "研究 SSI（Serializable Snapshot Isolation）如何在 MVCC 上实现可串行化。",
        ],
        sourceUrls: [
            "https://www.postgresql.org/docs/current/mvcc-intro.html",
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html",
            "https://en.wikipedia.org/wiki/Multiversion_concurrency_control",
        ],
    },
    "w7-4": {
        lessonId: "w7-4",
        background: [
            "【悲观锁】假设冲突会发生，先获取锁再操作。典型实现：SELECT FOR UPDATE。",
            "【乐观锁】假设冲突很少，先操作后检查。典型实现：版本号或时间戳检查。",
            "【版本号实现】表中增加 version 字段，UPDATE 时检查版本：UPDATE ... WHERE id=? AND version=?",
            "【冲突处理】乐观锁检测到冲突后通常重试或报错，需要应用层处理。",
            "【适用场景】悲观锁适合写冲突频繁的场景；乐观锁适合读多写少、冲突概率低的场景。",
        ],
        keyDifficulties: [
            "【乐观锁不是真的锁】乐观锁是一种并发控制策略，不使用数据库锁，而是通过版本检查实现。",
            "【ABA 问题】简单版本号可能有 ABA 问题（版本 1→2→1）。使用单调递增版本号或时间戳避免。",
            "【重试策略】乐观锁冲突后如何重试？重试次数限制？退避策略？需要仔细设计。",
            "【混合策略】实际系统可能混合使用：读用乐观锁，关键写操作用悲观锁。",
        ],
        handsOnPath: [
            "用 SELECT FOR UPDATE 实现悲观锁的库存扣减。",
            "用版本号实现乐观锁的库存扣减，处理冲突重试。",
            "benchmark 对比两种方式在不同并发度下的性能。",
            "实现带重试和指数退避的乐观锁更新。",
            "用 JPA/Hibernate 的 @Version 注解体验框架层乐观锁。",
        ],
        selfCheck: [
            "悲观锁和乐观锁的核心区别是什么？",
            "乐观锁如何检测冲突？冲突后怎么处理？",
            "什么场景适合悲观锁？什么场景适合乐观锁？",
            "乐观锁的版本号为什么要单调递增？",
            "SELECT FOR UPDATE 和普通 SELECT 有什么区别？",
        ],
        extensions: [
            "研究 CAS（Compare-And-Swap）与数据库乐观锁的关系。",
            "学习分布式环境下的乐观锁实现挑战。",
            "了解 ORM 框架（Hibernate、GORM）的乐观锁支持。",
            "研究电商秒杀场景的库存扣减最佳实践。",
        ],
        sourceUrls: [
            "https://martinfowler.com/eaaCatalog/optimisticOfflineLock.html",
            "https://www.baeldung.com/jpa-pessimistic-locking",
            "https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE",
        ],
    },
}

export const week7Quizzes: Record<string, QuizQuestion[]> = {
    "w7-1": [
        {
            id: "w7-1-q1",
            question: "ACID 中的 A（Atomicity）表示什么？",
            options: [
                "原子性：事务中的操作要么全部成功，要么全部回滚",
                "可用性",
                "一致性",
                "自动提交",
            ],
            answer: 0,
            rationale: "Atomicity（原子性）保证事务是不可分割的工作单元，所有操作要么全部完成，要么全部不做。",
        },
        {
            id: "w7-1-q2",
            question: "数据库如何保证持久性（Durability）？",
            options: [
                "使用更快的 CPU",
                "通过 WAL（Write-Ahead Logging）在提交前将日志写入磁盘",
                "增加内存",
                "使用 SSD",
            ],
            answer: 1,
            rationale: "WAL 确保事务提交前，其修改的日志先写入持久存储。即使崩溃，也能通过日志恢复已提交的事务。",
        },
        {
            id: "w7-1-q3",
            question: "以下哪个不是 ACID 特性？",
            options: [
                "原子性",
                "一致性",
                "可用性",
                "隔离性",
            ],
            answer: 2,
            rationale: "ACID 是 Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性）。可用性是 CAP 定理中的概念。",
        },
        {
            id: "w7-1-q4",
            question: "事务的隔离性是什么意思？",
            options: [
                "事务完全独立运行，不能并发",
                "并发事务之间相互隔离，中间状态不可见",
                "事务只能读取自己的数据",
                "数据库只允许一个连接",
            ],
            answer: 1,
            rationale: "隔离性使并发执行的事务看起来像是串行执行的，一个事务的中间状态对其他事务不可见（程度取决于隔离级别）。",
        },
        {
            id: "w7-1-q5",
            question: "为什么事务应该尽量短？",
            options: [
                "减少内存使用",
                "长事务持有锁时间长，影响并发性能并增加死锁风险",
                "数据库有时间限制",
                "短事务更安全",
            ],
            answer: 1,
            rationale: "长事务长时间持有锁，阻塞其他事务；积累的 undo log 无法清理；增加死锁概率。应尽快提交或回滚。",
        },
        {
            id: "w7-1-q6",
            question: "MySQL 中如何开始一个显式事务？",
            options: [
                "TRANSACTION START",
                "BEGIN 或 START TRANSACTION",
                "OPEN TRANSACTION",
                "NEW TRANSACTION",
            ],
            answer: 1,
            rationale: "MySQL 使用 BEGIN 或 START TRANSACTION 开始事务，COMMIT 提交，ROLLBACK 回滚。",
        },
        {
            id: "w7-1-q7",
            question: "事务回滚（ROLLBACK）的作用是什么？",
            options: [
                "提交事务",
                "撤销当前事务的所有修改，恢复到事务开始前的状态",
                "重启数据库",
                "清空表",
            ],
            answer: 1,
            rationale: "ROLLBACK 撤销当前事务中所有未提交的修改，数据库状态恢复到事务开始时的状态。",
        },
        {
            id: "w7-1-q8",
            question: "一致性（Consistency）在数据库层面的含义是什么？",
            options: [
                "所有副本数据相同",
                "事务执行前后，数据库满足所有约束条件",
                "数据不会丢失",
                "查询总是返回最新数据",
            ],
            answer: 1,
            rationale: "数据库层面的一致性指事务使数据库从一个满足约束的状态转换到另一个满足约束的状态。",
        },
        {
            id: "w7-1-q9",
            question: "autocommit 模式下，每条 SQL 语句会怎样？",
            options: [
                "等待显式提交",
                "自动成为一个独立事务并立即提交",
                "不执行",
                "加入当前事务",
            ],
            answer: 1,
            rationale: "autocommit=ON 时，每条 SQL 语句自动成为一个事务并立即提交。显式 BEGIN 会禁用 autocommit 直到 COMMIT/ROLLBACK。",
        },
        {
            id: "w7-1-q10",
            question: "redo log 的作用是什么？",
            options: [
                "记录删除的数据",
                "保证持久性：记录已提交的修改，崩溃恢复时重放",
                "记录查询日志",
                "记录用户登录",
            ],
            answer: 1,
            rationale: "redo log 记录已提交事务的物理修改。崩溃恢复时通过重放 redo log 恢复已提交但未写入数据文件的修改。",
        },
        {
            id: "w7-1-q11",
            question: "undo log 的作用是什么？",
            options: [
                "记录已提交的修改",
                "记录修改前的数据，用于回滚和 MVCC",
                "记录查询计划",
                "记录表结构",
            ],
            answer: 1,
            rationale: "undo log 记录修改前的数据版本。用于事务回滚时恢复数据，也用于 MVCC 提供历史版本的读取。",
        },
        {
            id: "w7-1-q12",
            question: "在分布式系统中，CAP 定理如何影响 ACID？",
            options: [
                "无影响",
                "网络分区时可能需要在一致性和可用性间权衡，完整 ACID 难以实现",
                "CAP 与 ACID 无关",
                "分布式系统不需要 ACID",
            ],
            answer: 1,
            rationale: "CAP 定理指出分布式系统不能同时保证 C（一致性）、A（可用性）、P（分区容忍）。很多系统为了可用性放松了一致性。",
        },
    ],
    "w7-2": [
        {
            id: "w7-2-q1",
            question: "SQL 标准定义的四种隔离级别从低到高是什么？",
            options: [
                "Serializable → Repeatable Read → Read Committed → Read Uncommitted",
                "Read Uncommitted → Read Committed → Repeatable Read → Serializable",
                "Read Committed → Read Uncommitted → Repeatable Read → Serializable",
                "Serializable → Read Committed → Repeatable Read → Read Uncommitted",
            ],
            answer: 1,
            rationale: "从低（最不严格）到高（最严格）：Read Uncommitted → Read Committed → Repeatable Read → Serializable。",
        },
        {
            id: "w7-2-q2",
            question: "什么是脏读（Dirty Read）？",
            options: [
                "读取过期数据",
                "读取到其他未提交事务的修改",
                "读取被删除的数据",
                "读取加密数据",
            ],
            answer: 1,
            rationale: "脏读是读取到其他事务尚未提交的修改。如果那个事务回滚，读取的数据就是「脏」的（无效的）。",
        },
        {
            id: "w7-2-q3",
            question: "什么隔离级别可以防止脏读？",
            options: [
                "只有 Serializable",
                "Read Committed 及以上",
                "只有 Repeatable Read",
                "任何级别都不能",
            ],
            answer: 1,
            rationale: "Read Committed 只读取已提交的数据，从而防止脏读。更高的隔离级别也能防止脏读。",
        },
        {
            id: "w7-2-q4",
            question: "什么是不可重复读（Non-repeatable Read）？",
            options: [
                "无法读取数据",
                "同一事务内两次读取同一行，结果不同（被其他已提交事务修改）",
                "读取速度慢",
                "读取返回 null",
            ],
            answer: 1,
            rationale: "不可重复读：事务 A 读取一行，事务 B 修改并提交，事务 A 再次读取同一行，结果与第一次不同。",
        },
        {
            id: "w7-2-q5",
            question: "什么是幻读（Phantom Read）？",
            options: [
                "读取不存在的表",
                "同一事务内两次范围查询，结果集行数不同（有新行被插入）",
                "读取到 null",
                "无法读取大数据",
            ],
            answer: 1,
            rationale: "幻读：事务 A 执行范围查询，事务 B 插入新行并提交，事务 A 再次执行相同范围查询，出现了新的「幻影」行。",
        },
        {
            id: "w7-2-q6",
            question: "MySQL InnoDB 的默认隔离级别是什么？",
            options: [
                "Read Uncommitted",
                "Read Committed",
                "Repeatable Read",
                "Serializable",
            ],
            answer: 2,
            rationale: "MySQL InnoDB 默认使用 Repeatable Read 隔离级别，通过 MVCC 和间隙锁提供较强的隔离保证。",
        },
        {
            id: "w7-2-q7",
            question: "PostgreSQL 的默认隔离级别是什么？",
            options: [
                "Read Uncommitted",
                "Read Committed",
                "Repeatable Read",
                "Serializable",
            ],
            answer: 1,
            rationale: "PostgreSQL 默认使用 Read Committed 隔离级别。注意：PostgreSQL 的 Read Uncommitted 实际等同于 Read Committed。",
        },
        {
            id: "w7-2-q8",
            question: "如何设置 MySQL 会话的隔离级别？",
            options: [
                "SET ISOLATION_LEVEL",
                "SET TRANSACTION ISOLATION LEVEL <level>",
                "CHANGE ISOLATION <level>",
                "ALTER SESSION SET ISOLATION",
            ],
            answer: 1,
            rationale: "MySQL 使用 SET TRANSACTION ISOLATION LEVEL 设置隔离级别，如 SET TRANSACTION ISOLATION LEVEL READ COMMITTED。",
        },
        {
            id: "w7-2-q9",
            question: "Repeatable Read 能防止幻读吗？",
            options: [
                "完全能",
                "SQL 标准不保证，但 MySQL InnoDB 通过间隙锁部分解决",
                "完全不能",
                "取决于数据量",
            ],
            answer: 1,
            rationale: "SQL 标准中 RR 不保证防止幻读，但 MySQL InnoDB 通过 MVCC（快照读）和间隙锁（当前读）部分解决了幻读问题。",
        },
        {
            id: "w7-2-q10",
            question: "为什么大多数应用不使用 Serializable 隔离级别？",
            options: [
                "太安全了",
                "性能开销大，大量锁和回滚影响吞吐量",
                "不被数据库支持",
                "太复杂",
            ],
            answer: 1,
            rationale: "Serializable 需要大量锁或冲突检测，可能导致频繁回滚，严重影响并发性能。大多数应用不需要这么强的隔离。",
        },
        {
            id: "w7-2-q11",
            question: "什么是快照读（Snapshot Read）？",
            options: [
                "读取最新数据",
                "读取事务开始时的数据快照，使用 MVCC 实现",
                "读取备份数据",
                "读取压缩数据",
            ],
            answer: 1,
            rationale: "快照读通过 MVCC 读取符合事务快照的历史版本，普通 SELECT 使用快照读，不加锁，不阻塞写操作。",
        },
        {
            id: "w7-2-q12",
            question: "什么是当前读（Current Read）？",
            options: [
                "读取历史数据",
                "读取最新已提交数据并加锁，如 SELECT FOR UPDATE",
                "读取当前时间",
                "快速读取",
            ],
            answer: 1,
            rationale: "当前读读取最新版本的数据并加锁，包括 SELECT FOR UPDATE、UPDATE、DELETE 等。会绕过 MVCC 的快照。",
        },
    ],
    "w7-3": [
        {
            id: "w7-3-q1",
            question: "MVCC 的核心优势是什么？",
            options: [
                "减少存储空间",
                "读操作不阻塞写操作，写操作不阻塞读操作",
                "提高写入速度",
                "自动解决死锁",
            ],
            answer: 1,
            rationale: "MVCC 通过维护数据的多个版本，让读操作读取历史版本，无需等待写操作释放锁，大幅提升并发性能。",
        },
        {
            id: "w7-3-q2",
            question: "MySQL InnoDB 如何存储历史版本？",
            options: [
                "单独的历史表",
                "通过 undo log 形成版本链",
                "在数据页中并排存储",
                "外部文件",
            ],
            answer: 1,
            rationale: "InnoDB 将修改前的数据存入 undo log，通过行中的 roll_pointer 指针链接形成版本链，供 MVCC 和回滚使用。",
        },
        {
            id: "w7-3-q3",
            question: "Read View 的作用是什么？",
            options: [
                "显示数据库结构",
                "记录事务开始时的活跃事务列表，决定版本可见性",
                "查看读取统计",
                "优化读取性能",
            ],
            answer: 1,
            rationale: "Read View 记录事务开始时哪些事务活跃、当前最大事务 ID 等，用于判断哪些版本对当前事务可见。",
        },
        {
            id: "w7-3-q4",
            question: "PostgreSQL 的 MVCC 实现与 MySQL 有什么不同？",
            options: [
                "完全相同",
                "PostgreSQL 在表中直接存储多版本（xmin/xmax），通过 VACUUM 清理",
                "PostgreSQL 不支持 MVCC",
                "MySQL 更高效",
            ],
            answer: 1,
            rationale: "PostgreSQL 在堆表中直接存储所有版本，每行有 xmin（创建事务）和 xmax（删除事务）。需要 VACUUM 清理过期版本。",
        },
        {
            id: "w7-3-q5",
            question: "长事务对 MVCC 系统有什么影响？",
            options: [
                "无影响",
                "导致旧版本无法清理，undo log 或表膨胀",
                "提高性能",
                "减少锁竞争",
            ],
            answer: 1,
            rationale: "长事务的 Read View 可能需要很旧的版本，导致这些版本无法被清理（purge），造成 undo log 或表空间膨胀。",
        },
        {
            id: "w7-3-q6",
            question: "MVCC 下普通 SELECT 是什么类型的读？",
            options: [
                "当前读",
                "快照读",
                "脏读",
                "锁定读",
            ],
            answer: 1,
            rationale: "普通 SELECT（不带 FOR UPDATE/SHARE）是快照读，读取符合事务快照的历史版本，不加锁。",
        },
        {
            id: "w7-3-q7",
            question: "SELECT FOR UPDATE 在 MVCC 系统中的行为是什么？",
            options: [
                "读取历史版本",
                "读取最新版本并加排他锁（当前读）",
                "只加锁不读取",
                "与普通 SELECT 相同",
            ],
            answer: 1,
            rationale: "SELECT FOR UPDATE 是当前读，读取最新已提交版本并加排他锁，绕过 MVCC 的快照机制。",
        },
        {
            id: "w7-3-q8",
            question: "在 Repeatable Read 下，Read View 何时创建？",
            options: [
                "每次查询时",
                "事务第一次快照读时创建，整个事务使用同一个",
                "BEGIN 时",
                "COMMIT 时",
            ],
            answer: 1,
            rationale: "RR 级别下，事务第一次执行快照读时创建 Read View，之后的快照读都使用同一个，保证可重复读。",
        },
        {
            id: "w7-3-q9",
            question: "在 Read Committed 下，Read View 的创建规则是什么？",
            options: [
                "事务开始时创建一次",
                "每次快照读时都创建新的 Read View",
                "不使用 Read View",
                "提交时创建",
            ],
            answer: 1,
            rationale: "RC 级别下，每次快照读都创建新的 Read View，所以能看到其他事务在此之前提交的修改。",
        },
        {
            id: "w7-3-q10",
            question: "PostgreSQL 的 VACUUM 命令做什么？",
            options: [
                "备份数据库",
                "清理过期的行版本，回收空间",
                "优化查询",
                "压缩数据",
            ],
            answer: 1,
            rationale: "VACUUM 清理被标记为删除的行版本（dead tuples），回收它们占用的空间，让空间可以被新数据复用。",
        },
        {
            id: "w7-3-q11",
            question: "MVCC 能解决哪些并发问题？",
            options: [
                "所有并发问题",
                "读-写冲突，但写-写冲突仍需要锁",
                "只解决死锁",
                "不解决任何问题",
            ],
            answer: 1,
            rationale: "MVCC 让读操作看到一致快照而无需加锁，解决了读-写冲突。写-写冲突仍需要锁机制来解决。",
        },
        {
            id: "w7-3-q12",
            question: "事务的可见性判断规则中，什么条件下一个版本对当前事务可见？",
            options: [
                "版本越新越可见",
                "创建该版本的事务已提交，且事务 ID 在当前事务 Read View 之前",
                "任何版本都可见",
                "只有自己创建的可见",
            ],
            answer: 1,
            rationale: "版本可见需要：创建它的事务在 Read View 创建前已提交，或者是当前事务自己创建的。活跃事务的版本不可见。",
        },
    ],
    "w7-4": [
        {
            id: "w7-4-q1",
            question: "悲观锁的核心思想是什么？",
            options: [
                "假设冲突很少",
                "假设冲突会发生，先获取锁再操作",
                "不使用锁",
                "事后检测冲突",
            ],
            answer: 1,
            rationale: "悲观锁假设并发冲突很可能发生，所以在操作数据前先获取锁，确保操作期间数据不会被其他事务修改。",
        },
        {
            id: "w7-4-q2",
            question: "乐观锁的核心思想是什么？",
            options: [
                "假设冲突会发生",
                "假设冲突很少，先操作后检测是否有冲突",
                "总是成功",
                "不检测冲突",
            ],
            answer: 1,
            rationale: "乐观锁假设冲突概率低，直接进行操作，在提交时检查是否有冲突（通过版本号等），有冲突则重试或报错。",
        },
        {
            id: "w7-4-q3",
            question: "SQL 中如何实现悲观锁？",
            options: [
                "普通 SELECT",
                "SELECT ... FOR UPDATE",
                "UPDATE 语句",
                "INSERT 语句",
            ],
            answer: 1,
            rationale: "SELECT ... FOR UPDATE 查询数据同时加排他锁，其他事务无法修改这些行，直到当前事务提交或回滚。",
        },
        {
            id: "w7-4-q4",
            question: "乐观锁通常如何实现？",
            options: [
                "使用数据库锁",
                "在表中增加版本号字段，更新时检查版本",
                "不需要实现",
                "使用触发器",
            ],
            answer: 1,
            rationale: "典型实现：UPDATE ... SET version=version+1 WHERE id=? AND version=?。如果 version 不匹配则更新失败，表示有冲突。",
        },
        {
            id: "w7-4-q5",
            question: "乐观锁检测到冲突后通常怎么处理？",
            options: [
                "直接成功",
                "重试操作或向用户报告冲突",
                "回滚数据库",
                "等待锁释放",
            ],
            answer: 1,
            rationale: "乐观锁冲突后应用层需要处理：可以自动重试（重新读取最新数据再更新），或通知用户数据已被修改。",
        },
        {
            id: "w7-4-q6",
            question: "什么场景更适合使用悲观锁？",
            options: [
                "读多写少",
                "写冲突频繁的场景",
                "单用户系统",
                "只读系统",
            ],
            answer: 1,
            rationale: "写冲突频繁时，乐观锁会导致大量重试，反而降低性能。悲观锁在操作前获取锁，避免无效操作。",
        },
        {
            id: "w7-4-q7",
            question: "什么场景更适合使用乐观锁？",
            options: [
                "高并发写入",
                "读多写少，冲突概率低的场景",
                "需要严格串行化",
                "金融交易",
            ],
            answer: 1,
            rationale: "乐观锁在读多写少、冲突概率低时效果好：大多数操作无需等待锁，偶尔的冲突通过重试解决。",
        },
        {
            id: "w7-4-q8",
            question: "乐观锁为什么要使用单调递增的版本号？",
            options: [
                "方便排序",
                "避免 ABA 问题，确保版本只会增加不会回退",
                "数据库要求",
                "节省空间",
            ],
            answer: 1,
            rationale: "如果版本号可以回退（如循环使用），可能出现 ABA 问题。单调递增确保版本号唯一标识数据状态。",
        },
        {
            id: "w7-4-q9",
            question: "SELECT ... FOR UPDATE 和 SELECT ... FOR SHARE 的区别是什么？",
            options: [
                "完全相同",
                "FOR UPDATE 加排他锁，FOR SHARE 加共享锁",
                "FOR SHARE 不加锁",
                "FOR UPDATE 更快",
            ],
            answer: 1,
            rationale: "FOR UPDATE 加排他锁（X 锁），阻止其他事务读写；FOR SHARE 加共享锁（S 锁），允许其他事务读但阻止写。",
        },
        {
            id: "w7-4-q10",
            question: "JPA/Hibernate 中如何使用乐观锁？",
            options: [
                "手动写 SQL",
                "使用 @Version 注解标记版本字段",
                "配置数据库",
                "使用事务注解",
            ],
            answer: 1,
            rationale: "@Version 注解告诉 JPA 这是乐观锁版本字段，框架会自动在更新时检查并递增版本号，冲突时抛出 OptimisticLockException。",
        },
        {
            id: "w7-4-q11",
            question: "乐观锁的重试策略应该注意什么？",
            options: [
                "无限重试",
                "限制重试次数，考虑退避策略",
                "不需要重试",
                "立即失败",
            ],
            answer: 1,
            rationale: "应限制最大重试次数避免无限循环；使用退避策略（如指数退避）减少再次冲突概率；重试前重新读取最新数据。",
        },
        {
            id: "w7-4-q12",
            question: "在电商秒杀场景中，扣减库存通常使用什么策略？",
            options: [
                "只用乐观锁",
                "悲观锁或数据库原子更新，或分布式锁",
                "不需要锁",
                "文件锁",
            ],
            answer: 1,
            rationale: "秒杀是高并发写场景，乐观锁会大量失败。通常用 UPDATE stock SET count=count-1 WHERE count>0 原子更新，或分布式锁串行化。",
        },
    ],
}
