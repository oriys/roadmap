import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week4Guides: Record<string, LessonGuide> = {
    "w4-1": {
        lessonId: "w4-1",
        background: [
            "【synchronized 本质】Java 中 synchronized 是内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）的实现。每个 Java 对象都可以作为锁，JVM 管理其获取和释放。",
            "【监视器概念】Oracle 文档：'Synchronization is built around an internal entity known as the intrinsic lock or monitor lock'——同步机制围绕内置锁构建。",
            "【三种使用方式】synchronized 可修饰实例方法（锁 this）、静态方法（锁 Class 对象）、代码块（锁指定对象）。",
            "【JVM 锁优化】HotSpot JVM 实现了锁升级机制：偏向锁（Biased Locking）→ 轻量级锁（Lightweight Lock）→ 重量级锁（Heavyweight Lock）。",
            "【偏向锁原理】JVM 假设大多数锁只被一个线程访问。偏向锁记录拥有者线程 ID，后续该线程获取锁无需 CAS 操作，几乎无开销。",
        ],
        keyDifficulties: [
            "【可重入性】synchronized 是可重入锁：同一线程可以多次获取同一个锁，JVM 维护一个计数器记录重入次数。",
            "【锁升级不可逆】偏向锁 → 轻量级锁 → 重量级锁的升级通常是单向的，一旦升级很少降级（JDK 15 后默认禁用偏向锁）。",
            "【等待不可中断】synchronized 阻塞的线程无法被中断，也不能设置超时——这是它相比 ReentrantLock 的局限。",
            "【锁粗化与消除】JIT 编译器会进行锁优化：合并连续的同步块（锁粗化）、消除不可能发生竞争的锁（锁消除）。",
        ],
        handsOnPath: [
            "编写 synchronized 方法和同步块的基本用法，观察其互斥效果。",
            "用 JOL（Java Object Layout）工具查看对象头中的锁标记位变化。",
            "使用 -XX:+PrintFlagsFinal 查看 JVM 锁相关参数。",
            "通过 jstack 查看线程状态，观察 BLOCKED 与 WAITING 的区别。",
            "测试 synchronized 在无竞争、低竞争、高竞争场景下的性能。",
        ],
        selfCheck: [
            "synchronized 修饰实例方法和静态方法时，锁对象分别是什么？",
            "什么是偏向锁？它在什么情况下会升级？",
            "synchronized 是可重入的吗？重入时 JVM 如何处理？",
            "JDK 15 为什么默认禁用偏向锁？",
            "锁粗化和锁消除分别是什么优化？",
        ],
        extensions: [
            "阅读 OpenJDK 源码中 ObjectMonitor 的实现。",
            "学习 Java 对象头（Mark Word）的内存布局。",
            "研究 JEP 374: Deprecate and Disable Biased Locking 的背景。",
            "了解 Project Loom 对 synchronized 的影响。",
        ],
        sourceUrls: [
            "https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html",
            "https://wiki.openjdk.org/display/HotSpot/Synchronization",
            "https://www.baeldung.com/java-synchronized",
        ],
    },
    "w4-2": {
        lessonId: "w4-2",
        background: [
            "【ReentrantLock 定义】Java 文档：'A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock'——与 synchronized 语义相同但功能更丰富。",
            "【显式锁接口】ReentrantLock 实现 Lock 接口，提供 lock()、unlock()、tryLock()、lockInterruptibly() 等方法。",
            "【公平性选择】构造时可选择公平模式：new ReentrantLock(true)。Java 文档：'Fair locks favor granting access to the longest-waiting thread'。",
            "【Condition 支持】每个 ReentrantLock 可以创建多个 Condition 对象，比 Object.wait/notify 更灵活：'multiple Condition objects associated with a single lock'。",
            "【AQS 框架】ReentrantLock 基于 AbstractQueuedSynchronizer（AQS）实现，AQS 是 Java 并发包的核心框架。",
        ],
        keyDifficulties: [
            "【必须手动释放】使用 ReentrantLock 必须在 finally 块中调用 unlock()：'failure to do so will likely result in deadlock'。",
            "【tryLock 注意事项】tryLock() 可能「窃取」锁（barging），即使有等待线程也可能成功。用 tryLock(0, TimeUnit.SECONDS) 获得公平行为。",
            "【公平锁性能】公平锁保证 FIFO 顺序但性能较差：'Programs using fair locks accessed by many threads may display lower overall throughput'。",
            "【与 synchronized 选择】Oracle 建议：除非需要 ReentrantLock 的高级特性，否则优先使用 synchronized——更简洁且自动释放。",
        ],
        handsOnPath: [
            "用 ReentrantLock 替换 synchronized 实现线程安全计数器。",
            "使用 tryLock(timeout) 实现带超时的锁获取，避免无限等待。",
            "用 lockInterruptibly() 实现可中断的锁获取。",
            "创建多个 Condition 实现生产者-消费者模式的精细控制。",
            "对比公平锁和非公平锁在高竞争下的吞吐量差异。",
        ],
        selfCheck: [
            "ReentrantLock 相比 synchronized 有哪些额外功能？",
            "为什么必须在 finally 块中释放 ReentrantLock？",
            "ReentrantLock 的公平模式和非公平模式有什么区别？",
            "什么是 tryLock 的「窃取」行为？",
            "什么情况下应该使用 ReentrantLock 而非 synchronized？",
        ],
        extensions: [
            "阅读 Doug Lea 的 AQS 论文《The java.util.concurrent Synchronizer Framework》。",
            "研究 ReentrantLock 源码中的 FairSync 和 NonfairSync 实现。",
            "学习 ReentrantLock 的 Condition 实现原理。",
            "了解 Java 虚拟线程（Project Loom）对 ReentrantLock 的影响。",
        ],
        sourceUrls: [
            "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html",
            "https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html",
            "https://www.baeldung.com/java-concurrent-locks",
        ],
    },
    "w4-3": {
        lessonId: "w4-3",
        background: [
            "【StampedLock 定义】Java 8 引入，Java 文档：'A capability-based lock with three modes for controlling read/write access'——基于能力的锁，有三种模式。",
            "【三种模式】写锁（writeLock）、悲观读锁（readLock）、乐观读（tryOptimisticRead）。乐观读不是真正的锁。",
            "【乐观读原理】tryOptimisticRead() 返回一个 stamp（版本号），读取后用 validate(stamp) 验证期间是否有写入。无写入则数据有效。",
            "【性能优势】乐观读在无写入时几乎零开销：'Optimistic reading is useful when reads are much more common than writes'。",
            "【不可重入】StampedLock 不可重入：'StampedLocks are not reentrant, so locked bodies should not call other unknown methods that may try to re-acquire locks'。",
        ],
        keyDifficulties: [
            "【乐观读失败处理】validate 失败后必须有备选方案，通常是升级为悲观读锁：tryConvertToReadLock(stamp)。",
            "【stamp 管理】必须正确管理 stamp：获取锁返回的 stamp 必须用于释放锁。stamp 为 0 表示获取失败。",
            "【不支持 Condition】与 ReentrantLock 不同，StampedLock 不支持 Condition。需要条件等待时应使用其他锁。",
            "【死锁风险】因为不可重入，在持有 StampedLock 的代码中调用可能需要同一锁的方法会导致死锁。",
        ],
        handsOnPath: [
            "实现使用 StampedLock 乐观读的 Point 类：读坐标时先乐观读，验证失败再悲观读。",
            "测量乐观读 vs 悲观读在读多写少场景的性能差异。",
            "实现乐观读失败后升级为悲观读的完整流程。",
            "对比 StampedLock、ReentrantReadWriteLock、synchronized 的性能。",
            "编写代码触发 StampedLock 不可重入导致的死锁。",
        ],
        selfCheck: [
            "StampedLock 的三种模式分别是什么？各有什么特点？",
            "乐观读为什么比悲观读性能好？它的使用限制是什么？",
            "validate 返回 false 后应该怎么处理？",
            "为什么 StampedLock 设计为不可重入？",
            "StampedLock 与 ReentrantReadWriteLock 如何选择？",
        ],
        extensions: [
            "研究 StampedLock 源码中的 state 位设计。",
            "学习 Martin Thompson 关于 StampedLock 性能分析的文章。",
            "了解数据库乐观锁的实现与 StampedLock 的对比。",
            "研究其他语言中的顺序锁（seqlock）实现。",
        ],
        sourceUrls: [
            "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/locks/StampedLock.html",
            "https://www.baeldung.com/java-stamped-lock",
            "https://martinfowler.com/eaaCatalog/optimisticOfflineLock.html",
        ],
    },
    "w4-4": {
        lessonId: "w4-4",
        background: [
            "【Atomic 包概述】java.util.concurrent.atomic 提供原子变量类：AtomicInteger、AtomicLong、AtomicReference 等，支持无锁线程安全操作。",
            "【CAS 基础】Java 文档：Atomic 类基于 'compare-and-swap (CAS)'——硬件级别的原子操作，比较并交换。",
            "【主要方法】get()、set()、getAndSet()、compareAndSet()、getAndIncrement()、incrementAndGet() 等。",
            "【LongAdder/LongAccumulator】Java 8 引入，用于高竞争场景：'may be preferable to AtomicLong when multiple threads update a common sum'。",
            "【VarHandle】Java 9 引入 VarHandle API，提供更底层的原子操作访问，是 Unsafe 的安全替代。",
        ],
        keyDifficulties: [
            "【ABA 问题】CAS 无法检测值从 A→B→A 的变化。解决方案：AtomicStampedReference 添加版本号，AtomicMarkableReference 添加布尔标记。",
            "【自旋开销】CAS 循环在高竞争下可能自旋很多次。LongAdder 通过分散竞争（striping）解决此问题。",
            "【compareAndSet vs weakCompareAndSet】weakCompareAndSet 可能虚假失败，但在某些架构上性能更好。通常使用 compareAndSet。",
            "【内存语义】CAS 操作提供 volatile 语义：compareAndSet 有 acquire-release 语义，确保可见性。",
        ],
        handsOnPath: [
            "用 AtomicInteger 实现线程安全计数器，对比 synchronized 版本的性能。",
            "实现一个 CAS 循环：读取、计算、compareAndSet，失败重试。",
            "使用 AtomicStampedReference 解决 ABA 问题的示例。",
            "在高竞争场景对比 AtomicLong 和 LongAdder 的吞吐量。",
            "用 AtomicReference 实现无锁栈（Treiber Stack）。",
        ],
        selfCheck: [
            "CAS 操作的原子性是如何保证的？",
            "什么是 ABA 问题？如何解决？",
            "AtomicLong 和 LongAdder 的区别是什么？什么时候用哪个？",
            "compareAndSet 和 weakCompareAndSet 有什么区别？",
            "Atomic 类提供什么样的内存语义？",
        ],
        extensions: [
            "研究 HotSpot JVM 中 CAS 的底层实现（Unsafe.compareAndSwapInt）。",
            "学习 CPU 的 CMPXCHG 指令和 LOCK 前缀。",
            "了解 Java 9 VarHandle 的设计目标和用法。",
            "研究无锁数据结构的正确性证明方法。",
        ],
        sourceUrls: [
            "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/atomic/package-summary.html",
            "https://docs.oracle.com/javase/tutorial/essential/concurrency/atomicvars.html",
            "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/atomic/AtomicStampedReference.html",
        ],
    },
}

export const week4Quizzes: Record<string, QuizQuestion[]> = {
    "w4-1": [
        {
            id: "w4-1-q1",
            question: "synchronized 修饰静态方法时，锁对象是什么？",
            options: [
                "this 对象",
                "Class 对象",
                "Object.class",
                "无锁对象",
            ],
            answer: 1,
            rationale: "静态方法属于类而非实例，所以 synchronized 静态方法锁的是该类的 Class 对象，如 MyClass.class。",
        },
        {
            id: "w4-1-q2",
            question: "JVM 锁升级的顺序是什么？",
            options: [
                "重量级锁 → 轻量级锁 → 偏向锁",
                "偏向锁 → 轻量级锁 → 重量级锁",
                "轻量级锁 → 偏向锁 → 重量级锁",
                "随机选择",
            ],
            answer: 1,
            rationale: "JVM 锁升级是单向的：偏向锁（单线程访问）→ 轻量级锁（CAS 竞争）→ 重量级锁（阻塞等待）。",
        },
        {
            id: "w4-1-q3",
            question: "偏向锁的设计目的是什么？",
            options: [
                "提高多线程竞争时的性能",
                "优化单线程重复获取同一锁的场景",
                "支持锁中断",
                "支持公平调度",
            ],
            answer: 1,
            rationale: "偏向锁假设大多数锁只被一个线程访问。记录拥有者线程 ID 后，该线程再次获取锁时无需任何同步操作。",
        },
        {
            id: "w4-1-q4",
            question: "synchronized 的可重入性是如何实现的？",
            options: [
                "创建新的锁对象",
                "JVM 维护计数器，每次重入加 1，退出减 1",
                "使用线程本地存储",
                "不支持重入",
            ],
            answer: 1,
            rationale: "JVM 为每个锁维护一个拥有者线程和重入计数。同一线程获取锁时计数加 1，释放时减 1，计数为 0 时真正释放锁。",
        },
        {
            id: "w4-1-q5",
            question: "JDK 15 默认禁用偏向锁的主要原因是什么？",
            options: [
                "偏向锁有安全漏洞",
                "偏向锁的撤销开销大，现代应用中收益不明显",
                "偏向锁不兼容新版本 JVM",
                "内存使用过多",
            ],
            answer: 1,
            rationale: "JEP 374 说明：偏向锁的撤销需要在安全点暂停线程，开销显著。现代应用中锁竞争更频繁，偏向锁收益降低。",
        },
        {
            id: "w4-1-q6",
            question: "什么是锁消除（Lock Elimination）？",
            options: [
                "删除不需要的锁对象",
                "JIT 编译器移除不可能发生竞争的同步代码",
                "手动移除 synchronized",
                "降低锁的粒度",
            ],
            answer: 1,
            rationale: "JIT 编译器通过逃逸分析发现某个锁对象不会被其他线程访问时，会消除该同步块，完全移除同步开销。",
        },
        {
            id: "w4-1-q7",
            question: "synchronized 块等待锁的线程处于什么状态？",
            options: [
                "RUNNABLE",
                "BLOCKED",
                "WAITING",
                "TIMED_WAITING",
            ],
            answer: 1,
            rationale: "等待进入 synchronized 块的线程处于 BLOCKED 状态。这与 Object.wait() 导致的 WAITING 状态不同。",
        },
        {
            id: "w4-1-q8",
            question: "什么是锁粗化（Lock Coarsening）？",
            options: [
                "增加锁的数量",
                "合并连续的同步块以减少锁获取次数",
                "使用更大范围的锁对象",
                "降低锁优先级",
            ],
            answer: 1,
            rationale: "如果 JIT 发现一系列操作都对同一对象加锁，会将多个同步块合并为一个更大的同步块，减少锁操作次数。",
        },
        {
            id: "w4-1-q9",
            question: "轻量级锁使用什么机制获取锁？",
            options: [
                "操作系统 mutex",
                "CAS（Compare-And-Swap）操作",
                "信号量",
                "自旋等待",
            ],
            answer: 1,
            rationale: "轻量级锁通过 CAS 尝试将对象头的 Mark Word 指向栈帧中的锁记录。如果 CAS 成功则获取锁，失败则可能升级。",
        },
        {
            id: "w4-1-q10",
            question: "synchronized 相比 ReentrantLock 的局限是什么？",
            options: [
                "不支持可重入",
                "不支持中断等待、超时等待和公平锁",
                "性能太差",
                "不能修饰方法",
            ],
            answer: 1,
            rationale: "synchronized 不支持可中断的锁获取、超时锁获取、公平模式选择，也不能尝试非阻塞获取（tryLock）。",
        },
        {
            id: "w4-1-q11",
            question: "以下哪种方式使用 synchronized 是错误的？",
            options: [
                "synchronized(this) { ... }",
                "synchronized(MyClass.class) { ... }",
                "synchronized(new Object()) { ... }",
                "synchronized 方法",
            ],
            answer: 2,
            rationale: "synchronized(new Object()) 每次创建新对象，不同线程锁的是不同对象，无法实现互斥。应锁同一个共享对象。",
        },
        {
            id: "w4-1-q12",
            question: "对象头中的 Mark Word 在偏向锁状态下存储什么？",
            options: [
                "对象的哈希码",
                "拥有锁的线程 ID",
                "锁记录指针",
                "Monitor 指针",
            ],
            answer: 1,
            rationale: "偏向锁状态下，Mark Word 存储偏向的线程 ID 和 epoch（用于批量重偏向）。同一线程再次获取时比较线程 ID 即可。",
        },
    ],
    "w4-2": [
        {
            id: "w4-2-q1",
            question: "ReentrantLock 必须如何释放锁？",
            options: [
                "自动释放",
                "在 finally 块中调用 unlock()",
                "调用 close()",
                "等待超时",
            ],
            answer: 1,
            rationale: "ReentrantLock 不会自动释放，必须显式调用 unlock()。为防止异常导致锁未释放，应在 finally 块中调用。",
        },
        {
            id: "w4-2-q2",
            question: "如何创建一个公平的 ReentrantLock？",
            options: [
                "new ReentrantLock()",
                "new ReentrantLock(true)",
                "new FairReentrantLock()",
                "ReentrantLock.fair()",
            ],
            answer: 1,
            rationale: "ReentrantLock 构造函数接受 boolean 参数：true 表示公平锁，false（默认）表示非公平锁。",
        },
        {
            id: "w4-2-q3",
            question: "lockInterruptibly() 与 lock() 的区别是什么？",
            options: [
                "lockInterruptibly() 更快",
                "lockInterruptibly() 在等待时可以响应中断",
                "lock() 可以设置超时",
                "没有区别",
            ],
            answer: 1,
            rationale: "lockInterruptibly() 在等待获取锁时可以被 Thread.interrupt() 中断并抛出 InterruptedException。lock() 则不响应中断。",
        },
        {
            id: "w4-2-q4",
            question: "ReentrantLock 的非公平锁为什么性能通常更好？",
            options: [
                "代码更简单",
                "允许线程「插队」减少上下文切换",
                "使用更少内存",
                "公平锁有 bug",
            ],
            answer: 1,
            rationale: "非公平锁允许刚请求的线程直接尝试获取锁，可能避免唤醒等待队列中的线程，减少上下文切换开销。",
        },
        {
            id: "w4-2-q5",
            question: "ReentrantLock 的 tryLock() 方法的行为是什么？",
            options: [
                "无限等待直到获取锁",
                "尝试获取锁，立即返回成功或失败",
                "等待固定时间",
                "抛出异常",
            ],
            answer: 1,
            rationale: "tryLock() 是非阻塞的：如果锁可用则获取并返回 true，否则立即返回 false，不会等待。",
        },
        {
            id: "w4-2-q6",
            question: "ReentrantLock 的 Condition 相比 Object.wait/notify 的优势是什么？",
            options: [
                "性能更好",
                "一个锁可以关联多个 Condition，支持多个等待队列",
                "不需要持有锁",
                "自动处理虚假唤醒",
            ],
            answer: 1,
            rationale: "Object 只有一个等待集合，而 ReentrantLock 可创建多个 Condition，实现更精细的等待-通知控制。",
        },
        {
            id: "w4-2-q7",
            question: "以下关于 ReentrantLock 的说法，哪个是错误的？",
            options: [
                "支持可重入",
                "支持公平和非公平模式",
                "支持 try-with-resources 自动释放",
                "可以创建多个 Condition",
            ],
            answer: 2,
            rationale: "ReentrantLock 没有实现 AutoCloseable 接口，不能用 try-with-resources。必须显式在 finally 中调用 unlock()。",
        },
        {
            id: "w4-2-q8",
            question: "ReentrantLock 的 getHoldCount() 返回什么？",
            options: [
                "等待线程数",
                "当前线程持有该锁的次数（重入次数）",
                "总获取次数",
                "锁的优先级",
            ],
            answer: 1,
            rationale: "getHoldCount() 返回当前线程对该锁的重入次数。如果当前线程不持有锁则返回 0。",
        },
        {
            id: "w4-2-q9",
            question: "ReentrantLock 基于什么框架实现？",
            options: [
                "Object Monitor",
                "AbstractQueuedSynchronizer (AQS)",
                "Unsafe",
                "synchronized",
            ],
            answer: 1,
            rationale: "ReentrantLock 内部使用 AQS 框架实现。AQS 提供了同步状态管理和等待队列的基础设施。",
        },
        {
            id: "w4-2-q10",
            question: "何时应该使用 ReentrantLock 而非 synchronized？",
            options: [
                "总是使用 ReentrantLock",
                "需要超时获取、可中断、公平锁或多 Condition 时",
                "性能要求高时",
                "代码简洁时",
            ],
            answer: 1,
            rationale: "Oracle 建议：除非需要 ReentrantLock 特有的功能（超时、中断、公平、多条件），否则优先使用 synchronized。",
        },
        {
            id: "w4-2-q11",
            question: "tryLock(0, TimeUnit.SECONDS) 与 tryLock() 的区别是什么？",
            options: [
                "完全相同",
                "前者遵守公平策略，后者可能「窃取」锁",
                "前者更快",
                "前者会抛异常",
            ],
            answer: 1,
            rationale: "tryLock() 不遵守公平策略，可能跳过等待队列。tryLock(0, SECONDS) 则会遵守公平策略，在公平锁中不会插队。",
        },
        {
            id: "w4-2-q12",
            question: "ReentrantLock 的 isHeldByCurrentThread() 方法的用途是什么？",
            options: [
                "检查锁是否被占用",
                "检查当前线程是否持有此锁",
                "检查是否有线程等待",
                "检查是否是公平锁",
            ],
            answer: 1,
            rationale: "isHeldByCurrentThread() 用于调试或断言，验证当前线程确实持有锁后再进行某些操作。",
        },
    ],
    "w4-3": [
        {
            id: "w4-3-q1",
            question: "StampedLock 的乐观读模式的特点是什么？",
            options: [
                "获取真正的读锁",
                "不获取锁，只获取一个 stamp 用于后续验证",
                "与悲观读相同",
                "需要写锁配合",
            ],
            answer: 1,
            rationale: "tryOptimisticRead() 不获取任何锁，只返回一个 stamp（版本号）。读取数据后用 validate(stamp) 验证期间是否有写入。",
        },
        {
            id: "w4-3-q2",
            question: "StampedLock 的 validate(stamp) 返回 false 意味着什么？",
            options: [
                "stamp 无效",
                "自获取 stamp 后发生过写入，数据可能已变",
                "锁已被释放",
                "需要升级为写锁",
            ],
            answer: 1,
            rationale: "validate 返回 false 表示在 tryOptimisticRead 和 validate 之间有写操作发生，读取的数据可能不一致，需要重新处理。",
        },
        {
            id: "w4-3-q3",
            question: "StampedLock 为什么设计为不可重入？",
            options: [
                "实现更简单",
                "避免持锁代码调用可能需要同一锁的方法导致复杂问题",
                "性能考虑",
                "Java 语言限制",
            ],
            answer: 1,
            rationale: "Java 文档警告：'locked bodies should not call other unknown methods that may try to re-acquire locks'——不可重入是有意设计，避免复杂的重入场景。",
        },
        {
            id: "w4-3-q4",
            question: "StampedLock 乐观读验证失败后的推荐做法是什么？",
            options: [
                "重试乐观读",
                "升级为悲观读锁再读取",
                "直接使用读取的数据",
                "抛出异常",
            ],
            answer: 1,
            rationale: "验证失败后应升级为悲观读锁（tryConvertToReadLock 或 readLock）确保数据一致性。无限重试乐观读可能导致活锁。",
        },
        {
            id: "w4-3-q5",
            question: "StampedLock 相比 ReentrantReadWriteLock 的优势是什么？",
            options: [
                "支持可重入",
                "乐观读模式在读多写少时性能更好",
                "支持 Condition",
                "更简单易用",
            ],
            answer: 1,
            rationale: "StampedLock 的乐观读在无写入时几乎零开销，适合读远多于写的场景。ReentrantReadWriteLock 的读锁仍有开销。",
        },
        {
            id: "w4-3-q6",
            question: "StampedLock 的 stamp 值为 0 表示什么？",
            options: [
                "成功获取锁",
                "获取锁失败",
                "锁已释放",
                "需要重试",
            ],
            answer: 1,
            rationale: "在 tryWriteLock() 等方法中，返回 0 表示获取失败。有效的 stamp 总是非零值。",
        },
        {
            id: "w4-3-q7",
            question: "StampedLock 的 tryConvertToWriteLock(stamp) 的作用是什么？",
            options: [
                "强制获取写锁",
                "尝试将读锁或乐观读升级为写锁",
                "释放锁后获取写锁",
                "总是成功",
            ],
            answer: 1,
            rationale: "tryConvertToWriteLock 尝试将现有的锁（读锁或乐观读 stamp）升级为写锁。如果成功返回新 stamp，失败返回 0。",
        },
        {
            id: "w4-3-q8",
            question: "以下关于 StampedLock 的说法，哪个是错误的？",
            options: [
                "不支持 Condition",
                "不可重入",
                "支持锁降级（写锁→读锁）",
                "乐观读需要持有锁",
            ],
            answer: 3,
            rationale: "乐观读（tryOptimisticRead）不获取任何锁，只是获取一个版本号用于后续验证。这是其高性能的关键。",
        },
        {
            id: "w4-3-q9",
            question: "StampedLock 适合什么场景？",
            options: [
                "写操作频繁的场景",
                "需要条件等待的场景",
                "读操作远多于写操作的场景",
                "需要重入的场景",
            ],
            answer: 2,
            rationale: "StampedLock 的乐观读优化了读多写少场景。写操作频繁或需要 Condition/重入时应选择其他锁。",
        },
        {
            id: "w4-3-q10",
            question: "使用 StampedLock 必须注意什么？",
            options: [
                "总是使用乐观读",
                "必须正确管理 stamp，获取的 stamp 必须用于释放",
                "只能用于静态方法",
                "必须配合 synchronized",
            ],
            answer: 1,
            rationale: "stamp 管理是 StampedLock 使用的关键：获取锁返回的 stamp 必须保存并在释放时使用，否则可能导致锁泄漏或错误。",
        },
        {
            id: "w4-3-q11",
            question: "乐观读的典型使用模式是什么？",
            options: [
                "lock → read → unlock",
                "tryOptimisticRead → read → validate → (失败则升级为悲观读)",
                "read → validate → lock",
                "lock → validate → read",
            ],
            answer: 1,
            rationale: "标准模式：获取 stamp → 读取数据 → validate → 验证成功则使用数据，失败则获取悲观读锁重新读取。",
        },
        {
            id: "w4-3-q12",
            question: "StampedLock 的 writeLock() 和 tryWriteLock() 的区别是什么？",
            options: [
                "完全相同",
                "writeLock 阻塞等待，tryWriteLock 立即返回",
                "tryWriteLock 更安全",
                "writeLock 返回 boolean",
            ],
            answer: 1,
            rationale: "writeLock() 阻塞直到获取写锁；tryWriteLock() 是非阻塞的，成功返回非零 stamp，失败返回 0。",
        },
    ],
    "w4-4": [
        {
            id: "w4-4-q1",
            question: "AtomicInteger 的 incrementAndGet() 方法的语义是什么？",
            options: [
                "返回当前值然后加 1",
                "加 1 然后返回新值",
                "只加 1 不返回",
                "返回是否成功",
            ],
            answer: 1,
            rationale: "incrementAndGet() 原子地将值加 1 并返回更新后的新值。getAndIncrement() 则返回旧值。",
        },
        {
            id: "w4-4-q2",
            question: "什么是 ABA 问题？",
            options: [
                "两个线程同时修改",
                "值从 A 变成 B 再变回 A，CAS 无法检测这个变化",
                "原子操作失败",
                "内存泄漏",
            ],
            answer: 1,
            rationale: "CAS 只比较当前值和期望值。如果值从 A→B→A，CAS 会认为值未变并成功更新，但实际上中间发生过变化。",
        },
        {
            id: "w4-4-q3",
            question: "AtomicStampedReference 如何解决 ABA 问题？",
            options: [
                "使用更强的 CAS",
                "配合引用添加一个整数版本号，同时比较引用和版本",
                "禁止 ABA 发生",
                "使用锁",
            ],
            answer: 1,
            rationale: "AtomicStampedReference 维护 [reference, stamp] 对，CAS 同时比较引用和版本号。即使引用相同，版本号不同也会失败。",
        },
        {
            id: "w4-4-q4",
            question: "LongAdder 相比 AtomicLong 的优势是什么？",
            options: [
                "功能更多",
                "在高竞争场景下性能更好",
                "使用更少内存",
                "支持更大的数值",
            ],
            answer: 1,
            rationale: "LongAdder 使用分段（striping）技术，将值分散到多个 Cell 中更新，减少 CAS 竞争。最终求和时合并所有 Cell。",
        },
        {
            id: "w4-4-q5",
            question: "compareAndSet(expect, update) 的语义是什么？",
            options: [
                "总是设置为 update",
                "如果当前值等于 expect 则设置为 update 并返回 true",
                "比较后等待",
                "设置后比较",
            ],
            answer: 1,
            rationale: "CAS 操作：原子地比较当前值与 expect，相等则更新为 update 返回 true，否则不更新返回 false。",
        },
        {
            id: "w4-4-q6",
            question: "实现无锁计数器的典型 CAS 循环模式是什么？",
            options: [
                "直接调用 set()",
                "循环：读取旧值 → 计算新值 → CAS 更新，失败则重试",
                "使用 synchronized 保护 CAS",
                "只重试一次",
            ],
            answer: 1,
            rationale: "CAS 可能因竞争失败。标准模式：do { old = get(); new = compute(old); } while (!compareAndSet(old, new));",
        },
        {
            id: "w4-4-q7",
            question: "AtomicReference 的用途是什么？",
            options: [
                "原子更新基本类型",
                "原子更新对象引用",
                "原子更新数组",
                "原子更新字段",
            ],
            answer: 1,
            rationale: "AtomicReference<V> 提供对引用类型的原子操作，可以原子地更新指向的对象。",
        },
        {
            id: "w4-4-q8",
            question: "weakCompareAndSet 和 compareAndSet 的区别是什么？",
            options: [
                "完全相同",
                "weakCompareAndSet 可能虚假失败，但在某些架构上更高效",
                "weakCompareAndSet 更安全",
                "compareAndSet 会重试",
            ],
            answer: 1,
            rationale: "weakCompareAndSet 在某些架构上可能虚假失败（即使值匹配也返回 false），但避免了内存屏障开销。通常用在循环中。",
        },
        {
            id: "w4-4-q9",
            question: "LongAdder 的 sum() 方法的特点是什么？",
            options: [
                "返回精确值",
                "返回的值可能不是调用时刻的精确和（有并发更新）",
                "会阻塞更新操作",
                "只能调用一次",
            ],
            answer: 1,
            rationale: "sum() 遍历所有 Cell 求和，期间可能有其他线程在更新，所以返回值是近似的「当前和」，不是精确快照。",
        },
        {
            id: "w4-4-q10",
            question: "什么时候应该使用 LongAdder 而非 AtomicLong？",
            options: [
                "需要精确读取时",
                "高并发写入、偶尔读取总和的场景",
                "读多写少时",
                "需要 CAS 操作时",
            ],
            answer: 1,
            rationale: "LongAdder 优化了写入性能但读取需要合并。适合统计计数等场景：频繁 add()，偶尔 sum()。",
        },
        {
            id: "w4-4-q11",
            question: "AtomicIntegerArray 的作用是什么？",
            options: [
                "创建原子整数的数组",
                "对 int[] 数组的元素提供原子操作",
                "原子地操作整个数组",
                "替代 ArrayList",
            ],
            answer: 1,
            rationale: "AtomicIntegerArray 包装 int[] 数组，提供对数组元素的原子 get/set/CAS 操作，如 getAndIncrement(index)。",
        },
        {
            id: "w4-4-q12",
            question: "Atomic 类提供什么样的内存可见性保证？",
            options: [
                "无保证",
                "与 volatile 相同的可见性保证",
                "比 volatile 弱",
                "只保证原子性",
            ],
            answer: 1,
            rationale: "Atomic 类的操作具有 volatile 语义：写操作对后续读操作可见。compareAndSet 等还提供了更强的内存屏障效果。",
        },
    ],
}
