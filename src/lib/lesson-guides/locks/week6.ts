import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week6Guides: Record<string, LessonGuide> = {
    "w6-1": {
        lessonId: "w6-1",
        background: [
            "【CAS 定义】Compare-And-Swap 是无锁编程的核心原语：'atomically compares the contents of a memory location with an expected value and, only if they are the same, modifies the contents to a new value'。",
            "【硬件支持】现代 CPU 提供 CAS 原子指令：x86 的 CMPXCHG、ARM 的 LDREX/STREX（LL/SC）。这些指令保证操作不可分割。",
            "【无锁 vs 无等待】Lock-Free：至少一个线程能前进；Wait-Free：所有线程都能在有限步内完成。后者更强但更难实现。",
            "【CAS 循环模式】典型用法：`do { old = value; new = compute(old); } while (!CAS(&value, old, new))`——失败则重试。",
            "【无锁优势】避免了锁的开销（上下文切换、优先级反转）和死锁风险。但实现复杂，且高竞争下 CAS 重试可能导致性能下降。",
        ],
        keyDifficulties: [
            "【ABA 问题】CAS 无法检测「值从 A 变成 B 再变回 A」的变化。后续课时将详细讲解解决方案。",
            "【进度保证】无锁不意味着无等待。在极端竞争下，某个线程的 CAS 可能一直失败（活锁风险）。",
            "【正确性证明困难】无锁算法的正确性依赖细微的内存顺序，很难证明且容易出错。测试往往不充分。",
            "【内存顺序】CAS 通常需要特定的内存顺序（如 acquire-release）来确保其他线程看到一致的状态。",
        ],
        handsOnPath: [
            "用 Java AtomicInteger.compareAndSet() 实现无锁计数器。",
            "用 Go atomic.CompareAndSwapInt64() 实现相同功能。",
            "用 C++ std::atomic 的 compare_exchange_strong() 实现。",
            "实现一个 CAS 循环，测试高竞争下的重试次数。",
            "对比无锁计数器和 Mutex 保护的计数器在不同竞争级别下的性能。",
        ],
        selfCheck: [
            "CAS 操作的三个参数分别是什么？返回值表示什么？",
            "什么是 Lock-Free？什么是 Wait-Free？它们的区别是什么？",
            "CAS 循环为什么要在失败时重试？",
            "无锁编程的主要优势和挑战是什么？",
            "x86 的 CMPXCHG 指令如何工作？",
        ],
        extensions: [
            "研究 Herlihy 的无锁/无等待层次理论。",
            "学习 LL/SC（Load-Linked/Store-Conditional）与 CAS 的区别。",
            "了解无锁编程中的形式化验证方法。",
            "研究现代 CPU 如何在硬件层面实现原子操作。",
        ],
        sourceUrls: [
            "https://en.wikipedia.org/wiki/Compare-and-swap",
            "https://www.baeldung.com/lock-free-programming",
            "https://lwn.net/Articles/847973/",
        ],
    },
    "w6-2": {
        lessonId: "w6-2",
        background: [
            "【ABA 问题定义】CAS 只比较值，无法检测「值从 A→B→A」的变化。如果中间状态很重要，可能导致逻辑错误。",
            "【经典场景】无锁栈：线程 1 准备 pop(A)，被中断。线程 2 pop(A), pop(B), push(A)。线程 1 恢复，CAS 成功但实际栈结构已变。",
            "【版本号方案】为每个值附加版本号：CAS 同时比较值和版本。即使值相同，版本号不同也会失败。",
            "【AtomicStampedReference】Java 的解决方案：'maintains an object reference along with an integer stamp'——引用+整数版本号。",
            "【Hazard Pointer】内存回收问题的解决方案：标记正在使用的指针，延迟回收。SMR（Safe Memory Reclamation）的一种。",
        ],
        keyDifficulties: [
            "【何时是问题】ABA 只在特定场景下是问题：当中间状态有意义时。简单计数器通常不受影响。",
            "【版本号溢出】版本号有上限。实践中使用 64 位版本号，溢出概率极低。",
            "【AtomicMarkableReference】Java 还提供 AtomicMarkableReference：引用+布尔标记，适合标记删除。",
            "【内存回收难题】无锁数据结构中，何时安全回收内存是难点。Hazard Pointer、RCU、Epoch-Based Reclamation 是常见方案。",
        ],
        handsOnPath: [
            "用普通 AtomicReference 实现无锁栈，演示 ABA 问题。",
            "改用 AtomicStampedReference 修复 ABA 问题。",
            "实现一个带版本号的 CAS 包装器。",
            "测试版本号溢出的边界情况。",
            "研究 Java ConcurrentLinkedQueue 如何避免 ABA。",
        ],
        selfCheck: [
            "什么是 ABA 问题？举一个具体例子说明。",
            "AtomicStampedReference 如何解决 ABA 问题？",
            "AtomicStampedReference 和 AtomicMarkableReference 的区别是什么？",
            "什么场景下 ABA 问题不重要？",
            "什么是 Hazard Pointer？它解决什么问题？",
        ],
        extensions: [
            "研究 Epoch-Based Reclamation（EBR）的原理。",
            "学习 Linux RCU（Read-Copy-Update）机制。",
            "了解 C++ Boost.Lockfree 如何处理 ABA。",
            "研究 memory_order 对 ABA 检测的影响。",
        ],
        sourceUrls: [
            "https://en.wikipedia.org/wiki/ABA_problem",
            "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/atomic/AtomicStampedReference.html",
            "https://en.wikipedia.org/wiki/Hazard_pointer",
        ],
    },
    "w6-3": {
        lessonId: "w6-3",
        background: [
            "【Michael-Scott 队列】1996 年提出的经典无锁队列算法，被广泛采用（如 Java ConcurrentLinkedQueue）。使用两个指针：head 和 tail。",
            "【Treiber 栈】最简单的无锁数据结构：单链表，只在 head 进行 CAS。push/pop 都是 O(1)。受 ABA 问题影响。",
            "【ConcurrentLinkedQueue】Java 文档：'An unbounded thread-safe queue based on linked nodes...uses an efficient non-blocking algorithm based on Michael & Scott'。",
            "【正确性关键】无锁算法的正确性依赖于细微的操作顺序。例如 M&S 队列中必须先链接节点再移动 tail。",
            "【帮助机制】M&S 队列的「帮助」机制：如果发现 tail 落后，其他线程帮助推进 tail，避免单点阻塞。",
        ],
        keyDifficulties: [
            "【内存管理】无锁数据结构的内存回收很复杂：不能在有线程可能访问时释放节点。需要特殊的回收机制。",
            "【线性化点】每个操作必须有明确的线性化点（linearization point），使操作看起来是原子的。找出线性化点是设计的关键。",
            "【DCAS 缺失】许多优雅的无锁算法需要双字 CAS（DCAS），但大多数硬件不支持。必须用单字 CAS 模拟。",
            "【性能不一定更好】无锁不一定比锁快。在低竞争下，锁可能更快（少一次失败的 CAS）。高竞争下优势明显。",
        ],
        handsOnPath: [
            "实现 Treiber 无锁栈，测试其正确性。",
            "研究 ConcurrentLinkedQueue 源码，理解 M&S 算法实现。",
            "实现简化版 M&S 队列，处理 enqueue 和 dequeue。",
            "benchmark 对比无锁队列和 BlockingQueue 在不同场景下的性能。",
            "尝试在无锁栈中触发 ABA 问题。",
        ],
        selfCheck: [
            "Treiber 栈的 push 和 pop 操作是如何实现的？",
            "M&S 队列为什么需要 dummy 节点（哨兵节点）？",
            "什么是线性化点？为什么它重要？",
            "无锁数据结构的内存回收为什么困难？",
            "M&S 队列中的「帮助」机制是什么？",
        ],
        extensions: [
            "阅读 Michael & Scott 1996 年的原始论文。",
            "研究 LCRQ（Lock-free FIFO Queue）等更高级的无锁队列。",
            "学习 Flat Combining 等混合技术。",
            "了解 MPMC（多生产者多消费者）无锁队列的实现。",
        ],
        sourceUrls: [
            "https://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf",
            "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ConcurrentLinkedQueue.html",
            "https://en.wikipedia.org/wiki/Treiber_stack",
        ],
    },
    "w6-4": {
        lessonId: "w6-4",
        background: [
            "【内存顺序问题】现代 CPU 和编译器会重排序指令以提高性能。多线程下，不同线程可能以不同顺序「看到」内存操作。",
            "【C++ memory_order】C++ 定义了多种内存顺序：relaxed（无同步）、acquire（读屏障）、release（写屏障）、seq_cst（全序一致）。",
            "【acquire-release 语义】release 操作之前的写入对后续 acquire 操作可见。这是最常用的同步模式。",
            "【顺序一致性】seq_cst 提供最强保证：所有线程看到相同的操作顺序。代价是可能禁止某些优化。",
            "【Go 的选择】Go 只提供顺序一致的原子操作，不暴露 relaxed 语义。简化编程但可能牺牲极端性能。",
        ],
        keyDifficulties: [
            "【relaxed 陷阱】memory_order_relaxed 只保证原子性，不保证顺序。错误使用可能导致「不可能」的执行结果。",
            "【消耗性读取】memory_order_consume 本意是轻量级的 acquire，但实现复杂，C++17 起不推荐使用。",
            "【架构差异】不同 CPU 架构的内存模型不同。x86 相对强（TSO），ARM 较弱。在弱内存模型上更容易出 bug。",
            "【测试困难】内存顺序 bug 很难复现——可能只在特定硬件、特定时序下出现。需要专门的测试工具。",
        ],
        handsOnPath: [
            "用 C++ atomic 和不同 memory_order 实现无锁计数器，观察行为差异。",
            "实现一个 acquire-release 同步的标志变量。",
            "用 ThreadSanitizer 检测内存顺序错误。",
            "在 ARM 设备上测试 x86 上正确的代码是否仍然正确。",
            "研究 Go atomic 包没有 memory_order 参数的设计决策。",
        ],
        selfCheck: [
            "memory_order_relaxed 提供什么保证？",
            "acquire 和 release 语义分别是什么？它们如何配对使用？",
            "为什么 seq_cst 是最安全但可能最慢的选择？",
            "什么是「存储缓冲区重排序」？它如何影响程序行为？",
            "Go 为什么不提供 relaxed 原子操作？",
        ],
        extensions: [
            "研究 x86-TSO 和 ARM 内存模型的差异。",
            "学习 LLVM 如何实现不同的 memory_order。",
            "了解 Linux 内核的 READ_ONCE/WRITE_ONCE 和 smp_mb() 宏。",
            "研究 Promising Semantics 等新的内存模型理论。",
        ],
        sourceUrls: [
            "https://en.cppreference.com/w/cpp/atomic/memory_order",
            "https://go.dev/ref/mem",
            "https://www.kernel.org/doc/html/latest/core-api/wrappers/memory-barriers.html",
        ],
    },
}

export const week6Quizzes: Record<string, QuizQuestion[]> = {
    "w6-1": [
        {
            id: "w6-1-q1",
            question: "CAS（Compare-And-Swap）操作的语义是什么？",
            options: [
                "交换两个变量的值",
                "比较内存值与期望值，相等则更新，整个过程原子执行",
                "比较两个内存位置",
                "无条件设置新值",
            ],
            answer: 1,
            rationale: "CAS 原子地：比较内存中的值与期望值，相等则替换为新值并返回成功，否则不修改并返回失败。",
        },
        {
            id: "w6-1-q2",
            question: "Lock-Free 和 Wait-Free 的区别是什么？",
            options: [
                "相同概念",
                "Lock-Free 保证至少一个线程前进，Wait-Free 保证所有线程都能在有限步完成",
                "Lock-Free 更强",
                "Wait-Free 不使用原子操作",
            ],
            answer: 1,
            rationale: "Lock-Free 保证系统整体在前进（至少一个线程）；Wait-Free 更强，每个线程都有进度保证，不会被其他线程阻碍。",
        },
        {
            id: "w6-1-q3",
            question: "CAS 失败后的典型处理方式是什么？",
            options: [
                "抛出异常",
                "在循环中重新读取值并重试 CAS",
                "放弃操作",
                "使用锁代替",
            ],
            answer: 1,
            rationale: "CAS 循环模式：读取当前值 → 计算新值 → CAS 尝试更新 → 失败则回到第一步重试。",
        },
        {
            id: "w6-1-q4",
            question: "x86 架构提供的 CAS 指令是什么？",
            options: [
                "ADD",
                "CMPXCHG",
                "XCHG",
                "LOCK",
            ],
            answer: 1,
            rationale: "x86 的 CMPXCHG（Compare and Exchange）指令实现 CAS，通常配合 LOCK 前缀确保多核下的原子性。",
        },
        {
            id: "w6-1-q5",
            question: "无锁编程相比使用锁的主要优势是什么？",
            options: [
                "总是更快",
                "实现更简单",
                "避免死锁、优先级反转，不需要上下文切换",
                "不需要原子操作",
            ],
            answer: 2,
            rationale: "无锁避免了锁的常见问题：死锁、优先级反转、锁竞争导致的上下文切换。但实现复杂，不一定更快。",
        },
        {
            id: "w6-1-q6",
            question: "以下哪个是无锁编程的挑战？",
            options: [
                "不能使用多线程",
                "ABA 问题、内存顺序、正确性难以验证",
                "只能在单核 CPU 上运行",
                "性能总是比锁差",
            ],
            answer: 1,
            rationale: "无锁编程面临：ABA 问题、复杂的内存顺序保证、难以测试和证明正确性、极端竞争下的活锁风险。",
        },
        {
            id: "w6-1-q7",
            question: "CAS 操作通常需要什么内存语义？",
            options: [
                "无内存语义要求",
                "至少 acquire-release 语义确保可见性",
                "只需要 relaxed",
                "只需要 acquire",
            ],
            answer: 1,
            rationale: "CAS 通常用于同步，需要 acquire-release 语义确保 CAS 成功后，其他线程能看到相关的内存修改。",
        },
        {
            id: "w6-1-q8",
            question: "ARM 架构实现原子操作使用什么机制？",
            options: [
                "CMPXCHG",
                "LL/SC（Load-Linked/Store-Conditional）",
                "LOCK 前缀",
                "软件模拟",
            ],
            answer: 1,
            rationale: "ARM 使用 LL/SC：LDREX 加载并标记内存位置，STREX 条件存储（如果标记未被清除）。与 CAS 效果相似但机制不同。",
        },
        {
            id: "w6-1-q9",
            question: "无锁算法在高竞争下可能出现什么问题？",
            options: [
                "死锁",
                "CAS 不断失败重试，类似活锁",
                "数据丢失",
                "无问题",
            ],
            answer: 1,
            rationale: "高竞争下，某个线程的 CAS 可能持续被其他线程「击败」而一直重试，虽然系统整体在前进，但该线程可能长时间无进展。",
        },
        {
            id: "w6-1-q10",
            question: "Java 中实现 CAS 的底层类是什么？",
            options: [
                "java.util.concurrent.Lock",
                "sun.misc.Unsafe（或 VarHandle）",
                "java.lang.Object",
                "java.util.concurrent.Semaphore",
            ],
            answer: 1,
            rationale: "Java 的原子类底层使用 Unsafe.compareAndSwapXxx()（Java 9+ 推荐使用 VarHandle）直接调用 CPU 的 CAS 指令。",
        },
        {
            id: "w6-1-q11",
            question: "CAS 操作如果成功返回什么？",
            options: [
                "新值",
                "旧值",
                "true（布尔）",
                "0",
            ],
            answer: 2,
            rationale: "大多数 API（如 Java compareAndSet）在 CAS 成功时返回 true，失败时返回 false。某些 API 返回旧值。",
        },
        {
            id: "w6-1-q12",
            question: "无锁编程什么时候比使用锁更有优势？",
            options: [
                "总是更好",
                "高竞争、临界区短、需要避免死锁时",
                "低竞争时",
                "单线程时",
            ],
            answer: 1,
            rationale: "无锁在高竞争、短临界区时优势明显（避免上下文切换）。低竞争时锁可能更快。需要避免死锁时无锁是好选择。",
        },
    ],
    "w6-2": [
        {
            id: "w6-2-q1",
            question: "什么是 ABA 问题？",
            options: [
                "CAS 总是失败",
                "值从 A→B→A 变化，CAS 无法检测中间状态",
                "内存泄漏",
                "死锁的一种",
            ],
            answer: 1,
            rationale: "ABA 问题：CAS 只比较当前值与期望值。如果值经历 A→B→A 的变化，CAS 会认为值「没变」而成功，但实际中间发生过变化。",
        },
        {
            id: "w6-2-q2",
            question: "AtomicStampedReference 如何解决 ABA 问题？",
            options: [
                "使用更强的 CAS",
                "为引用添加整数版本号，CAS 同时比较引用和版本",
                "禁止值变化",
                "使用锁",
            ],
            answer: 1,
            rationale: "AtomicStampedReference 维护 [reference, stamp] 对。CAS 同时比较引用和版本号，即使引用相同，版本号变化也会检测到。",
        },
        {
            id: "w6-2-q3",
            question: "无锁栈中 ABA 问题的典型场景是什么？",
            options: [
                "push 操作失败",
                "pop 时节点被移除又重新加入，导致 CAS 成功但栈结构已变",
                "栈溢出",
                "内存不足",
            ],
            answer: 1,
            rationale: "线程 1 准备 pop(A)，被中断。其他线程 pop(A), pop(B), push(A)。线程 1 恢复，head 仍是 A，CAS 成功，但 A.next 已不是原来的 B。",
        },
        {
            id: "w6-2-q4",
            question: "AtomicMarkableReference 与 AtomicStampedReference 的区别是什么？",
            options: [
                "完全相同",
                "前者用布尔标记，后者用整数版本号",
                "前者更快",
                "后者不解决 ABA",
            ],
            answer: 1,
            rationale: "AtomicStampedReference 用整数 stamp（可无限递增），AtomicMarkableReference 用布尔 mark（只有两个状态），适合标记删除。",
        },
        {
            id: "w6-2-q5",
            question: "什么情况下 ABA 问题不重要？",
            options: [
                "所有无锁场景",
                "当中间状态不影响最终结果时，如简单计数器",
                "使用 64 位值时",
                "单线程时",
            ],
            answer: 1,
            rationale: "简单计数器中，值从 5→6→5 变化后 CAS 成功更新为 6，结果仍正确。ABA 只在中间状态有语义意义时才是问题。",
        },
        {
            id: "w6-2-q6",
            question: "Hazard Pointer 解决的是什么问题？",
            options: [
                "ABA 问题",
                "无锁数据结构中的安全内存回收",
                "死锁",
                "竞态条件",
            ],
            answer: 1,
            rationale: "Hazard Pointer 让线程声明正在访问的指针，回收器延迟释放这些指针指向的内存，确保不会在使用时被释放。",
        },
        {
            id: "w6-2-q7",
            question: "版本号（stamp）溢出是否是实际问题？",
            options: [
                "是，必须处理",
                "不是，64 位版本号溢出概率极低",
                "版本号不会溢出",
                "只在 32 位系统上是问题",
            ],
            answer: 1,
            rationale: "使用 64 位版本号，即使每秒递增十亿次，也需要数百年才会溢出。实践中可以忽略这个问题。",
        },
        {
            id: "w6-2-q8",
            question: "Java ConcurrentLinkedQueue 如何避免 ABA 问题？",
            options: [
                "使用 AtomicStampedReference",
                "通过不重用节点和「帮助」机制设计算法避免",
                "使用锁",
                "不处理 ABA",
            ],
            answer: 1,
            rationale: "M&S 队列通过算法设计避免 ABA：节点一旦出队就不再重用，且使用哨兵节点和帮助机制确保一致性。",
        },
        {
            id: "w6-2-q9",
            question: "AtomicStampedReference 的 compareAndSet 方法需要几个参数？",
            options: [
                "2 个",
                "4 个：期望引用、新引用、期望版本、新版本",
                "3 个",
                "1 个",
            ],
            answer: 1,
            rationale: "compareAndSet(expectedRef, newRef, expectedStamp, newStamp)：同时比较引用和版本号，都匹配才更新。",
        },
        {
            id: "w6-2-q10",
            question: "Epoch-Based Reclamation（EBR）的基本思想是什么？",
            options: [
                "立即释放内存",
                "将时间划分为 epoch，只在所有线程都离开旧 epoch 后才回收该 epoch 的内存",
                "永不回收",
                "使用垃圾回收器",
            ],
            answer: 1,
            rationale: "EBR 维护全局 epoch 计数器，每个线程记录其当前 epoch。只有当所有线程都进入新 epoch 后，旧 epoch 的内存才能安全回收。",
        },
        {
            id: "w6-2-q11",
            question: "为什么无锁数据结构的内存回收困难？",
            options: [
                "内存不足",
                "无法确定何时没有线程在访问某块内存",
                "GC 不工作",
                "内存碎片",
            ],
            answer: 1,
            rationale: "没有锁保护，无法确定何时可以安全释放内存——可能有线程正在通过已缓存的指针访问它。需要特殊的回收协议。",
        },
        {
            id: "w6-2-q12",
            question: "Go 语言如何处理无锁数据结构的 ABA 问题？",
            options: [
                "提供 AtomicStampedPointer",
                "依赖 GC，被引用的对象不会被回收，避免指针悬挂",
                "不支持无锁编程",
                "使用 channel 代替",
            ],
            answer: 1,
            rationale: "Go 有 GC，指针指向的对象在有引用时不会被回收，避免了 C/C++ 中因内存重用导致的 ABA 问题。",
        },
    ],
    "w6-3": [
        {
            id: "w6-3-q1",
            question: "Treiber 栈的基本数据结构是什么？",
            options: [
                "数组",
                "单链表，head 指针指向栈顶",
                "双链表",
                "树",
            ],
            answer: 1,
            rationale: "Treiber 栈是最简单的无锁栈：单链表结构，只需要一个 head 指针，push/pop 都在 head 进行 CAS。",
        },
        {
            id: "w6-3-q2",
            question: "Michael-Scott 队列为什么需要 dummy 节点（哨兵节点）？",
            options: [
                "提高性能",
                "简化边界条件，避免 head==tail 时的特殊处理",
                "存储元数据",
                "不需要 dummy 节点",
            ],
            answer: 1,
            rationale: "哨兵节点让空队列时 head 和 tail 都指向它，避免了 null 指针和空队列的特殊处理，简化了 CAS 逻辑。",
        },
        {
            id: "w6-3-q3",
            question: "什么是线性化点（Linearization Point）？",
            options: [
                "代码的起点",
                "操作「生效」的原子时刻，使并发操作看起来按某顺序原子执行",
                "循环的终点",
                "函数返回点",
            ],
            answer: 1,
            rationale: "线性化点是并发操作的逻辑生效时刻。所有操作的线性化点可以排成一个顺序，使结果等价于顺序执行。",
        },
        {
            id: "w6-3-q4",
            question: "M&S 队列 enqueue 操作的线性化点在哪里？",
            options: [
                "创建新节点时",
                "将新节点链接到 tail 时的成功 CAS",
                "更新 tail 指针时",
                "方法返回时",
            ],
            answer: 1,
            rationale: "enqueue 的线性化点是 CAS 成功将新节点链接到当前最后节点的 next 指针。此时元素逻辑上进入队列。",
        },
        {
            id: "w6-3-q5",
            question: "M&S 队列的「帮助」机制是什么？",
            options: [
                "管理员手动干预",
                "如果发现 tail 落后，其他线程帮助推进 tail 指针",
                "增加线程数",
                "使用锁辅助",
            ],
            answer: 1,
            rationale: "如果线程发现 tail.next != null（tail 落后），会帮助 CAS 推进 tail，确保 tail 不会长期落后阻碍其他操作。",
        },
        {
            id: "w6-3-q6",
            question: "Treiber 栈的 push 操作如何实现？",
            options: [
                "直接修改 head",
                "创建新节点 → new.next=head → CAS(head, old, new)，失败重试",
                "先锁定再修改",
                "在尾部插入",
            ],
            answer: 1,
            rationale: "push：创建新节点，设置 next 指向当前 head，然后 CAS 将 head 更新为新节点。CAS 失败则重新读取 head 重试。",
        },
        {
            id: "w6-3-q7",
            question: "为什么无锁数据结构很难正确实现？",
            options: [
                "代码量大",
                "需要精确的内存顺序和正确的线性化，测试难以覆盖所有交错",
                "编译器不支持",
                "只能用汇编",
            ],
            answer: 1,
            rationale: "无锁正确性依赖细微的操作顺序和内存模型。微小错误可能只在极少数执行交错下暴露，很难测试发现。",
        },
        {
            id: "w6-3-q8",
            question: "Java ConcurrentLinkedQueue 基于什么算法？",
            options: [
                "Treiber 栈",
                "Michael-Scott 无锁队列",
                "两锁队列",
                "循环数组",
            ],
            answer: 1,
            rationale: "Java 文档明确指出 ConcurrentLinkedQueue 基于 'Michael & Scott' 算法，使用链表实现无界无锁队列。",
        },
        {
            id: "w6-3-q9",
            question: "DCAS（Double Compare-And-Swap）是什么？为什么有用？",
            options: [
                "两次 CAS",
                "同时原子更新两个内存位置，可简化某些算法但硬件通常不支持",
                "更快的 CAS",
                "双精度 CAS",
            ],
            answer: 1,
            rationale: "DCAS 原子地 CAS 两个独立内存位置，可简化某些无锁算法。但大多数硬件不支持，必须用单字 CAS 模拟。",
        },
        {
            id: "w6-3-q10",
            question: "无锁队列在什么场景下比 BlockingQueue 更有优势？",
            options: [
                "需要阻塞等待时",
                "高吞吐量、低延迟、不能接受线程阻塞时",
                "队列很长时",
                "单生产者单消费者时",
            ],
            answer: 1,
            rationale: "无锁队列避免了线程阻塞和上下文切换，在高吞吐量、低延迟要求的场景（如高频交易）更有优势。",
        },
        {
            id: "w6-3-q11",
            question: "Treiber 栈受 ABA 问题影响的原因是什么？",
            options: [
                "不使用 CAS",
                "节点可能被 pop 后又 push 回来，导致 head 看起来没变但 next 已变",
                "栈太深",
                "内存不足",
            ],
            answer: 1,
            rationale: "如果节点 A 被 pop 后又被重用（或 push 回来），head 仍是 A，CAS 成功，但 A.next 可能已指向不同节点。",
        },
        {
            id: "w6-3-q12",
            question: "M&S 队列的 dequeue 操作返回什么时队列为空？",
            options: [
                "抛出异常",
                "返回 null 或特殊值表示空",
                "阻塞等待",
                "返回 dummy 节点",
            ],
            answer: 1,
            rationale: "M&S 队列的 dequeue 在检测到 head==tail 且 head.next==null 时，返回 null 表示队列为空，而非阻塞。",
        },
    ],
    "w6-4": [
        {
            id: "w6-4-q1",
            question: "memory_order_relaxed 提供什么保证？",
            options: [
                "完整的顺序一致性",
                "只保证原子性，不保证顺序和可见性",
                "acquire 语义",
                "release 语义",
            ],
            answer: 1,
            rationale: "relaxed 只保证操作是原子的，不提供任何同步或顺序保证。其他线程可能以任意顺序观察到 relaxed 操作。",
        },
        {
            id: "w6-4-q2",
            question: "acquire 和 release 语义如何配对使用？",
            options: [
                "不需要配对",
                "release 写之前的操作对后续 acquire 读可见",
                "acquire 必须在 release 之前",
                "只能单独使用",
            ],
            answer: 1,
            rationale: "release 操作之前的所有写入，对获取同一变量的 acquire 操作之后的读取可见。这是最常用的同步模式。",
        },
        {
            id: "w6-4-q3",
            question: "memory_order_seq_cst 的特点是什么？",
            options: [
                "最弱的保证",
                "提供全局一致的操作顺序，所有线程看到相同顺序",
                "无同步保证",
                "只保证单线程顺序",
            ],
            answer: 1,
            rationale: "seq_cst（顺序一致性）是最强的保证：所有 seq_cst 操作有一个全局一致的顺序，所有线程都观察到这个顺序。",
        },
        {
            id: "w6-4-q4",
            question: "为什么 memory_order_consume 不推荐使用？",
            options: [
                "性能差",
                "语义复杂，编译器难以正确实现",
                "已被移除",
                "与 acquire 相同",
            ],
            answer: 1,
            rationale: "consume 本意是轻量级 acquire，但语义复杂，编译器通常将其实现为 acquire。C++17 起不推荐使用。",
        },
        {
            id: "w6-4-q5",
            question: "Go 的 atomic 包提供什么内存顺序？",
            options: [
                "可选择 relaxed/acquire/release/seq_cst",
                "只有顺序一致的操作，不暴露弱内存顺序",
                "无内存顺序保证",
                "只有 relaxed",
            ],
            answer: 1,
            rationale: "Go 的设计选择是只提供顺序一致的原子操作，简化编程模型，避免内存顺序错误，代价是可能牺牲极端性能。",
        },
        {
            id: "w6-4-q6",
            question: "x86 的内存模型（TSO）有什么特点？",
            options: [
                "完全无序",
                "相对强，主要只允许 Store-Load 重排序",
                "与 ARM 相同",
                "不支持原子操作",
            ],
            answer: 1,
            rationale: "x86 TSO（Total Store Order）是相对强的内存模型，只允许 Store-Load 重排序（store 可能在后续 load 之后可见）。",
        },
        {
            id: "w6-4-q7",
            question: "在弱内存模型架构（如 ARM）上需要注意什么？",
            options: [
                "无需注意",
                "更容易出现内存顺序 bug，需要正确使用内存屏障",
                "性能更好",
                "不支持多线程",
            ],
            answer: 1,
            rationale: "ARM 等弱内存模型允许更多重排序。在 x86 上正确的代码可能在 ARM 上出错，必须正确使用内存顺序或屏障。",
        },
        {
            id: "w6-4-q8",
            question: "以下哪个操作通常需要 release 语义？",
            options: [
                "读取共享数据",
                "写入共享数据并通知其他线程",
                "增加计数器",
                "读取配置",
            ],
            answer: 1,
            rationale: "当一个线程完成写入并设置标志通知其他线程时，写标志应使用 release，确保之前的写入对看到标志的线程可见。",
        },
        {
            id: "w6-4-q9",
            question: "以下哪个操作通常需要 acquire 语义？",
            options: [
                "写入共享数据",
                "读取标志/锁后访问共享数据",
                "释放锁",
                "初始化变量",
            ],
            answer: 1,
            rationale: "当线程读取标志/锁确认可以访问数据时，读标志应使用 acquire，确保后续读取能看到其他线程的写入。",
        },
        {
            id: "w6-4-q10",
            question: "Linux 内核中的 smp_mb() 是什么？",
            options: [
                "内存分配函数",
                "完整的内存屏障，阻止屏障前后的读写重排序",
                "多处理器初始化",
                "消息传递函数",
            ],
            answer: 1,
            rationale: "smp_mb()（symmetric multiprocessor memory barrier）是完整内存屏障，确保屏障之前的读写操作在之后的操作之前完成。",
        },
        {
            id: "w6-4-q11",
            question: "为什么内存顺序 bug 难以发现？",
            options: [
                "编译器会报错",
                "可能只在特定硬件、特定时序下出现，难以复现",
                "总是会崩溃",
                "测试工具能完全检测",
            ],
            answer: 1,
            rationale: "内存顺序 bug 依赖特定的执行交错和硬件行为，可能在 x86 上从不出现但在 ARM 上崩溃，很难通过常规测试发现。",
        },
        {
            id: "w6-4-q12",
            question: "compare_exchange_weak 和 compare_exchange_strong 的区别是什么？",
            options: [
                "完全相同",
                "weak 可能虚假失败（即使值匹配），strong 只在值不匹配时失败",
                "strong 更快",
                "weak 更安全",
            ],
            answer: 1,
            rationale: "weak 版本在某些架构上可能虚假失败（spurious failure），但避免了循环内的额外同步。在循环中使用时可能更高效。",
        },
    ],
}
