import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week2Guides: Record<string, LessonGuide> = {
    "w2-1": {
        lessonId: "w2-1",
        background: [
            "【POSIX 标准】pthread_mutex 定义了三种互斥锁类型：NORMAL（死锁重入）、ERRORCHECK（返回错误）、RECURSIVE（维护锁计数）。不同类型在重复加锁时行为不同。",
            "【Go Mutex 特性】Go 官方文档：'A Mutex must not be copied after first use'——Mutex 首次使用后不能复制。零值即为未锁定状态，可直接使用。",
            "【Futex 原理】Linux futex 是 'fast userspace mutex' 的缩写，核心思想是 'the majority of the synchronization operations are performed in user space'——无竞争时完全在用户态完成。",
            "【原子比较阻塞】futex 文档：'The loading of the futex word's value, the comparison with the expected value, and the actual blocking will happen atomically'——这是 futex 的核心保证。",
            "【Robust Mutex】POSIX 提供健壮互斥锁，当持有锁的线程终止时返回 EOWNERDEAD，允许恢复不一致状态。",
        ],
        keyDifficulties: [
            "【不可重入陷阱】Go Mutex 不支持递归加锁：'A Mutex cannot be recursively locked by the same goroutine'——同一 goroutine 重复 Lock() 会死锁。",
            "【TryLock 警告】Go 文档明确警告：'correct uses of TryLock are rare...frequent use of TryLock signals deeper design problems'——TryLock 的正确使用场景很少。",
            "【解锁约束】Go 文档：对未锁定的 Mutex 调用 Unlock() 会导致运行时错误。但 'A locked Mutex is not associated with a particular goroutine'——任何 goroutine 都可以解锁。",
            "【公平性问题】默认的 Mutex 通常是非公平的，可能导致某些线程长期得不到锁（饥饿）。需要显式选择公平策略。",
        ],
        handsOnPath: [
            "用 Go sync.Mutex 保护一个共享计数器，测试并发递增的正确性。",
            "尝试在同一 goroutine 中两次调用 Lock()，观察死锁行为。",
            "使用 defer mu.Unlock() 模式确保锁一定被释放。",
            "对比 Mutex 和 channel 实现相同功能的代码复杂度。",
            "用 C 语言 pthread_mutex 实现相同功能，体会 POSIX 标准。",
        ],
        selfCheck: [
            "Go 的 sync.Mutex 支持递归加锁吗？如果同一 goroutine 两次 Lock() 会发生什么？",
            "什么是 futex？它为什么比传统内核锁更高效？",
            "POSIX 定义的三种 mutex 类型各有什么特点？",
            "为什么 Go 文档警告 TryLock 的正确使用场景很少？",
            "Mutex 首次使用后为什么不能复制？",
        ],
        extensions: [
            "研究 Go runtime 中 Mutex 的实现源码（runtime/lock_futex.go）。",
            "学习 Linux futex 系统调用的各种操作类型（FUTEX_WAIT、FUTEX_WAKE 等）。",
            "了解 Windows 的 CRITICAL_SECTION 与 POSIX mutex 的异同。",
            "研究公平锁与非公平锁的性能权衡。",
        ],
        sourceUrls: [
            "https://man7.org/linux/man-pages/man3/pthread_mutex_lock.3p.html",
            "https://pkg.go.dev/sync#Mutex",
            "https://man7.org/linux/man-pages/man2/futex.2.html",
        ],
    },
    "w2-2": {
        lessonId: "w2-2",
        background: [
            "【RWMutex 原理】Go 文档：'A RWMutex allows multiple concurrent readers or a single writer'——多个读者可以同时持有读锁，但写锁是排他的。",
            "【Java 实现】ReentrantReadWriteLock 支持公平和非公平两种模式，非公平模式 'may indefinitely postpone one or more reader or writer threads'。",
            "【锁降级】Java 文档展示锁降级模式：持有写锁时可获取读锁，然后释放写锁——'Reentrancy also allows downgrading from the write lock to a read lock'。",
            "【POSIX rwlock】pthread_rwlock 规定读锁获取条件：'a writer does not hold the lock and there are no writers blocked on the lock'——有等待的写者时新读者会阻塞。",
            "【递归读锁禁止】Go 明确禁止递归读锁：'A blocked Lock call excludes new readers from acquiring the lock'——防止写者饥饿。",
        ],
        keyDifficulties: [
            "【写者饥饿】如果总是有新读者到来，写者可能永远等待。Go RWMutex 通过阻塞新读者来防止这个问题。",
            "【锁升级危险】Go 文档：'RLock cannot be upgraded into a Lock, nor can Lock be downgraded into RLock'——尝试升级会死锁。Java 支持降级但不支持升级。",
            "【不可复制】Go RWMutex 与 Mutex 一样，首次使用后不能复制。",
            "【选择困难】何时用 RWMutex 而非 Mutex？只有当读操作远多于写操作，且临界区足够长以抵消额外开销时才值得。",
        ],
        handsOnPath: [
            "用 Go RWMutex 实现一个线程安全的缓存：读操作用 RLock，写操作用 Lock。",
            "测试多个并发读者的性能，对比 Mutex 和 RWMutex。",
            "尝试在持有 RLock 的情况下获取 Lock，观察死锁。",
            "用 Java ReentrantReadWriteLock 实现相同缓存，体验锁降级模式。",
            "模拟写者饥饿场景：持续的读请求阻止写请求完成。",
        ],
        selfCheck: [
            "RWMutex 相比 Mutex 的优势是什么？什么场景适合使用？",
            "什么是锁降级？Go 和 Java 分别是否支持？",
            "为什么 Go 禁止递归读锁？这如何防止写者饥饿？",
            "Java ReentrantReadWriteLock 的公平模式和非公平模式有什么区别？",
            "尝试锁升级（RLock → Lock）会发生什么？",
        ],
        extensions: [
            "研究 Go RWMutex 的 TryRLock 和 TryLock 方法（Go 1.18+）。",
            "学习 Java StampedLock 的乐观读模式。",
            "了解 seqlock（顺序锁）的原理与适用场景。",
            "研究读写锁的各种实现策略（读者优先、写者优先、公平）。",
        ],
        sourceUrls: [
            "https://pkg.go.dev/sync#RWMutex",
            "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/locks/ReentrantReadWriteLock.html",
            "https://man7.org/linux/man-pages/man3/pthread_rwlock_rdlock.3p.html",
        ],
    },
    "w2-3": {
        lessonId: "w2-3",
        background: [
            "【自旋锁定义】Linux 内核文档：自旋锁是 'the most fundamental locking primitive in the Linux kernel'——在等待时忙等（spin）而非阻塞。",
            "【适用场景】内核文档建议：自旋锁适合 'very short, simple' 的临界区。如果临界区较长，阻塞锁更合适。",
            "【中断安全】内核文档警告：如果数据可能被中断处理程序访问，必须使用 spin_lock_irqsave() 禁用本地中断，否则会死锁。",
            "【混合锁策略】现代 Mutex 通常采用混合策略：先自旋一小段时间，如果锁仍不可用则阻塞。Go runtime 的 Mutex 就是这样实现的。",
            "【单一锁原则】内核文档建议 'Keep your usage of spinlocks simple'——使用多个自旋锁增加复杂性，通常不能提高性能。",
        ],
        keyDifficulties: [
            "【CPU 浪费】自旋锁在等待时持续占用 CPU。如果持锁时间长，会严重浪费计算资源。",
            "【死锁风险】内核文档警告：在持有自旋锁时被中断，中断处理程序尝试获取同一锁会死锁——因为锁持有者被阻止继续执行。",
            "【读写自旋锁限制】内核文档：'Note that for rwlock, you cannot upgrade a read lock to a write lock'——不能从读锁升级到写锁。",
            "【优先级反转】低优先级任务持有自旋锁时，高优先级任务只能忙等，无法抢占，可能导致严重延迟。",
        ],
        handsOnPath: [
            "在用户态模拟一个简单的自旋锁：while (atomic_flag.test_and_set()) {}。",
            "测量不同临界区长度下自旋锁 vs 阻塞锁的性能差异。",
            "研究 Go runtime 源码中 Mutex 的自适应自旋实现。",
            "用 C 语言在 Linux 上使用 spinlock API（需要内核模块或特定环境）。",
            "实现一个简单的 ticket lock，保证公平性。",
        ],
        selfCheck: [
            "自旋锁和阻塞锁的主要区别是什么？各自适合什么场景？",
            "为什么在持有自旋锁时不能睡眠或被阻塞？",
            "什么是混合锁（hybrid lock）？它如何结合自旋和阻塞的优点？",
            "Linux 内核中为什么需要 spin_lock_irqsave()？",
            "什么是 ticket lock？它解决了什么问题？",
        ],
        extensions: [
            "研究 MCS 锁和 CLH 锁等可扩展自旋锁的设计。",
            "学习 Linux 内核的 queued spinlock 实现。",
            "了解实时系统中优先级继承协议如何解决优先级反转。",
            "研究无等待（wait-free）算法与自旋锁的权衡。",
        ],
        sourceUrls: [
            "https://www.kernel.org/doc/html/latest/locking/spinlocks.html",
            "https://wiki.openjdk.org/display/HotSpot/Synchronization",
            "https://github.com/golang/go/blob/master/src/runtime/lock_futex.go",
        ],
    },
    "w2-4": {
        lessonId: "w2-4",
        background: [
            "【条件变量定义】Go 文档：sync.Cond 是 'a rendezvous point for goroutines waiting for or announcing the occurrence of an event'——等待或宣布事件发生的会合点。",
            "【三个核心方法】Wait() 原子释放锁并阻塞；Signal() 唤醒一个等待者；Broadcast() 唤醒所有等待者。",
            "【Java Condition】Java 文档：Condition 'factors out the Object monitor methods into distinct objects'——将监视器方法分离到独立对象，支持一个锁关联多个条件。",
            "【POSIX 语义】pthread_cond_wait 'atomically releases the mutex and causes the calling thread to block'——原子释放互斥锁并阻塞是关键。",
            "【返回后重新加锁】所有平台的条件变量在 wait 返回前都会重新获取关联的锁。",
        ],
        keyDifficulties: [
            "【虚假唤醒】POSIX 和 Java 文档都警告：'return from the wait does not imply that the predicate is true'——必须在循环中检查条件，处理虚假唤醒。",
            "【正确使用模式】Go 文档强调必须在循环中调用 Wait：`for !condition() { c.Wait() }`——这是唯一正确的使用方式。",
            "【持锁要求】Go：调用 Wait 前必须持有关联的锁；Java：调用 signal/signalAll 必须持有锁。",
            "【Go 推荐 Channel】Go 文档建议：'For many simple use cases, users will be better off using channels than a Cond'——channel 通常更简单直接。",
        ],
        handsOnPath: [
            "用 Go sync.Cond 实现一个有界缓冲区（生产者-消费者模式）。",
            "用 Java Condition 实现相同功能，体验分离的条件变量优势。",
            "测试虚假唤醒：在 Wait 返回后检查条件是否真的满足。",
            "用 channel 重写生产者-消费者，对比代码简洁度。",
            "实现一个读写器问题：多个读者、多个写者共享缓冲区。",
        ],
        selfCheck: [
            "什么是虚假唤醒（spurious wakeup）？如何正确处理？",
            "为什么必须在 while 循环中调用 cond.Wait()？",
            "Signal() 和 Broadcast() 的区别是什么？各自什么时候使用？",
            "Java 的 Condition 相比 Object.wait/notify 有什么优势？",
            "Go 为什么推荐使用 channel 而非 sync.Cond？",
        ],
        extensions: [
            "研究 Java 的 CountDownLatch、CyclicBarrier、Semaphore 等高级同步工具。",
            "学习 Go 的 sync.WaitGroup 和 context.Context 的使用。",
            "了解 POSIX 条件变量的 clock 选项（单调时钟 vs 实时时钟）。",
            "研究条件变量在数据库和消息队列中的应用。",
        ],
        sourceUrls: [
            "https://man7.org/linux/man-pages/man3/pthread_cond_wait.3p.html",
            "https://pkg.go.dev/sync#Cond",
            "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/locks/Condition.html",
        ],
    },
}

export const week2Quizzes: Record<string, QuizQuestion[]> = {
    "w2-1": [
        {
            id: "w2-1-q1",
            question: "Go 的 sync.Mutex 首次使用后有什么限制？",
            options: [
                "必须显式初始化",
                "不能被复制",
                "只能在创建它的 goroutine 中使用",
                "必须在同一函数中解锁",
            ],
            answer: 1,
            rationale: "Go 文档明确指出：'A Mutex must not be copied after first use'——Mutex 包含内部状态，复制会导致未定义行为。",
        },
        {
            id: "w2-1-q2",
            question: "POSIX pthread_mutex 的 RECURSIVE 类型有什么特点？",
            options: [
                "不允许同一线程重复加锁",
                "同一线程可以多次加锁，维护锁计数",
                "只能用于读操作",
                "自动检测死锁",
            ],
            answer: 1,
            rationale: "POSIX 文档说明 RECURSIVE mutex 'shall maintain the concept of a lock count'——锁计数在首次获取时设为 1，每次加锁递增，解锁递减。",
        },
        {
            id: "w2-1-q3",
            question: "Linux futex 的核心优势是什么？",
            options: [
                "支持跨进程同步",
                "无竞争时大多数操作在用户态完成，避免系统调用",
                "自动处理优先级反转",
                "比自旋锁更快",
            ],
            answer: 1,
            rationale: "futex 文档指出其核心思想是 'the majority of the synchronization operations are performed in user space'——只在竞争时才进入内核。",
        },
        {
            id: "w2-1-q4",
            question: "Go 文档对 TryLock 方法的使用有什么警告？",
            options: [
                "性能比 Lock 差",
                "不是线程安全的",
                "正确使用场景很少，频繁使用表明设计有问题",
                "在 Go 1.18 后被废弃",
            ],
            answer: 2,
            rationale: "Go 文档明确警告：'correct uses of TryLock are rare...frequent use of TryLock signals deeper design problems'。",
        },
        {
            id: "w2-1-q5",
            question: "如果对未锁定的 Go Mutex 调用 Unlock() 会发生什么？",
            options: [
                "静默忽略",
                "返回错误",
                "运行时错误（panic）",
                "阻塞直到有人锁定",
            ],
            answer: 2,
            rationale: "Go 文档说明：'It is a run-time error if m is not locked on entry to Unlock'——对未锁定的 Mutex 解锁会导致 panic。",
        },
        {
            id: "w2-1-q6",
            question: "POSIX robust mutex 在持有锁的线程终止时会怎样？",
            options: [
                "锁被自动释放",
                "系统死锁",
                "下一个等待者获得锁并收到 EOWNERDEAD 错误",
                "所有等待线程被终止",
            ],
            answer: 2,
            rationale: "POSIX 文档说明健壮互斥锁在持有者终止时返回 EOWNERDEAD，提醒新持有者被保护的状态可能不一致。",
        },
        {
            id: "w2-1-q7",
            question: "Go Mutex 的零值状态是什么？",
            options: [
                "已锁定",
                "未锁定，可直接使用",
                "无效，必须初始化",
                "随机状态",
            ],
            answer: 1,
            rationale: "Go 文档说明 Mutex 的零值是未锁定状态：'A Mutex is ready to use immediately after declaration'。",
        },
        {
            id: "w2-1-q8",
            question: "Go Mutex 关于哪个 goroutine 可以解锁有什么规定？",
            options: [
                "只有加锁的 goroutine 才能解锁",
                "任何 goroutine 都可以解锁",
                "必须是主 goroutine",
                "解锁前必须验证身份",
            ],
            answer: 1,
            rationale: "Go 文档指出：'A locked Mutex is not associated with a particular goroutine'——锁不与特定 goroutine 关联，任何 goroutine 都可以解锁。",
        },
        {
            id: "w2-1-q9",
            question: "同一个 goroutine 对 Go sync.Mutex 连续调用两次 Lock() 会发生什么？",
            options: [
                "第二次调用立即返回",
                "锁计数增加",
                "死锁",
                "运行时错误",
            ],
            answer: 2,
            rationale: "Go 文档说明 Mutex 不支持递归加锁：'A Mutex cannot be recursively locked by the same goroutine'——第二次 Lock 会永久阻塞，导致死锁。",
        },
        {
            id: "w2-1-q10",
            question: "futex 的 FUTEX_WAIT 操作的语义是什么？",
            options: [
                "无条件等待直到被唤醒",
                "比较 futex 值与期望值，相等则阻塞",
                "等待固定时间后返回",
                "轮询 futex 值变化",
            ],
            answer: 1,
            rationale: "futex 文档说明 FUTEX_WAIT 是原子的比较-阻塞操作：只有当 futex 值等于期望值时才阻塞，防止竞态条件。",
        },
        {
            id: "w2-1-q11",
            question: "POSIX ERRORCHECK mutex 类型的特点是什么？",
            options: [
                "允许递归加锁",
                "重复加锁和错误解锁都返回错误而非死锁/未定义行为",
                "自动记录错误日志",
                "性能比 NORMAL 更好",
            ],
            answer: 1,
            rationale: "POSIX 文档说明 ERRORCHECK 类型在重复加锁和非持有者解锁时都返回错误，而非死锁或未定义行为。",
        },
        {
            id: "w2-1-q12",
            question: "Go 内存模型中 Mutex 的同步保证是什么？",
            options: [
                "Lock 之前的操作对 Unlock 之后可见",
                "第 n 次 Unlock 发生在第 m 次 Lock 之前（n < m）",
                "所有 Mutex 操作是全局有序的",
                "没有内存同步保证",
            ],
            answer: 1,
            rationale: "Go 文档指出：'The n'th call to Unlock synchronizes before the m'th call to Lock for any n < m'——这建立了 happens-before 关系。",
        },
    ],
    "w2-2": [
        {
            id: "w2-2-q1",
            question: "Go sync.RWMutex 允许什么样的并发访问？",
            options: [
                "多个写者同时访问",
                "多个读者同时访问，或一个写者独占",
                "读者和写者可以同时访问",
                "只允许一个读者或一个写者",
            ],
            answer: 1,
            rationale: "Go 文档明确：'A RWMutex allows multiple concurrent readers or a single writer, but not both'。",
        },
        {
            id: "w2-2-q2",
            question: "Java ReentrantReadWriteLock 支持什么样的锁转换？",
            options: [
                "读锁升级为写锁",
                "写锁降级为读锁",
                "双向转换都支持",
                "不支持任何转换",
            ],
            answer: 1,
            rationale: "Java 文档说明：'Reentrancy also allows downgrading from the write lock to a read lock'——支持降级但不支持升级。",
        },
        {
            id: "w2-2-q3",
            question: "Go RWMutex 如何防止写者饥饿？",
            options: [
                "写者优先级更高",
                "当有写者等待时，阻止新读者获取读锁",
                "限制读者数量",
                "写者可以抢占读者",
            ],
            answer: 1,
            rationale: "Go 文档说明：'A blocked Lock call excludes new readers from acquiring the lock'——当 Lock 等待时，新的 RLock 调用会被阻塞。",
        },
        {
            id: "w2-2-q4",
            question: "尝试在 Go 中将 RLock 升级为 Lock（持有读锁时获取写锁）会发生什么？",
            options: [
                "成功升级",
                "返回错误",
                "死锁",
                "自动释放读锁后获取写锁",
            ],
            answer: 2,
            rationale: "Go 文档明确：'RLock cannot be upgraded into a Lock'——尝试升级会导致死锁，因为写锁需要等待所有读锁释放。",
        },
        {
            id: "w2-2-q5",
            question: "Java ReentrantReadWriteLock 的公平模式有什么特点？",
            options: [
                "性能更好",
                "等待最长的写者或读者组优先获取锁",
                "写者总是优先",
                "与非公平模式相同",
            ],
            answer: 1,
            rationale: "Java 文档说明公平模式使用 'approximately arrival-order policy'——最长等待的单个写者或一组读者获得优先。",
        },
        {
            id: "w2-2-q6",
            question: "POSIX pthread_rwlock 的读锁获取条件是什么？",
            options: [
                "随时可以获取",
                "没有写者持有锁且没有写者在等待",
                "只有没有写者持有锁",
                "读者数量未达上限",
            ],
            answer: 1,
            rationale: "POSIX 文档规定读锁获取条件：'a writer does not hold the lock and there are no writers blocked on the lock'。",
        },
        {
            id: "w2-2-q7",
            question: "Go RWMutex 的 RLocker() 方法返回什么？",
            options: [
                "一个新的 RWMutex",
                "一个只支持 Lock/Unlock 的 Locker 接口，实际操作 RLock/RUnlock",
                "当前持有读锁的 goroutine 数量",
                "读锁状态",
            ],
            answer: 1,
            rationale: "Go 文档说明 RLocker() 返回一个 Locker 接口，其 Lock/Unlock 方法实际调用 RLock/RUnlock。",
        },
        {
            id: "w2-2-q8",
            question: "什么场景最适合使用 RWMutex？",
            options: [
                "读写频率相当",
                "写操作远多于读操作",
                "读操作远多于写操作，且临界区较长",
                "临界区很短的场景",
            ],
            answer: 2,
            rationale: "RWMutex 的额外开销只有在读远多于写且临界区足够长时才能被抵消。短临界区用普通 Mutex 可能更好。",
        },
        {
            id: "w2-2-q9",
            question: "Java ReentrantReadWriteLock 的最大锁数量限制是多少？",
            options: [
                "无限制",
                "1024",
                "65535 个递归写锁 + 65535 个读锁",
                "取决于 JVM 内存",
            ],
            answer: 2,
            rationale: "Java 文档说明：'Maximum number of recursive write locks: 65535; Maximum number of read locks: 65535'。",
        },
        {
            id: "w2-2-q10",
            question: "Go RWMutex 为什么禁止递归读锁？",
            options: [
                "技术上无法实现",
                "防止死锁和保证写者最终能获取锁",
                "性能考虑",
                "与其他语言保持一致",
            ],
            answer: 1,
            rationale: "Go 文档说明：'Recursive read-locking is prohibited'——如果允许递归读锁，写者可能永远无法获取锁。",
        },
        {
            id: "w2-2-q11",
            question: "Java 锁降级的正确步骤是什么？",
            options: [
                "先释放写锁，再获取读锁",
                "先获取读锁，再释放写锁",
                "同时释放写锁和获取读锁",
                "不需要特殊步骤",
            ],
            answer: 1,
            rationale: "Java 文档展示锁降级模式：在持有写锁的情况下先获取读锁，然后释放写锁——这样可以保持对数据的持续访问。",
        },
        {
            id: "w2-2-q12",
            question: "Go RWMutex 的 TryRLock 方法（Go 1.18+）的行为是什么？",
            options: [
                "总是成功",
                "尝试获取读锁，成功返回 true，失败（有写者）返回 false",
                "等待一段时间后超时",
                "与 TryLock 相同",
            ],
            answer: 1,
            rationale: "Go 文档说明 TryRLock 是非阻塞的读锁尝试：如果能立即获取返回 true，否则返回 false。",
        },
    ],
    "w2-3": [
        {
            id: "w2-3-q1",
            question: "自旋锁与阻塞锁的主要区别是什么？",
            options: [
                "自旋锁只能在内核使用",
                "自旋锁在等待时忙等（不让出 CPU），阻塞锁让线程休眠",
                "自旋锁不支持超时",
                "阻塞锁性能更好",
            ],
            answer: 1,
            rationale: "自旋锁的核心特点是在等待时持续检查锁状态（忙等），而阻塞锁会让线程进入休眠状态等待唤醒。",
        },
        {
            id: "w2-3-q2",
            question: "Linux 内核文档建议自旋锁适合什么样的临界区？",
            options: [
                "任何长度的临界区",
                "非常短小简单的临界区",
                "需要阻塞操作的临界区",
                "包含 I/O 操作的临界区",
            ],
            answer: 1,
            rationale: "内核文档建议自旋锁用于 'very short, simple' 的临界区——因为持锁期间其他等待者都在忙等消耗 CPU。",
        },
        {
            id: "w2-3-q3",
            question: "为什么在持有自旋锁时被中断可能导致死锁？",
            options: [
                "中断会自动释放锁",
                "中断处理程序如果尝试获取同一锁，会在同一 CPU 上死锁",
                "中断会破坏锁的状态",
                "自旋锁不支持中断",
            ],
            answer: 1,
            rationale: "内核文档警告：中断打断持锁代码后，如果中断处理程序尝试获取同一锁，会永远等待——因为锁持有者被阻止继续执行。",
        },
        {
            id: "w2-3-q4",
            question: "spin_lock_irqsave() 的作用是什么？",
            options: [
                "只获取锁",
                "获取锁并保存中断状态后禁用本地中断",
                "获取锁并启用中断",
                "只保存中断状态",
            ],
            answer: 1,
            rationale: "内核文档说明 spin_lock_irqsave() 会禁用本地中断并保存之前的中断状态，确保持锁期间不会被中断打断。",
        },
        {
            id: "w2-3-q5",
            question: "什么是混合锁（hybrid lock）？",
            options: [
                "既能读又能写的锁",
                "先尝试自旋一段时间，然后转为阻塞的锁",
                "同时使用多个锁",
                "跨进程的锁",
            ],
            answer: 1,
            rationale: "混合锁结合自旋和阻塞的优点：短时间等待用自旋（避免上下文切换），长时间等待转为阻塞（避免浪费 CPU）。",
        },
        {
            id: "w2-3-q6",
            question: "Linux 内核文档关于使用多个自旋锁有什么建议？",
            options: [
                "越多越好，可以提高并发度",
                "保持简单，多个锁增加复杂性且通常不能提高性能",
                "每个数据结构必须有自己的锁",
                "至少使用两个锁",
            ],
            answer: 1,
            rationale: "内核文档建议 'Keep your usage of spinlocks simple'——使用多个自旋锁会增加死锁风险和代码复杂性。",
        },
        {
            id: "w2-3-q7",
            question: "内核读写自旋锁有什么限制？",
            options: [
                "不支持多个读者",
                "不能从读锁升级到写锁",
                "写者不能等待",
                "只能在用户态使用",
            ],
            answer: 1,
            rationale: "内核文档指出：'you cannot upgrade a read lock to a write lock'——如果可能需要修改，必须一开始就获取写锁。",
        },
        {
            id: "w2-3-q8",
            question: "Go runtime 的 Mutex 实现采用什么策略？",
            options: [
                "纯自旋锁",
                "纯阻塞锁",
                "自适应混合策略：先自旋再阻塞",
                "随机选择",
            ],
            answer: 2,
            rationale: "Go runtime 的 Mutex 实现采用混合策略：短时间自旋尝试获取锁，如果失败则转为阻塞（使用 futex）。",
        },
        {
            id: "w2-3-q9",
            question: "为什么自旋锁不适合单处理器系统？",
            options: [
                "单处理器不支持原子操作",
                "自旋等待时锁持有者无法执行，导致浪费 CPU 且锁永远不会释放",
                "自旋锁只能在多核上工作",
                "性能考虑",
            ],
            answer: 1,
            rationale: "在单处理器上，自旋等待时锁持有者被阻止运行，锁永远不会被释放——只有禁用抢占或中断才有意义。",
        },
        {
            id: "w2-3-q10",
            question: "什么是 ticket lock？",
            options: [
                "一种门票系统",
                "保证 FIFO 顺序的公平自旋锁",
                "限制锁持有时间的锁",
                "支持超时的锁",
            ],
            answer: 1,
            rationale: "Ticket lock 像排队叫号：每个等待者取一个递增的票号，锁释放时服务号递增，票号匹配的等待者获得锁——保证 FIFO 公平性。",
        },
        {
            id: "w2-3-q11",
            question: "自旋锁在什么情况下比阻塞锁性能更好？",
            options: [
                "临界区很长",
                "临界区很短，锁等待时间小于上下文切换开销",
                "有很多等待者",
                "需要跨进程同步",
            ],
            answer: 1,
            rationale: "当预期等待时间小于线程挂起/唤醒的开销时，自旋锁更高效——这通常发生在非常短的临界区场景。",
        },
        {
            id: "w2-3-q12",
            question: "优先级反转在自旋锁场景下有什么危害？",
            options: [
                "没有危害",
                "低优先级任务持有锁时，高优先级任务只能忙等，浪费 CPU",
                "会自动解决",
                "只影响实时系统",
            ],
            answer: 1,
            rationale: "高优先级任务等待低优先级任务释放自旋锁时，会一直忙等消耗 CPU，而低优先级任务可能得不到调度来释放锁。",
        },
    ],
    "w2-4": [
        {
            id: "w2-4-q1",
            question: "Go sync.Cond 的 Wait() 方法在调用时会做什么？",
            options: [
                "只是等待",
                "原子地释放关联的锁并阻塞，返回前重新获取锁",
                "检查条件是否满足",
                "唤醒其他等待者",
            ],
            answer: 1,
            rationale: "Go 文档说明 Wait() 'atomically unlocks c.L and suspends the calling goroutine'，返回前会重新 Lock c.L。",
        },
        {
            id: "w2-4-q2",
            question: "为什么必须在循环中调用 cond.Wait()？",
            options: [
                "提高性能",
                "处理虚假唤醒（spurious wakeup）和竞态条件",
                "Go 语法要求",
                "防止死锁",
            ],
            answer: 1,
            rationale: "POSIX 和 Go 文档都强调：Wait 返回不保证条件为真（可能是虚假唤醒或其他线程已处理），必须重新检查条件。",
        },
        {
            id: "w2-4-q3",
            question: "Java Condition 相比 Object.wait/notify 的优势是什么？",
            options: [
                "性能更好",
                "一个锁可以关联多个条件，支持不同的等待队列",
                "不需要持有锁",
                "自动处理虚假唤醒",
            ],
            answer: 1,
            rationale: "Java 文档说明 Condition 'factors out the Object monitor methods'——允许一个 Lock 关联多个 Condition，实现更精细的线程协调。",
        },
        {
            id: "w2-4-q4",
            question: "Signal() 和 Broadcast() 的区别是什么？",
            options: [
                "Signal 更快",
                "Signal 唤醒一个等待者，Broadcast 唤醒所有等待者",
                "Signal 是阻塞的，Broadcast 是非阻塞的",
                "它们完全相同",
            ],
            answer: 1,
            rationale: "Go 和 Java 文档都说明：Signal 唤醒一个等待线程，Broadcast/signalAll 唤醒所有等待线程。",
        },
        {
            id: "w2-4-q5",
            question: "Go 文档对于 sync.Cond vs channel 有什么建议？",
            options: [
                "总是使用 sync.Cond",
                "对于大多数简单场景，channel 更好",
                "它们不能互换",
                "sync.Cond 性能更好",
            ],
            answer: 1,
            rationale: "Go 文档建议：'For many simple use cases, users will be better off using channels than a Cond'。",
        },
        {
            id: "w2-4-q6",
            question: "POSIX pthread_cond_timedwait 使用什么样的超时？",
            options: [
                "相对超时（从现在开始）",
                "绝对超时（特定时间点）",
                "无限超时",
                "固定超时",
            ],
            answer: 1,
            rationale: "POSIX 文档说明超时使用绝对时间（struct timespec），这避免了在循环中重新计算相对超时的问题。",
        },
        {
            id: "w2-4-q7",
            question: "调用 Java Condition.signal() 时必须满足什么条件？",
            options: [
                "没有条件",
                "当前线程必须持有关联的锁",
                "至少有一个等待者",
                "条件必须为真",
            ],
            answer: 1,
            rationale: "Java 文档要求：'An implementation may (and typically does) require that the current thread hold the lock when this method is called'。",
        },
        {
            id: "w2-4-q8",
            question: "Go sync.Cond 的正确使用模式是什么？",
            options: [
                "if !condition { c.Wait() }",
                "for !condition() { c.Wait() }",
                "c.Wait(); if condition { ... }",
                "while true { c.Wait() }",
            ],
            answer: 1,
            rationale: "Go 文档强调必须使用 for 循环：`for !condition() { c.Wait() }`——这是处理虚假唤醒的唯一正确方式。",
        },
        {
            id: "w2-4-q9",
            question: "Java Condition.awaitUninterruptibly() 的特点是什么？",
            options: [
                "不能被信号唤醒",
                "等待直到被 signal，忽略中断（但保留中断状态）",
                "无限等待",
                "比 await() 更快",
            ],
            answer: 1,
            rationale: "Java 文档说明 awaitUninterruptibly() 会忽略中断继续等待，但在返回时会保留中断状态。",
        },
        {
            id: "w2-4-q10",
            question: "在生产者-消费者模式中，为什么通常需要两个条件变量？",
            options: [
                "提高性能",
                "分别通知「缓冲区有空间」和「缓冲区有数据」两种条件",
                "Java 要求",
                "防止死锁",
            ],
            answer: 1,
            rationale: "Java 文档的 BoundedBuffer 示例展示：notFull 条件通知生产者可以放入，notEmpty 条件通知消费者可以取出。",
        },
        {
            id: "w2-4-q11",
            question: "Go sync.Cond 在内存模型中提供什么保证？",
            options: [
                "没有同步保证",
                "Broadcast/Signal 调用 synchronizes before 它们唤醒的 Wait 调用",
                "只保证可见性",
                "全局顺序一致",
            ],
            answer: 1,
            rationale: "Go 文档说明：'A call to Broadcast or Signal synchronizes before any Wait call it unblocks'——建立 happens-before 关系。",
        },
        {
            id: "w2-4-q12",
            question: "什么是虚假唤醒（spurious wakeup）？",
            options: [
                "错误地调用了 Signal",
                "线程在没有 Signal/Broadcast 的情况下从 Wait 返回",
                "多个线程同时被唤醒",
                "唤醒了错误的线程",
            ],
            answer: 1,
            rationale: "虚假唤醒指线程可能在没有任何线程调用 signal/broadcast 的情况下从 wait 返回——这是操作系统层面允许的行为。",
        },
    ],
}
