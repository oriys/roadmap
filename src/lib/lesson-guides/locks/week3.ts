import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week3Guides: Record<string, LessonGuide> = {
    "w3-1": {
        lessonId: "w3-1",
        background: [
            "【Coffman 条件】1971 年 Coffman 等人提出死锁的四个必要条件：互斥（Mutual Exclusion）、占有等待（Hold and Wait）、非抢占（No Preemption）、循环等待（Circular Wait）——四者缺一不可。",
            "【哲学家就餐问题】Dijkstra 提出的经典问题：五个哲学家围坐圆桌，每人需要两只筷子才能吃饭。如果每人都拿起左手边的筷子等待右手边的，就会死锁。",
            "【OSTEP 观点】OSTEP 教材指出：'Deadlock is a widespread problem, and can be hard to detect and avoid'——死锁问题普遍存在，难以检测和避免。",
            "【资源分配图】死锁可用有向图表示：进程节点、资源节点、请求边（进程→资源）、分配边（资源→进程）。图中存在环则可能死锁。",
            "【实际案例】数据库事务 A 锁定行 1 等待行 2，事务 B 锁定行 2 等待行 1——这是生产环境中最常见的死锁场景。",
        ],
        keyDifficulties: [
            "【四条件缺一不可】只破坏一个条件就能预防死锁，但每个条件的破坏都有代价：破坏互斥可能导致数据不一致；破坏占有等待影响效率。",
            "【环检测不充分】资源分配图有环不一定死锁——当每种资源有多个实例时，环只是必要条件而非充分条件。",
            "【死锁 vs 活锁】死锁是进程完全停止；活锁是进程不断重试但无法前进。两者都导致无进展，但表现不同。",
            "【隐蔽性】死锁可能在系统运行很久后才出现，因为需要特定的资源请求顺序和时序配合。",
        ],
        handsOnPath: [
            "用 Go 实现哲学家就餐问题，观察死锁发生：每个哲学家先拿左筷子再拿右筷子。",
            "修改实现打破循环等待：让最后一个哲学家先拿右筷子。",
            "用 Java 两个线程互相等待对方持有的锁，构造最简单的死锁。",
            "画出死锁场景的资源分配图，识别图中的环。",
            "在 MySQL 中构造两个事务的死锁，观察 InnoDB 的检测和回滚。",
        ],
        selfCheck: [
            "死锁的四个必要条件分别是什么？为什么缺一不可？",
            "哲学家就餐问题的多种解决方案各有什么优缺点？",
            "资源分配图中的环一定表示死锁吗？什么情况下不是？",
            "如何在代码 review 中识别潜在的死锁风险？",
            "生产环境中最常见的死锁场景是什么？",
        ],
        extensions: [
            "研究 Dijkstra 原始论文中对哲学家就餐问题的描述与解决方案。",
            "学习 Knuth 在《计算机程序设计艺术》中对死锁的讨论。",
            "了解操作系统中的死锁检测算法实现。",
            "研究分布式系统中的死锁问题与检测方法。",
        ],
        sourceUrls: [
            "https://pages.cs.wisc.edu/~remzi/OSTEP/threads-bugs.pdf",
            "https://en.wikipedia.org/wiki/Dining_philosophers_problem",
            "https://www.geeksforgeeks.org/introduction-of-deadlock-in-operating-system/",
        ],
    },
    "w3-2": {
        lessonId: "w3-2",
        background: [
            "【死锁预防】通过设计时破坏四个必要条件之一来预防死锁。这是静态方法，不需要运行时开销，但可能限制系统灵活性。",
            "【银行家算法】Dijkstra 提出的死锁避免算法：系统在分配资源前检查是否会进入不安全状态。类比银行家确保有足够现金满足所有可能的贷款需求。",
            "【安全状态】系统处于安全状态当且仅当存在一个安全序列：所有进程都能按此顺序依次获得所需资源、执行、释放资源。",
            "【资源有序分配】破坏循环等待的经典方法：给所有资源编号，进程必须按编号递增顺序申请资源。",
            "【一次性申请】破坏占有等待的方法：进程必须一次性申请所有需要的资源，要么全部获得要么全部不获得。",
        ],
        keyDifficulties: [
            "【银行家算法开销】每次资源请求都需要运行安全性检查算法，时间复杂度 O(m×n²)，m 是资源类型数，n 是进程数。",
            "【最大需求难以预知】银行家算法要求进程预先声明最大资源需求，但很多应用无法准确预估。",
            "【资源编号困难】在复杂系统中为所有资源确定全局一致的编号顺序可能很困难，且可能限制程序设计。",
            "【预防的代价】每种预防方法都有代价：一次性申请降低资源利用率；有序分配限制编程灵活性。",
        ],
        handsOnPath: [
            "实现银行家算法：维护 Available、Max、Allocation、Need 矩阵，判断安全状态。",
            "模拟银行家算法的资源请求过程，观察哪些请求被允许、哪些被拒绝。",
            "用资源有序分配改写哲学家就餐问题，确保不会死锁。",
            "实现一个简化的死锁预防系统：强制所有锁必须按固定顺序获取。",
            "对比不同预防策略的资源利用率和系统吞吐量。",
        ],
        selfCheck: [
            "银行家算法的安全状态判断过程是怎样的？",
            "为什么银行家算法在实际操作系统中很少使用？",
            "资源有序分配如何打破循环等待条件？",
            "一次性申请所有资源有什么优缺点？",
            "死锁预防和死锁避免的主要区别是什么？",
        ],
        extensions: [
            "研究银行家算法的证明：为什么安全状态一定不会死锁？",
            "学习 Windows 和 Linux 内核的锁顺序约定（lock ordering conventions）。",
            "了解数据库中的死锁预防策略：超时、等待图等。",
            "研究实时系统中的优先级天花板协议（Priority Ceiling Protocol）。",
        ],
        sourceUrls: [
            "https://www.geeksforgeeks.org/deadlock-prevention/",
            "https://www.geeksforgeeks.org/bankers-algorithm-in-operating-system-2/",
            "https://www.geeksforgeeks.org/resource-allocation-graph-rag-in-operating-system/",
        ],
    },
    "w3-3": {
        lessonId: "w3-3",
        background: [
            "【死锁检测】当预防和避免都不可行时，允许死锁发生但及时检测并恢复。这需要定期运行检测算法。",
            "【等待图】单实例资源的死锁检测可用等待图（Wait-for Graph）：节点是进程，边表示等待关系。图中有环则存在死锁。",
            "【MySQL 死锁检测】InnoDB 使用等待图检测死锁：'InnoDB automatically detects transaction deadlocks and rolls back a transaction or transactions to break the deadlock'。",
            "【Go 运行时检测】Go 可以检测所有 goroutine 都阻塞的情况：'all goroutines are asleep - deadlock!'——但只能检测全局死锁。",
            "【恢复策略】检测到死锁后的恢复选项：终止进程、抢占资源、回滚到检查点。每种策略都有代价。",
        ],
        keyDifficulties: [
            "【检测频率权衡】检测太频繁浪费 CPU；太稀疏则死锁持续时间长。需要根据系统特点选择合适频率。",
            "【选择牺牲者】检测到死锁后要选择回滚哪个进程。选择标准：已执行时间、持有资源数、优先级、回滚代价等。",
            "【部分死锁】Go 只能检测全局死锁（所有 goroutine 阻塞），无法检测部分 goroutine 的死锁。",
            "【饥饿风险】如果总是回滚同一个进程，该进程可能饥饿。需要记录回滚历史，避免反复牺牲同一进程。",
        ],
        handsOnPath: [
            "实现等待图的死锁检测算法：维护等待关系，定期检测环。",
            "在 MySQL 中执行 SHOW ENGINE INNODB STATUS 分析死锁日志。",
            "用 Go 编写一个会触发 'all goroutines are asleep' 的程序。",
            "实现一个带超时的锁获取机制作为简单的死锁恢复手段。",
            "模拟死锁恢复：选择代价最小的事务回滚。",
        ],
        selfCheck: [
            "等待图检测算法的时间复杂度是多少？",
            "MySQL InnoDB 检测到死锁后如何选择要回滚的事务？",
            "Go 运行时的死锁检测有什么限制？",
            "超时机制如何帮助处理死锁？有什么缺点？",
            "什么情况下应该选择死锁检测而非预防？",
        ],
        extensions: [
            "研究 MySQL 死锁日志的详细格式和解读方法。",
            "学习 PostgreSQL 的死锁检测实现。",
            "了解分布式数据库（如 CockroachDB）的死锁检测机制。",
            "研究死锁检测的并行化算法。",
        ],
        sourceUrls: [
            "https://dev.mysql.com/doc/refman/8.0/en/innodb-deadlock-detection.html",
            "https://www.geeksforgeeks.org/deadlock-detection-algorithm-in-operating-system/",
            "https://go.dev/ref/spec#Program_execution",
        ],
    },
    "w3-4": {
        lessonId: "w3-4",
        background: [
            "【活锁定义】活锁（Livelock）中进程没有阻塞，而是不断重试但无法前进。就像两个人在走廊相遇，都试图让路但总是选择同一方向。",
            "【饥饿定义】饥饿（Starvation）中进程无限期等待，因为资源总是被其他进程获得。低优先级进程在高优先级进程持续到来时可能饥饿。",
            "【指数退避】解决活锁的经典方法：冲突后等待随机时间再重试。等待时间随重试次数指数增长，减少再次冲突的概率。",
            "【公平调度】解决饥饿的方法：使用公平锁（FIFO 顺序）或老化（Aging）机制——等待越久优先级越高。",
            "【写者饥饿】读写锁中如果读者优先，持续的读请求可能让写者永远等待。Go RWMutex 通过阻塞新读者来防止此问题。",
        ],
        keyDifficulties: [
            "【活锁难诊断】系统看起来在运行（CPU 使用率高），但没有实际进展。比死锁更难发现和诊断。",
            "【退避参数选择】指数退避的基础等待时间和最大重试次数需要根据场景调整。参数不当可能导致响应时间过长或资源浪费。",
            "【公平性代价】公平锁通常比非公平锁性能差，因为需要额外的排队和唤醒开销。需要在公平性和性能间权衡。",
            "【优先级反转】高优先级任务等待低优先级任务持有的锁时，可能发生优先级反转。需要优先级继承或天花板协议解决。",
        ],
        handsOnPath: [
            "编写一个活锁示例：两个线程都尝试让步给对方，导致无限循环。",
            "实现指数退避算法：collision_delay = base_delay * 2^retry_count + random_jitter。",
            "用 Java ReentrantLock 对比公平模式和非公平模式的性能差异。",
            "模拟写者饥饿：持续的读请求阻止写者获得锁。",
            "实现一个简单的老化机制：记录等待时间，动态提升优先级。",
        ],
        selfCheck: [
            "活锁和死锁的主要区别是什么？如何区分？",
            "指数退避算法如何减少冲突？为什么要加随机抖动？",
            "什么场景容易发生写者饥饿？如何防止？",
            "优先级反转是什么？有哪些解决方案？",
            "公平锁为什么通常比非公平锁性能差？",
        ],
        extensions: [
            "研究以太网的 CSMA/CD 协议中的指数退避实现。",
            "学习 Mars Pathfinder 火星探测器的优先级反转事故。",
            "了解 Linux 内核的 RT-Mutex 如何实现优先级继承。",
            "研究无等待（Wait-Free）算法如何彻底避免饥饿。",
        ],
        sourceUrls: [
            "https://en.wikipedia.org/wiki/Exponential_backoff",
            "https://pages.cs.wisc.edu/~remzi/OSTEP/threads-bugs.pdf",
            "https://www.geeksforgeeks.org/starvation-and-aging-in-operating-systems/",
        ],
    },
}

export const week3Quizzes: Record<string, QuizQuestion[]> = {
    "w3-1": [
        {
            id: "w3-1-q1",
            question: "死锁的四个必要条件（Coffman 条件）不包括以下哪一个？",
            options: [
                "互斥（Mutual Exclusion）",
                "占有等待（Hold and Wait）",
                "优先级反转（Priority Inversion）",
                "循环等待（Circular Wait）",
            ],
            answer: 2,
            rationale: "Coffman 条件包括：互斥、占有等待、非抢占（No Preemption）、循环等待。优先级反转是另一个并发问题，不是死锁的必要条件。",
        },
        {
            id: "w3-1-q2",
            question: "哲学家就餐问题中，如果每个哲学家都先拿左手边的筷子再拿右手边的，会发生什么？",
            options: [
                "所有人都能顺利吃饭",
                "可能发生死锁——所有人都拿着一只筷子等待另一只",
                "只有一个人能吃饭",
                "会发生活锁",
            ],
            answer: 1,
            rationale: "当所有哲学家同时拿起左手边的筷子后，每个人都在等待右手边的筷子（被邻座持有），形成循环等待，导致死锁。",
        },
        {
            id: "w3-1-q3",
            question: "资源分配图中存在环是死锁的什么条件？",
            options: [
                "充分条件（一定死锁）",
                "必要条件（可能死锁）",
                "充分必要条件",
                "既非充分也非必要",
            ],
            answer: 1,
            rationale: "当每种资源只有一个实例时，环是充分必要条件；但当资源有多个实例时，环只是必要条件——有环不一定死锁。",
        },
        {
            id: "w3-1-q4",
            question: "以下哪种方法可以打破「循环等待」条件？",
            options: [
                "使用可重入锁",
                "给所有资源编号，按编号顺序申请",
                "设置锁超时",
                "使用读写锁",
            ],
            answer: 1,
            rationale: "资源有序分配要求所有进程按照固定的编号顺序申请资源，这样就不可能形成环状的等待链，从而打破循环等待条件。",
        },
        {
            id: "w3-1-q5",
            question: "「占有等待」条件的含义是什么？",
            options: [
                "进程必须等待才能获得资源",
                "进程持有资源的同时等待其他资源",
                "资源被占用时其他进程必须等待",
                "进程等待时占用 CPU",
            ],
            answer: 1,
            rationale: "占有等待（Hold and Wait）指进程在持有至少一个资源的情况下，还在等待获取其他进程持有的资源。",
        },
        {
            id: "w3-1-q6",
            question: "在数据库中，两个事务形成死锁的典型场景是什么？",
            options: [
                "两个事务读取同一行",
                "事务 A 锁行 1 等行 2，事务 B 锁行 2 等行 1",
                "一个事务锁定整个表",
                "两个事务同时提交",
            ],
            answer: 1,
            rationale: "这是经典的 AB-BA 死锁：事务 A 持有资源 1 等待资源 2，事务 B 持有资源 2 等待资源 1，形成循环等待。",
        },
        {
            id: "w3-1-q7",
            question: "以下哪个不是死锁的必要条件？",
            options: [
                "资源不能被抢占",
                "进程一次只能请求一个资源",
                "资源被互斥使用",
                "存在循环等待链",
            ],
            answer: 1,
            rationale: "死锁四条件是：互斥、占有等待、非抢占、循环等待。进程可以同时请求多个资源，这不是死锁条件。",
        },
        {
            id: "w3-1-q8",
            question: "打破「互斥」条件来预防死锁有什么问题？",
            options: [
                "实现复杂",
                "可能导致数据不一致",
                "性能下降",
                "需要额外内存",
            ],
            answer: 1,
            rationale: "很多资源（如打印机、文件写入）本质上需要互斥访问。强行共享可能导致数据损坏或输出混乱。",
        },
        {
            id: "w3-1-q9",
            question: "在资源分配图中，请求边的方向是？",
            options: [
                "从资源指向进程",
                "从进程指向资源",
                "双向",
                "没有方向",
            ],
            answer: 1,
            rationale: "资源分配图中：请求边从进程指向资源（表示进程请求该资源）；分配边从资源指向进程（表示资源已分配给该进程）。",
        },
        {
            id: "w3-1-q10",
            question: "哲学家就餐问题的「服务员解决方案」是什么？",
            options: [
                "每个哲学家有专属服务员",
                "引入一个仲裁者控制筷子的分配",
                "服务员给哲学家送食物",
                "服务员帮哲学家拿筷子",
            ],
            answer: 1,
            rationale: "服务员解决方案引入一个中央协调者，哲学家必须向服务员申请两只筷子，服务员保证不会形成死锁。",
        },
        {
            id: "w3-1-q11",
            question: "以下关于死锁的说法，哪个是正确的？",
            options: [
                "单线程程序不会死锁",
                "使用锁就一定会死锁",
                "死锁只发生在数据库中",
                "死锁一定涉及多个进程或线程",
            ],
            answer: 3,
            rationale: "死锁的定义就涉及多个进程/线程互相等待对方持有的资源。单个实体无法与自己形成循环等待（除非是不支持重入的递归锁调用）。",
        },
        {
            id: "w3-1-q12",
            question: "「非抢占」条件的含义是什么？",
            options: [
                "进程不能被中断",
                "资源只能由持有者主动释放，不能被强制剥夺",
                "高优先级进程不能抢占低优先级",
                "CPU 不能抢占",
            ],
            answer: 1,
            rationale: "非抢占（No Preemption）指已分配给进程的资源不能被强制收回，只能等进程主动释放。这是死锁四条件之一。",
        },
    ],
    "w3-2": [
        {
            id: "w3-2-q1",
            question: "银行家算法的主要作用是什么？",
            options: [
                "检测已发生的死锁",
                "在资源分配前判断是否会进入不安全状态",
                "强制进程释放资源",
                "计算最优资源分配",
            ],
            answer: 1,
            rationale: "银行家算法是死锁避免算法，在每次资源请求时检查：如果满足请求，系统是否仍处于安全状态。不安全则拒绝请求。",
        },
        {
            id: "w3-2-q2",
            question: "什么是「安全状态」？",
            options: [
                "没有进程在等待资源",
                "存在一个安全序列使所有进程都能完成",
                "所有资源都已分配",
                "没有死锁发生",
            ],
            answer: 1,
            rationale: "安全状态指存在一个进程执行顺序（安全序列），按此顺序每个进程都能获得所需资源、执行完成、释放资源。",
        },
        {
            id: "w3-2-q3",
            question: "银行家算法需要进程提供什么信息？",
            options: [
                "进程优先级",
                "进程的最大资源需求",
                "进程的执行时间",
                "进程的内存使用",
            ],
            answer: 1,
            rationale: "银行家算法要求每个进程在开始时声明其最大资源需求（Max 矩阵），算法根据此信息判断能否安全分配。",
        },
        {
            id: "w3-2-q4",
            question: "银行家算法在实际操作系统中很少使用的原因是什么？",
            options: [
                "算法太简单",
                "很难预知进程的最大资源需求",
                "现代 CPU 不支持",
                "只能用于单核系统",
            ],
            answer: 1,
            rationale: "银行家算法要求预先知道所有进程的最大资源需求，但大多数实际应用无法准确预估这个值，限制了算法的实用性。",
        },
        {
            id: "w3-2-q5",
            question: "资源有序分配打破的是哪个死锁条件？",
            options: [
                "互斥",
                "占有等待",
                "非抢占",
                "循环等待",
            ],
            answer: 3,
            rationale: "资源有序分配要求按固定编号顺序申请资源。这样进程 A 持有资源 i 时只会请求 j>i 的资源，不可能形成环。",
        },
        {
            id: "w3-2-q6",
            question: "一次性申请所有资源的策略打破的是哪个条件？",
            options: [
                "互斥",
                "占有等待",
                "非抢占",
                "循环等待",
            ],
            answer: 1,
            rationale: "一次性申请要求进程在开始时申请所有需要的资源，要么全部获得要么全部不获得。这避免了「持有资源同时等待」的情况。",
        },
        {
            id: "w3-2-q7",
            question: "死锁预防和死锁避免的主要区别是什么？",
            options: [
                "预防是静态的，避免是动态的",
                "预防更快，避免更慢",
                "预防用于数据库，避免用于操作系统",
                "没有区别",
            ],
            answer: 0,
            rationale: "死锁预防在设计时静态地破坏必要条件；死锁避免在运行时动态检查每个请求是否安全。两者权衡不同。",
        },
        {
            id: "w3-2-q8",
            question: "银行家算法中的 Need 矩阵表示什么？",
            options: [
                "已分配的资源",
                "最大需求减去已分配",
                "可用资源",
                "等待中的请求",
            ],
            answer: 1,
            rationale: "Need = Max - Allocation，表示每个进程还需要多少资源才能完成。这是银行家算法判断安全性的关键数据。",
        },
        {
            id: "w3-2-q9",
            question: "资源有序分配的主要缺点是什么？",
            options: [
                "无法保证不死锁",
                "可能限制编程灵活性，难以为所有资源确定全局顺序",
                "性能开销太大",
                "只适用于单线程",
            ],
            answer: 1,
            rationale: "在复杂系统中，为所有锁/资源确定一个全局一致的顺序可能很困难，且可能要求程序员按不自然的顺序获取锁。",
        },
        {
            id: "w3-2-q10",
            question: "一次性申请所有资源的主要缺点是什么？",
            options: [
                "无法实现",
                "资源利用率低，因为资源被占用但暂时不使用",
                "会导致死锁",
                "需要特殊硬件",
            ],
            answer: 1,
            rationale: "进程可能需要在不同阶段使用不同资源，一次性全部申请意味着很多资源在大部分时间被占用但未使用，降低利用率。",
        },
        {
            id: "w3-2-q11",
            question: "银行家算法的时间复杂度是多少？（m 为资源类型数，n 为进程数）",
            options: [
                "O(n)",
                "O(m×n)",
                "O(m×n²)",
                "O(2^n)",
            ],
            answer: 2,
            rationale: "安全性检查需要 O(n) 次迭代找到可完成的进程，每次迭代检查 O(n) 个进程的 O(m) 个资源，总体 O(m×n²)。",
        },
        {
            id: "w3-2-q12",
            question: "如果系统处于不安全状态，一定会发生死锁吗？",
            options: [
                "是的，一定会死锁",
                "不一定，但有死锁的风险",
                "不会，不安全状态不影响",
                "取决于 CPU 数量",
            ],
            answer: 1,
            rationale: "不安全状态意味着可能存在导致死锁的资源请求序列，但不意味着一定会发生。实际请求顺序可能不会触发死锁。",
        },
    ],
    "w3-3": [
        {
            id: "w3-3-q1",
            question: "等待图（Wait-for Graph）中的边表示什么？",
            options: [
                "资源分配关系",
                "进程 A 等待进程 B 持有的资源",
                "进程间的通信",
                "进程的优先级关系",
            ],
            answer: 1,
            rationale: "等待图是资源分配图的简化：只有进程节点，边 P1→P2 表示 P1 等待 P2 持有的某个资源。图中有环则存在死锁。",
        },
        {
            id: "w3-3-q2",
            question: "MySQL InnoDB 检测到死锁后的默认处理方式是什么？",
            options: [
                "终止所有相关事务",
                "回滚代价最小的事务",
                "等待管理员干预",
                "重启数据库",
            ],
            answer: 1,
            rationale: "InnoDB 文档说明：检测到死锁后会选择一个事务作为牺牲者回滚。通常选择回滚代价最小的事务（如修改行数最少的）。",
        },
        {
            id: "w3-3-q3",
            question: "Go 运行时的死锁检测能检测什么情况？",
            options: [
                "任意两个 goroutine 之间的死锁",
                "所有 goroutine 都阻塞的情况",
                "单个 goroutine 的无限循环",
                "内存泄漏",
            ],
            answer: 1,
            rationale: "Go 运行时只能检测全局死锁：'all goroutines are asleep - deadlock!'。如果只有部分 goroutine 死锁，其他 goroutine 仍在运行，则无法检测。",
        },
        {
            id: "w3-3-q4",
            question: "死锁检测的频率应该如何选择？",
            options: [
                "越频繁越好",
                "只在系统空闲时检测",
                "根据系统特点权衡检测开销和死锁持续时间",
                "每秒固定检测一次",
            ],
            answer: 2,
            rationale: "检测太频繁浪费 CPU 资源；太稀疏则死锁可能长时间存在。需要根据系统的死锁发生概率和检测成本来平衡。",
        },
        {
            id: "w3-3-q5",
            question: "选择死锁牺牲者时通常不考虑以下哪个因素？",
            options: [
                "进程已执行的时间",
                "进程持有的资源数量",
                "进程的用户名",
                "回滚进程的代价",
            ],
            answer: 2,
            rationale: "选择牺牲者通常考虑：执行时间、持有资源、剩余执行时间、回滚代价、优先级等。用户名一般不是考虑因素。",
        },
        {
            id: "w3-3-q6",
            question: "使用超时机制处理死锁的缺点是什么？",
            options: [
                "无法检测死锁",
                "可能误杀正常等待的进程",
                "实现复杂",
                "不支持多线程",
            ],
            answer: 1,
            rationale: "超时无法区分「正在死锁」和「资源确实被长时间占用」。超时设置太短会误杀正常进程；太长则死锁响应慢。",
        },
        {
            id: "w3-3-q7",
            question: "等待图检测死锁的时间复杂度是多少？（n 为进程数）",
            options: [
                "O(1)",
                "O(n)",
                "O(n²)",
                "O(n³)",
            ],
            answer: 2,
            rationale: "检测等待图中的环需要遍历所有节点和边。最坏情况下边数是 O(n²)，所以整体复杂度是 O(n²)。",
        },
        {
            id: "w3-3-q8",
            question: "以下哪个不是死锁恢复的方法？",
            options: [
                "终止死锁进程",
                "抢占资源",
                "增加 CPU 数量",
                "回滚到检查点",
            ],
            answer: 2,
            rationale: "死锁恢复方法包括：终止进程、抢占资源、回滚。增加 CPU 不能解决死锁——死锁是资源等待问题，不是计算能力问题。",
        },
        {
            id: "w3-3-q9",
            question: "MySQL 中查看最近死锁信息的命令是什么？",
            options: [
                "SHOW DEADLOCKS",
                "SHOW ENGINE INNODB STATUS",
                "SELECT * FROM deadlocks",
                "DESCRIBE DEADLOCK",
            ],
            answer: 1,
            rationale: "SHOW ENGINE INNODB STATUS 会显示 InnoDB 的详细状态信息，包括 LATEST DETECTED DEADLOCK 部分。",
        },
        {
            id: "w3-3-q10",
            question: "如果总是回滚同一个进程，会导致什么问题？",
            options: [
                "系统崩溃",
                "该进程可能饥饿，永远无法完成",
                "死锁无法解决",
                "其他进程也会被回滚",
            ],
            answer: 1,
            rationale: "如果牺牲者选择算法总是选中同一个进程，该进程会反复回滚，永远无法完成工作——这就是饥饿。需要记录回滚历史。",
        },
        {
            id: "w3-3-q11",
            question: "检测到死锁后抢占资源的难点是什么？",
            options: [
                "无法实现",
                "需要能够回滚被抢占进程的状态",
                "会导致更多死锁",
                "性能太差",
            ],
            answer: 1,
            rationale: "抢占资源意味着强制拿走进程持有的资源，但进程可能已经修改了资源状态。需要有机制回滚这些修改。",
        },
        {
            id: "w3-3-q12",
            question: "死锁检测相比死锁预防的优势是什么？",
            options: [
                "完全避免死锁",
                "不限制资源分配方式，系统更灵活",
                "没有运行时开销",
                "更容易实现",
            ],
            answer: 1,
            rationale: "死锁检测允许系统自由分配资源，只在检测到死锁时恢复。相比预防的静态限制，系统设计更灵活、资源利用率更高。",
        },
    ],
    "w3-4": [
        {
            id: "w3-4-q1",
            question: "活锁（Livelock）的特点是什么？",
            options: [
                "进程完全停止，不消耗 CPU",
                "进程不断执行但无法前进，消耗 CPU",
                "只有一个进程能运行",
                "和死锁完全相同",
            ],
            answer: 1,
            rationale: "活锁中进程没有阻塞，而是在不断尝试和重试，但总是冲突无法前进。CPU 使用率可能很高但没有实际进展。",
        },
        {
            id: "w3-4-q2",
            question: "以下哪个场景描述的是活锁？",
            options: [
                "两个线程都在等待对方释放锁",
                "两个人在走廊相遇，都让路但总选同一方向",
                "低优先级进程永远得不到资源",
                "进程等待用户输入",
            ],
            answer: 1,
            rationale: "走廊相遇场景是活锁的经典比喻：两人都在「礼让」（执行），但总是同时选择同一方向，导致谁也无法通过。",
        },
        {
            id: "w3-4-q3",
            question: "指数退避算法如何帮助解决活锁？",
            options: [
                "让冲突方等待随机时间再重试，减少再次冲突的概率",
                "强制终止一方",
                "增加资源数量",
                "提高优先级",
            ],
            answer: 0,
            rationale: "指数退避让冲突方等待一个随机时间（随重试次数指数增长）再重试。随机性打破了同步冲突的模式。",
        },
        {
            id: "w3-4-q4",
            question: "饥饿（Starvation）发生的原因通常是什么？",
            options: [
                "资源不足",
                "资源总是被更高优先级的进程获得",
                "死锁",
                "系统崩溃",
            ],
            answer: 1,
            rationale: "饥饿通常因为调度策略不公平：高优先级进程持续到来时，低优先级进程永远排在后面，无限期等待。",
        },
        {
            id: "w3-4-q5",
            question: "读写锁中的「写者饥饿」是什么？",
            options: [
                "写者无法获得锁",
                "持续的读请求导致写者永远等待",
                "写操作很慢",
                "写者优先级太高",
            ],
            answer: 1,
            rationale: "如果读者优先策略下持续有读请求到来，写者必须等待所有读者完成。新读者不断加入导致写者永远等不到。",
        },
        {
            id: "w3-4-q6",
            question: "Go 的 sync.RWMutex 如何防止写者饥饿？",
            options: [
                "写者优先级更高",
                "当有写者等待时，阻止新读者获取读锁",
                "限制读者数量",
                "设置读锁超时",
            ],
            answer: 1,
            rationale: "Go 文档说明：'A blocked Lock call excludes new readers from acquiring the lock'——当 Lock 等待时，新的 RLock 调用会被阻塞。",
        },
        {
            id: "w3-4-q7",
            question: "老化（Aging）机制如何解决饥饿？",
            options: [
                "终止老进程",
                "等待时间越长，优先级逐渐提高",
                "定期重置所有优先级",
                "禁用优先级调度",
            ],
            answer: 1,
            rationale: "老化机制让等待中的进程优先级随时间增加。即使初始优先级很低，等待足够久后也能获得足够高的优先级。",
        },
        {
            id: "w3-4-q8",
            question: "公平锁（Fair Lock）的缺点是什么？",
            options: [
                "可能导致死锁",
                "性能通常比非公平锁差",
                "不能保证公平",
                "只支持单线程",
            ],
            answer: 1,
            rationale: "公平锁按 FIFO 顺序分配，需要维护等待队列并按顺序唤醒。这些额外操作使其性能通常低于允许插队的非公平锁。",
        },
        {
            id: "w3-4-q9",
            question: "优先级反转是什么问题？",
            options: [
                "高优先级任务变成低优先级",
                "高优先级任务被低优先级任务持有的锁阻塞",
                "优先级设置错误",
                "两个任务优先级相同",
            ],
            answer: 1,
            rationale: "优先级反转：高优先级任务 H 等待低优先级任务 L 持有的锁，而中优先级任务 M 抢占 L，导致 H 被 M 间接阻塞。",
        },
        {
            id: "w3-4-q10",
            question: "指数退避中为什么要加随机抖动（jitter）？",
            options: [
                "提高性能",
                "防止多个进程在相同时间点重试造成再次冲突",
                "节省内存",
                "简化实现",
            ],
            answer: 1,
            rationale: "如果退避时间是固定的，多个冲突进程可能同时退避相同时间后同时重试，再次冲突。随机抖动打破这种同步。",
        },
        {
            id: "w3-4-q11",
            question: "以下哪个是解决优先级反转的方法？",
            options: [
                "禁用优先级",
                "优先级继承——让持锁的低优先级任务临时获得等待者的高优先级",
                "增加锁数量",
                "使用自旋锁",
            ],
            answer: 1,
            rationale: "优先级继承让持有锁的低优先级任务临时提升到等待该锁的最高优先级任务的级别，防止被中优先级任务抢占。",
        },
        {
            id: "w3-4-q12",
            question: "活锁比死锁更难诊断的原因是什么？",
            options: [
                "活锁更常见",
                "系统看起来在运行（CPU 使用率高），但没有实际进展",
                "活锁会导致系统崩溃",
                "活锁只在特定硬件上发生",
            ],
            answer: 1,
            rationale: "死锁时进程明显停止，容易发现。活锁时 CPU 使用率可能很高，系统看起来「正常运行」，但实际工作没有进展，更难察觉。",
        },
    ],
}
