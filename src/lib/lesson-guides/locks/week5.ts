import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week5Guides: Record<string, LessonGuide> = {
    "w5-1": {
        lessonId: "w5-1",
        background: [
            "【sync.Mutex 基础】Go 文档：'A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex.'——零值即可使用，无需初始化。",
            "【不可重入设计】Go 明确指出：'A locked Mutex is not associated with a particular goroutine'——Mutex 不记录持有者，因此不支持递归加锁。",
            "【RWMutex 语义】Go 文档：'A RWMutex allows multiple concurrent readers or a single writer'——读写分离，适合读多写少场景。",
            "【写者优先】Go RWMutex 防止写者饥饿：'A blocked Lock call excludes new readers from acquiring the lock'——有写者等待时新读者会阻塞。",
            "【defer 惯用法】Go 最佳实践：使用 defer mu.Unlock() 确保锁一定被释放，避免因 panic 或提前 return 导致死锁。",
        ],
        keyDifficulties: [
            "【复制陷阱】Go 文档警告：'A Mutex must not be copied after first use'——复制 Mutex 会导致两个独立的锁，失去互斥性。go vet 可检测此问题。",
            "【死锁调试】同一 goroutine 重复 Lock() 会死锁。Go 运行时只能检测全局死锁（所有 goroutine 都阻塞），部分死锁需要 pprof 分析。",
            "【锁粒度选择】锁粒度太粗降低并发度；太细增加复杂性和开销。需要根据实际竞争情况选择合适粒度。",
            "【RWMutex 开销】RWMutex 比 Mutex 开销大。只有在读操作远多于写且临界区较长时，RWMutex 才能带来收益。",
        ],
        handsOnPath: [
            "用 sync.Mutex 实现线程安全的计数器，使用 defer 确保解锁。",
            "用 sync.RWMutex 实现线程安全的缓存，读操作用 RLock，写操作用 Lock。",
            "故意在同一 goroutine 中两次 Lock()，观察死锁现象。",
            "使用 go vet 检测 Mutex 复制问题。",
            "用 benchmark 对比 Mutex 和 RWMutex 在不同读写比例下的性能。",
        ],
        selfCheck: [
            "为什么 Go 的 Mutex 不支持递归加锁？这是设计缺陷还是有意为之？",
            "sync.Mutex 的零值是什么状态？是否需要初始化？",
            "为什么说 Mutex 复制后会失去互斥性？",
            "RWMutex 如何防止写者饥饿？",
            "什么情况下 RWMutex 比 Mutex 更适合？",
        ],
        extensions: [
            "阅读 Go sync 包源码，理解 Mutex 的 state 字段设计。",
            "学习 Go 内存模型中 Mutex 的 happens-before 保证。",
            "研究 Go 1.9 引入的 Mutex 饥饿模式（starvation mode）。",
            "了解 deadlock 检测工具如 go-deadlock 的原理。",
        ],
        sourceUrls: [
            "https://pkg.go.dev/sync#Mutex",
            "https://pkg.go.dev/sync#RWMutex",
            "https://gobyexample.com/mutexes",
        ],
    },
    "w5-2": {
        lessonId: "w5-2",
        background: [
            "【WaitGroup 用途】Go 文档：'A WaitGroup waits for a collection of goroutines to finish'——等待一组 goroutine 完成，是并发编排的基础工具。",
            "【Add/Done/Wait】WaitGroup 三个核心方法：Add(delta) 增加计数器，Done() 减少计数器（等价于 Add(-1)），Wait() 阻塞直到计数器归零。",
            "【sync.Once 保证】Go 文档：'Once is an object that will perform exactly one action'——确保初始化函数只执行一次，即使并发调用。",
            "【Once 的 happens-before】Go 内存模型：'The completion of a single call of f() from once.Do(f) is synchronized before the return of any call of once.Do(f)'。",
            "【errgroup 扩展】golang.org/x/sync/errgroup 扩展了 WaitGroup：支持 goroutine 返回错误，第一个错误会取消其他 goroutine。",
        ],
        keyDifficulties: [
            "【Add 时机】必须在 goroutine 启动前调用 Add()，否则 Wait() 可能在 goroutine 运行前就返回。",
            "【负计数 panic】WaitGroup 计数器不能变负：如果 Done() 调用次数超过 Add()，会 panic。",
            "【复用 WaitGroup】Wait() 返回后可以重新使用 WaitGroup，但不能在 Wait() 期间调用 Add()。",
            "【Once 不能重置】sync.Once 没有重置方法，一旦执行过就永远不再执行。如需重试需要新的 Once 实例。",
        ],
        handsOnPath: [
            "用 WaitGroup 等待多个并发下载任务完成。",
            "实现并发爬虫：每发现一个新链接 Add(1)，处理完 Done()。",
            "用 sync.Once 实现单例模式的并发安全初始化。",
            "用 errgroup 实现并发任务，收集第一个错误并取消其他任务。",
            "故意多调用一次 Done()，观察 panic 信息。",
        ],
        selfCheck: [
            "WaitGroup 的 Add() 应该在什么时机调用？为什么？",
            "sync.Once 如何保证函数只执行一次？",
            "WaitGroup 的计数器变负会发生什么？",
            "errgroup 相比 WaitGroup 有什么额外功能？",
            "如何正确处理 WaitGroup 在循环中的使用？",
        ],
        extensions: [
            "研究 sync.Once 源码中的双重检查锁定实现。",
            "学习 errgroup 的上下文取消机制。",
            "了解 sync.OnceFunc/OnceValue（Go 1.21+）的便捷用法。",
            "研究 semaphore（golang.org/x/sync/semaphore）的使用场景。",
        ],
        sourceUrls: [
            "https://pkg.go.dev/sync#WaitGroup",
            "https://pkg.go.dev/sync#Once",
            "https://gobyexample.com/waitgroups",
        ],
    },
    "w5-3": {
        lessonId: "w5-3",
        background: [
            "【sync.Cond 定义】Go 文档：'Cond implements a condition variable, a rendezvous point for goroutines waiting for or announcing the occurrence of an event'。",
            "【三个方法】Wait() 释放锁并等待通知；Signal() 唤醒一个等待者；Broadcast() 唤醒所有等待者。",
            "【Channel 哲学】Go 官方博客：'Do not communicate by sharing memory; instead, share memory by communicating'——Channel 是 Go 的首选同步方式。",
            "【Cond vs Channel】Go 文档建议：'For many simple use cases, users will be better off using channels than a Cond'——简单场景优先用 channel。",
            "【Cond 适用场景】当需要向多个等待者广播事件时，Cond.Broadcast() 比 channel 更自然。例如：配置变更通知所有 worker。",
        ],
        keyDifficulties: [
            "【Wait 必须在循环中】Go 文档强调：'Because c.L is not locked when Wait first resumes, the caller typically cannot assume that the condition is true when Wait returns'——必须重新检查条件。",
            "【持锁调用 Wait】调用 Wait() 前必须持有关联的锁，Wait() 会原子地释放锁并阻塞，返回时会重新获取锁。",
            "【虚假唤醒】即使没有 Signal/Broadcast，Wait 也可能返回（spurious wakeup）。这是循环检查条件的另一个原因。",
            "【Channel 的局限】Channel 不支持直接「广播给所有消费者」——需要关闭 channel 或每个消费者一个 channel。",
        ],
        handsOnPath: [
            "用 sync.Cond 实现有界缓冲区（生产者-消费者模式）。",
            "用 channel 实现相同功能，对比代码复杂度。",
            "使用 Cond.Broadcast() 实现配置热更新通知所有 worker。",
            "测试虚假唤醒：在 Wait 返回后打印是否条件真的满足。",
            "实现一个简单的消息订阅系统：发布者 Broadcast，订阅者 Wait。",
        ],
        selfCheck: [
            "为什么 Cond.Wait() 必须在循环中调用？",
            "sync.Cond 和 channel 各自适合什么场景？",
            "什么是虚假唤醒？如何正确处理？",
            "Cond.Signal() 和 Cond.Broadcast() 的区别是什么？",
            "为什么 Go 官方更推荐使用 channel？",
        ],
        extensions: [
            "研究 sync.Cond 的源码实现，理解 notifyList 结构。",
            "学习 context.Context 在取消和超时控制中的应用。",
            "了解为什么某些语言（如 Rust）不提供条件变量。",
            "研究 Go 运行时中 goroutine 的 park/unpark 机制。",
        ],
        sourceUrls: [
            "https://pkg.go.dev/sync#Cond",
            "https://go.dev/blog/pipelines",
            "https://go.dev/blog/codelab-share",
        ],
    },
    "w5-4": {
        lessonId: "w5-4",
        background: [
            "【sync.Map 定义】Go 文档：'Map is like a Go map[interface{}]interface{} but is safe for concurrent use by multiple goroutines'——并发安全的 map。",
            "【优化场景】Go 文档说明 sync.Map 优化了两种场景：'(1) when the entry for a given key is only ever written once but read many times, (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys'。",
            "【sync.Pool 用途】Go 文档：'A Pool is a set of temporary objects that may be individually saved and retrieved'——临时对象池，减少 GC 压力。",
            "【Pool 不是缓存】Go 文档警告：'A Pool is not suitable for pools of resources like network connections'——Pool 中的对象可能随时被回收，不适合持久资源。",
            "【普通 map + Mutex】对于大多数场景，普通 map 配合 sync.Mutex 或 sync.RWMutex 是更简单直接的选择。",
        ],
        keyDifficulties: [
            "【不适合所有场景】sync.Map 不是通用解决方案。如果有大量写入或 key 集合频繁变化，普通 map+锁可能更好。",
            "【类型不安全】sync.Map 使用 interface{}，需要类型断言。Go 1.18+ 可以用泛型封装。",
            "【无法遍历时修改】Range 遍历期间不应该修改 map，否则行为未定义。",
            "【Pool 的 New 函数】如果 Pool 为空且设置了 New 函数，Get() 会调用 New 创建新对象。否则返回 nil。",
        ],
        handsOnPath: [
            "用 sync.Map 实现一个简单的并发缓存。",
            "用普通 map + RWMutex 实现相同功能，对比 API 易用性。",
            "benchmark 对比 sync.Map 和 map+Mutex 在不同场景下的性能。",
            "用 sync.Pool 优化频繁创建销毁的临时对象（如 buffer）。",
            "测试 sync.Pool 在 GC 后对象被回收的行为。",
        ],
        selfCheck: [
            "sync.Map 优化了哪两种使用模式？",
            "什么时候应该用 sync.Map，什么时候用 map+Mutex？",
            "sync.Pool 为什么不适合作为资源池（如连接池）？",
            "sync.Map 的 LoadOrStore 方法的语义是什么？",
            "如何为 sync.Map 添加类型安全的包装？",
        ],
        extensions: [
            "研究 sync.Map 源码中的 read/dirty 双 map 设计。",
            "学习 sync.Pool 如何与 GC 配合（poolLocal、victim cache）。",
            "了解第三方并发 map 实现（如 concurrent-map）的设计。",
            "研究分段锁（shard lock）实现高性能并发 map 的思路。",
        ],
        sourceUrls: [
            "https://pkg.go.dev/sync#Map",
            "https://pkg.go.dev/sync#Pool",
            "https://medium.com/@deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c",
        ],
    },
}

export const week5Quizzes: Record<string, QuizQuestion[]> = {
    "w5-1": [
        {
            id: "w5-1-q1",
            question: "Go sync.Mutex 的零值状态是什么？",
            options: [
                "已锁定",
                "未锁定，可直接使用",
                "无效，必须调用 Init()",
                "随机状态",
            ],
            answer: 1,
            rationale: "Go 文档说明：'The zero value for a Mutex is an unlocked mutex'——零值就是未锁定状态，无需初始化即可使用。",
        },
        {
            id: "w5-1-q2",
            question: "为什么 Go Mutex 不支持递归加锁？",
            options: [
                "技术上无法实现",
                "Mutex 不记录持有者 goroutine，无法判断是否重入",
                "性能考虑",
                "为了兼容 C",
            ],
            answer: 1,
            rationale: "Go 文档：'A locked Mutex is not associated with a particular goroutine'——Mutex 不跟踪持有者，因此无法支持重入。",
        },
        {
            id: "w5-1-q3",
            question: "复制一个已使用的 sync.Mutex 会发生什么？",
            options: [
                "没有问题",
                "两份拷贝是独立的锁，失去互斥性",
                "程序会 panic",
                "编译错误",
            ],
            answer: 1,
            rationale: "复制 Mutex 会创建一个新的独立锁，原来受保护的数据可能被两个不同的锁「保护」，实际上失去了互斥性。",
        },
        {
            id: "w5-1-q4",
            question: "Go RWMutex 如何防止写者饥饿？",
            options: [
                "写者优先级更高",
                "当有写者等待时，阻止新读者获取读锁",
                "限制读者数量",
                "设置超时",
            ],
            answer: 1,
            rationale: "Go 文档：'A blocked Lock call excludes new readers from acquiring the lock'——等待中的写者会阻塞后续的新读者。",
        },
        {
            id: "w5-1-q5",
            question: "使用 defer mu.Unlock() 的好处是什么？",
            options: [
                "性能更好",
                "确保无论函数如何返回（正常/panic）锁都会被释放",
                "可以跨函数使用",
                "支持重入",
            ],
            answer: 1,
            rationale: "defer 确保即使发生 panic 或有多个 return 路径，unlock 都会执行，避免死锁。",
        },
        {
            id: "w5-1-q6",
            question: "go vet 能检测什么与 Mutex 相关的问题？",
            options: [
                "死锁",
                "复制了首次使用后的 Mutex",
                "未释放锁",
                "锁竞争",
            ],
            answer: 1,
            rationale: "go vet 的 copylocks 检查能发现复制包含 sync.Mutex、sync.RWMutex 等同步原语的值。",
        },
        {
            id: "w5-1-q7",
            question: "sync.RWMutex 的 RLocker() 方法返回什么？",
            options: [
                "读锁的持有者",
                "一个 Locker 接口，其 Lock/Unlock 调用 RLock/RUnlock",
                "读锁计数",
                "新的 RWMutex",
            ],
            answer: 1,
            rationale: "RLocker() 返回一个实现 Locker 接口的对象，调用其 Lock() 实际执行 RLock()，方便传递给需要 Locker 的函数。",
        },
        {
            id: "w5-1-q8",
            question: "什么时候 RWMutex 比 Mutex 更合适？",
            options: [
                "总是使用 RWMutex",
                "读操作远多于写操作，且临界区较长时",
                "只有写操作时",
                "单 goroutine 场景",
            ],
            answer: 1,
            rationale: "RWMutex 有额外开销，只有在读远多于写且临界区足够长以抵消开销时才值得使用。",
        },
        {
            id: "w5-1-q9",
            question: "同一 goroutine 对 sync.Mutex 连续调用两次 Lock() 会发生什么？",
            options: [
                "第二次立即返回",
                "死锁（永久阻塞）",
                "Panic",
                "重入成功",
            ],
            answer: 1,
            rationale: "Go Mutex 不支持重入，第二次 Lock() 会等待第一次 Unlock()，但因为是同一 goroutine，永远不会 unlock，导致死锁。",
        },
        {
            id: "w5-1-q10",
            question: "Go 1.9 引入的 Mutex「饥饿模式」解决什么问题？",
            options: [
                "死锁检测",
                "某些 goroutine 长时间等待锁的公平性问题",
                "性能优化",
                "内存泄漏",
            ],
            answer: 1,
            rationale: "饥饿模式确保等待超过 1ms 的 goroutine 能获得锁，防止某些 goroutine 无限期等待。",
        },
        {
            id: "w5-1-q11",
            question: "尝试对未锁定的 Mutex 调用 Unlock() 会发生什么？",
            options: [
                "静默忽略",
                "运行时 panic",
                "返回错误",
                "阻塞",
            ],
            answer: 1,
            rationale: "Go 文档说明：对未锁定的 Mutex 调用 Unlock() 会导致运行时错误（panic）。",
        },
        {
            id: "w5-1-q12",
            question: "sync.Mutex 的 TryLock() 方法（Go 1.18+）的作用是什么？",
            options: [
                "带超时的锁获取",
                "尝试获取锁，成功返回 true，失败立即返回 false",
                "可中断的锁获取",
                "总是成功",
            ],
            answer: 1,
            rationale: "TryLock() 是非阻塞的：如果锁可用则获取并返回 true，否则立即返回 false，不等待。",
        },
    ],
    "w5-2": [
        {
            id: "w5-2-q1",
            question: "WaitGroup 的 Add() 方法应该在什么时机调用？",
            options: [
                "goroutine 内部",
                "启动 goroutine 之前",
                "任何时候都可以",
                "Wait() 之后",
            ],
            answer: 1,
            rationale: "必须在启动 goroutine 前调用 Add()，否则 Wait() 可能在 goroutine 执行 Add() 前就返回。",
        },
        {
            id: "w5-2-q2",
            question: "WaitGroup 的计数器变为负数会发生什么？",
            options: [
                "自动重置为 0",
                "panic",
                "返回错误",
                "忽略",
            ],
            answer: 1,
            rationale: "如果 Done()（即 Add(-1)）导致计数器变负，程序会 panic：'sync: negative WaitGroup counter'。",
        },
        {
            id: "w5-2-q3",
            question: "sync.Once 能保证什么？",
            options: [
                "函数最多执行两次",
                "函数恰好执行一次，即使并发调用",
                "函数能被重置",
                "函数会超时",
            ],
            answer: 1,
            rationale: "Go 文档：'Once is an object that will perform exactly one action'——无论多少 goroutine 并发调用，函数只执行一次。",
        },
        {
            id: "w5-2-q4",
            question: "sync.Once 的 Do 方法返回后，其他并发调用者会怎样？",
            options: [
                "也执行函数",
                "立即返回，不执行函数",
                "阻塞等待",
                "panic",
            ],
            answer: 1,
            rationale: "其他调用者在第一次 Do 完成后会直接返回，不会再执行函数。",
        },
        {
            id: "w5-2-q5",
            question: "如何重置 sync.Once 使其能再次执行？",
            options: [
                "调用 Reset() 方法",
                "无法重置，需要创建新的 Once 实例",
                "设置 Done = false",
                "调用 Clear()",
            ],
            answer: 1,
            rationale: "sync.Once 没有重置方法。如果需要重新执行，必须创建新的 sync.Once 实例。",
        },
        {
            id: "w5-2-q6",
            question: "errgroup 相比 WaitGroup 的主要优势是什么？",
            options: [
                "性能更好",
                "支持 goroutine 返回错误，并能取消其他 goroutine",
                "更简单",
                "支持超时",
            ],
            answer: 1,
            rationale: "errgroup 扩展了 WaitGroup：goroutine 可以返回错误，且支持通过 context 取消其他正在运行的 goroutine。",
        },
        {
            id: "w5-2-q7",
            question: "在循环中启动 goroutine 时使用 WaitGroup 的正确模式是什么？",
            options: [
                "在 goroutine 内部 Add(1)",
                "循环前 Add(n)，或每次迭代前 Add(1)",
                "循环后 Add(n)",
                "不需要 Add",
            ],
            answer: 1,
            rationale: "可以在循环前一次性 Add(n)，或在每次启动 goroutine 前 Add(1)。关键是 Add 在 go 语句之前。",
        },
        {
            id: "w5-2-q8",
            question: "sync.Once 内部函数发生 panic 后，后续调用会怎样？",
            options: [
                "重新执行函数",
                "Once 被认为已完成，后续调用直接返回",
                "继续 panic",
                "阻塞",
            ],
            answer: 1,
            rationale: "即使函数 panic，Once 也被标记为已执行。后续调用 Do 会直接返回，不会重试。",
        },
        {
            id: "w5-2-q9",
            question: "Go 1.21+ 引入的 sync.OnceValue 的作用是什么？",
            options: [
                "执行多次",
                "包装函数使其只执行一次，并缓存返回值",
                "支持并发",
                "错误处理",
            ],
            answer: 1,
            rationale: "OnceValue 是便捷封装：返回一个函数，该函数会懒惰执行原函数一次，并缓存返回值供后续调用。",
        },
        {
            id: "w5-2-q10",
            question: "WaitGroup 的 Wait() 返回后，该 WaitGroup 还能复用吗？",
            options: [
                "不能",
                "能，但需要等计数器归零后才能重新 Add",
                "必须创建新实例",
                "需要调用 Reset()",
            ],
            answer: 1,
            rationale: "Wait() 返回后计数器为 0，可以重新使用。但不能在 Wait() 期间调用 Add()。",
        },
        {
            id: "w5-2-q11",
            question: "WaitGroup 的内存模型保证是什么？",
            options: [
                "无保证",
                "Done() happens-before 对应的 Wait() 返回",
                "只保证计数正确",
                "Add 和 Done 是原子的",
            ],
            answer: 1,
            rationale: "Go 内存模型保证：所有 Done() 调用 happens-before Wait() 返回，确保 Wait 返回后能看到所有 goroutine 的修改。",
        },
        {
            id: "w5-2-q12",
            question: "在 errgroup 中，如果一个 goroutine 返回错误，其他 goroutine 会怎样？",
            options: [
                "继续运行",
                "通过 context 收到取消信号（如果使用 WithContext）",
                "立即被终止",
                "忽略错误",
            ],
            answer: 1,
            rationale: "如果使用 errgroup.WithContext()，第一个返回的错误会触发 context 取消，其他 goroutine 可以检查 ctx.Done() 来响应。",
        },
    ],
    "w5-3": [
        {
            id: "w5-3-q1",
            question: "sync.Cond 的 Wait() 方法做了什么？",
            options: [
                "只是等待",
                "原子地释放关联的锁并阻塞，唤醒后重新获取锁",
                "检查条件",
                "唤醒其他等待者",
            ],
            answer: 1,
            rationale: "Go 文档：Wait 'atomically unlocks c.L and suspends the calling goroutine'，返回前会重新 Lock c.L。",
        },
        {
            id: "w5-3-q2",
            question: "为什么 Cond.Wait() 必须在循环中调用？",
            options: [
                "性能优化",
                "处理虚假唤醒和条件可能在等待期间被其他 goroutine 改变",
                "Go 语法要求",
                "防止死锁",
            ],
            answer: 1,
            rationale: "Go 文档说明：Wait 返回不保证条件为真（可能虚假唤醒或被其他 goroutine 先处理），必须重新检查条件。",
        },
        {
            id: "w5-3-q3",
            question: "Signal() 和 Broadcast() 的区别是什么？",
            options: [
                "Signal 更快",
                "Signal 唤醒一个等待者，Broadcast 唤醒所有等待者",
                "Broadcast 是阻塞的",
                "没有区别",
            ],
            answer: 1,
            rationale: "Signal() 唤醒一个等待该条件的 goroutine；Broadcast() 唤醒所有等待者。",
        },
        {
            id: "w5-3-q4",
            question: "Go 官方更推荐使用什么来同步 goroutine？",
            options: [
                "sync.Cond",
                "channel",
                "sync.Mutex",
                "全局变量",
            ],
            answer: 1,
            rationale: "Go 官方博客倡导：'share memory by communicating'——通过 channel 通信是 Go 的首选同步方式。",
        },
        {
            id: "w5-3-q5",
            question: "sync.Cond 适合什么场景？",
            options: [
                "简单的互斥访问",
                "需要向多个等待者广播事件的场景",
                "单生产者单消费者",
                "无锁编程",
            ],
            answer: 1,
            rationale: "当需要唤醒所有等待某条件的 goroutine 时（如配置变更通知），Cond.Broadcast() 比 channel 更自然。",
        },
        {
            id: "w5-3-q6",
            question: "什么是虚假唤醒（spurious wakeup）？",
            options: [
                "错误地调用了 Signal",
                "goroutine 在没有 Signal/Broadcast 的情况下从 Wait 返回",
                "多个 goroutine 同时被唤醒",
                "唤醒了错误的 goroutine",
            ],
            answer: 1,
            rationale: "虚假唤醒指 goroutine 可能在没有任何 Signal/Broadcast 调用的情况下从 Wait 返回——这是操作系统层面允许的行为。",
        },
        {
            id: "w5-3-q7",
            question: "调用 Cond.Wait() 前必须满足什么条件？",
            options: [
                "没有条件",
                "必须持有关联的锁",
                "必须有其他 goroutine 等待",
                "必须设置超时",
            ],
            answer: 1,
            rationale: "Go 文档要求：'c.L must be held when calling Wait'——调用 Wait 前必须已经 Lock 了关联的 Locker。",
        },
        {
            id: "w5-3-q8",
            question: "channel 相比 sync.Cond 的局限是什么？",
            options: [
                "不能发送数据",
                "难以实现向所有消费者广播（需要关闭或多 channel）",
                "性能差",
                "不是线程安全的",
            ],
            answer: 1,
            rationale: "channel 是单消费：一条消息只能被一个接收者收到。广播需要 close channel 或为每个消费者创建单独 channel。",
        },
        {
            id: "w5-3-q9",
            question: "创建 sync.Cond 需要提供什么？",
            options: [
                "无参数",
                "一个实现 Locker 接口的对象（如 *Mutex）",
                "一个 channel",
                "一个 WaitGroup",
            ],
            answer: 1,
            rationale: "sync.NewCond(l Locker) 需要一个 Locker（通常是 *sync.Mutex 或 *sync.RWMutex）作为关联的锁。",
        },
        {
            id: "w5-3-q10",
            question: "Cond.Signal() 在没有等待者时的行为是什么？",
            options: [
                "Panic",
                "静默忽略，不做任何事",
                "阻塞直到有等待者",
                "返回错误",
            ],
            answer: 1,
            rationale: "如果没有 goroutine 在等待，Signal() 和 Broadcast() 不做任何事，信号会「丢失」。",
        },
        {
            id: "w5-3-q11",
            question: "sync.Cond 的正确使用模式是什么？",
            options: [
                "if !condition { c.Wait() }",
                "for !condition() { c.Wait() }",
                "c.Wait(); if condition { ... }",
                "while true { c.Wait() }",
            ],
            answer: 1,
            rationale: "Go 文档强调必须用 for 循环：`for !condition() { c.Wait() }`——处理虚假唤醒和竞态条件。",
        },
        {
            id: "w5-3-q12",
            question: "sync.Cond 的 L 字段（关联的锁）可以是什么类型？",
            options: [
                "只能是 *sync.Mutex",
                "任何实现 sync.Locker 接口的类型",
                "只能是 *sync.RWMutex",
                "channel",
            ],
            answer: 1,
            rationale: "L 的类型是 sync.Locker 接口，所以 *Mutex、*RWMutex（或其 RLocker()）都可以。",
        },
    ],
    "w5-4": [
        {
            id: "w5-4-q1",
            question: "sync.Map 优化了哪两种使用模式？",
            options: [
                "高写入、高读取",
                "写一次读多次，或不同 key 被不同 goroutine 访问",
                "单 goroutine 访问",
                "频繁删除",
            ],
            answer: 1,
            rationale: "Go 文档说明 sync.Map 优化了：(1) key 写一次读多次，(2) 多 goroutine 访问不相交的 key 集合。",
        },
        {
            id: "w5-4-q2",
            question: "sync.Pool 中的对象会在什么时候被回收？",
            options: [
                "手动调用 Remove 时",
                "任何 GC 时都可能被回收",
                "永不回收",
                "超时后回收",
            ],
            answer: 1,
            rationale: "Go 文档警告：'Any item stored in the Pool may be removed automatically at any time without notification'——GC 时可能被清理。",
        },
        {
            id: "w5-4-q3",
            question: "sync.Map 的 LoadOrStore 方法的语义是什么？",
            options: [
                "只加载不存储",
                "如果 key 存在返回现有值，否则存储并返回新值",
                "总是覆盖",
                "先删除再存储",
            ],
            answer: 1,
            rationale: "LoadOrStore 是原子的：如果 key 存在返回现有值和 true；否则存储提供的值并返回它和 false。",
        },
        {
            id: "w5-4-q4",
            question: "为什么 sync.Pool 不适合用作连接池？",
            options: [
                "性能差",
                "对象可能被 GC 回收，不保证持久存在",
                "不支持并发",
                "有大小限制",
            ],
            answer: 1,
            rationale: "Pool 中的对象可能在任何 GC 时被回收，不适合管理需要持久存在的资源（如数据库连接）。",
        },
        {
            id: "w5-4-q5",
            question: "sync.Map 的 Range 方法的特点是什么？",
            options: [
                "返回所有 key 的切片",
                "接受回调函数遍历，返回 false 时停止",
                "阻塞其他操作",
                "需要先锁定",
            ],
            answer: 1,
            rationale: "Range(f func(key, value any) bool) 遍历所有键值对，f 返回 false 时停止遍历。",
        },
        {
            id: "w5-4-q6",
            question: "sync.Pool 的 New 字段的作用是什么？",
            options: [
                "清空 Pool",
                "当 Get() 时 Pool 为空，调用 New 创建新对象",
                "设置最大容量",
                "初始化 Pool",
            ],
            answer: 1,
            rationale: "New 是一个函数，当 Pool 为空且调用 Get() 时会调用它来创建新对象。如果 New 为 nil 且 Pool 为空，Get 返回 nil。",
        },
        {
            id: "w5-4-q7",
            question: "什么情况下应该用普通 map + Mutex 而非 sync.Map？",
            options: [
                "读多写少时",
                "写操作频繁或需要批量操作时",
                "单 goroutine 时",
                "key 是 string 时",
            ],
            answer: 1,
            rationale: "sync.Map 的优势在特定模式下才体现。写操作频繁、需要批量操作（如遍历时修改）时，map+锁更高效灵活。",
        },
        {
            id: "w5-4-q8",
            question: "sync.Map 使用 interface{} 的问题是什么？",
            options: [
                "性能差",
                "类型不安全，需要类型断言",
                "不支持 nil 值",
                "内存泄漏",
            ],
            answer: 1,
            rationale: "sync.Map 的 key 和 value 都是 interface{}，使用时需要类型断言，可能在运行时出错。Go 1.18+ 可以用泛型封装。",
        },
        {
            id: "w5-4-q9",
            question: "sync.Map 的 Delete 方法的特点是什么？",
            options: [
                "如果 key 不存在会 panic",
                "key 不存在也可以调用，不会出错",
                "返回被删除的值",
                "需要先 Load 确认存在",
            ],
            answer: 1,
            rationale: "Delete(key) 删除 key 对应的值。如果 key 不存在，Delete 不做任何事，也不会出错。",
        },
        {
            id: "w5-4-q10",
            question: "sync.Pool 的 Put 方法有什么限制？",
            options: [
                "不能放入 nil",
                "对象必须实现特定接口",
                "有容量限制",
                "必须是指针类型",
            ],
            answer: 0,
            rationale: "Go 1.13+ 开始，Put(nil) 会被忽略。放入 nil 值没有意义且浪费资源。",
        },
        {
            id: "w5-4-q11",
            question: "sync.Map 的 CompareAndSwap 方法（Go 1.20+）的作用是什么？",
            options: [
                "交换两个 key 的值",
                "原子地比较并替换 key 的值",
                "比较两个 Map",
                "交换 Map 实例",
            ],
            answer: 1,
            rationale: "CompareAndSwap 原子地：如果 key 的当前值等于 old，则替换为 new。这是 sync.Map 的 CAS 操作。",
        },
        {
            id: "w5-4-q12",
            question: "sync.Pool 的最佳使用场景是什么？",
            options: [
                "管理数据库连接",
                "复用频繁创建销毁的临时对象（如 buffer）",
                "缓存计算结果",
                "存储配置信息",
            ],
            answer: 1,
            rationale: "Pool 适合复用生命周期短、创建开销大的临时对象（如 bytes.Buffer），减少 GC 压力和分配开销。",
        },
    ],
}
