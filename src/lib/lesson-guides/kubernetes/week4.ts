import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week4Guides: Record<string, LessonGuide> = {
    "w4-1": {
        lessonId: "w4-1",
        background: [
            "【Deployment 定义】官方文档：'A Deployment manages a set of Pods to run an application workload, usually stateless'——管理一组 Pod 运行无状态应用，'provides declarative updates for Pods and ReplicaSets'——提供声明式更新能力。",
            "【滚动更新触发条件】官方文档明确：'A rollout is triggered only when .spec.template changes'——只有 Pod 模板变更（镜像、标签、环境变量）才触发滚动更新，replicas 变更只是扩缩容，不会创建新 ReplicaSet。",
            "【Job 核心职责】官方文档：Job'creates one or more Pods and retries execution until a specified number complete successfully'——创建 Pod 并重试直到指定数量成功完成。适合批处理、数据迁移等一次性任务。",
            "【CronJob 定时调度】官方文档：'A CronJob creates Jobs on a repeating schedule'——按重复计划创建 Job。使用标准 Cron 格式（五字段：分 时 日 月 周），支持 @hourly、@daily 等宏。",
            "【ReplicaSet 隔离机制】官方文档警告：'Do not manage ReplicaSets owned by a Deployment directly'——不要直接管理 Deployment 创建的 ReplicaSet，由控制器自动管理以避免冲突。"
        ],
        keyDifficulties: [
            "【pod-template-hash 本质】官方文档：hash 是'Generated by hashing the PodTemplate'，作用是'ensures child ReplicaSets don't overlap'——确保不同版本的 ReplicaSet 不会冲突，标签格式如 pod-template-hash=75675f5897。",
            "【滚动更新双参数】maxUnavailable 定义更新时'Max Pods unavailable during update'，maxSurge 定义'Max Pods above desired replicas during update'。两者可以是数字或百分比，共同控制更新速度和资源占用。",
            "【Job restartPolicy 限制】官方文档：'Only two policies allowed: Never or OnFailure'——Never 时失败创建新 Pod，OnFailure 时在同一 Pod 内重启容器。不能是 Always，因为 Job 需要有终止条件。",
            "【CronJob 幂等性要求】官方文档强调：'Jobs must be idempotent'——Job 必须幂等（多次运行安全）。concurrencyPolicy 控制并发：Allow（允许并发）、Forbid（跳过新调度）、Replace（替换运行中 Job）。",
            "【CronJob 错过调度处理】startingDeadlineSeconds 定义错过调度后延迟启动的最大秒数。官方警告：如果超过 100 次错过调度，会报错'Too many missed start time'，需检查时钟偏移或减小此值。"
        ],
        handsOnPath: [
            "创建一个 Deployment 并使用 kubectl set image 更新镜像版本，用 kubectl rollout status 观察滚动更新过程，用 kubectl get rs 查看新旧 ReplicaSet 的副本数变化。",
            "使用 kubectl rollout undo 回滚 Deployment，用 kubectl rollout history 查看 revision 历史，尝试回滚到指定版本（--to-revision=N）。",
            "创建一个 Job 运行批处理任务（如计算 π），设置 backoffLimit 和 completions，观察 Pod 完成后的状态。",
            "创建一个 CronJob 每分钟运行一次，观察 Job 的自动创建，测试 concurrencyPolicy: Forbid 防止并发执行。"
        ],
        selfCheck: [
            "Deployment 和 ReplicaSet 的关系是什么？为什么不直接使用 ReplicaSet？",
            "滚动更新时 maxUnavailable 和 maxSurge 各自控制什么？如何设置才能实现零停机更新？",
            "如何查看 Deployment 的历史版本？如何回滚到指定版本？",
            "Job 的 completions 和 parallelism 参数分别控制什么？restartPolicy 为什么不能是 Always？",
            "CronJob 的 concurrencyPolicy 三个选项各是什么含义？startingDeadlineSeconds 的作用是什么？"
        ],
        extensions: [
            "研究 Deployment 的 .spec.revisionHistoryLimit 参数，了解如何控制保留的历史 ReplicaSet 数量以节省资源。",
            "探索 Indexed Job 模式，了解如何通过 JOB_COMPLETION_INDEX 环境变量在 Pod 中获取索引，实现分布式任务分片。",
            "学习 Job 的 TTL 机制（ttlSecondsAfterFinished），了解如何自动清理已完成的 Job 和 Pod。",
            "对比 Deployment 与 StatefulSet 的更新策略差异，理解有状态应用的特殊更新需求（如有序更新、保持身份）。"
        ],
        sourceUrls: [
            "https://kubernetes.io/docs/concepts/workloads/controllers/deployment/",
            "https://kubernetes.io/docs/concepts/workloads/controllers/job/",
            "https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/"
        ]
    },
    "w4-2": {
        lessonId: "w4-2",
        background: [
            "【Service 核心价值】官方文档：Service'解决了 Pod 动态变化导致的服务发现问题'，提供'稳定的网络端点来访问 Pod 集合'。通过 selector 或 EndpointSlices 定义目标 Pod。",
            "【四种 Service 类型】ClusterIP（默认，'仅在集群内部可访问'）、NodePort（'在每个 Node 上开放端口'，30000-32767 范围）、LoadBalancer（'集成云厂商负载均衡器'）、ExternalName（'映射到外部服务 DNS CNAME'）。",
            "【DNS 服务发现】官方格式：'<service-name>.<namespace>.svc.cluster.local'。支持简写：同 namespace 内可用 my-service，跨 namespace 用 my-service.default。",
            "【kube-proxy 机制】官方文档：'kube-proxy 实现虚拟 IP 机制，在每个节点运行，监视 Service 和 EndpointSlice 变化，配置数据包转发规则将流量重定向到后端 Pod'。",
            "【为何用代理而非 DNS】官方解释：'DNS 实现常忽略 TTL 并无限期缓存结果，应用频繁缓存 DNS 查询不重新解析，低/零 TTL 会给 DNS 服务器带来高负载'——因此 K8s 选择代理机制。"
        ],
        keyDifficulties: [
            "【Headless Service 本质】官方文档：设置'clusterIP: None'，特点是'无虚拟 IP，直接返回 Pod IP'，DNS 返回所有 Pod 的 A 记录。常与 StatefulSet 配合，用于需要直接 Pod-to-Pod 通信的场景。",
            "【iptables vs IPVS vs nftables】iptables 是默认模式，基于内核 netfilter；IPVS 使用哈希表，'在大规模集群中性能更好'但 v1.35 已弃用；nftables 是官方推荐的新模式，性能优于两者。",
            "【Session Affinity 配置】官方文档：sessionAffinity: ClientIP 确保'同一客户端 IP 总是路由到同一 Pod'，默认超时'10800 秒（3 小时）'。注意：经过 NAT 或代理时可能失效。",
            "【无 Selector Service】官方用途：'外部数据库集群、跨 Namespace/集群 Service、工作负载迁移期间'——手动创建 EndpointSlice 指向外部服务地址。",
            "【端口字段区分】port 是 Service 监听端口，targetPort 是 Pod 容器端口（可用端口名引用），nodePort 是 NodePort 类型在节点上开放的端口（30000-32767）。"
        ],
        handsOnPath: [
            "创建一个 Deployment 和 ClusterIP Service，使用 kubectl get endpoints 查看自动创建的端点列表，在 Pod 内通过服务名访问验证 DNS 解析。",
            "将 Service 类型改为 NodePort，使用 curl http://<node-ip>:<node-port> 从集群外部访问服务，观察 kubectl get svc 显示的分配端口。",
            "创建一个 Headless Service（clusterIP: None），使用 nslookup 或 dig 查询服务名，验证返回的是 Pod IP 列表而非虚拟 IP。",
            "使用 kubectl describe svc <name> 查看 Service 详情，包括 selector、endpoints、type 等信息；使用 iptables -t nat -L -n | grep <service-ip> 查看 kube-proxy 创建的 NAT 规则。"
        ],
        selfCheck: [
            "ClusterIP、NodePort、LoadBalancer 三种 Service 类型的区别是什么？各适合什么场景？",
            "Service 如何通过 selector 发现和关联后端 Pod？如果没有 selector 会怎样？",
            "kube-proxy 的 iptables 模式和 IPVS 模式有什么区别？各有什么优缺点？",
            "什么是 Headless Service？它的 DNS 解析行为与普通 Service 有何不同？",
            "Service 的 port、targetPort、nodePort 三个字段分别代表什么？"
        ],
        extensions: [
            "研究 ExternalName 类型 Service，了解如何将集群内服务名映射到外部 DNS 名称（如外部数据库）。",
            "探索 Service 的 externalTrafficPolicy（Local vs Cluster）对源 IP 保留和负载均衡的影响。",
            "学习 Service Topology 和 Topology Aware Hints，了解如何实现流量就近访问，减少跨区延迟。",
            "研究 Gateway API（Service Mesh 标准 API），了解它如何扩展和改进传统的 Service + Ingress 模型。"
        ],
        sourceUrls: [
            "https://kubernetes.io/docs/concepts/services-networking/service/",
            "https://kubernetes.io/docs/reference/networking/virtual-ips/",
            "https://kubernetes.io/docs/tutorials/stateless-application/guestbook/"
        ]
    },
    "w4-3": {
        lessonId: "w4-3",
        background: [
            "Ingress 是 Kubernetes 中管理集群外部访问的 API 对象，提供 HTTP/HTTPS 路由、负载均衡、SSL/TLS 终止和虚拟主机功能。Ingress 通过声明式规则将外部流量路由到内部 Service。",
            "Ingress 本身只是一个资源定义，需要 Ingress Controller 来实现其功能。常见的 Ingress Controller 包括 NGINX Ingress Controller、Traefik、Istio Ingress Gateway、AWS ALB Controller 等。",
            "Ingress 规则（rules）定义路由逻辑：host 指定域名（虚拟主机），paths 定义 URL 路径到后端 Service 的映射。pathType 有三种：Exact（精确匹配）、Prefix（前缀匹配）、ImplementationSpecific（由控制器决定）。",
            "TLS 配置通过 spec.tls 字段实现，引用 kubernetes.io/tls 类型的 Secret 存储证书和私钥。Ingress Controller 在边界处理 SSL 终止，后端 Service 通常接收 HTTP 流量。"
        ],
        keyDifficulties: [
            "Ingress Controller 选型：NGINX Ingress Controller 功能丰富、社区活跃；Traefik 原生支持动态配置；云厂商控制器（如 AWS ALB）深度集成云负载均衡器。选型需考虑功能需求、性能和运维复杂度。",
            "路径匹配优先级：多个规则匹配时，最长路径优先；同等长度时 Exact 优先于 Prefix。理解匹配顺序对调试路由问题至关重要。注意：Prefix /foo 会匹配 /foo、/foo/、/foo/bar，但不匹配 /foobar。",
            "常见 4xx/5xx 错误排查：502 Bad Gateway（后端 Service 不可达或 Pod 未就绪）、503 Service Unavailable（没有健康的后端）、404 Not Found（路由规则不匹配）、400 Bad Request（请求格式问题或 TLS 配置错误）。",
            "Annotations 的控制器依赖性：不同 Ingress Controller 使用不同的 annotations（如 nginx.ingress.kubernetes.io/rewrite-target）。迁移控制器时需要调整 annotations，这是常见的兼容性问题。"
        ],
        handsOnPath: [
            "在 minikube 上启用 Ingress 插件（minikube addons enable ingress），部署示例应用和 Service，创建 Ingress 资源验证路由功能。",
            "配置基于路径的路由：将 /api 路由到 api-service，将 /web 路由到 web-service，使用 curl 测试不同路径访问。",
            "配置基于主机名的虚拟主机：为 api.example.com 和 web.example.com 配置不同的后端，通过修改 /etc/hosts 或 curl -H 'Host: xxx' 测试。",
            "创建 TLS Secret 并配置 HTTPS：使用 openssl 生成自签名证书，创建 kubernetes.io/tls 类型 Secret，在 Ingress 中启用 TLS 并验证 HTTPS 访问。"
        ],
        selfCheck: [
            "Ingress 和 Service 的区别是什么？为什么需要 Ingress？",
            "Ingress Controller 的作用是什么？仅创建 Ingress 资源能否工作？",
            "pathType 的三种类型（Exact、Prefix、ImplementationSpecific）有什么区别？路径 /foo 和 /foo/ 的匹配行为是什么？",
            "遇到 502 Bad Gateway 错误时，应该如何排查？可能的原因有哪些？",
            "如何为 Ingress 配置 TLS？证书和私钥存储在什么类型的资源中？"
        ],
        extensions: [
            "研究 Gateway API（Kubernetes 推荐的 Ingress 替代方案），了解 Gateway、HTTPRoute 等资源的设计理念和优势。",
            "探索 NGINX Ingress Controller 的高级 annotations：限流（rate-limiting）、重写规则（rewrite-target）、跨域配置（CORS）。",
            "学习使用 cert-manager 自动管理 TLS 证书，实现 Let's Encrypt 证书的自动签发和续期。",
            "研究 Ingress 的高可用部署模式：多副本控制器、负载均衡器健康检查、跨可用区部署。"
        ],
        sourceUrls: [
            "https://kubernetes.io/docs/concepts/services-networking/ingress/",
            "https://kubernetes.github.io/ingress-nginx/user-guide/basic-usage/",
            "https://v1-32.docs.kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/"
        ]
    },
    "w4-4": {
        lessonId: "w4-4",
        background: [
            "Kubernetes 通过 requests 和 limits 管理容器资源。requests 是容器需要的最小资源量，用于调度决策；limits 是容器可使用的最大资源量，由内核强制执行。合理配置两者对集群稳定性至关重要。",
            "CPU 资源是可压缩的（compressible），超出 limit 时容器会被限流（throttle）但不会被杀死；内存资源是不可压缩的（incompressible），超出 limit 时容器会被 OOM Killer 终止。",
            "Kubernetes 根据 requests/limits 配置将 Pod 分为三个 QoS 类别：Guaranteed（requests=limits）、Burstable（有 requests 但不等于 limits）、BestEffort（无 requests/limits）。QoS 决定节点资源紧张时的驱逐优先级。",
            "ResourceQuota 和 LimitRange 是 Namespace 级别的资源治理工具。ResourceQuota 限制 Namespace 的总资源使用量和对象数量；LimitRange 为容器设置默认值和强制范围，确保所有 Pod 都有资源配置。"
        ],
        keyDifficulties: [
            "资源单位理解：CPU 使用毫核（m），1000m = 1 核；内存使用二进制单位（Mi/Gi）而非十进制（M/G）。常见错误：400m 内存实际是 0.4 字节，应写 400Mi。",
            "QoS 与驱逐：节点资源紧张时，BestEffort 最先被驱逐，其次是超出 requests 的 Burstable，最后是 Guaranteed。理解 QoS 对生产环境的 Pod 稳定性至关重要。",
            "ResourceQuota 的连锁效应：当 Namespace 启用 ResourceQuota 限制 CPU/内存时，所有 Pod 必须指定 requests/limits，否则创建失败。需要配合 LimitRange 设置默认值。",
            "超额分配（Overcommitment）：requests 用于调度，limits 用于运行时限制。如果 Σrequests < Σlimits，节点可能超额分配，在高负载时触发驱逐。生产环境建议 requests ≈ limits。"
        ],
        handsOnPath: [
            "创建一个 Pod 分别设置 requests 和 limits，使用 kubectl describe pod 查看 QoS Class，观察不同配置如何影响 QoS 分类。",
            "创建一个内存 limit 较小的 Pod 并运行内存密集型任务，观察 OOMKilled 事件；创建 CPU limit 较小的 Pod 观察 throttling 现象。",
            "在一个 Namespace 中创建 ResourceQuota 限制总 CPU 和内存，然后创建超出配额的 Pod 观察拒绝行为；使用 kubectl describe quota 查看使用情况。",
            "创建 LimitRange 设置默认 requests/limits，然后创建不指定资源的 Pod，验证默认值是否被自动应用。"
        ],
        selfCheck: [
            "requests 和 limits 的区别是什么？它们分别在什么时候起作用？",
            "三种 QoS 类别的判定条件是什么？节点资源紧张时驱逐顺序是什么？",
            "CPU 资源和内存资源在超出 limits 时的行为有什么不同？为什么？",
            "ResourceQuota 和 LimitRange 各自的作用是什么？为什么通常需要同时使用？",
            "如何确保一个 Pod 获得 Guaranteed QoS 级别？这样做有什么好处？"
        ],
        extensions: [
            "研究 Vertical Pod Autoscaler（VPA），了解如何自动调整 Pod 的 requests/limits 配置。",
            "探索节点级别的资源预留（kube-reserved、system-reserved），了解如何保护系统组件免受用户 Pod 影响。",
            "学习 PriorityClass 和 Pod 抢占（Preemption），了解高优先级 Pod 如何抢占低优先级 Pod 的资源。",
            "研究 cgroup v2 的内存 QoS 特性（memory.min、memory.high），了解更精细的内存管理机制。"
        ],
        sourceUrls: [
            "https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
            "https://kubernetes.io/docs/concepts/policy/resource-quotas/",
            "https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/"
        ]
    }
}

export const week4Quizzes: Record<string, QuizQuestion[]> = {
    "w4-1": [
        {
            id: "w4-1-q1",
            question: "官方文档对 Deployment 的核心定义是什么？",
            options: [
                "'manages a set of Pods to run an application workload, usually stateless'——管理无状态应用的 Pod 集合",
                "管理有状态应用的持久化存储",
                "直接创建和删除 Pod",
                "只负责网络流量路由"
            ],
            answer: 0,
            rationale: "官方文档明确定义：'A Deployment manages a set of Pods to run an application workload, usually stateless'，同时'provides declarative updates for Pods and ReplicaSets'。"
        },
        {
            id: "w4-1-q2",
            question: "什么操作会触发 Deployment 的滚动更新？",
            options: [
                "修改 replicas 数量",
                "添加 annotation",
                "修改 Pod 模板（.spec.template）如镜像、标签、环境变量",
                "修改 Deployment 名称"
            ],
            answer: 2,
            rationale: "官方文档明确：'A rollout is triggered only when .spec.template changes'——只有 Pod 模板变更才触发滚动更新，replicas 变更只是扩缩容。"
        },
        {
            id: "w4-1-q3",
            question: "pod-template-hash 标签的作用是什么？",
            options: [
                "用于 Pod 排序",
                "记录 Pod 创建时间",
                "确保不同版本的 ReplicaSet 不会冲突",
                "标识 Pod 所属的 Namespace"
            ],
            answer: 2,
            rationale: "官方文档：hash 是'Generated by hashing the PodTemplate'，作用是'ensures child ReplicaSets don't overlap'——防止子 ReplicaSet 冲突。"
        },
        {
            id: "w4-1-q4",
            question: "maxSurge 参数在滚动更新中的作用是什么？",
            options: [
                "定义更新时最多有多少 Pod 不可用",
                "定义更新的超时时间",
                "定义失败重试次数",
                "定义更新时可以超出期望副本数的 Pod 数量"
            ],
            answer: 3,
            rationale: "官方文档：maxSurge 定义'Max Pods above desired replicas during update'——更新期间可超出期望副本数的最大 Pod 数量。"
        },
        {
            id: "w4-1-q5",
            question: "官方文档对 Job 核心职责的描述是什么？",
            options: [
                "持续运行守护进程",
                "'creates one or more Pods and retries execution until a specified number complete successfully'",
                "管理网络服务发现",
                "调度 Pod 到特定节点"
            ],
            answer: 1,
            rationale: "官方文档定义 Job'creates one or more Pods and retries execution until a specified number complete successfully'——创建 Pod 并重试直到成功完成。"
        },
        {
            id: "w4-1-q6",
            question: "Job 的 restartPolicy 可以设置为哪些值？",
            options: [
                "Always、OnFailure、Never",
                "只能是 Always",
                "只能是 Never 或 OnFailure",
                "只能是 Never"
            ],
            answer: 2,
            rationale: "官方文档明确：'Only two policies allowed: Never or OnFailure'——Job 不能用 Always，因为需要有终止条件。"
        },
        {
            id: "w4-1-q7",
            question: "backoffLimit 参数的默认值和作用是什么？",
            options: [
                "默认 6，限制 Job 失败重试次数",
                "默认 3，限制并行 Pod 数量",
                "默认 10，限制 Job 运行时间",
                "默认 1，限制 completions 数量"
            ],
            answer: 0,
            rationale: "官方文档：'.spec.backoffLimit: Maximum retry attempts (default: 6)'——默认 6 次，超过后 Job 标记为失败。"
        },
        {
            id: "w4-1-q8",
            question: "CronJob 的 concurrencyPolicy: Forbid 意味着什么？",
            options: [
                "允许多个 Job 并发运行",
                "用新 Job 替换正在运行的 Job",
                "如果上一个 Job 仍在运行，跳过新的调度",
                "禁止创建任何 Job"
            ],
            answer: 2,
            rationale: "官方文档：Forbid 策略'Skips new Job if previous one still running'——如果前一个 Job 仍在运行则跳过新调度。"
        },
        {
            id: "w4-1-q9",
            question: "官方文档对 CronJob 中 Job 的要求是什么？",
            options: [
                "'Jobs must be idempotent'——Job 必须幂等（多次运行安全）",
                "Job 必须在 1 分钟内完成",
                "Job 不能有任何输出",
                "Job 必须使用特定镜像"
            ],
            answer: 0,
            rationale: "官方文档强调：'Jobs must be idempotent'——由于调度可能重复，Job 必须幂等以确保多次运行安全。"
        },
        {
            id: "w4-1-q10",
            question: "如何回滚 Deployment 到指定版本？",
            options: [
                "kubectl revert deployment/<name> --revision=N",
                "kubectl restore deployment/<name> --to-revision=N",
                "kubectl rollback deployment/<name> --version=N",
                "kubectl rollout undo deployment/<name> --to-revision=N"
            ],
            answer: 3,
            rationale: "官方文档：使用'kubectl rollout undo deployment/<name> --to-revision=N'回滚到指定版本。"
        },
        {
            id: "w4-1-q11",
            question: "Job 的 Indexed 完成模式有什么特点？",
            options: [
                "Pod 按创建时间排序",
                "只运行索引为 0 的 Pod",
                "每个 Pod 有唯一索引（0 到 completions-1）",
                "Pod 按字母顺序排列"
            ],
            answer: 2,
            rationale: "官方文档：'Indexed mode gives each Pod a unique index (0 to completions-1)'——每个 Pod 分配唯一索引，适合分布式任务分片。"
        },
        {
            id: "w4-1-q12",
            question: "关于管理 Deployment 创建的 ReplicaSet，官方文档的建议是什么？",
            options: [
                "可以直接修改 ReplicaSet 的 replicas",
                "应该通过 kubectl edit rs 调整配置",
                "'Do not manage ReplicaSets owned by a Deployment directly'——不要直接管理",
                "需要手动删除旧的 ReplicaSet"
            ],
            answer: 2,
            rationale: "官方文档明确警告：'Do not manage ReplicaSets owned by a Deployment directly'——应让 Deployment 控制器自动管理。"
        }
    ],
    "w4-2": [
        {
            id: "w4-2-q1",
            question: "Service 在 Kubernetes 中解决什么核心问题？",
            options: [
                "管理容器镜像版本",
                "解决 Pod 动态变化导致的服务发现问题，提供稳定的网络端点",
                "调度 Pod 到特定节点",
                "管理持久化存储"
            ],
            answer: 1,
            rationale: "官方文档：Service'解决了 Pod 动态变化导致的服务发现问题'，提供'稳定的网络端点来访问 Pod 集合'。"
        },
        {
            id: "w4-2-q2",
            question: "以下哪种是默认的 Service 类型？",
            options: [
                "ClusterIP——仅在集群内部可访问",
                "NodePort——在每个节点上开放端口",
                "LoadBalancer——集成云厂商负载均衡器",
                "ExternalName——映射到外部 DNS"
            ],
            answer: 0,
            rationale: "官方文档：ClusterIP 是默认类型，'仅在集群内部可访问'，分配虚拟 IP。"
        },
        {
            id: "w4-2-q3",
            question: "NodePort 类型 Service 的端口范围是什么？",
            options: [
                "1-1024",
                "1024-65535",
                "8000-9000",
                "30000-32767"
            ],
            answer: 3,
            rationale: "官方文档：NodePort'在每个 Node 上开放端口'，范围是 30000-32767。"
        },
        {
            id: "w4-2-q4",
            question: "Kubernetes Service 的 DNS 记录格式是什么？",
            options: [
                "<service-name>.<namespace>.svc.cluster.local",
                "<namespace>.<service-name>.k8s.local",
                "<pod-name>.<service-name>.cluster.local",
                "<service-name>.default.local"
            ],
            answer: 0,
            rationale: "官方文档：DNS 格式为'<service-name>.<namespace>.svc.cluster.local'，支持同 namespace 内简写。"
        },
        {
            id: "w4-2-q5",
            question: "官方文档解释 Kubernetes 为什么使用代理而非 DNS 负载均衡？",
            options: [
                "代理更安全",
                "DNS 太复杂难以实现",
                "'DNS 实现常忽略 TTL 并无限期缓存结果，应用频繁缓存 DNS 查询不重新解析'",
                "DNS 不支持多端口"
            ],
            answer: 2,
            rationale: "官方解释：'DNS 实现常忽略 TTL 并无限期缓存结果，应用频繁缓存 DNS 查询不重新解析，低/零 TTL 会给 DNS 服务器带来高负载'。"
        },
        {
            id: "w4-2-q6",
            question: "Headless Service 的关键配置是什么？",
            options: [
                "type: Headless",
                "headless: true",
                "clusterIP: None",
                "selector: none"
            ],
            answer: 2,
            rationale: "官方文档：Headless Service 通过设置'clusterIP: None'实现，'无虚拟 IP，直接返回 Pod IP'。"
        },
        {
            id: "w4-2-q7",
            question: "kube-proxy 在每个节点上的作用是什么？",
            options: [
                "运行容器进程",
                "调度 Pod 到节点",
                "实现虚拟 IP 机制，配置数据包转发规则将流量重定向到后端 Pod",
                "存储 etcd 数据"
            ],
            answer: 2,
            rationale: "官方文档：'kube-proxy 实现虚拟 IP 机制，监视 Service 和 EndpointSlice 变化，配置数据包转发规则'。"
        },
        {
            id: "w4-2-q8",
            question: "kube-proxy 的哪个模式在 v1.35 已被弃用？",
            options: [
                "iptables 模式",
                "IPVS 模式",
                "nftables 模式",
                "userspace 模式"
            ],
            answer: 1,
            rationale: "官方文档：IPVS 模式'v1.35 已弃用'，因为'IPVS 内核 API 不完全匹配 Kubernetes Services API'，推荐使用 nftables 模式。"
        },
        {
            id: "w4-2-q9",
            question: "sessionAffinity: ClientIP 的默认超时时间是多少？",
            options: [
                "10800 秒（3 小时）",
                "3600 秒（1 小时）",
                "300 秒（5 分钟）",
                "86400 秒（1 天）"
            ],
            answer: 0,
            rationale: "官方文档：sessionAffinity: ClientIP 确保'同一客户端 IP 总是路由到同一 Pod'，默认超时'10800 秒（3 小时）'。"
        },
        {
            id: "w4-2-q10",
            question: "无 Selector 的 Service 适合什么场景？",
            options: [
                "'外部数据库集群、跨 Namespace/集群 Service、工作负载迁移期间'",
                "只用于内部微服务通信",
                "仅用于 StatefulSet",
                "仅用于 LoadBalancer 类型"
            ],
            answer: 0,
            rationale: "官方用途：无 Selector Service 适合'外部数据库集群、跨 Namespace/集群 Service、工作负载迁移期间'，需手动创建 EndpointSlice。"
        },
        {
            id: "w4-2-q11",
            question: "Service 的 port、targetPort、nodePort 三个字段分别代表什么？",
            options: [
                "都指向同一个端口",
                "port 是 Service 监听端口，targetPort 是 Pod 容器端口，nodePort 是节点端口",
                "port 是节点端口，targetPort 是 Service 端口",
                "三者可以互换使用"
            ],
            answer: 1,
            rationale: "port 是 Service 监听端口，targetPort 是 Pod 容器端口（可用端口名引用），nodePort 是 NodePort 类型在节点上开放的端口。"
        },
        {
            id: "w4-2-q12",
            question: "ExternalName 类型 Service 的用途是什么？",
            options: [
                "暴露外部访问入口",
                "创建多个 IP 地址",
                "映射到外部服务（DNS CNAME），不创建 Endpoints",
                "限制外部访问"
            ],
            answer: 2,
            rationale: "官方文档：ExternalName'映射到外部服务（DNS CNAME）'，'不创建 Endpoints'，用于访问集群外的资源如外部数据库。"
        }
    ],
    "w4-3": [
        {
            id: "w4-3-q1",
            question: "Ingress 在 Kubernetes 中的核心作用是什么？",
            options: [
                "运行容器化应用",
                "管理集群外部到内部 Service 的 HTTP/HTTPS 访问路由",
                "存储应用配置",
                "调度 Pod 到节点"
            ],
            answer: 1,
            rationale: "Ingress 提供 HTTP/HTTPS 路由、负载均衡、SSL 终止和虚拟主机功能，将外部流量路由到集群内部的 Service。"
        },
        {
            id: "w4-3-q2",
            question: "仅创建 Ingress 资源能否使路由生效？",
            options: [
                "可以，Ingress 资源会自动处理路由",
                "不能，必须部署 Ingress Controller 来实现 Ingress 功能",
                "可以，但需要等待几分钟",
                "不能，还需要创建 LoadBalancer Service"
            ],
            answer: 1,
            rationale: "Ingress 只是资源定义，需要 Ingress Controller（如 NGINX Ingress Controller）来实际执行路由逻辑。"
        },
        {
            id: "w4-3-q3",
            question: "pathType: Prefix 的匹配规则是什么？",
            options: [
                "精确匹配 URL 路径",
                "基于 / 分隔的路径元素前缀匹配",
                "正则表达式匹配",
                "后缀匹配"
            ],
            answer: 1,
            rationale: "Prefix 以 / 分隔的路径元素为单位匹配。例如 /foo 会匹配 /foo、/foo/、/foo/bar，但不匹配 /foobar。"
        },
        {
            id: "w4-3-q4",
            question: "pathType: Exact 和 Prefix 的主要区别是什么？",
            options: [
                "Exact 区分大小写，Prefix 不区分",
                "Exact 精确匹配 URL 路径，Prefix 匹配路径前缀",
                "Exact 更快，Prefix 更慢",
                "Exact 只能用于根路径"
            ],
            answer: 1,
            rationale: "Exact 要求 URL 路径与规则完全匹配；Prefix 匹配以规则路径开头的所有请求（以 / 为边界）。"
        },
        {
            id: "w4-3-q5",
            question: "Ingress 的 TLS 证书存储在什么类型的资源中？",
            options: [
                "ConfigMap",
                "kubernetes.io/tls 类型的 Secret",
                "PersistentVolume",
                "ServiceAccount"
            ],
            answer: 1,
            rationale: "TLS 证书和私钥存储在 kubernetes.io/tls 类型的 Secret 中，包含 tls.crt 和 tls.key 两个字段。"
        },
        {
            id: "w4-3-q6",
            question: "502 Bad Gateway 错误通常表示什么问题？",
            options: [
                "客户端请求格式错误",
                "后端 Service 不可达或 Pod 未就绪",
                "Ingress 规则配置错误",
                "TLS 证书过期"
            ],
            answer: 1,
            rationale: "502 Bad Gateway 通常表示 Ingress Controller 无法连接到后端 Service，可能是 Pod 未运行、未就绪或网络问题。"
        },
        {
            id: "w4-3-q7",
            question: "以下哪个是常见的 Ingress Controller？",
            options: [
                "kube-proxy",
                "NGINX Ingress Controller",
                "CoreDNS",
                "kubelet"
            ],
            answer: 1,
            rationale: "NGINX Ingress Controller 是最常用的 Ingress Controller 之一，其他还有 Traefik、Istio、AWS ALB Controller 等。"
        },
        {
            id: "w4-3-q8",
            question: "Ingress 规则中的 host 字段用于什么？",
            options: [
                "指定后端 Pod 的主机名",
                "基于请求的 Host 头进行虚拟主机路由",
                "配置 Ingress Controller 运行的节点",
                "设置 DNS 服务器地址"
            ],
            answer: 1,
            rationale: "host 字段实现虚拟主机功能，根据 HTTP 请求的 Host 头将流量路由到不同的后端 Service。"
        },
        {
            id: "w4-3-q9",
            question: "defaultBackend 的作用是什么？",
            options: [
                "设置默认的容器镜像",
                "处理与任何规则都不匹配的请求",
                "配置默认的 TLS 证书",
                "指定默认的 Namespace"
            ],
            answer: 1,
            rationale: "defaultBackend 定义当请求不匹配任何 host 或 path 规则时的后端 Service，类似于 catch-all 路由。"
        },
        {
            id: "w4-3-q10",
            question: "ingressClassName 字段的作用是什么？",
            options: [
                "设置 Ingress 的名称",
                "指定使用哪个 Ingress Controller 处理此 Ingress",
                "定义 Ingress 的优先级",
                "配置 Ingress 的访问权限"
            ],
            answer: 1,
            rationale: "ingressClassName 指定 IngressClass，决定由哪个 Ingress Controller 处理此 Ingress 资源。"
        },
        {
            id: "w4-3-q11",
            question: "503 Service Unavailable 错误通常表示什么？",
            options: [
                "路由规则配置错误",
                "没有健康的后端 Pod 可用",
                "TLS 握手失败",
                "请求超时"
            ],
            answer: 1,
            rationale: "503 表示服务暂时不可用，通常是因为后端所有 Pod 都不健康或 Endpoints 为空。"
        },
        {
            id: "w4-3-q12",
            question: "如何在 minikube 上启用 Ingress 功能？",
            options: [
                "minikube start --ingress",
                "minikube addons enable ingress",
                "kubectl apply -f ingress.yaml",
                "minikube tunnel"
            ],
            answer: 1,
            rationale: "minikube addons enable ingress 命令启用内置的 NGINX Ingress Controller 插件。"
        },
        {
            id: "w4-3-q13",
            question: "Ingress 的 annotations 有什么特点？",
            options: [
                "所有 Ingress Controller 使用相同的 annotations",
                "不同的 Ingress Controller 可能使用不同的 annotations",
                "annotations 不影响 Ingress 行为",
                "annotations 只能用于 TLS 配置"
            ],
            answer: 1,
            rationale: "annotations 是控制器相关的，不同 Ingress Controller 使用不同的 annotations 前缀和功能，迁移时需要调整。"
        },
        {
            id: "w4-3-q14",
            question: "Kubernetes 官方推荐用什么替代 Ingress？",
            options: [
                "LoadBalancer Service",
                "Gateway API",
                "NodePort Service",
                "ExternalName Service"
            ],
            answer: 1,
            rationale: "Kubernetes 官方推荐使用 Gateway API 替代 Ingress，因为它提供更强大和灵活的功能，Ingress API 已冻结不再接收新功能。"
        },
        {
            id: "w4-3-q15",
            question: "多个 Ingress 规则匹配时，优先级如何确定？",
            options: [
                "按创建时间排序",
                "最长路径优先，同等长度时 Exact 优先于 Prefix",
                "按字母顺序排序",
                "随机选择"
            ],
            answer: 1,
            rationale: "路由优先级：最长路径优先匹配；相同长度时，Exact 类型优先于 Prefix 类型。"
        }
    ],
    "w4-4": [
        {
            id: "w4-4-q1",
            question: "resources.requests 的作用是什么？",
            options: [
                "限制容器可使用的最大资源量",
                "用于调度决策，表示容器需要的最小资源量",
                "设置容器启动时的初始资源",
                "定义容器的默认资源配置"
            ],
            answer: 1,
            rationale: "requests 表示容器需要的最小资源量，kube-scheduler 根据 requests 决定 Pod 调度到哪个节点。"
        },
        {
            id: "w4-4-q2",
            question: "resources.limits 的作用是什么？",
            options: [
                "用于调度决策",
                "限制容器可使用的最大资源量，由内核强制执行",
                "设置资源的默认值",
                "定义 Namespace 的资源配额"
            ],
            answer: 1,
            rationale: "limits 定义容器可使用的资源上限，CPU 超限会被 throttle，内存超限会被 OOM Killer 终止。"
        },
        {
            id: "w4-4-q3",
            question: "CPU 资源超出 limits 时会发生什么？",
            options: [
                "容器被终止（OOMKilled）",
                "容器被限流（throttled），但不会被杀死",
                "Pod 被驱逐",
                "节点崩溃"
            ],
            answer: 1,
            rationale: "CPU 是可压缩资源，超出 limits 时内核会限制 CPU 时间片分配（throttling），容器继续运行但变慢。"
        },
        {
            id: "w4-4-q4",
            question: "内存资源超出 limits 时会发生什么？",
            options: [
                "容器被限流",
                "容器被 OOM Killer 终止",
                "自动扩展内存限制",
                "请求被拒绝"
            ],
            answer: 1,
            rationale: "内存是不可压缩资源，超出 limits 时容器会被 OOM Killer 终止，Pod 状态显示 OOMKilled。"
        },
        {
            id: "w4-4-q5",
            question: "Guaranteed QoS 级别需要满足什么条件？",
            options: [
                "只设置 requests",
                "只设置 limits",
                "所有容器的 requests 和 limits 都相等（且都设置了 CPU 和内存）",
                "不设置任何资源配置"
            ],
            answer: 2,
            rationale: "Guaranteed 要求 Pod 中所有容器的 CPU 和内存的 requests 都等于 limits。"
        },
        {
            id: "w4-4-q6",
            question: "BestEffort QoS 级别的 Pod 有什么特点？",
            options: [
                "资源得到最好的保障",
                "没有设置任何 requests 和 limits，最先被驱逐",
                "有最高的调度优先级",
                "使用固定的资源配额"
            ],
            answer: 1,
            rationale: "BestEffort Pod 没有任何资源配置，在节点资源紧张时会被最先驱逐。"
        },
        {
            id: "w4-4-q7",
            question: "节点资源紧张时，Pod 的驱逐顺序是什么？",
            options: [
                "Guaranteed → Burstable → BestEffort",
                "BestEffort → Burstable → Guaranteed",
                "随机驱逐",
                "按创建时间驱逐"
            ],
            answer: 1,
            rationale: "驱逐优先级：BestEffort 最先被驱逐，其次是超出 requests 的 Burstable，最后是 Guaranteed。"
        },
        {
            id: "w4-4-q8",
            question: "CPU 资源的单位 500m 表示什么？",
            options: [
                "500 MB 内存",
                "500 毫核，即 0.5 个 CPU 核心",
                "500 分钟 CPU 时间",
                "500 个 CPU 周期"
            ],
            answer: 1,
            rationale: "m 表示毫核（milli-core），500m = 0.5 核。1000m = 1 个完整的 CPU 核心。"
        },
        {
            id: "w4-4-q9",
            question: "内存资源 400m 和 400Mi 有什么区别？",
            options: [
                "完全相同",
                "400m 是 0.4 字节，400Mi 是 400 MiB（约 419 MB）",
                "400m 更大",
                "400Mi 是 400 毫秒"
            ],
            answer: 1,
            rationale: "这是常见错误！m 表示毫（milli），400m = 0.4 字节；Mi 表示 MiB，400Mi = 419,430,400 字节。"
        },
        {
            id: "w4-4-q10",
            question: "ResourceQuota 的作用是什么？",
            options: [
                "为单个容器设置资源限制",
                "限制 Namespace 的总资源使用量和对象数量",
                "设置节点的资源容量",
                "配置 Pod 的 QoS 级别"
            ],
            answer: 1,
            rationale: "ResourceQuota 在 Namespace 级别限制资源总量（如总 CPU、内存）和对象数量（如 Pod 数、Service 数）。"
        },
        {
            id: "w4-4-q11",
            question: "LimitRange 的主要作用是什么？",
            options: [
                "限制 Namespace 的总资源",
                "为容器设置默认的 requests/limits 和强制范围",
                "配置节点的资源预留",
                "设置 Pod 的优先级"
            ],
            answer: 1,
            rationale: "LimitRange 为 Namespace 中的容器设置默认 requests/limits 值，以及允许的最大/最小值范围。"
        },
        {
            id: "w4-4-q12",
            question: "当 Namespace 有 ResourceQuota 限制 CPU/内存时，创建不指定资源的 Pod 会怎样？",
            options: [
                "自动分配默认资源",
                "创建失败（除非有 LimitRange 设置默认值）",
                "使用 Namespace 的全部配额",
                "Pod 被标记为 BestEffort"
            ],
            answer: 1,
            rationale: "启用 ResourceQuota 后，所有 Pod 必须指定 requests/limits，否则会被拒绝。需要配合 LimitRange 设置默认值。"
        },
        {
            id: "w4-4-q13",
            question: "如何查看 Namespace 的资源配额使用情况？",
            options: [
                "kubectl get pods",
                "kubectl describe quota -n <namespace>",
                "kubectl top nodes",
                "kubectl get limitrange"
            ],
            answer: 1,
            rationale: "kubectl describe quota 显示 ResourceQuota 的已使用量和硬限制，便于监控 Namespace 的资源消耗。"
        },
        {
            id: "w4-4-q14",
            question: "超额分配（Overcommitment）是什么意思？",
            options: [
                "Pod 数量超过节点容量",
                "Σlimits > Σrequests，允许节点运行的 Pod 总 limits 超过实际容量",
                "创建超过配额的资源",
                "CPU 使用率超过 100%"
            ],
            answer: 1,
            rationale: "超额分配指 requests < limits，调度基于 requests，但 Pod 可能使用更多资源。高负载时可能触发驱逐。"
        },
        {
            id: "w4-4-q15",
            question: "生产环境中推荐如何配置 requests 和 limits？",
            options: [
                "只设置 limits",
                "只设置 requests",
                "requests ≈ limits（接近或相等），确保 Guaranteed QoS",
                "不设置任何资源配置"
            ],
            answer: 2,
            rationale: "生产环境推荐 requests ≈ limits，这样 Pod 获得 Guaranteed QoS，资源预留明确，不易被驱逐。"
        }
    ]
}
