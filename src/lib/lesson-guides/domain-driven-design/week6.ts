import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week6Guides: Record<string, LessonGuide> = {
    "w6-1": {
        lessonId: "w6-1",
        background: [
            "【聚合定义】聚合（Aggregate）是'clusters of domain objects that are treated as a single unit for data changes'——作为数据变更单元的领域对象集群。",
            "【一致性边界】聚合定义了事务一致性边界，'A properly designed Aggregate is one that can be modified...with its invariants completely consistent within a single transaction'。",
            "【聚合根】每个聚合有一个根实体（Aggregate Root），是访问聚合内对象的唯一入口点。",
            "【业务不变量】聚合的核心职责是保护业务不变量，确保数据始终处于有效状态。",
            "【事务边界】'In one transaction, you can only modify one aggregate and never more than one aggregate'——单事务只修改一个聚合。",
        ],
        keyDifficulties: [
            "【边界划分】确定哪些对象应该在同一个聚合内是最困难的决策之一。",
            "【过大聚合】'A large-cluster Aggregate will never perform or scale well'——过大的聚合是反模式。",
            "【跨聚合一致性】跨聚合的一致性需要通过最终一致性而非事务一致性实现。",
            "【识别不变量】正确识别业务不变量需要深入理解业务规则。",
        ],
        handsOnPath: [
            "识别项目中的核心业务不变量",
            "分析哪些对象必须一起保持一致",
            "绘制候选聚合的边界图",
            "评估每个聚合是否过大或过小",
            "与领域专家验证聚合边界",
        ],
        selfCheck: [
            "什么是聚合？它的核心作用是什么？",
            "什么是聚合根？它的职责是什么？",
            "为什么单事务只应该修改一个聚合？",
            "如何识别业务不变量？",
            "聚合过大会带来什么问题？",
        ],
        extensions: [
            "阅读 Vaughn Vernon 的 Effective Aggregate Design 系列",
            "学习聚合设计画布（Aggregate Design Canvas）",
            "了解聚合与微服务边界的关系",
            "研究事件溯源中的聚合设计",
        ],
        sourceUrls: [
            "https://www.dddcommunity.org/library/vernon_2011/",
            "https://kalele.io/effective-aggregate-design/",
        ],
    },
    "w6-2": {
        lessonId: "w6-2",
        background: [
            "【聚合根职责】聚合根是聚合的入口点，负责协调聚合内的所有操作，保护内部一致性。",
            "【外部访问规则】外部只能通过聚合根访问聚合内的对象，不能直接引用内部实体。",
            "【内部实体标识】聚合内部的实体可以有局部标识，但这些标识只在聚合内有效。",
            "【生命周期管理】聚合根负责管理内部对象的创建和删除。",
            "【边界设计原则】边界应该足够小以保证事务性能，但要包含足够的对象以维护不变量。",
        ],
        keyDifficulties: [
            "【导航限制】开发者习惯于自由导航对象图，聚合边界限制了这种自由。",
            "【延迟加载陷阱】在聚合边界内使用延迟加载可能导致 N+1 查询问题。",
            "【并发冲突】聚合越大，并发修改的冲突概率越高。",
            "【重构困难】已有系统中引入聚合边界需要重构，可能影响大量代码。",
        ],
        handsOnPath: [
            "为核心聚合定义聚合根",
            "设计聚合根的公共接口，确保所有修改通过聚合根",
            "识别并移除对聚合内部对象的直接引用",
            "实现聚合内对象的级联创建和删除",
            "编写测试验证不变量在任何操作后都保持有效",
        ],
        selfCheck: [
            "聚合根的主要职责是什么？",
            "为什么外部不能直接访问聚合内的对象？",
            "聚合内部实体的标识有什么特点？",
            "如何设计聚合边界以平衡一致性和性能？",
            "延迟加载在聚合中有什么风险？",
        ],
        extensions: [
            "学习乐观锁与聚合版本控制",
            "了解聚合根的工厂模式",
            "研究聚合的序列化策略",
            "探索聚合在不同存储技术中的实现",
        ],
        sourceUrls: [
            "https://www.dddcommunity.org/library/vernon_2011/",
            "https://www.archi-lab.io/infopages/ddd/aggregate-design-rules-vernon.html",
        ],
    },
    "w6-3": {
        lessonId: "w6-3",
        background: [
            "【规则一：模型真实不变量】'Model True Invariants in Consistency Boundaries'——在一致性边界内建模真实的业务不变量。",
            "【规则二：设计小聚合】'Design Small Aggregates'——聚合应该小，只包含必要的对象。",
            "【规则三：通过 ID 引用】'Reference Other Aggregates by Identity'——通过标识而非对象引用关联其他聚合。",
            "【规则四：最终一致性】'Use Eventual Consistency Outside the Boundary'——聚合边界外使用最终一致性。",
            "【小聚合优势】小聚合减少锁冲突，提高并发性能，简化理解和测试。",
        ],
        keyDifficulties: [
            "【不变量识别】正确识别'真实'的不变量需要深入理解业务，有些看似不变量的规则实际可以放松。",
            "【最小化挑战】确定'正确的最小值'——足够小但又能保护所有必要的不变量。",
            "【ID 引用适应】习惯对象导航的开发者可能不适应通过 ID 引用。",
            "【最终一致性设计】设计正确的最终一致性机制需要额外的技术复杂度。",
        ],
        handsOnPath: [
            "审查现有聚合，评估是否遵循四条规则",
            "列出聚合的所有不变量，区分真实不变量和可放松的规则",
            "检查是否有通过对象引用关联的其他聚合，重构为 ID 引用",
            "识别需要跨聚合更新的场景，设计最终一致性方案",
            "测量聚合的大小和并发冲突率",
        ],
        selfCheck: [
            "Vernon 的四条聚合设计规则是什么？",
            "为什么应该设计小聚合？",
            "为什么应该通过 ID 而非对象引用其他聚合？",
            "什么是聚合的'正确的最小值'？",
            "聚合边界外为什么使用最终一致性？",
        ],
        extensions: [
            "学习领域事件实现最终一致性",
            "了解 Saga 模式处理跨聚合业务流程",
            "研究聚合性能优化技术",
            "探索 CQRS 与聚合的结合",
        ],
        sourceUrls: [
            "https://www.dddcommunity.org/library/vernon_2011/",
            "https://www.informit.com/articles/article.aspx?p=2020371&seqNum=3",
        ],
    },
    "w6-4": {
        lessonId: "w6-4",
        background: [
            "【ID 引用优势】通过 ID 引用其他聚合可以防止在同一事务中修改多个聚合的诱惑。",
            "【最终一致性机制】跨聚合的更新通过领域事件实现最终一致性，而非事务一致性。",
            "【事件驱动更新】'Update other aggregates using domain events'——使用领域事件更新其他聚合。",
            "【分布式友好】ID 引用天然支持分布式系统，聚合可以分布在不同服务中。",
            "【加载策略】需要其他聚合数据时，通过仓储按需加载而非预先加载。",
        ],
        keyDifficulties: [
            "【一致性时间窗口】最终一致性意味着存在不一致的时间窗口，需要业务能接受。",
            "【补偿机制】跨聚合操作失败时需要设计补偿或重试机制。",
            "【查询复杂性】跨聚合的查询可能需要额外的读模型或组合多个聚合的数据。",
            "【调试困难】异步的最终一致性比同步事务更难调试和追踪。",
        ],
        handsOnPath: [
            "识别系统中跨聚合的业务流程",
            "设计领域事件来协调跨聚合的更新",
            "实现事件发布和订阅机制",
            "设计补偿操作处理失败场景",
            "建立监控和告警机制追踪一致性延迟",
        ],
        selfCheck: [
            "为什么通过 ID 引用可以防止修改多个聚合的诱惑？",
            "如何使用领域事件实现跨聚合的最终一致性？",
            "最终一致性的时间窗口意味着什么？业务如何接受？",
            "跨聚合操作失败时如何处理？",
            "如何监控最终一致性的健康状况？",
        ],
        extensions: [
            "学习 Outbox 模式保证事件发布的可靠性",
            "了解事件溯源与最终一致性",
            "研究分布式追踪技术",
            "探索 CDC（Change Data Capture）实现跨服务同步",
        ],
        sourceUrls: [
            "https://www.dddcommunity.org/library/vernon_2011/",
            "https://microservices.io/patterns/data/saga.html",
        ],
    },
}

export const week6Quizzes: Record<string, QuizQuestion[]> = {
    "w6-1": [
        {
            id: "w6-1-q1",
            question: "聚合（Aggregate）的定义是什么？",
            options: [
                "一个数据库表",
                "作为数据变更单元的领域对象集群",
                "一组 API",
                "一个微服务",
            ],
            answer: 1,
            rationale: "聚合是'clusters of domain objects that are treated as a single unit for data changes'。",
        },
        {
            id: "w6-1-q2",
            question: "聚合的核心作用是什么？",
            options: [
                "提高性能",
                "定义事务一致性边界，保护业务不变量",
                "简化代码",
                "减少数据库表",
            ],
            answer: 1,
            rationale: "聚合定义了事务一致性边界，核心职责是保护业务不变量，确保数据始终处于有效状态。",
        },
        {
            id: "w6-1-q3",
            question: "关于单事务与聚合的关系，以下哪个说法是正确的？",
            options: [
                "可以在一个事务中修改任意多个聚合",
                "单事务只应该修改一个聚合",
                "事务与聚合无关",
                "每个聚合必须在单独的事务中",
            ],
            answer: 1,
            rationale: "'In one transaction, you can only modify one aggregate and never more than one aggregate'。",
        },
        {
            id: "w6-1-q4",
            question: "什么是聚合根（Aggregate Root）？",
            options: [
                "数据库主键",
                "聚合的入口点，是访问聚合内对象的唯一入口",
                "最大的实体",
                "服务层入口",
            ],
            answer: 1,
            rationale: "每个聚合有一个根实体（Aggregate Root），是访问聚合内对象的唯一入口点。",
        },
        {
            id: "w6-1-q5",
            question: "过大的聚合会带来什么问题？",
            options: [
                "代码太少",
                "永远不会有良好的性能和扩展性",
                "没有问题",
                "数据库太小",
            ],
            answer: 1,
            rationale: "'A large-cluster Aggregate will never perform or scale well'——过大的聚合是反模式。",
        },
        {
            id: "w6-1-q6",
            question: "聚合边界划分的主要依据是什么？",
            options: [
                "代码行数",
                "需要一起保持一致的业务不变量",
                "数据库表设计",
                "团队分工",
            ],
            answer: 1,
            rationale: "聚合边界应该包含必须一起保持一致的对象，基于业务不变量划分。",
        },
        {
            id: "w6-1-q7",
            question: "什么是业务不变量？",
            options: [
                "永远不变的代码",
                "必须始终为真的业务规则",
                "不变的数据库表",
                "静态方法",
            ],
            answer: 1,
            rationale: "业务不变量是必须始终为真的业务规则，聚合负责保护这些不变量。",
        },
        {
            id: "w6-1-q8",
            question: "跨聚合的一致性应该如何实现？",
            options: [
                "使用分布式事务",
                "通过最终一致性而非事务一致性",
                "忽略一致性",
                "合并为一个聚合",
            ],
            answer: 1,
            rationale: "跨聚合的一致性需要通过最终一致性而非事务一致性实现。",
        },
        {
            id: "w6-1-q9",
            question: "确定聚合边界的主要困难是什么？",
            options: [
                "技术限制",
                "确定哪些对象应该在同一个聚合内",
                "代码组织",
                "数据库设计",
            ],
            answer: 1,
            rationale: "确定哪些对象应该在同一个聚合内是最困难的决策之一。",
        },
        {
            id: "w6-1-q10",
            question: "一个正确设计的聚合应该能做到什么？",
            options: [
                "包含尽可能多的对象",
                "在单事务内以任何业务需要的方式修改，保持不变量一致",
                "跨多个事务修改",
                "不需要保持一致性",
            ],
            answer: 1,
            rationale: "'A properly designed Aggregate is one that can be modified in any way required by the business with its invariants completely consistent within a single transaction'。",
        },
        {
            id: "w6-1-q11",
            question: "如何验证聚合边界的正确性？",
            options: [
                "只看代码",
                "与领域专家验证，确保包含所有必要的不变量",
                "看数据库表",
                "不需要验证",
            ],
            answer: 1,
            rationale: "与领域专家验证聚合边界是否包含了所有必要的业务不变量。",
        },
        {
            id: "w6-1-q12",
            question: "识别业务不变量需要什么？",
            options: [
                "只看代码",
                "深入理解业务规则",
                "只看数据库",
                "只看 API",
            ],
            answer: 1,
            rationale: "正确识别业务不变量需要深入理解业务规则。",
        },
    ],
    "w6-2": [
        {
            id: "w6-2-q1",
            question: "聚合根的主要职责是什么？",
            options: [
                "存储数据",
                "协调聚合内的所有操作，保护内部一致性",
                "提供 API",
                "连接数据库",
            ],
            answer: 1,
            rationale: "聚合根是聚合的入口点，负责协调聚合内的所有操作，保护内部一致性。",
        },
        {
            id: "w6-2-q2",
            question: "外部对象如何访问聚合内的对象？",
            options: [
                "直接引用",
                "只能通过聚合根访问",
                "通过数据库直接访问",
                "随意访问",
            ],
            answer: 1,
            rationale: "外部只能通过聚合根访问聚合内的对象，不能直接引用内部实体。",
        },
        {
            id: "w6-2-q3",
            question: "聚合内部实体的标识有什么特点？",
            options: [
                "全局唯一",
                "局部标识，只在聚合内有效",
                "没有标识",
                "与数据库主键相同",
            ],
            answer: 1,
            rationale: "聚合内部的实体可以有局部标识，但这些标识只在聚合内有效。",
        },
        {
            id: "w6-2-q4",
            question: "聚合内部对象的生命周期由谁管理？",
            options: [
                "外部服务",
                "聚合根",
                "数据库",
                "框架自动管理",
            ],
            answer: 1,
            rationale: "聚合根负责管理内部对象的创建和删除。",
        },
        {
            id: "w6-2-q5",
            question: "聚合边界设计应该平衡什么？",
            options: [
                "代码量和文档",
                "足够小保证性能，但包含足够对象维护不变量",
                "团队规模和代码量",
                "只考虑性能",
            ],
            answer: 1,
            rationale: "边界应该足够小以保证事务性能，但要包含足够的对象以维护不变量。",
        },
        {
            id: "w6-2-q6",
            question: "在聚合边界内使用延迟加载有什么风险？",
            options: [
                "没有风险",
                "可能导致 N+1 查询问题",
                "性能更好",
                "代码更简单",
            ],
            answer: 1,
            rationale: "在聚合边界内使用延迟加载可能导致 N+1 查询问题。",
        },
        {
            id: "w6-2-q7",
            question: "聚合越大，什么问题越严重？",
            options: [
                "代码复杂度",
                "并发修改的冲突概率",
                "数据库存储",
                "网络延迟",
            ],
            answer: 1,
            rationale: "聚合越大，并发修改的冲突概率越高。",
        },
        {
            id: "w6-2-q8",
            question: "开发者对聚合边界的常见不适应是什么？",
            options: [
                "代码太少",
                "习惯自由导航对象图，聚合边界限制了这种自由",
                "测试太多",
                "文档太多",
            ],
            answer: 1,
            rationale: "开发者习惯于自由导航对象图，聚合边界限制了这种自由。",
        },
        {
            id: "w6-2-q9",
            question: "设计聚合根的公共接口时应该确保什么？",
            options: [
                "尽可能多的方法",
                "所有修改都通过聚合根进行",
                "最少的方法",
                "没有限制",
            ],
            answer: 1,
            rationale: "设计聚合根的公共接口时应确保所有修改通过聚合根进行，保护内部一致性。",
        },
        {
            id: "w6-2-q10",
            question: "如何验证聚合的不变量正确性？",
            options: [
                "手动检查",
                "编写测试验证不变量在任何操作后都保持有效",
                "不需要验证",
                "只验证数据库约束",
            ],
            answer: 1,
            rationale: "应编写测试验证不变量在任何操作后都保持有效。",
        },
        {
            id: "w6-2-q11",
            question: "在已有系统中引入聚合边界的挑战是什么？",
            options: [
                "没有挑战",
                "需要重构，可能影响大量代码",
                "只需要修改数据库",
                "只需要添加新代码",
            ],
            answer: 1,
            rationale: "已有系统中引入聚合边界需要重构，可能影响大量代码。",
        },
        {
            id: "w6-2-q12",
            question: "实现聚合内对象的级联删除意味着什么？",
            options: [
                "删除数据库",
                "删除聚合根时，其内部对象也被删除",
                "只删除聚合根",
                "不删除任何对象",
            ],
            answer: 1,
            rationale: "聚合根负责管理内部对象的生命周期，删除聚合根时其内部对象也应被删除。",
        },
    ],
    "w6-3": [
        {
            id: "w6-3-q1",
            question: "Vernon 的第一条聚合设计规则是什么？",
            options: [
                "设计小聚合",
                "在一致性边界内建模真实的业务不变量",
                "通过 ID 引用",
                "使用最终一致性",
            ],
            answer: 1,
            rationale: "规则一：'Model True Invariants in Consistency Boundaries'——在一致性边界内建模真实的业务不变量。",
        },
        {
            id: "w6-3-q2",
            question: "Vernon 的第二条聚合设计规则是什么？",
            options: [
                "建模真实不变量",
                "设计小聚合",
                "通过 ID 引用",
                "使用最终一致性",
            ],
            answer: 1,
            rationale: "规则二：'Design Small Aggregates'——聚合应该小，只包含必要的对象。",
        },
        {
            id: "w6-3-q3",
            question: "Vernon 的第三条聚合设计规则是什么？",
            options: [
                "建模真实不变量",
                "设计小聚合",
                "通过标识而非对象引用关联其他聚合",
                "使用最终一致性",
            ],
            answer: 2,
            rationale: "规则三：'Reference Other Aggregates by Identity'——通过标识而非对象引用关联其他聚合。",
        },
        {
            id: "w6-3-q4",
            question: "Vernon 的第四条聚合设计规则是什么？",
            options: [
                "建模真实不变量",
                "设计小聚合",
                "通过 ID 引用",
                "聚合边界外使用最终一致性",
            ],
            answer: 3,
            rationale: "规则四：'Use Eventual Consistency Outside the Boundary'——聚合边界外使用最终一致性。",
        },
        {
            id: "w6-3-q5",
            question: "小聚合有什么优势？",
            options: [
                "代码更多",
                "减少锁冲突，提高并发性能，简化理解和测试",
                "数据库更复杂",
                "需要更多事务",
            ],
            answer: 1,
            rationale: "小聚合减少锁冲突，提高并发性能，简化理解和测试。",
        },
        {
            id: "w6-3-q6",
            question: "什么是聚合的'正确的最小值'？",
            options: [
                "最少的代码",
                "足够小但能保护所有必要的不变量",
                "只有聚合根",
                "没有最小值",
            ],
            answer: 1,
            rationale: "'正确的最小值'是足够小但又能保护所有必要的不变量。",
        },
        {
            id: "w6-3-q7",
            question: "为什么应该通过 ID 而非对象引用其他聚合？",
            options: [
                "性能更好",
                "防止在同一事务中修改多个聚合的诱惑",
                "代码更简单",
                "数据库要求",
            ],
            answer: 1,
            rationale: "通过 ID 引用可以防止在同一事务中修改多个聚合的诱惑。",
        },
        {
            id: "w6-3-q8",
            question: "如何更新其他聚合？",
            options: [
                "在同一事务中直接修改",
                "使用领域事件实现最终一致性",
                "不需要更新",
                "通过数据库触发器",
            ],
            answer: 1,
            rationale: "'Update other aggregates using domain events'——使用领域事件更新其他聚合。",
        },
        {
            id: "w6-3-q9",
            question: "识别'真实'不变量的挑战是什么？",
            options: [
                "没有挑战",
                "有些看似不变量的规则实际可以放松，需要深入理解业务",
                "所有规则都是不变量",
                "只看代码就能识别",
            ],
            answer: 1,
            rationale: "正确识别'真实'的不变量需要深入理解业务，有些看似不变量的规则实际可以放松。",
        },
        {
            id: "w6-3-q10",
            question: "设计最终一致性机制的挑战是什么？",
            options: [
                "没有挑战",
                "需要额外的技术复杂度",
                "代码更少",
                "数据库更简单",
            ],
            answer: 1,
            rationale: "设计正确的最终一致性机制需要额外的技术复杂度。",
        },
        {
            id: "w6-3-q11",
            question: "审查现有聚合时应该评估什么？",
            options: [
                "代码行数",
                "是否遵循 Vernon 的四条规则",
                "文件大小",
                "团队人数",
            ],
            answer: 1,
            rationale: "审查现有聚合时应评估是否遵循 Vernon 的四条聚合设计规则。",
        },
        {
            id: "w6-3-q12",
            question: "习惯对象导航的开发者为什么不适应 ID 引用？",
            options: [
                "ID 太长",
                "习惯直接访问关联对象，ID 引用需要额外的加载步骤",
                "数据库不支持",
                "框架限制",
            ],
            answer: 1,
            rationale: "习惯对象导航的开发者可能不适应通过 ID 引用，因为需要额外的加载步骤。",
        },
    ],
    "w6-4": [
        {
            id: "w6-4-q1",
            question: "通过 ID 引用其他聚合的主要优势是什么？",
            options: [
                "代码更短",
                "防止在同一事务中修改多个聚合",
                "数据库性能",
                "框架支持",
            ],
            answer: 1,
            rationale: "通过 ID 引用其他聚合可以防止在同一事务中修改多个聚合的诱惑。",
        },
        {
            id: "w6-4-q2",
            question: "跨聚合的更新应该通过什么实现？",
            options: [
                "分布式事务",
                "领域事件实现最终一致性",
                "直接数据库操作",
                "忽略一致性",
            ],
            answer: 1,
            rationale: "跨聚合的更新通过领域事件实现最终一致性，而非事务一致性。",
        },
        {
            id: "w6-4-q3",
            question: "最终一致性的时间窗口意味着什么？",
            options: [
                "数据永远一致",
                "存在短暂的不一致期，业务需要能接受",
                "数据永远不一致",
                "不需要考虑",
            ],
            answer: 1,
            rationale: "最终一致性意味着存在不一致的时间窗口，需要业务能接受。",
        },
        {
            id: "w6-4-q4",
            question: "跨聚合操作失败时应该如何处理？",
            options: [
                "忽略失败",
                "设计补偿或重试机制",
                "回滚所有操作",
                "停止系统",
            ],
            answer: 1,
            rationale: "跨聚合操作失败时需要设计补偿或重试机制。",
        },
        {
            id: "w6-4-q5",
            question: "ID 引用如何支持分布式系统？",
            options: [
                "不支持",
                "聚合可以分布在不同服务中，通过 ID 关联",
                "只支持单体",
                "需要共享数据库",
            ],
            answer: 1,
            rationale: "ID 引用天然支持分布式系统，聚合可以分布在不同服务中。",
        },
        {
            id: "w6-4-q6",
            question: "需要其他聚合数据时应该如何获取？",
            options: [
                "预先加载所有聚合",
                "通过仓储按需加载",
                "直接访问数据库",
                "缓存所有数据",
            ],
            answer: 1,
            rationale: "需要其他聚合数据时，通过仓储按需加载而非预先加载。",
        },
        {
            id: "w6-4-q7",
            question: "异步最终一致性的调试挑战是什么？",
            options: [
                "没有挑战",
                "比同步事务更难调试和追踪",
                "更容易调试",
                "不需要调试",
            ],
            answer: 1,
            rationale: "异步的最终一致性比同步事务更难调试和追踪。",
        },
        {
            id: "w6-4-q8",
            question: "跨聚合查询的挑战是什么？",
            options: [
                "没有挑战",
                "可能需要额外的读模型或组合多个聚合的数据",
                "直接查询数据库",
                "不支持查询",
            ],
            answer: 1,
            rationale: "跨聚合的查询可能需要额外的读模型或组合多个聚合的数据。",
        },
        {
            id: "w6-4-q9",
            question: "监控最终一致性健康状况需要关注什么？",
            options: [
                "代码行数",
                "一致性延迟和事件处理状态",
                "文件大小",
                "团队人数",
            ],
            answer: 1,
            rationale: "建立监控和告警机制追踪一致性延迟和事件处理状态。",
        },
        {
            id: "w6-4-q10",
            question: "Outbox 模式的作用是什么？",
            options: [
                "存储邮件",
                "保证事件发布的可靠性",
                "缓存数据",
                "日志记录",
            ],
            answer: 1,
            rationale: "Outbox 模式用于保证事件发布的可靠性，确保事件不会丢失。",
        },
        {
            id: "w6-4-q11",
            question: "实现跨聚合更新的步骤是什么？",
            options: [
                "直接修改数据库",
                "设计领域事件 → 发布事件 → 订阅处理 → 更新目标聚合",
                "使用分布式事务",
                "手动同步",
            ],
            answer: 1,
            rationale: "实现跨聚合更新：设计领域事件、实现事件发布和订阅机制、设计补偿操作处理失败场景。",
        },
        {
            id: "w6-4-q12",
            question: "设计补偿操作的目的是什么？",
            options: [
                "提高性能",
                "处理跨聚合操作失败时的恢复",
                "减少代码",
                "简化数据库",
            ],
            answer: 1,
            rationale: "设计补偿操作是为了处理跨聚合操作失败时的恢复场景。",
        },
    ],
}
