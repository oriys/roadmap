import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week11Guides: Record<string, LessonGuide> = {
    "w11-1": {
        lessonId: "w11-1",
        background: [
            "【CQRS 定义】Martin Fowler：'CQRS stands for Command Query Responsibility Segregation'——命令查询职责分离。",
            "【核心理念】'you can use a different model to update information than the model you use to read information'——读写使用不同的模型。",
            "【起源】CQRS 模式由 Greg Young 首先描述，源于对复杂领域建模的需求。",
            "【独立运行】读模型和写模型作为独立的对象模型运行，可能在不同的逻辑进程或硬件上执行。",
            "【与 CQS 区别】CQS（命令查询分离）是方法级别，CQRS 是架构级别的模型分离。",
        ],
        keyDifficulties: [
            "【复杂性警告】Fowler 强调：'you should be very cautious about using CQRS'——对大多数系统会增加不必要的复杂性。",
            "【适用范围】建议仅在特定边界上下文中使用，而非整个系统。",
            "【同步问题】读模型和写模型之间的数据同步是主要技术挑战。",
            "【调试困难】分离的模型增加了问题追踪和调试的难度。",
        ],
        handsOnPath: [
            "识别系统中读写比例差异大的场景",
            "分析单一模型的痛点",
            "设计分离的命令模型和查询模型",
            "决定是否使用单一数据存储还是分离存储",
            "实现数据同步机制",
            "评估 CQRS 引入后的复杂度变化",
        ],
        selfCheck: [
            "什么是 CQRS？它与 CQS 有什么区别？",
            "为什么 Fowler 说应该谨慎使用 CQRS？",
            "CQRS 在什么场景下最有价值？",
            "读模型和写模型可以使用不同的数据存储吗？",
            "CQRS 应该应用于整个系统还是特定上下文？",
        ],
        extensions: [
            "学习 Greg Young 的 CQRS 文档",
            "了解 CQRS 与事件驱动架构的关系",
            "研究 CQRS 在微服务中的应用",
            "探索简化版 CQRS 的实现方式",
        ],
        sourceUrls: [
            "https://martinfowler.com/bliki/CQRS.html",
            "https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf",
        ],
    },
    "w11-2": {
        lessonId: "w11-2",
        background: [
            "【命令定义】命令（Command）是更新数据的操作，代表用户的意图和行为。",
            "【业务语义】命令应使用高级业务任务而非低层数据操作：'Book hotel room' 而非 'Set ReservationStatus to Reserved'。",
            "【命令处理器】CommandHandler 接收命令，协调聚合执行业务逻辑，然后持久化变更。",
            "【异步处理】建议使用消息队列而非同步处理，提高系统响应性和可扩展性。",
            "【验证分层】客户端验证（UI 禁用不可用选项）+ 服务端逻辑（处理边界情况和竞态条件）。",
        ],
        keyDifficulties: [
            "【命令粒度】命令应该代表完整的业务意图，太细碎会失去业务含义。",
            "【幂等性】命令处理应该是幂等的，重复提交不应产生副作用。",
            "【事务边界】命令处理通常对应一个聚合的事务边界。",
            "【错误处理】命令失败时的错误返回和补偿机制设计。",
        ],
        handsOnPath: [
            "定义命令对象（Command）包含必要的数据",
            "实现命令处理器（CommandHandler）",
            "在处理器中加载聚合、执行业务逻辑、保存变更",
            "添加命令验证逻辑",
            "配置消息队列实现异步命令处理",
            "实现命令的幂等性检查",
        ],
        selfCheck: [
            "命令应该如何命名？为什么？",
            "命令处理器的职责是什么？",
            "为什么推荐使用消息队列处理命令？",
            "命令的验证应该在哪些层次进行？",
            "什么是命令的幂等性？为什么重要？",
        ],
        extensions: [
            "学习 MediatR 等命令总线的使用",
            "了解命令的版本控制",
            "研究 Saga 模式处理跨聚合命令",
            "探索命令的审计和追踪",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs",
            "https://enterprisecraftsmanship.com/posts/cqrs-commands-part-3/",
        ],
    },
    "w11-3": {
        lessonId: "w11-3",
        background: [
            "【查询定义】查询（Query）是检索数据的操作，无副作用，从不修改数据。",
            "【返回 DTO】查询返回数据传输对象（DTO），无业务逻辑，专为展示优化。",
            "【优化结构】查询模型可以为查询性能优化数据结构，如预先计算、反范式化。",
            "【物化视图】可以使用物化视图避免复杂 JOIN，提高查询性能。",
            "【独立存储】查询模型可以使用与写模型不同的存储技术（如文档数据库、搜索引擎）。",
        ],
        keyDifficulties: [
            "【最终一致性】读库可能滞后于写库，导致数据'陈旧'——需要业务接受。",
            "【同步机制】写模型变更后如何高效同步到读模型。",
            "【投影设计】为不同查询场景设计合适的投影（Projection）。",
            "【版本冲突】并发更新读模型时的冲突处理。",
        ],
        handsOnPath: [
            "定义查询对象和 DTO",
            "实现查询处理器直接访问读存储",
            "设计物化视图或投影",
            "实现从写模型到读模型的同步机制",
            "添加缓存层优化查询性能",
            "监控读写模型的一致性延迟",
        ],
        selfCheck: [
            "查询的特点是什么？为什么说它无副作用？",
            "为什么查询返回 DTO 而非领域对象？",
            "什么是物化视图？它解决什么问题？",
            "读模型如何与写模型同步？",
            "最终一致性意味着什么？业务如何接受？",
        ],
        extensions: [
            "学习 Elasticsearch 作为查询存储",
            "了解 Redis 缓存在查询模型中的应用",
            "研究 GraphQL 与 CQRS 的结合",
            "探索实时查询和 WebSocket 推送",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs",
            "https://enterprisecraftsmanship.com/posts/cqrs-read-models/",
        ],
    },
    "w11-4": {
        lessonId: "w11-4",
        background: [
            "【适用场景一】复杂领域：某些复杂业务域通过分离模型可能更易处理。",
            "【适用场景二】高性能应用：当系统读写操作差异大时，允许独立扩展。",
            "【主要优势】独立扩展、优化的架构、安全隔离、关注点分离、简化查询。",
            "【不适用场景】简单 CRUD 应用、领域逻辑简单、业务规则稳定的系统。",
            "【复杂性代价】消息处理（失败、重复、重试）、最终一致性、调试困难。",
        ],
        keyDifficulties: [
            "【过度工程】在不需要的地方引入 CQRS 是常见的反模式。",
            "【团队能力】CQRS 需要团队理解分布式系统的复杂性。",
            "【运维成本】分离的存储意味着更高的运维复杂度。",
            "【迁移成本】从单一模型迁移到 CQRS 的成本可能很高。",
        ],
        handsOnPath: [
            "评估当前系统是否真的需要 CQRS",
            "列出 CQRS 带来的收益和成本",
            "选择合适的边界上下文应用 CQRS",
            "设计渐进式的迁移策略",
            "建立监控和告警机制",
            "培训团队理解 CQRS 的复杂性",
        ],
        selfCheck: [
            "CQRS 最适合什么场景？",
            "CQRS 的主要优势有哪些？",
            "什么时候不应该使用 CQRS？",
            "引入 CQRS 的主要代价是什么？",
            "如何渐进式地引入 CQRS？",
        ],
        extensions: [
            "学习简化版 CQRS（单存储）",
            "了解 CQRS 与微服务的关系",
            "研究 CQRS 的反模式",
            "探索 CQRS 的监控和可观测性",
        ],
        sourceUrls: [
            "https://martinfowler.com/bliki/CQRS.html",
            "https://enterprisecraftsmanship.com/posts/cqrs-commands-part-1/",
        ],
    },
}

export const week11Quizzes: Record<string, QuizQuestion[]> = {
    "w11-1": [
        {
            id: "w11-1-q1",
            question: "CQRS 是什么的缩写？",
            options: [
                "Command Query Response System",
                "Command Query Responsibility Segregation",
                "Create Query Read System",
                "Command Queue Response Service",
            ],
            answer: 1,
            rationale: "'CQRS stands for Command Query Responsibility Segregation'——命令查询职责分离。",
        },
        {
            id: "w11-1-q2",
            question: "CQRS 的核心理念是什么？",
            options: [
                "使用相同的模型处理所有操作",
                "读写使用不同的模型",
                "只使用查询",
                "只使用命令",
            ],
            answer: 1,
            rationale: "'you can use a different model to update information than the model you use to read information'。",
        },
        {
            id: "w11-1-q3",
            question: "CQRS 模式由谁首先描述？",
            options: [
                "Martin Fowler",
                "Greg Young",
                "Eric Evans",
                "Robert C. Martin",
            ],
            answer: 1,
            rationale: "CQRS 模式由 Greg Young 首先描述，源于对复杂领域建模的需求。",
        },
        {
            id: "w11-1-q4",
            question: "Martin Fowler 对 CQRS 的态度是什么？",
            options: [
                "强烈推荐所有项目使用",
                "应该谨慎使用，对大多数系统会增加不必要的复杂性",
                "完全不推荐",
                "只用于小项目",
            ],
            answer: 1,
            rationale: "Fowler 强调：'you should be very cautious about using CQRS'——对大多数系统会增加不必要的复杂性。",
        },
        {
            id: "w11-1-q5",
            question: "CQRS 应该应用于什么范围？",
            options: [
                "整个系统",
                "仅在特定边界上下文中",
                "所有微服务",
                "只在数据库层",
            ],
            answer: 1,
            rationale: "建议仅在特定边界上下文中使用，而非整个系统。",
        },
        {
            id: "w11-1-q6",
            question: "CQRS 与 CQS 的区别是什么？",
            options: [
                "没有区别",
                "CQS 是方法级别，CQRS 是架构级别的模型分离",
                "CQS 更复杂",
                "CQRS 是 CQS 的简化版",
            ],
            answer: 1,
            rationale: "CQS（命令查询分离）是方法级别，CQRS 是架构级别的模型分离。",
        },
        {
            id: "w11-1-q7",
            question: "读模型和写模型可以运行在哪里？",
            options: [
                "必须在同一进程",
                "可以在不同的逻辑进程或硬件上执行",
                "只能在同一数据库",
                "必须在同一服务器",
            ],
            answer: 1,
            rationale: "读模型和写模型作为独立的对象模型运行，可能在不同的逻辑进程或硬件上执行。",
        },
        {
            id: "w11-1-q8",
            question: "CQRS 的主要技术挑战是什么？",
            options: [
                "代码量增加",
                "读模型和写模型之间的数据同步",
                "性能下降",
                "安全问题",
            ],
            answer: 1,
            rationale: "读模型和写模型之间的数据同步是主要技术挑战。",
        },
        {
            id: "w11-1-q9",
            question: "CQRS 在什么场景最有价值？",
            options: [
                "简单 CRUD 应用",
                "复杂领域和高性能应用（读写比例差异大）",
                "小型项目",
                "静态网站",
            ],
            answer: 1,
            rationale: "CQRS 在复杂领域和高性能应用（读写比例差异大）场景最有价值。",
        },
        {
            id: "w11-1-q10",
            question: "CQRS 常与哪些模式结合使用？",
            options: [
                "只有 MVC",
                "事件驱动架构、事件溯源和最终一致性",
                "只有数据库分片",
                "只有缓存",
            ],
            answer: 1,
            rationale: "CQRS 常与事件驱动架构、事件溯源和最终一致性等模式结合使用。",
        },
        {
            id: "w11-1-q11",
            question: "分离的模型会带来什么调试问题？",
            options: [
                "没有问题",
                "增加了问题追踪和调试的难度",
                "更容易调试",
                "自动调试",
            ],
            answer: 1,
            rationale: "分离的模型增加了问题追踪和调试的难度。",
        },
        {
            id: "w11-1-q12",
            question: "在识别是否需要 CQRS 时，应该首先分析什么？",
            options: [
                "代码量",
                "读写比例差异和单一模型的痛点",
                "团队规模",
                "数据库类型",
            ],
            answer: 1,
            rationale: "应该识别系统中读写比例差异大的场景，分析单一模型的痛点。",
        },
    ],
    "w11-2": [
        {
            id: "w11-2-q1",
            question: "命令（Command）是什么？",
            options: [
                "查询数据的操作",
                "更新数据的操作，代表用户的意图和行为",
                "日志记录",
                "配置操作",
            ],
            answer: 1,
            rationale: "命令（Command）是更新数据的操作，代表用户的意图和行为。",
        },
        {
            id: "w11-2-q2",
            question: "命令应该如何命名？",
            options: [
                "使用技术术语",
                "使用高级业务任务如'Book hotel room'而非'Set ReservationStatus to Reserved'",
                "使用数据库字段名",
                "使用随机名称",
            ],
            answer: 1,
            rationale: "命令应使用高级业务任务而非低层数据操作：'Book hotel room' 而非 'Set ReservationStatus to Reserved'。",
        },
        {
            id: "w11-2-q3",
            question: "CommandHandler 的职责是什么？",
            options: [
                "查询数据",
                "接收命令，协调聚合执行业务逻辑，然后持久化变更",
                "渲染 UI",
                "管理配置",
            ],
            answer: 1,
            rationale: "CommandHandler 接收命令，协调聚合执行业务逻辑，然后持久化变更。",
        },
        {
            id: "w11-2-q4",
            question: "为什么推荐使用消息队列处理命令？",
            options: [
                "代码更少",
                "提高系统响应性和可扩展性",
                "减少数据库访问",
                "简化代码",
            ],
            answer: 1,
            rationale: "建议使用消息队列而非同步处理，提高系统响应性和可扩展性。",
        },
        {
            id: "w11-2-q5",
            question: "命令的验证应该在哪些层次进行？",
            options: [
                "只在客户端",
                "客户端验证（UI 禁用不可用选项）+ 服务端逻辑（处理边界情况和竞态条件）",
                "只在服务端",
                "不需要验证",
            ],
            answer: 1,
            rationale: "验证分层：客户端验证（UI 禁用不可用选项）+ 服务端逻辑（处理边界情况和竞态条件）。",
        },
        {
            id: "w11-2-q6",
            question: "什么是命令的幂等性？",
            options: [
                "命令只能执行一次",
                "重复提交不应产生副作用",
                "命令自动重试",
                "命令自动取消",
            ],
            answer: 1,
            rationale: "命令处理应该是幂等的，重复提交不应产生副作用。",
        },
        {
            id: "w11-2-q7",
            question: "命令处理通常对应什么边界？",
            options: [
                "整个系统",
                "一个聚合的事务边界",
                "多个聚合",
                "整个数据库",
            ],
            answer: 1,
            rationale: "命令处理通常对应一个聚合的事务边界。",
        },
        {
            id: "w11-2-q8",
            question: "命令的粒度应该如何设计？",
            options: [
                "越细越好",
                "代表完整的业务意图，太细碎会失去业务含义",
                "越粗越好",
                "与数据库表对应",
            ],
            answer: 1,
            rationale: "命令应该代表完整的业务意图，太细碎会失去业务含义。",
        },
        {
            id: "w11-2-q9",
            question: "命令对象应该包含什么？",
            options: [
                "业务逻辑",
                "执行命令所需的必要数据",
                "查询结果",
                "UI 状态",
            ],
            answer: 1,
            rationale: "定义命令对象（Command）包含必要的数据。",
        },
        {
            id: "w11-2-q10",
            question: "命令处理器的标准流程是什么？",
            options: [
                "直接修改数据库",
                "加载聚合、执行业务逻辑、保存变更",
                "只验证数据",
                "只发送消息",
            ],
            answer: 1,
            rationale: "在处理器中加载聚合、执行业务逻辑、保存变更。",
        },
        {
            id: "w11-2-q11",
            question: "命令失败时应该如何处理？",
            options: [
                "忽略失败",
                "返回错误并设计补偿机制",
                "自动重试无限次",
                "删除命令",
            ],
            answer: 1,
            rationale: "命令失败时的错误返回和补偿机制设计是重要考虑。",
        },
        {
            id: "w11-2-q12",
            question: "MediatR 等命令总线的作用是什么？",
            options: [
                "替代数据库",
                "解耦命令发送者和处理器",
                "替代消息队列",
                "替代 ORM",
            ],
            answer: 1,
            rationale: "MediatR 等命令总线帮助解耦命令发送者和处理器。",
        },
    ],
    "w11-3": [
        {
            id: "w11-3-q1",
            question: "查询（Query）的特点是什么？",
            options: [
                "修改数据",
                "无副作用，从不修改数据",
                "创建新记录",
                "删除记录",
            ],
            answer: 1,
            rationale: "查询（Query）是检索数据的操作，无副作用，从不修改数据。",
        },
        {
            id: "w11-3-q2",
            question: "查询应该返回什么？",
            options: [
                "领域对象",
                "数据传输对象（DTO），无业务逻辑",
                "聚合根",
                "实体集合",
            ],
            answer: 1,
            rationale: "查询返回数据传输对象（DTO），无业务逻辑，专为展示优化。",
        },
        {
            id: "w11-3-q3",
            question: "什么是物化视图？它解决什么问题？",
            options: [
                "临时表",
                "预先计算的视图，避免复杂 JOIN 提高查询性能",
                "备份数据",
                "日志表",
            ],
            answer: 1,
            rationale: "可以使用物化视图避免复杂 JOIN，提高查询性能。",
        },
        {
            id: "w11-3-q4",
            question: "查询模型可以使用什么存储技术？",
            options: [
                "只能用关系数据库",
                "可以使用与写模型不同的存储技术（如文档数据库、搜索引擎）",
                "只能用文件",
                "只能用缓存",
            ],
            answer: 1,
            rationale: "查询模型可以使用与写模型不同的存储技术（如文档数据库、搜索引擎）。",
        },
        {
            id: "w11-3-q5",
            question: "最终一致性意味着什么？",
            options: [
                "数据永远一致",
                "读库可能滞后于写库，导致数据'陈旧'",
                "数据永远不一致",
                "不需要一致性",
            ],
            answer: 1,
            rationale: "最终一致性意味着读库可能滞后于写库，导致数据'陈旧'——需要业务接受。",
        },
        {
            id: "w11-3-q6",
            question: "什么是投影（Projection）？",
            options: [
                "数据备份",
                "为特定查询场景设计的数据视图",
                "数据加密",
                "数据压缩",
            ],
            answer: 1,
            rationale: "为不同查询场景设计合适的投影（Projection）。",
        },
        {
            id: "w11-3-q7",
            question: "读模型如何与写模型同步？",
            options: [
                "不需要同步",
                "写模型变更后通过事件或其他机制同步到读模型",
                "手动复制",
                "数据库触发器",
            ],
            answer: 1,
            rationale: "实现从写模型到读模型的同步机制是关键技术挑战。",
        },
        {
            id: "w11-3-q8",
            question: "查询优化可以采用什么策略？",
            options: [
                "减少查询",
                "预先计算、反范式化、添加缓存层",
                "只用主键查询",
                "不进行优化",
            ],
            answer: 1,
            rationale: "查询模型可以为查询性能优化数据结构，如预先计算、反范式化，添加缓存层。",
        },
        {
            id: "w11-3-q9",
            question: "查询处理器应该如何访问数据？",
            options: [
                "通过聚合",
                "直接访问读存储",
                "通过命令处理器",
                "通过领域服务",
            ],
            answer: 1,
            rationale: "实现查询处理器直接访问读存储。",
        },
        {
            id: "w11-3-q10",
            question: "并发更新读模型时可能遇到什么问题？",
            options: [
                "没有问题",
                "版本冲突",
                "性能提升",
                "自动解决",
            ],
            answer: 1,
            rationale: "并发更新读模型时的版本冲突处理是需要考虑的问题。",
        },
        {
            id: "w11-3-q11",
            question: "如何监控读写模型的一致性？",
            options: [
                "不需要监控",
                "监控读写模型的一致性延迟",
                "只监控写模型",
                "只监控读模型",
            ],
            answer: 1,
            rationale: "监控读写模型的一致性延迟是运维的重要部分。",
        },
        {
            id: "w11-3-q12",
            question: "GraphQL 与 CQRS 如何结合？",
            options: [
                "不能结合",
                "GraphQL 可以作为查询模型的 API 层",
                "GraphQL 替代 CQRS",
                "只用于命令",
            ],
            answer: 1,
            rationale: "GraphQL 可以与 CQRS 结合，作为查询模型的灵活 API 层。",
        },
    ],
    "w11-4": [
        {
            id: "w11-4-q1",
            question: "CQRS 的主要优势有哪些？",
            options: [
                "代码更少",
                "独立扩展、优化的架构、安全隔离、关注点分离、简化查询",
                "更简单",
                "不需要数据库",
            ],
            answer: 1,
            rationale: "主要优势包括：独立扩展、优化的架构、安全隔离、关注点分离、简化查询。",
        },
        {
            id: "w11-4-q2",
            question: "什么时候不应该使用 CQRS？",
            options: [
                "复杂领域",
                "简单 CRUD 应用、领域逻辑简单、业务规则稳定的系统",
                "高性能应用",
                "大数据量系统",
            ],
            answer: 1,
            rationale: "不适用场景：简单 CRUD 应用、领域逻辑简单、业务规则稳定的系统。",
        },
        {
            id: "w11-4-q3",
            question: "引入 CQRS 的主要代价是什么？",
            options: [
                "没有代价",
                "消息处理（失败、重复、重试）、最终一致性、调试困难",
                "性能下降",
                "安全风险",
            ],
            answer: 1,
            rationale: "复杂性代价：消息处理（失败、重复、重试）、最终一致性、调试困难。",
        },
        {
            id: "w11-4-q4",
            question: "在不需要的地方引入 CQRS 是什么？",
            options: [
                "最佳实践",
                "常见的反模式（过度工程）",
                "推荐做法",
                "正常情况",
            ],
            answer: 1,
            rationale: "在不需要的地方引入 CQRS 是常见的反模式（过度工程）。",
        },
        {
            id: "w11-4-q5",
            question: "CQRS 对团队有什么要求？",
            options: [
                "没有要求",
                "团队需要理解分布式系统的复杂性",
                "只需要了解数据库",
                "只需要了解 UI",
            ],
            answer: 1,
            rationale: "CQRS 需要团队理解分布式系统的复杂性。",
        },
        {
            id: "w11-4-q6",
            question: "分离的存储意味着什么运维成本？",
            options: [
                "更低的成本",
                "更高的运维复杂度",
                "没有影响",
                "自动管理",
            ],
            answer: 1,
            rationale: "分离的存储意味着更高的运维复杂度。",
        },
        {
            id: "w11-4-q7",
            question: "如何渐进式地引入 CQRS？",
            options: [
                "一次性全部重写",
                "选择合适的边界上下文，设计渐进式的迁移策略",
                "不需要渐进",
                "自动迁移",
            ],
            answer: 1,
            rationale: "选择合适的边界上下文应用 CQRS，设计渐进式的迁移策略。",
        },
        {
            id: "w11-4-q8",
            question: "什么是简化版 CQRS？",
            options: [
                "不使用 CQRS",
                "使用单一数据存储但分离读写模型",
                "只用命令",
                "只用查询",
            ],
            answer: 1,
            rationale: "简化版 CQRS 使用单一数据存储但在应用层分离读写模型。",
        },
        {
            id: "w11-4-q9",
            question: "评估是否需要 CQRS 时应该列出什么？",
            options: [
                "代码行数",
                "CQRS 带来的收益和成本",
                "团队人数",
                "服务器数量",
            ],
            answer: 1,
            rationale: "列出 CQRS 带来的收益和成本是评估的关键步骤。",
        },
        {
            id: "w11-4-q10",
            question: "从单一模型迁移到 CQRS 的成本如何？",
            options: [
                "几乎没有成本",
                "成本可能很高",
                "成本固定",
                "自动迁移",
            ],
            answer: 1,
            rationale: "从单一模型迁移到 CQRS 的成本可能很高。",
        },
        {
            id: "w11-4-q11",
            question: "CQRS 与微服务的关系是什么？",
            options: [
                "没有关系",
                "CQRS 适合在微服务的特定上下文中使用",
                "必须一起使用",
                "互相排斥",
            ],
            answer: 1,
            rationale: "CQRS 适合在微服务的特定边界上下文中使用。",
        },
        {
            id: "w11-4-q12",
            question: "建立 CQRS 系统后应该关注什么？",
            options: [
                "不需要关注",
                "建立监控和告警机制",
                "只关注性能",
                "只关注安全",
            ],
            answer: 1,
            rationale: "建立监控和告警机制是 CQRS 系统运维的重要部分。",
        },
    ],
}
