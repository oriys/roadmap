import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week8Guides: Record<string, LessonGuide> = {
    "w8-1": {
        lessonId: "w8-1",
        background: [
            "【领域服务定义】领域服务是无状态的类，封装不自然属于实体或值对象的领域知识和业务逻辑。",
            "【核心区别】'domain services hold domain logic whereas application services don't'——领域服务持有领域逻辑，应用服务不持有。",
            "【决策参与】应用服务将决策委托给领域模型，而领域服务参与决策过程本身。",
            "【无状态特性】领域服务是无状态的，不保存任何数据，只提供操作。",
            "【领域层归属】领域服务属于领域层，而非应用层或基础设施层。",
        ],
        keyDifficulties: [
            "【提取时机】当逻辑不能归属于实体/值对象而不破坏其隔离性时，应提取领域服务。",
            "【必要的不纯】领域服务应只包含'necessary impurity'——只有做出业务决策所必需的外部依赖。",
            "【避免过度使用】过度使用领域服务会导致贫血模型，实体应处理能独立处理的逻辑。",
            "【仓储不在领域服务中】仓储交互应该在应用服务中，而非领域服务中。",
        ],
        handsOnPath: [
            "识别跨越多个实体的业务规则",
            "判断该逻辑是否真的不属于任何实体",
            "创建无状态的领域服务类",
            "定义清晰的服务方法，使用领域语言命名",
            "注入必要的依赖（如其他领域服务）",
            "编写单元测试验证服务逻辑",
        ],
        selfCheck: [
            "什么是领域服务？它与实体有什么区别？",
            "领域服务与应用服务的核心区别是什么？",
            "什么时候应该提取领域服务？",
            "领域服务应该是有状态还是无状态的？",
            "仓储交互应该放在哪里？",
        ],
        extensions: [
            "学习领域服务的依赖注入策略",
            "了解领域服务与策略模式的结合",
            "研究领域服务的测试策略",
            "探索领域服务与规格模式的配合",
        ],
        sourceUrls: [
            "https://enterprisecraftsmanship.com/posts/domain-vs-application-services/",
        ],
    },
    "w8-2": {
        lessonId: "w8-2",
        background: [
            "【领域事件定义】Martin Fowler：领域事件'Captures the memory of something interesting which affects the domain'——捕获影响领域的有趣事情的记忆。",
            "【过去时态命名】领域事件代表已经发生的事实，命名使用过去时态（如 OrderCreated、PaymentReceived）。",
            "【不可变性】Microsoft 文档：事件必须是不可变的（只读属性），因为它们代表已经发生的事情。",
            "【领域内通信】领域事件用于同一领域内的通信，使副作用显式化而非隐式耦合。",
            "【源数据与处理数据】事件包含源数据（不可变的发生信息）和处理数据（可变的系统响应信息）。",
        ],
        keyDifficulties: [
            "【时间维度】事件应捕获两个时间点：事情实际发生的时间 vs 系统注意到的时间。",
            "【领域事件 vs 集成事件】领域事件在进程内、同一领域；集成事件跨微服务/系统。",
            "【事件结构设计】事件应包含足够的信息让订阅者处理，但不应包含过多不相关的数据。",
            "【追溯性修正】变更应通过单独的追溯事件处理，而非修改源数据。",
        ],
        handsOnPath: [
            "识别领域中的重要业务事件",
            "使用过去时态命名事件类",
            "定义不可变的事件属性（只读）",
            "在聚合中添加事件到集合",
            "选择同步或异步处理策略",
            "编写测试验证事件触发",
        ],
        selfCheck: [
            "什么是领域事件？它代表什么？",
            "领域事件应该如何命名？",
            "为什么领域事件必须是不可变的？",
            "领域事件与集成事件有什么区别？",
            "事件应该捕获哪些时间维度？",
        ],
        extensions: [
            "学习事件溯源（Event Sourcing）基础",
            "了解事件版本控制和演进",
            "研究事件的序列化策略",
            "探索事件的审计和合规应用",
        ],
        sourceUrls: [
            "https://martinfowler.com/eaaDev/DomainEvent.html",
            "https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation",
        ],
    },
    "w8-3": {
        lessonId: "w8-3",
        background: [
            "【延迟发布模式】在聚合中将事件添加到集合，而非立即调度，在适当时机统一发布。",
            "【发布时机选择】可以在事务提交前（单事务）或事务提交后（最终一致性）发布事件。",
            "【单事务方式】Microsoft 文档推荐的 eShop 方式：事务提交前发布，所有变更一起回滚或提交。",
            "【中介者模式】使用中介者（如 MediatR）解耦事件与处理器，实现开放/封闭原则。",
            "【处理器位置】事件处理器应该在应用层，而非领域层。",
        ],
        keyDifficulties: [
            "【单事务 vs 最终一致性】单事务更简单但锁更多；最终一致性更可扩展但需要补偿机制。",
            "【事件丢失风险】异步发布需要保证事件不丢失，可能需要 Outbox 模式。",
            "【重复处理】消费者需要处理潜在的重复消息，实现幂等处理。",
            "【事件顺序】跨实例的事件需要保证消息顺序。",
        ],
        handsOnPath: [
            "在聚合基类中添加领域事件集合",
            "实现 AddDomainEvent() 方法",
            "在 DbContext.SaveChanges 中调度事件",
            "使用 MediatR 实现发布/订阅",
            "创建事件处理器类",
            "测试事件的完整发布流程",
        ],
        selfCheck: [
            "为什么使用延迟发布而非立即调度？",
            "事件应该在事务提交前还是后发布？各有什么优缺点？",
            "如何使用中介者模式解耦事件处理？",
            "事件处理器应该放在哪一层？",
            "如何保证事件不丢失？",
        ],
        extensions: [
            "学习 Transactional Outbox 模式",
            "了解事件重试和死信队列",
            "研究 Saga 模式的事件编排",
            "探索分布式追踪在事件系统中的应用",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation",
            "https://microservices.io/patterns/data/transactional-outbox.html",
        ],
    },
    "w8-4": {
        lessonId: "w8-4",
        background: [
            "【事件驱动集成】Martin Fowler：通过事件通知实现系统间的松耦合，系统广播变更而不期望直接响应。",
            "【Event-Carried State Transfer】事件传输完整状态数据，允许接收方维护本地副本，减少延迟和系统负载。",
            "【集成事件】领域事件可以触发集成事件，用于跨微服务通信。",
            "【Transactional Outbox】'write the message/event to a database OUTBOX table as part of the transaction'——在同一事务中写入 Outbox 表。",
            "【消息可靠性】Outbox 模式消除对 2PC 协议的依赖，保证只有数据库事务成功时才发送消息。",
        ],
        keyDifficulties: [
            "【隐式流程风险】事件驱动的业务逻辑可能变得隐式在事件链中，增加调试难度。",
            "【最终一致性窗口】事件驱动意味着存在不一致的时间窗口，业务需要能接受。",
            "【幂等消费】消息中继可能多次发布，消费者必须通过幂等处理处理重复消息。",
            "【模式选择】Event Notification、Event-Carried State Transfer、Event Sourcing、CQRS——需要区分并正确应用。",
        ],
        handsOnPath: [
            "设计领域事件到集成事件的转换",
            "实现 Outbox 表结构",
            "创建消息中继进程",
            "配置消息代理（如 RabbitMQ、Kafka）",
            "实现幂等的事件消费者",
            "设置监控和告警追踪事件流",
        ],
        selfCheck: [
            "什么是事件驱动集成？它的优势和风险是什么？",
            "领域事件如何触发集成事件？",
            "Transactional Outbox 模式解决什么问题？",
            "消费者如何处理重复消息？",
            "Event-Carried State Transfer 模式的特点是什么？",
        ],
        extensions: [
            "学习 Event Sourcing 模式",
            "了解 CDC（Change Data Capture）实现事件发布",
            "研究事件 Schema 的版本演进",
            "探索事件网格和事件平台",
        ],
        sourceUrls: [
            "https://martinfowler.com/articles/201701-event-driven.html",
            "https://microservices.io/patterns/data/transactional-outbox.html",
        ],
    },
}

export const week8Quizzes: Record<string, QuizQuestion[]> = {
    "w8-1": [
        {
            id: "w8-1-q1",
            question: "领域服务与应用服务的核心区别是什么？",
            options: [
                "领域服务更复杂",
                "领域服务持有领域逻辑，应用服务不持有",
                "应用服务更重要",
                "它们是一样的",
            ],
            answer: 1,
            rationale: "'domain services hold domain logic whereas application services don't'——领域服务持有领域逻辑，应用服务不持有。",
        },
        {
            id: "w8-1-q2",
            question: "领域服务应该是什么特性？",
            options: [
                "有状态的",
                "无状态的",
                "单例的",
                "静态的",
            ],
            answer: 1,
            rationale: "领域服务是无状态的类，不保存任何数据，只提供操作。",
        },
        {
            id: "w8-1-q3",
            question: "什么时候应该提取领域服务？",
            options: [
                "所有业务逻辑都用领域服务",
                "当逻辑不能归属于实体/值对象而不破坏其隔离性时",
                "只有跨聚合操作时",
                "永远不应该使用领域服务",
            ],
            answer: 1,
            rationale: "当逻辑不能归属于实体/值对象而不破坏其隔离性时，应提取领域服务。",
        },
        {
            id: "w8-1-q4",
            question: "领域服务应该包含什么程度的外部依赖？",
            options: [
                "越多越好",
                "只有做出业务决策所必需的（necessary impurity）",
                "不能有任何依赖",
                "所有基础设施依赖",
            ],
            answer: 1,
            rationale: "领域服务应只包含'necessary impurity'——只有做出业务决策所必需的外部依赖。",
        },
        {
            id: "w8-1-q5",
            question: "仓储交互应该放在哪里？",
            options: [
                "领域服务中",
                "应用服务中",
                "实体中",
                "控制器中",
            ],
            answer: 1,
            rationale: "仓储交互应该在应用服务中，而非领域服务中。",
        },
        {
            id: "w8-1-q6",
            question: "过度使用领域服务会导致什么问题？",
            options: [
                "性能问题",
                "贫血模型，实体失去行为",
                "内存泄漏",
                "编译错误",
            ],
            answer: 1,
            rationale: "过度使用领域服务会导致贫血模型，实体应处理能独立处理的逻辑。",
        },
        {
            id: "w8-1-q7",
            question: "领域服务属于哪一层？",
            options: [
                "基础设施层",
                "领域层",
                "应用层",
                "表现层",
            ],
            answer: 1,
            rationale: "领域服务属于领域层，因为它们封装领域知识和业务逻辑。",
        },
        {
            id: "w8-1-q8",
            question: "应用服务与领域服务在决策中的角色有什么不同？",
            options: [
                "都做决策",
                "应用服务委托决策给领域模型，领域服务参与决策过程",
                "都不做决策",
                "只有应用服务做决策",
            ],
            answer: 1,
            rationale: "应用服务将决策委托给领域模型，而领域服务参与决策过程本身。",
        },
        {
            id: "w8-1-q9",
            question: "领域服务的命名应该体现什么？",
            options: [
                "技术实现细节",
                "领域语言中的业务操作",
                "数据库表名",
                "类名前缀",
            ],
            answer: 1,
            rationale: "领域服务的命名应使用领域语言，体现业务操作而非技术实现。",
        },
        {
            id: "w8-1-q10",
            question: "领域服务中可以注入什么类型的依赖？",
            options: [
                "任何依赖",
                "其他领域服务和必要的领域接口",
                "所有仓储",
                "数据库连接",
            ],
            answer: 1,
            rationale: "领域服务可以注入其他领域服务和必要的领域接口，保持领域层的纯净。",
        },
        {
            id: "w8-1-q11",
            question: "以下哪种情况适合使用领域服务？",
            options: [
                "实体的简单属性修改",
                "跨越多个实体的复杂业务规则计算",
                "数据库查询",
                "用户界面渲染",
            ],
            answer: 1,
            rationale: "当业务规则跨越多个实体且不自然属于任何一个实体时，适合使用领域服务。",
        },
        {
            id: "w8-1-q12",
            question: "保持领域服务无状态有什么好处？",
            options: [
                "减少代码量",
                "便于测试、并发安全、可以共享实例",
                "提高性能",
                "简化部署",
            ],
            answer: 1,
            rationale: "无状态的领域服务便于单元测试、并发安全、可以在多个调用间共享实例。",
        },
    ],
    "w8-2": [
        {
            id: "w8-2-q1",
            question: "根据 Martin Fowler，领域事件的定义是什么？",
            options: [
                "数据库触发器",
                "捕获影响领域的有趣事情的记忆",
                "API 调用",
                "用户操作",
            ],
            answer: 1,
            rationale: "Fowler：领域事件'Captures the memory of something interesting which affects the domain'。",
        },
        {
            id: "w8-2-q2",
            question: "领域事件应该如何命名？",
            options: [
                "动词形式（如 CreateOrder）",
                "过去时态（如 OrderCreated）",
                "名词形式（如 Order）",
                "将来时态（如 OrderWillBeCreated）",
            ],
            answer: 1,
            rationale: "领域事件代表已经发生的事实，命名使用过去时态（如 OrderCreated、PaymentReceived）。",
        },
        {
            id: "w8-2-q3",
            question: "为什么领域事件必须是不可变的？",
            options: [
                "性能原因",
                "因为它们代表已经发生的事情，不能被修改",
                "编译器要求",
                "框架限制",
            ],
            answer: 1,
            rationale: "事件必须是不可变的（只读属性），因为它们代表已经发生的事情。",
        },
        {
            id: "w8-2-q4",
            question: "领域事件与集成事件的主要区别是什么？",
            options: [
                "没有区别",
                "领域事件在进程内同一领域，集成事件跨微服务/系统",
                "集成事件更重要",
                "领域事件更复杂",
            ],
            answer: 1,
            rationale: "领域事件在进程内、同一领域；集成事件跨微服务/系统，通常是异步的。",
        },
        {
            id: "w8-2-q5",
            question: "事件应该捕获哪些时间维度？",
            options: [
                "只有创建时间",
                "事情实际发生的时间和系统注意到的时间",
                "只有处理时间",
                "不需要时间信息",
            ],
            answer: 1,
            rationale: "事件应捕获两个时间点：事情实际发生的时间 vs 系统注意到的时间。",
        },
        {
            id: "w8-2-q6",
            question: "事件中的源数据有什么特点？",
            options: [
                "可变的",
                "不可变的，关于发生了什么的信息",
                "可选的",
                "只用于日志",
            ],
            answer: 1,
            rationale: "源数据是不可变的，包含关于事情发生的信息（如收费金额、供应商）。",
        },
        {
            id: "w8-2-q7",
            question: "如何处理对已发生事件的修正？",
            options: [
                "直接修改原事件",
                "通过单独的追溯事件处理",
                "删除原事件",
                "忽略修正",
            ],
            answer: 1,
            rationale: "变更应通过单独的追溯事件处理，而非修改源数据。",
        },
        {
            id: "w8-2-q8",
            question: "领域事件使副作用如何体现？",
            options: [
                "隐式耦合",
                "显式化，而非隐式耦合到代码中",
                "自动处理",
                "忽略副作用",
            ],
            answer: 1,
            rationale: "领域事件使副作用显式化而非隐式耦合到代码中，提高关注点分离。",
        },
        {
            id: "w8-2-q9",
            question: "领域事件在 DDD 中的统一语言作用是什么？",
            options: [
                "没有作用",
                "事件名称体现领域语言，促进业务沟通",
                "只用于技术文档",
                "替代文档",
            ],
            answer: 1,
            rationale: "领域事件使用领域语言命名，促进 DDD 的统一语言建设和业务沟通。",
        },
        {
            id: "w8-2-q10",
            question: "事件结构设计的原则是什么？",
            options: [
                "包含所有可能的数据",
                "包含足够的信息让订阅者处理，但不包含过多不相关数据",
                "只包含 ID",
                "不包含任何数据",
            ],
            answer: 1,
            rationale: "事件应包含足够的信息让订阅者处理，但不应包含过多不相关的数据。",
        },
        {
            id: "w8-2-q11",
            question: "领域事件支持什么架构风格？",
            options: [
                "只支持单体",
                "支持 pipes and filters 风格，便于架构演进",
                "只支持微服务",
                "只支持同步调用",
            ],
            answer: 1,
            rationale: "领域事件支持'pipes and filters'架构风格，便于系统替换和架构演进。",
        },
        {
            id: "w8-2-q12",
            question: "领域事件为事件溯源提供什么基础？",
            options: [
                "没有关系",
                "完整的审计跟踪，支持状态重建",
                "只用于日志",
                "只用于调试",
            ],
            answer: 1,
            rationale: "领域事件提供完整的审计跟踪，是事件溯源模式的基础，支持状态重建。",
        },
    ],
    "w8-3": [
        {
            id: "w8-3-q1",
            question: "为什么使用延迟发布而非立即调度事件？",
            options: [
                "性能更好",
                "可以在适当时机（如事务提交时）统一发布，保证一致性",
                "代码更简单",
                "不需要延迟",
            ],
            answer: 1,
            rationale: "延迟发布允许在适当时机（如事务提交前/后）统一发布事件，保证一致性。",
        },
        {
            id: "w8-3-q2",
            question: "Microsoft 的 eShop 示例推荐在什么时机发布事件？",
            options: [
                "事件创建时立即发布",
                "事务提交前发布（单事务方式）",
                "事务提交后发布",
                "手动触发",
            ],
            answer: 1,
            rationale: "Microsoft 推荐的 eShop 方式：事务提交前发布，所有变更一起回滚或提交。",
        },
        {
            id: "w8-3-q3",
            question: "单事务方式发布事件有什么优缺点？",
            options: [
                "更复杂但更灵活",
                "更简单但锁更多，所有变更一起回滚或提交",
                "性能更好",
                "不支持回滚",
            ],
            answer: 1,
            rationale: "单事务方式更简单，所有变更一起回滚或提交，但数据库锁更多。",
        },
        {
            id: "w8-3-q4",
            question: "事件处理器应该放在哪一层？",
            options: [
                "领域层",
                "应用层",
                "基础设施层",
                "表现层",
            ],
            answer: 1,
            rationale: "事件处理器应该在应用层，而非领域层，协调领域操作和外部集成。",
        },
        {
            id: "w8-3-q5",
            question: "使用中介者模式（如 MediatR）有什么好处？",
            options: [
                "代码更多",
                "解耦事件与处理器，实现开放/封闭原则",
                "性能更好",
                "减少类数量",
            ],
            answer: 1,
            rationale: "使用中介者解耦事件与处理器，实现开放/封闭原则，可以添加新处理器而不修改现有代码。",
        },
        {
            id: "w8-3-q6",
            question: "如何在聚合中管理领域事件？",
            options: [
                "直接发布",
                "添加到聚合的事件集合中，由基础设施统一调度",
                "存储到数据库",
                "发送到消息队列",
            ],
            answer: 1,
            rationale: "在聚合基类中添加领域事件集合，通过 AddDomainEvent() 方法添加，由基础设施统一调度。",
        },
        {
            id: "w8-3-q7",
            question: "最终一致性方式发布事件有什么优缺点？",
            options: [
                "更简单但不可靠",
                "更可扩展、锁更少，但需要补偿机制处理失败",
                "不支持分布式",
                "性能更差",
            ],
            answer: 1,
            rationale: "最终一致性更可扩展、锁更少，但需要补偿机制处理失败，实现更复杂。",
        },
        {
            id: "w8-3-q8",
            question: "如何保证事件不丢失？",
            options: [
                "依赖内存",
                "使用 Transactional Outbox 模式或可靠消息机制",
                "多次发送",
                "不需要保证",
            ],
            answer: 1,
            rationale: "使用 Transactional Outbox 模式，将事件与业务数据在同一事务中写入数据库，确保不丢失。",
        },
        {
            id: "w8-3-q9",
            question: "领域事件可以触发什么？",
            options: [
                "只能触发日志",
                "可以触发集成事件用于跨微服务通信",
                "只能触发数据库操作",
                "不能触发其他事件",
            ],
            answer: 1,
            rationale: "领域事件可以触发集成事件，用于跨微服务通信。",
        },
        {
            id: "w8-3-q10",
            question: "事件处理器如何实现解耦增长？",
            options: [
                "修改现有代码",
                "添加新处理器而不修改现有代码",
                "删除旧处理器",
                "合并处理器",
            ],
            answer: 1,
            rationale: "通过中介者模式，可以添加新处理器而不修改现有代码，实现开放/封闭原则。",
        },
        {
            id: "w8-3-q11",
            question: "在 DbContext.SaveChanges 中应该做什么？",
            options: [
                "只保存数据",
                "调度领域事件，然后保存数据",
                "只调度事件",
                "什么都不做",
            ],
            answer: 1,
            rationale: "在 SaveChanges 中调度领域事件（DispatchDomainEventsAsync），然后保存数据。",
        },
        {
            id: "w8-3-q12",
            question: "Saga 模式在事件系统中的作用是什么？",
            options: [
                "替代事件",
                "编排跨聚合/服务的长事务，通过事件协调",
                "只用于日志",
                "优化性能",
            ],
            answer: 1,
            rationale: "Saga 模式用于编排跨聚合/服务的长事务，通过事件协调各步骤。",
        },
    ],
    "w8-4": [
        {
            id: "w8-4-q1",
            question: "事件驱动集成的核心特点是什么？",
            options: [
                "同步调用",
                "系统广播变更而不期望直接响应，实现松耦合",
                "紧耦合",
                "请求/响应模式",
            ],
            answer: 1,
            rationale: "事件驱动集成通过事件通知实现系统间的松耦合，系统广播变更而不期望直接响应。",
        },
        {
            id: "w8-4-q2",
            question: "Transactional Outbox 模式解决什么问题？",
            options: [
                "性能问题",
                "数据库更新和消息发送的原子性问题",
                "安全问题",
                "缓存问题",
            ],
            answer: 1,
            rationale: "Outbox 模式解决同时更新数据库和发送消息的原子性问题，消除对 2PC 的依赖。",
        },
        {
            id: "w8-4-q3",
            question: "Transactional Outbox 的实现方式是什么？",
            options: [
                "直接发送消息",
                "在同一事务中将消息写入 Outbox 表，由单独进程发布",
                "使用分布式事务",
                "依赖消息队列事务",
            ],
            answer: 1,
            rationale: "'write the message/event to a database OUTBOX table as part of the transaction'，由消息中继进程发布。",
        },
        {
            id: "w8-4-q4",
            question: "消费者如何处理重复消息？",
            options: [
                "忽略重复",
                "通过幂等处理确保多次处理结果相同",
                "报错",
                "丢弃消息",
            ],
            answer: 1,
            rationale: "消息中继可能多次发布，消费者必须通过幂等处理处理重复消息。",
        },
        {
            id: "w8-4-q5",
            question: "Event-Carried State Transfer 模式的特点是什么？",
            options: [
                "只传递事件 ID",
                "事件传输完整状态数据，允许接收方维护本地副本",
                "不传递任何数据",
                "只用于同步",
            ],
            answer: 1,
            rationale: "Event-Carried State Transfer 事件传输完整状态数据，允许接收方维护本地副本，减少延迟。",
        },
        {
            id: "w8-4-q6",
            question: "事件驱动架构的风险是什么？",
            options: [
                "太简单",
                "业务逻辑可能变得隐式在事件链中，增加调试难度",
                "性能太好",
                "代码太少",
            ],
            answer: 1,
            rationale: "事件驱动的业务逻辑可能变得隐式在事件链中，增加调试和维护难度。",
        },
        {
            id: "w8-4-q7",
            question: "领域事件如何触发集成事件？",
            options: [
                "自动转换",
                "在领域事件处理器中创建并发布集成事件",
                "不能触发",
                "通过数据库触发器",
            ],
            answer: 1,
            rationale: "在领域事件处理器中可以创建并发布集成事件，用于跨服务通信。",
        },
        {
            id: "w8-4-q8",
            question: "Outbox 模式保证了什么？",
            options: [
                "消息立即送达",
                "只有数据库事务成功时才发送消息",
                "消息永不丢失",
                "消息顺序",
            ],
            answer: 1,
            rationale: "Outbox 模式保证只有数据库事务成功时才发送消息，消除不一致性。",
        },
        {
            id: "w8-4-q9",
            question: "Martin Fowler 对 CQRS 的态度是什么？",
            options: [
                "总是推荐使用",
                "同事们'deeply wary of using CQRS'，经常被误用",
                "从不推荐",
                "只用于简单系统",
            ],
            answer: 1,
            rationale: "Fowler 指出同事们'deeply wary of using CQRS, finding it often misused'——CQRS 经常被误用。",
        },
        {
            id: "w8-4-q10",
            question: "最终一致性窗口意味着什么？",
            options: [
                "永远一致",
                "存在短暂的不一致期，业务需要能接受",
                "永远不一致",
                "只有技术影响",
            ],
            answer: 1,
            rationale: "事件驱动意味着存在不一致的时间窗口，业务需要能接受这种暂时的不一致。",
        },
        {
            id: "w8-4-q11",
            question: "消息中继（Message Relay）的职责是什么？",
            options: [
                "写入数据库",
                "从 Outbox 表读取消息并发布到消息代理",
                "处理消息",
                "验证消息",
            ],
            answer: 1,
            rationale: "消息中继是单独的进程，从 Outbox 表检索待发送消息并发布到消息代理。",
        },
        {
            id: "w8-4-q12",
            question: "Event Sourcing 的核心思想是什么？",
            options: [
                "只存储当前状态",
                "记录每个状态变更为事件，事件日志成为单一事实来源",
                "删除历史数据",
                "只存储最新事件",
            ],
            answer: 1,
            rationale: "Event Sourcing：'whenever we make a change to the state, we record that state change as an event'，事件日志成为单一事实来源。",
        },
    ],
}
