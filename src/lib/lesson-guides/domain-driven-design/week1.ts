import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week1Guides: Record<string, LessonGuide> = {
    "w1-1": {
        lessonId: "w1-1",
        background: [
            "【核心定义】Martin Fowler：'Domain-Driven Design is an approach to software development that centers the development on programming a domain model that has a rich understanding of the processes and rules of a domain'——DDD 是一种以领域模型为中心的软件开发方法。",
            "【历史背景】DDD 源自 Eric Evans 2003 年的经典著作《Domain-Driven Design: Tackling Complexity in the Heart of Software》，旨在解决复杂业务系统的设计问题。",
            "【三种基础对象】Evans 定义了三种核心对象类型：实体（Entities）具有唯一标识、值对象（Value Objects）由属性定义、服务对象（Service Objects）封装领域逻辑。",
            "【战略设计创新】DDD 最具创新性的贡献是限界上下文（Bounded Contexts）的概念，用于组织复杂领域，将大系统划分为多个有边界的模型区域。",
            "【通用语言】Ubiquitous Language 是 DDD 的基石，强调建立一套嵌入软件系统中的共同术语体系，确保开发团队与领域专家使用相同的语言。",
        ],
        keyDifficulties: [
            "【常见误解】DDD 不仅仅是一套设计模式，更是一种思维方式——将业务领域知识置于软件设计的核心位置。",
            "【适用边界】DDD 'particularly suited to complex domains, where a lot of often-messy logic needs to be organized'——适合逻辑复杂、需要精心组织的领域，简单 CRUD 应用不需要 DDD。",
            "【语言一致性】代码中的命名必须反映领域术语，而非技术术语。统一语言是演进的，随着对领域理解的深入会不断精化。",
            "【模型演进】领域模型需在软件开发过程中不断演进，而非仅作纸面设计。模型应该能够准确反映业务规则和流程。",
        ],
        handsOnPath: [
            "阅读 Martin Fowler 的 DDD 博客文章，理解 DDD 的核心定义和价值主张",
            "识别一个你熟悉的业务领域，尝试列出其中的核心概念和业务规则",
            "与业务专家（或假想的业务专家）讨论，建立该领域的初始术语表",
            "尝试用代码表达这些领域概念，注意使用业务术语而非技术术语命名",
            "反思：你的代码是否能被业务专家理解？如果不能，哪里需要改进？",
        ],
        selfCheck: [
            "什么是领域驱动设计？它与传统的数据驱动设计有什么区别？",
            "DDD 中的三种基础对象类型是什么？各自的特点是什么？",
            "什么是通用语言（Ubiquitous Language）？为什么它如此重要？",
            "限界上下文（Bounded Context）解决了什么问题？",
            "DDD 适合什么样的项目？什么样的项目不需要 DDD？",
            "为什么说 DDD 不仅仅是设计模式，更是一种思维方式？",
        ],
        extensions: [
            "阅读 Eric Evans 的《Domain-Driven Design》蓝皮书第一部分",
            "了解 DDD 与面向对象设计原则（SOLID）的关系",
            "探索 DDD 在微服务架构中的应用",
            "研究 DDD 社区的最新发展和实践经验",
        ],
        sourceUrls: [
            "https://martinfowler.com/bliki/DomainDrivenDesign.html",
            "https://www.infoq.com/articles/ddd-in-practice/",
        ],
    },
    "w1-2": {
        lessonId: "w1-2",
        background: [
            "【本质复杂性】Fred Brooks：'Essential complexity is caused by the problem to be solved, and nothing can remove it'——本质复杂性源于问题本身，无法消除，只能管理。",
            "【偶然复杂性】'Accidental complexity relates to problems that engineers create and can fix'——偶然复杂性是开发者自己引入的，可以通过更好的工具和方法消除。",
            "【四大固有困难】Brooks 识别了软件的四个本质困难：复杂性（Complexity）、一致性（Conformity）、可变性（Changeability）、不可见性（Invisibility）。",
            "【复杂性非线性增长】'The complexity of the whole increases much more than linearly with scale'——软件系统的复杂性随规模增长而呈非线性增长。",
            "【DDD 的应对】DDD 通过领域建模、限界上下文、通用语言等手段，帮助团队管理本质复杂性，同时减少偶然复杂性。",
        ],
        keyDifficulties: [
            "【没有银弹】Brooks 论证：'There is no single development, in either technology or management technique, which by itself promises even one order of magnitude improvement'——没有单一技术能带来数量级的提升。",
            "【复杂性不可抽象】'Descriptions of a software entity that abstract away its complexity often abstract away its essence'——抽象掉复杂性往往也抽象掉了本质。",
            "【外部约束】软件必须适应任意的外部系统和制度，面对'arbitrary complexity, forced without rhyme or reason'——无理由的任意复杂性。",
            "【持续变化】软件存在于不断变化的文化环境中——应用、用户、法律、硬件都在持续演变，迫使系统不断修改。",
        ],
        handsOnPath: [
            "分析一个你参与过的项目，识别其中的本质复杂性和偶然复杂性",
            "列出项目中因设计选择引入的偶然复杂性，思考如何消除",
            "识别项目中不可避免的本质复杂性，思考如何通过 DDD 更好地管理",
            "绘制领域概念图，尝试将复杂业务逻辑可视化",
            "评估当前代码是否准确反映了业务领域，还是充满了技术偶然复杂性",
        ],
        selfCheck: [
            "什么是本质复杂性？什么是偶然复杂性？两者的区别是什么？",
            "Brooks 提出的软件四大固有困难是什么？",
            "为什么 Brooks 说'没有银弹'？这对我们的启示是什么？",
            "DDD 如何帮助管理软件的本质复杂性？",
            "为什么说'抽象掉复杂性往往也抽象掉了本质'？",
            "如何识别项目中的偶然复杂性并消除它？",
        ],
        extensions: [
            "阅读 Fred Brooks 的原文《No Silver Bullet》",
            "了解 Tesler's Law（复杂性守恒定律）",
            "研究 Amdahl's Law 与软件复杂性的关系",
            "探索不同编程范式如何应对复杂性",
        ],
        sourceUrls: [
            "https://blog.acolyer.org/2016/09/06/no-silver-bullet-essence-and-accident-in-software-engineering/",
            "https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215",
        ],
    },
    "w1-3": {
        lessonId: "w1-3",
        background: [
            "【适用场景】DDD 适合：复杂业务逻辑的系统、需要与领域专家紧密协作的项目、长期演进和维护的系统。",
            "【不适用场景】简单 CRUD 应用、技术驱动而非业务驱动的系统、一次性项目不需要 DDD 的全部概念。",
            "【团队条件】成功实施 DDD 需要：能接触到领域专家、团队愿意学习领域知识、组织支持迭代式开发。",
            "【八步建模流程】DDD Starter Modelling Process 提供了结构化方法：Understand → Discover → Decompose → Strategize → Connect → Organise → Define → Code。",
            "【非线性过程】'This linear process is not realistic...it's just a starting point to reduce cognitive load'——实际过程是非线性的，需要不断迭代。",
        ],
        keyDifficulties: [
            "【过度设计风险】对简单问题使用复杂的 DDD 模式会增加不必要的复杂性，需要判断问题是否真的需要 DDD。",
            "【领域专家参与】没有领域专家的参与，DDD 很难成功。团队需要建立与业务的沟通渠道。",
            "【渐进式采用】不需要一次性应用所有 DDD 概念，可以从核心域开始逐步推广。",
            "【组织文化】DDD 需要组织支持跨职能协作、迭代开发和持续学习的文化。",
        ],
        handsOnPath: [
            "评估你当前的项目是否适合使用 DDD：业务复杂度、团队条件、组织支持",
            "使用 DDD Starter Modelling Process 的八个步骤分析一个业务场景",
            "识别项目中的核心域——哪些功能是业务的核心竞争力？",
            "尝试组织一次与业务专家的沟通会议，讨论领域概念",
            "制定一个渐进式采用 DDD 的计划，从核心域开始",
        ],
        selfCheck: [
            "DDD 适合什么样的项目？什么样的项目不适合？",
            "成功实施 DDD 需要哪些团队和组织条件？",
            "DDD Starter Modelling Process 的八个步骤是什么？",
            "为什么说 DDD 的实施过程是非线性的？",
            "如何判断一个项目是否过度设计？",
            "渐进式采用 DDD 的策略是什么？",
        ],
        extensions: [
            "学习 Business Model Canvas 和 Impact Mapping 工具",
            "了解团队拓扑（Team Topologies）与 DDD 的关系",
            "研究 Conway's Law 对系统设计的影响",
            "探索敏捷方法与 DDD 的结合实践",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd",
            "https://github.com/ddd-crew/ddd-starter-modelling-process",
        ],
    },
    "w1-4": {
        lessonId: "w1-4",
        background: [
            "【战略设计定义】战略设计关注高层概念：定义限界上下文（Bounded Contexts）、上下文映射（Context Mapping）、识别子域（Subdomains）。",
            "【战术设计定义】战术设计关注实现细节：'Tactical DDD is when you define your domain models with more precision'——在单个限界上下文内使用实体、值对象、聚合等模式。",
            "【两者关系】战略设计先于战术设计：先划分上下文边界，再在边界内进行详细建模。'Tactical patterns are applied within a single bounded context'。",
            "【微服务边界】'As a general principle, a microservice should be no smaller than an aggregate and no larger than a bounded context'——微服务的边界应介于聚合和限界上下文之间。",
            "【战略设计的重要性】'One experienced project became increasingly difficult to iterate due to lack of model boundaries'——忽视战略设计会导致系统难以演进。",
        ],
        keyDifficulties: [
            "【常见错误】只关注战术模式而忽视战略设计，导致系统缺乏清晰的边界。",
            "【边界划分】限界上下文的边界通常由组织文化决定——当语言改变时，模型也应改变。",
            "【上下文映射】不同上下文之间需要通过映射机制协调，处理多义概念（如'客户'在不同上下文的含义）。",
            "【持续演进】战略设计不是一次性的，需要随着业务理解的深入不断调整。",
        ],
        handsOnPath: [
            "绘制当前系统的上下文映射图，识别现有的限界上下文",
            "分析各个上下文之间的关系：共享内核、客户-供应商、防腐层等",
            "识别系统中的核心域、支撑域和通用域",
            "为核心域设计详细的战术模型：实体、值对象、聚合",
            "评估当前的微服务边界是否与限界上下文对齐",
        ],
        selfCheck: [
            "战略设计和战术设计分别关注什么？",
            "为什么战略设计应该先于战术设计？",
            "限界上下文与微服务的关系是什么？",
            "什么是上下文映射？它解决什么问题？",
            "如何识别和划分限界上下文的边界？",
            "忽视战略设计会带来什么问题？",
        ],
        extensions: [
            "深入学习上下文映射的各种模式",
            "了解 Wardley Mapping 在战略分析中的应用",
            "研究微服务架构与 DDD 的深度结合",
            "探索事件风暴（Event Storming）作为发现限界上下文的工具",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/azure/architecture/microservices/model/domain-analysis",
            "https://github.com/ddd-crew/free-ddd-learning-resources",
            "https://martinfowler.com/bliki/BoundedContext.html",
        ],
    },
}

export const week1Quizzes: Record<string, QuizQuestion[]> = {
    "w1-1": [
        {
            id: "w1-1-q1",
            question: "根据 Martin Fowler 的定义，DDD 的核心是什么？",
            options: [
                "以数据库设计为中心的开发方法",
                "以领域模型为中心的开发方法，深入理解领域的流程和规则",
                "以技术架构为中心的开发方法",
                "以用户界面为中心的开发方法",
            ],
            answer: 1,
            rationale: "Martin Fowler 明确指出：'Domain-Driven Design is an approach to software development that centers the development on programming a domain model that has a rich understanding of the processes and rules of a domain'。",
        },
        {
            id: "w1-1-q2",
            question: "Eric Evans 在 DDD 中定义的三种基础对象类型是什么？",
            options: [
                "Controller, Service, Repository",
                "Model, View, Controller",
                "Entity, Value Object, Service Object",
                "Domain, Application, Infrastructure",
            ],
            answer: 2,
            rationale: "Evans 引入了三种基础对象类型：Entities（实体）、Value Objects（值对象）和 Service Objects（服务对象），以及 Aggregates（聚合）的概念。",
        },
        {
            id: "w1-1-q3",
            question: "什么是 DDD 中的通用语言（Ubiquitous Language）？",
            options: [
                "一种编程语言",
                "一种嵌入软件系统中的共同术语体系，反映领域专业知识",
                "一种文档格式",
                "一种测试方法",
            ],
            answer: 1,
            rationale: "DDD 强调建立一套嵌入软件系统中的共同术语体系，反映领域专业知识。这些模型需在软件开发过程中不断演进。",
        },
        {
            id: "w1-1-q4",
            question: "根据文档，DDD 最适合什么类型的项目？",
            options: [
                "简单的 CRUD 应用",
                "一次性的脚本项目",
                "复杂领域，需要精心组织大量复杂逻辑的系统",
                "纯技术驱动的工具类项目",
            ],
            answer: 2,
            rationale: "文档指出 DDD 'particularly suited to complex domains, where a lot of often-messy logic needs to be organized'——适合逻辑复杂、需要精心组织的领域。",
        },
        {
            id: "w1-1-q5",
            question: "DDD 中限界上下文（Bounded Context）的主要作用是什么？",
            options: [
                "定义数据库边界",
                "组织复杂领域，划分模型的语义边界",
                "限制代码行数",
                "定义 API 接口",
            ],
            answer: 1,
            rationale: "限界上下文是 DDD 最具创新性的贡献，用于组织复杂领域，通过边界清晰地分离关注点。",
        },
        {
            id: "w1-1-q6",
            question: "DDD 实践中，领域模型应该如何演进？",
            options: [
                "一次性设计完成，不再修改",
                "只在文档中维护，代码另行设计",
                "在软件开发过程中不断演进，而非仅作纸面设计",
                "由外部顾问定期更新",
            ],
            answer: 2,
            rationale: "文档强调领域模型需在软件开发过程中不断演进，而非仅作纸面设计。",
        },
        {
            id: "w1-1-q7",
            question: "在 DDD 实践中，代码命名应该遵循什么原则？",
            options: [
                "使用技术术语，如 Manager、Helper、Util",
                "使用领域术语，反映业务概念",
                "使用缩写以节省代码长度",
                "使用英文和中文混合命名",
            ],
            answer: 1,
            rationale: "DDD 强调代码中的命名必须反映领域术语，而非技术术语，这是通用语言的核心要求。",
        },
        {
            id: "w1-1-q8",
            question: "关于 DDD 的适用范围，以下哪个说法是正确的？",
            options: [
                "DDD 只能用于面向对象语言",
                "虽然源于面向对象背景，但其核心概念适用于任何编程范式",
                "DDD 只能用于 Java 和 C#",
                "DDD 只能用于微服务架构",
            ],
            answer: 1,
            rationale: "Martin Fowler 指出，虽然 DDD 源于面向对象背景，但其核心概念适用于任何编程范式。",
        },
        {
            id: "w1-1-q9",
            question: "实现有效 DDD 的三个关键支柱包括什么？",
            options: [
                "数据库、缓存、消息队列",
                "面向对象编程、依赖注入、面向切面编程",
                "前端、后端、数据库",
                "测试、部署、监控",
            ],
            answer: 1,
            rationale: "文档指出三个支柱支撑有效的 DDD 实现：面向对象编程（OOP）、依赖注入（DI）、面向切面编程（AOP）。",
        },
        {
            id: "w1-1-q10",
            question: "DDD 项目生命周期的正确顺序是什么？",
            options: [
                "开发 → 设计 → 测试 → 建模",
                "建模 → 设计 → 开发 → 测试 → 迭代",
                "测试 → 建模 → 开发 → 设计",
                "设计 → 测试 → 建模 → 开发",
            ],
            answer: 1,
            rationale: "DDD 项目生命周期包括：Model the domain → Design → Develop → Test and refactor → Iterate。",
        },
        {
            id: "w1-1-q11",
            question: "关于领域模型，以下哪个说法是正确的？",
            options: [
                "领域模型应该依赖框架实现",
                "领域模型应该保持独立，不依赖框架和基础设施",
                "领域模型必须与数据库表一一对应",
                "领域模型只是数据容器",
            ],
            answer: 1,
            rationale: "文档强调富领域模型应该'be designed using POJOs without framework dependencies'，保持独立于框架和基础设施。",
        },
        {
            id: "w1-1-q12",
            question: "DDD 填补了面向对象编程中的什么空白？",
            options: [
                "数据存储方面的空白",
                "用户界面设计方面的空白",
                "大规模系统组织方面的空白",
                "性能优化方面的空白",
            ],
            answer: 2,
            rationale: "Martin Fowler 指出 DDD 的价值在于填补了面向对象编程中的重要空白，特别是在大规模系统组织方面。",
        },
    ],
    "w1-2": [
        {
            id: "w1-2-q1",
            question: "根据 Fred Brooks 的定义，什么是本质复杂性（Essential Complexity）？",
            options: [
                "由开发者引入的可以修复的复杂性",
                "由问题本身引起的、无法消除的复杂性",
                "由技术选型引入的复杂性",
                "由团队协作引入的复杂性",
            ],
            answer: 1,
            rationale: "Brooks 定义：'Essential complexity is caused by the problem to be solved, and nothing can remove it'——本质复杂性源于问题本身，无法消除。",
        },
        {
            id: "w1-2-q2",
            question: "什么是偶然复杂性（Accidental Complexity）？",
            options: [
                "软件固有的不可避免的复杂性",
                "由业务需求引入的复杂性",
                "由工程师引入的、可以修复的复杂性",
                "由用户需求变化引入的复杂性",
            ],
            answer: 2,
            rationale: "Brooks 指出：'Accidental complexity relates to problems that engineers create and can fix'——偶然复杂性是开发者自己引入的，可以修复。",
        },
        {
            id: "w1-2-q3",
            question: "Brooks 识别的软件四大固有困难不包括以下哪项？",
            options: [
                "复杂性（Complexity）",
                "可扩展性（Scalability）",
                "可变性（Changeability）",
                "不可见性（Invisibility）",
            ],
            answer: 1,
            rationale: "Brooks 识别的四大固有困难是：Complexity（复杂性）、Conformity（一致性）、Changeability（可变性）、Invisibility（不可见性）。Scalability 不在其中。",
        },
        {
            id: "w1-2-q4",
            question: "Brooks 关于'没有银弹'的核心论点是什么？",
            options: [
                "软件开发不需要管理技术",
                "没有单一技术或管理方法能带来数量级的生产力提升",
                "所有软件项目都会失败",
                "技术进步对软件开发没有帮助",
            ],
            answer: 1,
            rationale: "Brooks 论证：'There is no single development, in either technology or management technique, which by itself promises even one order of magnitude improvement'。",
        },
        {
            id: "w1-2-q5",
            question: "关于软件复杂性的增长，Brooks 指出了什么规律？",
            options: [
                "复杂性随规模线性增长",
                "复杂性随规模对数增长",
                "复杂性随规模呈非线性增长，增长速度远超规模本身",
                "复杂性与规模无关",
            ],
            answer: 2,
            rationale: "Brooks 指出：'The complexity of the whole increases much more than linearly with scale'——复杂性随规模非线性增长。",
        },
        {
            id: "w1-2-q6",
            question: "为什么 Brooks 说软件是'不可见的'（Invisible）？",
            options: [
                "因为软件代码太小看不见",
                "因为软件缺乏固有的空间表示，无法像建筑或机械部件那样可视化",
                "因为软件存储在云端",
                "因为软件运行在后台",
            ],
            answer: 1,
            rationale: "Brooks 指出软件'is invisible and unvisualizable'，由多个叠加的有向图组成，缺乏像建筑或机械部件那样的空间表示。",
        },
        {
            id: "w1-2-q7",
            question: "根据 Brooks，高级语言对软件生产力的主要贡献是什么？",
            options: [
                "提高了代码执行速度",
                "减少了服务器成本",
                "消除了大量偶然复杂性",
                "增加了本质复杂性",
            ],
            answer: 2,
            rationale: "Brooks 指出高级语言'frees a program from much of its accidental complexity'——消除了大量偶然复杂性，是软件生产力最强大的提升。",
        },
        {
            id: "w1-2-q8",
            question: "软件的'一致性'（Conformity）困难指的是什么？",
            options: [
                "代码风格需要保持一致",
                "软件必须适应任意的外部系统和制度约束",
                "数据库表结构需要一致",
                "API 接口需要一致",
            ],
            answer: 1,
            rationale: "Conformity 指软件必须适应任意的外部系统和制度，面对'arbitrary complexity, forced without rhyme or reason'——无理由的任意复杂性。",
        },
        {
            id: "w1-2-q9",
            question: "根据 Brooks 的分析，当今程序员主要花时间在处理什么类型的复杂性？",
            options: [
                "主要处理偶然复杂性",
                "主要处理本质复杂性",
                "两者平均分配",
                "完全没有复杂性",
            ],
            answer: 1,
            rationale: "Brooks 指出偶然复杂性已大幅减少，今天的程序员主要花时间处理本质复杂性。",
        },
        {
            id: "w1-2-q10",
            question: "为什么 Brooks 说'抽象掉复杂性往往也抽象掉了本质'？",
            options: [
                "因为抽象会增加代码量",
                "因为软件的复杂性是本质属性，过度简化会失去系统的核心功能",
                "因为抽象会降低性能",
                "因为抽象需要更多的内存",
            ],
            answer: 1,
            rationale: "Brooks 指出'The complexity of software is an essential property...descriptions of a software entity that abstract away its complexity often abstract away its essence'。",
        },
        {
            id: "w1-2-q11",
            question: "DDD 如何帮助管理软件的本质复杂性？",
            options: [
                "通过消除所有复杂性",
                "通过领域建模、限界上下文、通用语言等手段建立更清晰的概念结构",
                "通过使用更多的设计模式",
                "通过增加更多的抽象层",
            ],
            answer: 1,
            rationale: "DDD 通过通用语言、限界上下文、领域建模等手段，帮助团队管理本质复杂性，建立更清晰的概念结构。",
        },
        {
            id: "w1-2-q12",
            question: "Brooks 使用 Amdahl 定律论证了什么？",
            options: [
                "软件开发速度可以无限提升",
                "由于至少一半的复杂性是本质的，所有技术创新最多只能带来 2 倍的改进",
                "硬件性能是软件瓶颈",
                "团队规模与效率成正比",
            ],
            answer: 1,
            rationale: "Brooks 使用 Amdahl 定律论证：如果至少一半的复杂性是本质的，那么所有技术创新加起来最多只能带来 2 倍的改进。",
        },
    ],
    "w1-3": [
        {
            id: "w1-3-q1",
            question: "DDD Starter Modelling Process 的第一步是什么？",
            options: [
                "编写代码",
                "理解业务模型、用户需求和组织目标",
                "设计数据库",
                "部署应用",
            ],
            answer: 1,
            rationale: "DDD Starter Modelling Process 第一步是 Understand——'Align with business model, user needs, and organizational goals'。",
        },
        {
            id: "w1-3-q2",
            question: "DDD Starter Modelling Process 的八个步骤中，'Discover' 阶段主要使用什么技术？",
            options: [
                "代码审查和单元测试",
                "EventStorming、Domain Storytelling、User Journey Mapping",
                "数据库设计和 SQL 优化",
                "性能测试和压力测试",
            ],
            answer: 1,
            rationale: "Discover 阶段通过 EventStorming、Domain Storytelling、User Journey Mapping 等技术'visually and collaboratively'发现领域知识。",
        },
        {
            id: "w1-3-q3",
            question: "为什么 DDD Starter Modelling Process 被描述为'非线性的'？",
            options: [
                "因为步骤可以随意跳过",
                "因为它只是起点，实际过程需要不断迭代和调整",
                "因为它不需要按顺序执行",
                "因为它只适用于小项目",
            ],
            answer: 1,
            rationale: "文档指出：'This linear process is not realistic...it's just a starting point to reduce cognitive load'——线性过程只是起点，实际需要不断迭代。",
        },
        {
            id: "w1-3-q4",
            question: "在 DDD Starter Modelling Process 中，'Strategize' 阶段的目标是什么？",
            options: [
                "编写代码",
                "识别对业务影响最大的核心域，指导资源分配",
                "设计用户界面",
                "优化数据库性能",
            ],
            answer: 1,
            rationale: "Strategize 阶段使用 Core Domain Charts 和 Wardley Mapping'identify core domains with greatest business impact'来指导资源分配。",
        },
        {
            id: "w1-3-q5",
            question: "以下哪个不是 DDD 成功实施的前提条件？",
            options: [
                "能接触到领域专家",
                "团队愿意学习领域知识",
                "所有团队成员必须是 DDD 专家",
                "组织支持迭代式开发",
            ],
            answer: 2,
            rationale: "DDD 成功需要能接触领域专家、团队愿意学习、组织支持迭代开发，但不要求所有人都是 DDD 专家。",
        },
        {
            id: "w1-3-q6",
            question: "在 DDD Starter Modelling Process 中，'Define' 阶段使用什么工具？",
            options: [
                "代码编辑器",
                "Bounded Context Canvas",
                "数据库管理工具",
                "性能监控工具",
            ],
            answer: 1,
            rationale: "Define 阶段使用 Bounded Context Canvas'to make explicit design decisions'来明确设计决策。",
        },
        {
            id: "w1-3-q7",
            question: "关于 DDD 的渐进式采用，以下哪个说法是正确的？",
            options: [
                "必须一次性应用所有 DDD 概念",
                "只能应用于新项目",
                "可以从核心域开始逐步推广",
                "不能与现有系统共存",
            ],
            answer: 2,
            rationale: "DDD 可以渐进式采用，不需要一次性应用所有概念，可以从核心域开始逐步推广。",
        },
        {
            id: "w1-3-q8",
            question: "DDD Starter Modelling Process 中，'Decompose' 阶段的目的是什么？",
            options: [
                "分解代码文件",
                "将领域分解为松耦合的子域，降低认知负担",
                "分解团队成员",
                "分解数据库表",
            ],
            answer: 1,
            rationale: "Decompose 阶段使用 Business Capability Modelling 和 Context Maps'break the domain into loosely-coupled sub-domains'降低认知负担。",
        },
        {
            id: "w1-3-q9",
            question: "以下哪种项目类型最不适合使用完整的 DDD？",
            options: [
                "电商平台核心交易系统",
                "银行核心业务系统",
                "简单的内部工具 CRUD 应用",
                "保险理赔处理系统",
            ],
            answer: 2,
            rationale: "简单的 CRUD 应用不需要 DDD 的全部概念，DDD 适合复杂业务逻辑的系统。",
        },
        {
            id: "w1-3-q10",
            question: "DDD Starter Modelling Process 中，'Organise' 阶段考虑什么因素？",
            options: [
                "代码格式化规则",
                "团队拓扑和组织约束，使团队与上下文边界对齐",
                "文件命名规范",
                "版本控制策略",
            ],
            answer: 1,
            rationale: "Organise 阶段'structure autonomous teams aligned with context boundaries, considering Team Topologies and organizational constraints'。",
        },
        {
            id: "w1-3-q11",
            question: "为什么持续发现（Continuous Discovery）在 DDD 中很重要？",
            options: [
                "因为需要不断发现新的技术",
                "因为总有更多的领域知识需要挖掘",
                "因为需要发现更多的 Bug",
                "因为需要发现更多的用户",
            ],
            answer: 1,
            rationale: "DDD Starter Modelling Process 强调'there's always more domain knowledge to uncover'——总有更多的领域知识需要持续挖掘。",
        },
        {
            id: "w1-3-q12",
            question: "在判断是否使用 DDD 时，以下哪个因素最不重要？",
            options: [
                "业务逻辑的复杂程度",
                "是否能接触到领域专家",
                "使用的编程语言",
                "系统的长期演进需求",
            ],
            answer: 2,
            rationale: "编程语言不是决定是否使用 DDD 的关键因素，DDD 的核心概念适用于任何编程范式。关键是业务复杂度、领域专家参与和演进需求。",
        },
    ],
    "w1-4": [
        {
            id: "w1-4-q1",
            question: "战略设计（Strategic Design）主要关注什么？",
            options: [
                "具体的代码实现细节",
                "数据库表结构设计",
                "定义限界上下文、上下文映射和识别子域等高层概念",
                "用户界面设计",
            ],
            answer: 2,
            rationale: "战略设计关注高层概念：定义限界上下文（Bounded Contexts）、上下文映射（Context Mapping）、识别子域（Subdomains）。",
        },
        {
            id: "w1-4-q2",
            question: "战术设计（Tactical Design）在什么范围内应用？",
            options: [
                "整个系统范围",
                "单个限界上下文内",
                "所有微服务之间",
                "仅在数据库层",
            ],
            answer: 1,
            rationale: "文档明确指出：'Tactical patterns are applied within a single bounded context'——战术模式应用于单个限界上下文内。",
        },
        {
            id: "w1-4-q3",
            question: "关于微服务与限界上下文的关系，以下哪个说法是正确的？",
            options: [
                "微服务必须与限界上下文一一对应",
                "微服务应该不小于聚合，不大于限界上下文",
                "每个微服务必须包含多个限界上下文",
                "限界上下文与微服务无关",
            ],
            answer: 1,
            rationale: "文档指出：'As a general principle, a microservice should be no smaller than an aggregate and no larger than a bounded context'。",
        },
        {
            id: "w1-4-q4",
            question: "忽视战略设计会导致什么问题？",
            options: [
                "代码性能下降",
                "系统越来越难以迭代演进",
                "数据库变慢",
                "用户界面变丑",
            ],
            answer: 1,
            rationale: "文档引用案例：'One experienced project became increasingly difficult to iterate due to lack of model boundaries'——缺乏模型边界导致难以迭代。",
        },
        {
            id: "w1-4-q5",
            question: "限界上下文的边界通常由什么决定？",
            options: [
                "技术栈选择",
                "数据库类型",
                "组织文化和语言边界",
                "服务器配置",
            ],
            answer: 2,
            rationale: "Martin Fowler 强调限界上下文的边界通常由组织文化决定——当语言改变时，模型也应改变。",
        },
        {
            id: "w1-4-q6",
            question: "DDD 承认大型系统的域模型完全统一是什么情况？",
            options: [
                "完全可行且必要",
                "既不可行也不划算",
                "只需要足够的时间就可以实现",
                "只对小团队不可行",
            ],
            answer: 1,
            rationale: "DDD 承认'total unification of the domain model for a large system will not be feasible or cost-effective'——完全统一既不可行也不划算。",
        },
        {
            id: "w1-4-q7",
            question: "战略设计和战术设计的正确顺序是什么？",
            options: [
                "先战术后战略",
                "同时进行",
                "先战略后战术",
                "顺序不重要",
            ],
            answer: 2,
            rationale: "应该先进行战略设计划分上下文边界，再在边界内进行战术设计。'During the strategic phase of DDD, you map out the business domain and define bounded contexts'。",
        },
        {
            id: "w1-4-q8",
            question: "以下哪个不属于战术设计的模式？",
            options: [
                "实体（Entity）",
                "值对象（Value Object）",
                "上下文映射（Context Mapping）",
                "聚合（Aggregate）",
            ],
            answer: 2,
            rationale: "上下文映射是战略设计的概念，用于描述限界上下文之间的关系。实体、值对象、聚合都是战术设计模式。",
        },
        {
            id: "w1-4-q9",
            question: "限界上下文（Bounded Context）主要解决什么问题？",
            options: [
                "代码性能问题",
                "相同概念在不同场景产生歧义的问题",
                "数据存储问题",
                "网络延迟问题",
            ],
            answer: 1,
            rationale: "Martin Fowler 以电力公司为例说明，'meter'对不同部门含义截然不同，限界上下文通过划分边界解决概念歧义。",
        },
        {
            id: "w1-4-q10",
            question: "关于只使用战术模式而忽视战略设计，以下哪个说法是正确的？",
            options: [
                "这是正确的实践方式",
                "即使战术模式应用得再好，缺乏边界也会影响整体设计",
                "战术模式比战略设计更重要",
                "只要代码质量好就没问题",
            ],
            answer: 1,
            rationale: "文档警告：'Perhaps more importantly than the tactics, one can overlook the very critical strategic patterns, which can harm the rest of the design regardless of how well applied the tactical patterns are'。",
        },
        {
            id: "w1-4-q11",
            question: "上下文映射（Context Mapping）的目的是什么？",
            options: [
                "绘制地图",
                "协调不同限界上下文之间的关系，处理多义概念",
                "映射数据库表",
                "映射 URL 路由",
            ],
            answer: 1,
            rationale: "不同上下文之间需要通过映射机制协调，处理多义概念（如'客户'在不同上下文的含义不同）。",
        },
        {
            id: "w1-4-q12",
            question: "关于战略设计的持续性，以下哪个说法是正确的？",
            options: [
                "战略设计是一次性的，完成后不需要调整",
                "战略设计应该随着业务理解的深入不断调整",
                "战略设计只在项目开始时进行",
                "战略设计由专门的架构师负责，开发团队不需要参与",
            ],
            answer: 1,
            rationale: "战略设计不是一次性的，需要随着业务理解的深入不断调整，是持续的过程。",
        },
    ],
}
