import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week10Guides: Record<string, LessonGuide> = {
    "w10-1": {
        lessonId: "w10-1",
        background: [
            "【六边形架构定义】Alistair Cockburn 提出六边形架构的意图：'Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases'。",
            "【内外对称性】核心原则是区分应用内部（业务逻辑）与外部（用户界面、数据库等），'code pertaining to the inside part should not leak into the outside part'。",
            "【端口定义】端口（Port）是应用与外部实体之间的通信接口，其协议由对话目的定义，而非技术细节。",
            "【适配器定义】适配器将 API 定义转换为特定设备所需的信号，'For each external device there is an adapter that converts the API definition to the signals needed by that device'。",
            "【别名来源】又称'Ports and Adapters'架构，六边形只是可视化形状，强调多个平等的外部交互点。",
        ],
        keyDifficulties: [
            "【与分层架构的区别】分层架构有层级高低之分，六边形架构所有外部交互都是平等的'面'。",
            "【端口粒度】端口的粒度选择——太粗会混杂职责，太细会增加复杂度。",
            "【六边形并非六个】六边形只是示意图，实际端口数量由应用需求决定，可以是任意数量。",
            "【业务逻辑位置】业务逻辑必须在六边形内部，任何泄漏到适配器中都违反架构原则。",
        ],
        handsOnPath: [
            "识别应用的所有外部交互点（UI、数据库、第三方服务）",
            "将应用核心与外部依赖分离",
            "为每个外部交互定义端口接口",
            "实现具体的适配器",
            "使用依赖注入连接端口和适配器",
            "验证应用核心可以独立运行和测试",
        ],
        selfCheck: [
            "什么是六边形架构？它的核心目标是什么？",
            "端口和适配器分别是什么？它们的关系是什么？",
            "六边形架构与传统分层架构有什么区别？",
            "为什么六边形架构叫'六边形'？实际端口数量是多少？",
            "六边形架构如何支持测试隔离？",
        ],
        extensions: [
            "学习洋葱架构（Onion Architecture）与六边形的关系",
            "了解六边形架构在微服务中的应用",
            "研究六边形架构的依赖注入策略",
            "探索六边形架构与 DDD 的结合",
        ],
        sourceUrls: [
            "https://alistair.cockburn.us/hexagonal-architecture/",
            "https://herbertograca.com/2017/09/14/ports-adapters-architecture/",
        ],
    },
    "w10-2": {
        lessonId: "w10-2",
        background: [
            "【两类适配器】Primary (Driving) Adapters 发起对应用的操作；Secondary (Driven) Adapters 响应应用的请求。",
            "【驱动适配器】驱动适配器（左侧）包括 UI 组件、控制器、CLI 命令，它们将外部请求转换为应用用例调用。",
            "【被驱动适配器】被驱动适配器（右侧）包装外部工具如数据库、搜索引擎，实现应用核心定义的接口。",
            "【依赖方向差异】左侧：适配器依赖端口，都在应用边界内；右侧：端口在内部，具体实现包装外部工具在外部。",
            "【端口即接口】接口作为隔离机制，'interfaces serve as the isolating mechanism, keeping ephemeral technologies from corrupting domain logic'。",
        ],
        keyDifficulties: [
            "【依赖方向理解】理解驱动端口和被驱动端口的依赖方向差异是最大难点。",
            "【端口所有权】驱动端口由应用定义和拥有；被驱动端口也由应用定义，但由外部实现。",
            "【适配器职责】适配器只负责技术转换，不应包含业务逻辑。",
            "【多适配器场景】同一端口可以有多个适配器（如 REST 和 GraphQL 适配器共享用例端口）。",
        ],
        handsOnPath: [
            "识别应用中的驱动端口（入站操作）",
            "识别被驱动端口（出站依赖）",
            "定义驱动端口接口（用例边界）",
            "定义被驱动端口接口（仓储、网关）",
            "实现 REST 控制器作为驱动适配器",
            "实现数据库仓储作为被驱动适配器",
        ],
        selfCheck: [
            "驱动端口和被驱动端口有什么区别？",
            "驱动适配器和被驱动适配器的依赖方向有什么不同？",
            "端口接口应该由谁定义和拥有？",
            "一个端口可以有多个适配器吗？举例说明。",
            "适配器中应该包含业务逻辑吗？",
        ],
        extensions: [
            "学习 Primary Port 与 Use Case 的关系",
            "了解 Secondary Port 与 Repository 接口的关系",
            "研究 Anti-Corruption Layer 作为特殊适配器",
            "探索多适配器场景的依赖注入配置",
        ],
        sourceUrls: [
            "https://herbertograca.com/2017/09/14/ports-adapters-architecture/",
            "https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/",
        ],
    },
    "w10-3": {
        lessonId: "w10-3",
        background: [
            "【适配器类型】常见适配器包括：REST/GraphQL 控制器、消息消费者、数据库仓储、外部 API 客户端、消息发布者。",
            "【技术转换职责】适配器将应用核心的领域概念转换为具体技术协议，反之亦然。",
            "【可替换性】'Switching from Elasticsearch to Solr requires only creating a new adapter implementing the same interface'——适配器使技术替换变得简单。",
            "【应用核心不变】应用核心保持稳定，'the application core remains unchanged'，无论外部技术如何变化。",
            "【DTO 转换】适配器负责将外部数据格式（JSON、XML）转换为领域对象，以及反向转换。",
        ],
        keyDifficulties: [
            "【转换逻辑位置】数据转换逻辑应该在适配器中，不要泄漏到应用核心。",
            "【事务管理】数据库适配器需要处理事务边界，但事务策略应由应用层决定。",
            "【异常转换】适配器需要将技术异常转换为应用层可理解的异常。",
            "【配置管理】适配器的配置（连接字符串、API 密钥）应该外部化。",
        ],
        handsOnPath: [
            "实现 REST 控制器适配器（请求/响应转换）",
            "实现数据库仓储适配器（ORM 封装）",
            "实现消息队列适配器（发布/订阅）",
            "实现外部 API 客户端适配器",
            "添加 DTO 到领域对象的映射",
            "配置依赖注入绑定适配器到端口",
        ],
        selfCheck: [
            "适配器的主要职责是什么？",
            "为什么说适配器使技术替换变得简单？",
            "数据转换逻辑应该放在哪里？",
            "适配器如何处理异常？",
            "适配器的配置应该如何管理？",
        ],
        extensions: [
            "学习 AutoMapper 等映射工具的使用",
            "了解适配器的错误处理最佳实践",
            "研究适配器的日志和监控策略",
            "探索适配器的重试和熔断机制",
        ],
        sourceUrls: [
            "https://herbertograca.com/2017/09/14/ports-adapters-architecture/",
            "https://github.com/thombergs/buckpal",
        ],
    },
    "w10-4": {
        lessonId: "w10-4",
        background: [
            "【测试隔离】六边形架构的核心优势之一是'to be developed and tested in isolation from its eventual run-time devices and databases'。",
            "【假适配器】'Testing becomes simpler through interface mocking'——可以用假适配器替换真实实现进行测试。",
            "【测试层次】单元测试使用假适配器测试应用核心；集成测试使用真实适配器测试完整流程。",
            "【端口即测试边界】端口接口定义了测试边界，可以在端口级别进行桩和模拟。",
            "【并行开发】前端团队可以用假适配器开发 UI，后端团队开发真实适配器，互不阻塞。",
        ],
        keyDifficulties: [
            "【Mock vs Fake】Mock 验证行为，Fake 提供简化实现——选择取决于测试目的。",
            "【测试数据管理】假适配器需要管理测试数据，确保测试可重复。",
            "【集成测试范围】集成测试应该覆盖适配器的技术细节，但不应重复单元测试的逻辑。",
            "【测试金字塔平衡】大量单元测试（快）+ 适量集成测试（慢）+ 少量端到端测试（最慢）。",
        ],
        handsOnPath: [
            "为被驱动端口创建内存实现（假适配器）",
            "使用假适配器编写应用核心的单元测试",
            "使用真实数据库适配器编写集成测试",
            "实现测试数据构建器（Test Data Builder）",
            "配置测试环境的依赖注入",
            "验证测试覆盖率和测试金字塔平衡",
        ],
        selfCheck: [
            "六边形架构如何简化测试？",
            "什么是假适配器？它与 Mock 有什么区别？",
            "单元测试和集成测试应该使用什么类型的适配器？",
            "端口接口如何作为测试边界？",
            "测试金字塔在六边形架构中如何应用？",
        ],
        extensions: [
            "学习 Test Double 的各种类型（Stub, Mock, Fake, Spy）",
            "了解契约测试（Contract Testing）验证适配器",
            "研究测试容器（Testcontainers）用于集成测试",
            "探索 BDD 与六边形架构的结合",
        ],
        sourceUrls: [
            "https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/",
            "https://blog.octo.com/en/hexagonal-architecture-three-principles-and-an-implementation-example/",
        ],
    },
}

export const week10Quizzes: Record<string, QuizQuestion[]> = {
    "w10-1": [
        {
            id: "w10-1-q1",
            question: "根据 Alistair Cockburn，六边形架构的核心目标是什么？",
            options: [
                "提高系统性能",
                "允许应用被用户、程序、测试脚本等平等驱动，并与运行时设备和数据库隔离开发测试",
                "减少代码量",
                "简化数据库设计",
            ],
            answer: 1,
            rationale: "Cockburn 定义：'Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases'。",
        },
        {
            id: "w10-1-q2",
            question: "六边形架构的核心原则是什么？",
            options: [
                "数据优先",
                "区分应用内部（业务逻辑）与外部（UI、数据库），内部代码不能泄漏到外部",
                "层次分明",
                "面向数据库设计",
            ],
            answer: 1,
            rationale: "核心原则是区分内外，'code pertaining to the inside part should not leak into the outside part'。",
        },
        {
            id: "w10-1-q3",
            question: "什么是端口（Port）？",
            options: [
                "网络端口号",
                "应用与外部实体之间的通信接口，其协议由对话目的定义",
                "数据库连接",
                "API 端点",
            ],
            answer: 1,
            rationale: "端口是应用与外部实体之间的通信接口，其协议由对话目的定义，而非技术细节。",
        },
        {
            id: "w10-1-q4",
            question: "适配器（Adapter）的定义是什么？",
            options: [
                "设计模式的一种",
                "将 API 定义转换为特定设备所需信号的组件",
                "数据转换器",
                "消息队列",
            ],
            answer: 1,
            rationale: "Cockburn：'For each external device there is an adapter that converts the API definition to the signals needed by that device and vice versa'。",
        },
        {
            id: "w10-1-q5",
            question: "六边形架构与传统分层架构的主要区别是什么？",
            options: [
                "六边形架构更复杂",
                "分层架构有层级高低之分，六边形架构所有外部交互都是平等的'面'",
                "六边形架构不支持数据库",
                "没有区别",
            ],
            answer: 1,
            rationale: "分层架构有层级高低之分，六边形架构所有外部交互都是平等的'面'。",
        },
        {
            id: "w10-1-q6",
            question: "六边形架构为什么叫'六边形'？",
            options: [
                "必须有六个端口",
                "只是可视化形状，强调多个平等的外部交互点，实际端口数量由需求决定",
                "六个层次",
                "六种适配器",
            ],
            answer: 1,
            rationale: "六边形只是示意图，实际端口数量由应用需求决定，可以是任意数量。",
        },
        {
            id: "w10-1-q7",
            question: "GUI、FIT 测试框架、模拟数据库在六边形架构中是什么？",
            options: [
                "端口",
                "同一端口的不同适配器",
                "应用核心",
                "领域服务",
            ],
            answer: 1,
            rationale: "GUI、FIT 测试框架、模拟数据库均为同一端口的不同适配器。",
        },
        {
            id: "w10-1-q8",
            question: "业务逻辑应该放在六边形的什么位置？",
            options: [
                "适配器中",
                "六边形内部（应用核心）",
                "端口接口中",
                "外部系统中",
            ],
            answer: 1,
            rationale: "业务逻辑必须在六边形内部，任何泄漏到适配器中都违反架构原则。",
        },
        {
            id: "w10-1-q9",
            question: "六边形架构如何支持自动化测试？",
            options: [
                "不支持自动化测试",
                "允许应用与运行时设备和数据库隔离开发测试",
                "只支持手动测试",
                "需要特殊测试框架",
            ],
            answer: 1,
            rationale: "Cockburn 强调六边形架构支持'be developed and tested in isolation from its eventual run-time devices and databases'。",
        },
        {
            id: "w10-1-q10",
            question: "六边形架构解决了传统分层架构的什么问题？",
            options: [
                "性能问题",
                "业务逻辑散落在 UI 层的问题",
                "数据库设计问题",
                "网络延迟问题",
            ],
            answer: 1,
            rationale: "这解决了传统分层架构中业务逻辑散落在 UI 层的问题。",
        },
        {
            id: "w10-1-q11",
            question: "多个适配器共享同一端口协议意味着什么？",
            options: [
                "代码重复",
                "可替换性——可以用不同技术实现相同的交互",
                "性能下降",
                "复杂度增加",
            ],
            answer: 1,
            rationale: "多个适配器共享同一端口协议实现可替换性。",
        },
        {
            id: "w10-1-q12",
            question: "六边形架构的另一个名称是什么？",
            options: [
                "三层架构",
                "端口与适配器架构（Ports and Adapters）",
                "MVC 架构",
                "单体架构",
            ],
            answer: 1,
            rationale: "六边形架构又称'Ports and Adapters'架构。",
        },
    ],
    "w10-2": [
        {
            id: "w10-2-q1",
            question: "Primary (Driving) Adapters 的作用是什么？",
            options: [
                "响应应用请求",
                "发起对应用的操作，将外部请求转换为应用用例调用",
                "存储数据",
                "管理配置",
            ],
            answer: 1,
            rationale: "Primary (Driving) Adapters 发起对应用的操作，包括 UI 组件、控制器、CLI 命令。",
        },
        {
            id: "w10-2-q2",
            question: "Secondary (Driven) Adapters 的作用是什么？",
            options: [
                "发起操作",
                "响应应用的请求，包装外部工具如数据库、搜索引擎",
                "处理用户输入",
                "管理路由",
            ],
            answer: 1,
            rationale: "Secondary (Driven) Adapters 响应应用请求，包装外部工具如数据库、搜索引擎，实现应用核心定义的接口。",
        },
        {
            id: "w10-2-q3",
            question: "驱动端口（左侧）的依赖方向是什么？",
            options: [
                "端口依赖适配器",
                "适配器依赖端口，都在应用边界内",
                "没有依赖关系",
                "相互依赖",
            ],
            answer: 1,
            rationale: "左侧（UI）：适配器依赖端口，两者都在应用边界内。",
        },
        {
            id: "w10-2-q4",
            question: "被驱动端口（右侧）的依赖方向是什么？",
            options: [
                "端口依赖实现",
                "端口在内部，具体实现包装外部工具在外部",
                "没有依赖关系",
                "相互依赖",
            ],
            answer: 1,
            rationale: "右侧（Infrastructure）：端口在内部，具体实现包装外部工具在应用外部。",
        },
        {
            id: "w10-2-q5",
            question: "接口在六边形架构中的核心作用是什么？",
            options: [
                "提高性能",
                "作为隔离机制，防止技术细节污染领域逻辑",
                "减少代码量",
                "简化测试",
            ],
            answer: 1,
            rationale: "'interfaces serve as the isolating mechanism, keeping ephemeral technologies from corrupting domain logic'。",
        },
        {
            id: "w10-2-q6",
            question: "一个端口可以有多个适配器吗？",
            options: [
                "不可以",
                "可以，如 REST 和 GraphQL 适配器共享用例端口",
                "只能有一个",
                "取决于框架",
            ],
            answer: 1,
            rationale: "同一端口可以有多个适配器，如 REST 和 GraphQL 适配器共享用例端口。",
        },
        {
            id: "w10-2-q7",
            question: "端口接口应该由谁定义和拥有？",
            options: [
                "外部系统",
                "应用核心",
                "适配器",
                "框架",
            ],
            answer: 1,
            rationale: "端口接口由应用核心定义和拥有，适配器实现这些接口。",
        },
        {
            id: "w10-2-q8",
            question: "适配器中应该包含业务逻辑吗？",
            options: [
                "应该包含",
                "不应该，适配器只负责技术转换",
                "部分包含",
                "取决于复杂度",
            ],
            answer: 1,
            rationale: "适配器只负责技术转换，不应包含业务逻辑。",
        },
        {
            id: "w10-2-q9",
            question: "驱动适配器的典型例子有哪些？",
            options: [
                "数据库仓储",
                "UI 组件、控制器、CLI 命令",
                "消息发布者",
                "外部 API 客户端",
            ],
            answer: 1,
            rationale: "驱动适配器包括 UI 组件、控制器、CLI 命令，它们发起对应用的操作。",
        },
        {
            id: "w10-2-q10",
            question: "被驱动适配器的典型例子有哪些？",
            options: [
                "REST 控制器",
                "数据库仓储、搜索引擎客户端、外部 API 客户端",
                "Web 框架",
                "用户界面",
            ],
            answer: 1,
            rationale: "被驱动适配器包装外部工具如数据库、搜索引擎，实现应用核心定义的接口。",
        },
        {
            id: "w10-2-q11",
            question: "理解驱动端口和被驱动端口的最大难点是什么？",
            options: [
                "性能优化",
                "理解依赖方向的差异",
                "代码组织",
                "测试编写",
            ],
            answer: 1,
            rationale: "理解驱动端口和被驱动端口的依赖方向差异是最大难点。",
        },
        {
            id: "w10-2-q12",
            question: "Anti-Corruption Layer 在六边形架构中是什么角色？",
            options: [
                "端口",
                "一种特殊的适配器",
                "应用核心",
                "领域服务",
            ],
            answer: 1,
            rationale: "Anti-Corruption Layer 是一种特殊的适配器，用于隔离外部系统的不良设计。",
        },
    ],
    "w10-3": [
        {
            id: "w10-3-q1",
            question: "常见的适配器类型有哪些？",
            options: [
                "只有数据库适配器",
                "REST/GraphQL 控制器、消息消费者、数据库仓储、外部 API 客户端、消息发布者",
                "只有 UI 适配器",
                "只有消息适配器",
            ],
            answer: 1,
            rationale: "常见适配器包括：REST/GraphQL 控制器、消息消费者、数据库仓储、外部 API 客户端、消息发布者。",
        },
        {
            id: "w10-3-q2",
            question: "适配器的主要职责是什么？",
            options: [
                "实现业务逻辑",
                "将应用核心的领域概念转换为具体技术协议",
                "管理数据库",
                "处理用户认证",
            ],
            answer: 1,
            rationale: "适配器将应用核心的领域概念转换为具体技术协议，反之亦然。",
        },
        {
            id: "w10-3-q3",
            question: "为什么说适配器使技术替换变得简单？",
            options: [
                "适配器代码少",
                "只需创建新适配器实现相同接口，应用核心不变",
                "适配器是自动生成的",
                "不需要测试",
            ],
            answer: 1,
            rationale: "'Switching from Elasticsearch to Solr requires only creating a new adapter implementing the same interface—the application core remains unchanged'。",
        },
        {
            id: "w10-3-q4",
            question: "数据转换逻辑应该放在哪里？",
            options: [
                "应用核心",
                "适配器中",
                "领域服务",
                "端口接口",
            ],
            answer: 1,
            rationale: "数据转换逻辑应该在适配器中，不要泄漏到应用核心。",
        },
        {
            id: "w10-3-q5",
            question: "适配器如何处理技术异常？",
            options: [
                "直接抛出",
                "转换为应用层可理解的异常",
                "忽略异常",
                "记录日志后忽略",
            ],
            answer: 1,
            rationale: "适配器需要将技术异常转换为应用层可理解的异常。",
        },
        {
            id: "w10-3-q6",
            question: "适配器的配置（如连接字符串）应该如何管理？",
            options: [
                "硬编码在代码中",
                "外部化配置",
                "存储在数据库中",
                "不需要配置",
            ],
            answer: 1,
            rationale: "适配器的配置（连接字符串、API 密钥）应该外部化。",
        },
        {
            id: "w10-3-q7",
            question: "事务管理在六边形架构中应该如何处理？",
            options: [
                "由适配器完全控制",
                "数据库适配器处理事务边界，但事务策略由应用层决定",
                "不需要事务",
                "由框架自动处理",
            ],
            answer: 1,
            rationale: "数据库适配器需要处理事务边界，但事务策略应由应用层决定。",
        },
        {
            id: "w10-3-q8",
            question: "DTO 转换在六边形架构中的作用是什么？",
            options: [
                "提高性能",
                "将外部数据格式转换为领域对象，以及反向转换",
                "减少代码量",
                "简化测试",
            ],
            answer: 1,
            rationale: "适配器负责将外部数据格式（JSON、XML）转换为领域对象，以及反向转换。",
        },
        {
            id: "w10-3-q9",
            question: "REST 控制器在六边形架构中是什么类型的适配器？",
            options: [
                "被驱动适配器",
                "驱动适配器",
                "不是适配器",
                "端口",
            ],
            answer: 1,
            rationale: "REST 控制器是驱动适配器，将 HTTP 请求转换为应用用例调用。",
        },
        {
            id: "w10-3-q10",
            question: "数据库仓储在六边形架构中是什么类型的适配器？",
            options: [
                "驱动适配器",
                "被驱动适配器",
                "不是适配器",
                "端口",
            ],
            answer: 1,
            rationale: "数据库仓储是被驱动适配器，实现应用核心定义的仓储接口。",
        },
        {
            id: "w10-3-q11",
            question: "如何将适配器绑定到端口？",
            options: [
                "硬编码",
                "使用依赖注入",
                "直接实例化",
                "不需要绑定",
            ],
            answer: 1,
            rationale: "配置依赖注入绑定适配器到端口。",
        },
        {
            id: "w10-3-q12",
            question: "当应用核心保持不变时，外部技术如何变化？",
            options: [
                "不能变化",
                "通过创建新适配器实现相同接口",
                "需要重写应用核心",
                "自动适应",
            ],
            answer: 1,
            rationale: "应用核心保持稳定，'the application core remains unchanged'，无论外部技术如何变化，只需创建新适配器。",
        },
    ],
    "w10-4": [
        {
            id: "w10-4-q1",
            question: "六边形架构的核心测试优势是什么？",
            options: [
                "测试更少",
                "允许应用与运行时设备和数据库隔离开发测试",
                "自动生成测试",
                "不需要测试",
            ],
            answer: 1,
            rationale: "'to be developed and tested in isolation from its eventual run-time devices and databases'。",
        },
        {
            id: "w10-4-q2",
            question: "假适配器（Fake Adapter）的作用是什么？",
            options: [
                "生产环境使用",
                "用于测试，提供简化实现替换真实适配器",
                "提高性能",
                "减少代码量",
            ],
            answer: 1,
            rationale: "'Testing becomes simpler through interface mocking'——可以用假适配器替换真实实现进行测试。",
        },
        {
            id: "w10-4-q3",
            question: "单元测试应该使用什么类型的适配器？",
            options: [
                "真实适配器",
                "假适配器（内存实现）",
                "不使用适配器",
                "混合使用",
            ],
            answer: 1,
            rationale: "单元测试使用假适配器测试应用核心，确保快速和隔离。",
        },
        {
            id: "w10-4-q4",
            question: "集成测试应该使用什么类型的适配器？",
            options: [
                "假适配器",
                "真实适配器",
                "不使用适配器",
                "只用模拟对象",
            ],
            answer: 1,
            rationale: "集成测试使用真实适配器测试完整流程。",
        },
        {
            id: "w10-4-q5",
            question: "端口接口如何作为测试边界？",
            options: [
                "不能作为边界",
                "可以在端口级别进行桩和模拟",
                "只用于日志",
                "只用于监控",
            ],
            answer: 1,
            rationale: "端口接口定义了测试边界，可以在端口级别进行桩和模拟。",
        },
        {
            id: "w10-4-q6",
            question: "Mock 和 Fake 的区别是什么？",
            options: [
                "没有区别",
                "Mock 验证行为，Fake 提供简化实现",
                "Fake 更复杂",
                "Mock 用于生产",
            ],
            answer: 1,
            rationale: "Mock 验证行为，Fake 提供简化实现——选择取决于测试目的。",
        },
        {
            id: "w10-4-q7",
            question: "测试金字塔在六边形架构中如何应用？",
            options: [
                "只写端到端测试",
                "大量单元测试（快）+ 适量集成测试（慢）+ 少量端到端测试（最慢）",
                "只写单元测试",
                "平均分配",
            ],
            answer: 1,
            rationale: "大量单元测试（快）+ 适量集成测试（慢）+ 少量端到端测试（最慢）。",
        },
        {
            id: "w10-4-q8",
            question: "六边形架构如何支持并行开发？",
            options: [
                "不支持并行开发",
                "前端团队可用假适配器开发 UI，后端团队开发真实适配器，互不阻塞",
                "需要同步开发",
                "只能串行开发",
            ],
            answer: 1,
            rationale: "前端团队可以用假适配器开发 UI，后端团队开发真实适配器，互不阻塞。",
        },
        {
            id: "w10-4-q9",
            question: "假适配器需要管理什么？",
            options: [
                "生产数据",
                "测试数据，确保测试可重复",
                "用户数据",
                "配置数据",
            ],
            answer: 1,
            rationale: "假适配器需要管理测试数据，确保测试可重复。",
        },
        {
            id: "w10-4-q10",
            question: "集成测试应该覆盖什么？",
            options: [
                "业务逻辑",
                "适配器的技术细节，但不重复单元测试的逻辑",
                "所有代码",
                "只覆盖 UI",
            ],
            answer: 1,
            rationale: "集成测试应该覆盖适配器的技术细节，但不应重复单元测试的逻辑。",
        },
        {
            id: "w10-4-q11",
            question: "Test Data Builder 的作用是什么？",
            options: [
                "构建生产数据",
                "帮助创建测试数据，使测试代码更清晰",
                "删除测试数据",
                "验证数据",
            ],
            answer: 1,
            rationale: "Test Data Builder 帮助创建测试数据，使测试代码更清晰可维护。",
        },
        {
            id: "w10-4-q12",
            question: "契约测试（Contract Testing）验证什么？",
            options: [
                "业务逻辑",
                "适配器是否正确实现端口接口",
                "性能",
                "安全性",
            ],
            answer: 1,
            rationale: "契约测试验证适配器是否正确实现端口接口的契约。",
        },
    ],
}
