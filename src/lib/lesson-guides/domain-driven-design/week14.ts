import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week14Guides: Record<string, LessonGuide> = {
    "w14-1": {
        lessonId: "w14-1",
        background: [
            "【合作关系定义】Partnership 模式：'Where development failure in either of two contexts would result in delivery failure for both, forge a partnership between the teams'。",
            "【紧密协作】两个上下文紧密协作，同步演进，需要大量团队间沟通协调。",
            "【协调机制】需要建立协调规划流程和共同管理集成的机制，'Institute a process for coordinated planning'。",
            "【接口演进】团队必须合作演进接口以适应双方系统的开发需求。",
            "【同步交付】相互依赖的功能应安排在同一发布周期完成。",
        ],
        keyDifficulties: [
            "【高协调成本】Partnership 需要大量沟通和协调，成本较高。",
            "【团队依赖】一方的延迟会影响另一方，需要同步规划和执行。",
            "【适用范围】通常适用于同一团队或紧密合作的小团队。",
            "【退出困难】一旦建立 Partnership，解耦变得困难。",
        ],
        handsOnPath: [
            "识别系统中需要紧密协作的上下文",
            "建立团队间的沟通渠道和会议机制",
            "创建共享的发布计划和里程碑",
            "定义接口变更的协商流程",
            "建立共同的集成测试环境",
            "监控协作效率和问题",
        ],
        selfCheck: [
            "什么时候应该使用 Partnership 模式？",
            "Partnership 需要什么协调机制？",
            "Partnership 的主要成本是什么？",
            "如何评估 Partnership 是否有效？",
            "Partnership 与 Customer/Supplier 有什么区别？",
        ],
        extensions: [
            "学习敏捷团队协作最佳实践",
            "了解 SAFe 等规模化敏捷框架中的团队协作",
            "研究 Spotify 模型的 Squad 和 Tribe",
            "探索分布式团队的 Partnership 挑战",
        ],
        sourceUrls: [
            "https://deviq.com/domain-driven-design/context-mapping/",
            "https://teamtopologies.com/",
        ],
    },
    "w14-2": {
        lessonId: "w14-2",
        background: [
            "【共享内核定义】Shared Kernel：'designates some subset of the domain model that the two teams agree to share'。",
            "【明确共享】两个团队明确同意共享一小部分领域模型，需要相互协商变更。",
            "【统一语言】共享内核需要建立团队间的统一语言，确保概念理解一致。",
            "【变更协调】对共享内核的任何变更都需要两个团队的同意和协调。",
            "【最小化原则】共享内核应尽可能小，只包含必须共享的部分。",
        ],
        keyDifficulties: [
            "【耦合风险】共享内核增加系统耦合，变更影响范围大。",
            "【协调瓶颈】变更需要两个团队协调，可能成为瓶颈。",
            "【版本管理】共享代码的版本管理和依赖管理复杂。",
            "【边界蔓延】共享内核有扩大的趋势，需要持续治理。",
        ],
        handsOnPath: [
            "识别必须共享的领域概念",
            "定义共享内核的边界和范围",
            "建立共享代码的版本管理策略",
            "创建变更审批流程",
            "编写共享内核的文档和使用指南",
            "定期审查共享内核的大小和必要性",
        ],
        selfCheck: [
            "什么是共享内核？它共享什么？",
            "共享内核应该多大？为什么？",
            "共享内核的主要风险是什么？",
            "如何管理共享内核的变更？",
            "如何防止共享内核不断扩大？",
        ],
        extensions: [
            "学习 Monorepo 与共享内核的关系",
            "了解共享库的版本管理策略",
            "研究 API 优先与共享内核的权衡",
            "探索微服务中的共享库模式",
        ],
        sourceUrls: [
            "https://deviq.com/domain-driven-design/context-mapping/",
            "https://github.com/ddd-crew/context-mapping",
        ],
    },
    "w14-3": {
        lessonId: "w14-3",
        background: [
            "【客户供应商定义】Customer/Supplier：'When two teams are in an upstream-downstream relationship...establish a clear customer/supplier relationship'。",
            "【上下游关系】上游是供应商，下游是客户；上游可独立成功，但考虑下游需求。",
            "【需求影响】下游优先级影响上游规划，'downstream priorities factor into upstream planning'。",
            "【消费者驱动契约】可使用消费者驱动契约确保上游满足下游需求。",
            "【协作而非从属】与 Conformist 不同，Customer/Supplier 是协作模式。",
        ],
        keyDifficulties: [
            "【需求沟通】有效传达下游需求并影响上游优先级需要建立沟通机制。",
            "【期望管理】上游不能满足所有下游需求，需要管理期望和优先级。",
            "【契约演进】API 契约的演进需要考虑下游的迁移成本。",
            "【多下游协调】当有多个下游时，需求优先级协调更复杂。",
        ],
        handsOnPath: [
            "识别系统中的 Customer/Supplier 关系",
            "建立需求收集和优先级协商机制",
            "实现消费者驱动的契约测试",
            "创建 API 变更通知和迁移计划流程",
            "定义 SLA 和支持流程",
            "监控下游满意度和需求满足率",
        ],
        selfCheck: [
            "Customer/Supplier 与 Partnership 有什么区别？",
            "下游如何影响上游的规划？",
            "什么是消费者驱动契约？",
            "有多个下游时如何协调需求？",
            "如何管理 API 变更对下游的影响？",
        ],
        extensions: [
            "学习消费者驱动契约测试（Pact）",
            "了解 API 版本管理策略",
            "研究产品管理在 Customer/Supplier 中的角色",
            "探索内部 API 市场模式",
        ],
        sourceUrls: [
            "https://contextmapper.org/docs/customer-supplier/",
            "https://martinfowler.com/articles/consumerDrivenContracts.html",
        ],
    },
    "w14-4": {
        lessonId: "w14-4",
        background: [
            "【遵从者定义】Conformist：'downstream team conforms to the model of the upstream team despite that model not meeting their needs'。",
            "【非合作模式】上游没有动力支持下游，下游必须接受上游的设计。",
            "【简化集成】通过完全采用上游模型，不再需要复杂的反腐层翻译。",
            "【被动选择】通常是因为无法影响上游或翻译成本过高时的被动选择。",
            "【语义约束】Conformist 不适用于 Customer/Supplier 关系——这是重要的语义规则。",
        ],
        keyDifficulties: [
            "【模型污染】上游模型可能不适合下游领域，导致概念混乱。",
            "【被动依赖】下游完全依赖上游的设计决策，失去自主权。",
            "【变更风险】上游的任何变更都直接影响下游，无缓冲。",
            "【技术债务】长期可能积累技术债务，难以改变。",
        ],
        handsOnPath: [
            "识别系统中的 Conformist 关系",
            "评估是否真的无法建立 Customer/Supplier",
            "分析采用上游模型的成本和收益",
            "建立上游变更的监控和响应机制",
            "记录 Conformist 选择的原因和风险",
            "制定长期改进计划（如果可能）",
        ],
        selfCheck: [
            "什么时候选择 Conformist 是合理的？",
            "Conformist 与 Customer/Supplier 的关键区别是什么？",
            "Conformist 模式有什么风险？",
            "如何从 Conformist 演进到更好的关系？",
            "为什么 Conformist 不适用于 Customer/Supplier 关系？",
        ],
        extensions: [
            "学习评估 Conformist vs ACL 的决策框架",
            "了解遗留系统集成中的 Conformist 应用",
            "研究第三方 SaaS 集成的模式选择",
            "探索 Conformist 的退出策略",
        ],
        sourceUrls: [
            "https://contextmapper.org/docs/conformist/",
            "https://deviq.com/domain-driven-design/context-mapping/",
        ],
    },
}

export const week14Quizzes: Record<string, QuizQuestion[]> = {
    "w14-1": [
        {
            id: "w14-1-q1",
            question: "Partnership 模式什么时候应该使用？",
            options: [
                "所有情况",
                "当两个上下文的开发失败会导致双方交付失败时",
                "当团队想独立工作时",
                "当没有依赖时",
            ],
            answer: 1,
            rationale: "'Where development failure in either of two contexts would result in delivery failure for both, forge a partnership'。",
        },
        {
            id: "w14-1-q2",
            question: "Partnership 需要什么协调机制？",
            options: [
                "不需要协调",
                "协调规划流程和共同管理集成的机制",
                "只需要文档",
                "只需要代码审查",
            ],
            answer: 1,
            rationale: "'Institute a process for coordinated planning of development and joint management of integration'。",
        },
        {
            id: "w14-1-q3",
            question: "Partnership 模式的主要成本是什么？",
            options: [
                "代码量增加",
                "大量沟通和协调，协调成本高",
                "服务器成本",
                "没有成本",
            ],
            answer: 1,
            rationale: "Partnership 需要大量沟通和协调，成本较高。",
        },
        {
            id: "w14-1-q4",
            question: "相互依赖的功能应该如何安排发布？",
            options: [
                "分开发布",
                "安排在同一发布周期完成",
                "随机发布",
                "延迟发布",
            ],
            answer: 1,
            rationale: "相互依赖的功能应安排在同一发布周期完成。",
        },
        {
            id: "w14-1-q5",
            question: "Partnership 通常适用于什么团队？",
            options: [
                "跨公司团队",
                "同一团队或紧密合作的小团队",
                "完全独立的团队",
                "外包团队",
            ],
            answer: 1,
            rationale: "Partnership 通常适用于同一团队或紧密合作的小团队。",
        },
        {
            id: "w14-1-q6",
            question: "一旦建立 Partnership 有什么挑战？",
            options: [
                "没有挑战",
                "解耦变得困难",
                "更容易解耦",
                "自动解耦",
            ],
            answer: 1,
            rationale: "一旦建立 Partnership，解耦变得困难。",
        },
        {
            id: "w14-1-q7",
            question: "Partnership 与 Customer/Supplier 的主要区别是什么？",
            options: [
                "没有区别",
                "Partnership 是双向依赖，Customer/Supplier 是单向依赖",
                "Customer/Supplier 更复杂",
                "Partnership 不需要沟通",
            ],
            answer: 1,
            rationale: "Partnership 是双向依赖（一方失败导致双方失败），Customer/Supplier 是上游可以独立成功。",
        },
        {
            id: "w14-1-q8",
            question: "Partnership 中接口如何演进？",
            options: [
                "单方面决定",
                "团队必须合作演进以适应双方系统的需求",
                "不能演进",
                "自动演进",
            ],
            answer: 1,
            rationale: "'The teams must cooperate on the evolution of their interfaces to accommodate the development needs of both systems'。",
        },
        {
            id: "w14-1-q9",
            question: "如何评估 Partnership 是否有效？",
            options: [
                "看代码量",
                "监控协作效率和问题",
                "看文档量",
                "看服务器数量",
            ],
            answer: 1,
            rationale: "监控协作效率和问题是评估 Partnership 有效性的关键。",
        },
        {
            id: "w14-1-q10",
            question: "一方的延迟会对 Partnership 产生什么影响？",
            options: [
                "没有影响",
                "会影响另一方，需要同步规划和执行",
                "自动补偿",
                "只影响自己",
            ],
            answer: 1,
            rationale: "在 Partnership 中，一方的延迟会影响另一方，需要同步规划和执行。",
        },
        {
            id: "w14-1-q11",
            question: "Partnership 需要什么沟通渠道？",
            options: [
                "不需要沟通",
                "建立团队间的沟通渠道和会议机制",
                "只需要邮件",
                "只需要文档",
            ],
            answer: 1,
            rationale: "建立团队间的沟通渠道和会议机制是 Partnership 的基础。",
        },
        {
            id: "w14-1-q12",
            question: "分布式团队实施 Partnership 有什么挑战？",
            options: [
                "没有挑战",
                "沟通协调更困难，时区和文化差异",
                "更容易",
                "自动解决",
            ],
            answer: 1,
            rationale: "分布式团队的 Partnership 面临沟通协调、时区和文化差异等挑战。",
        },
    ],
    "w14-2": [
        {
            id: "w14-2-q1",
            question: "共享内核（Shared Kernel）共享什么？",
            options: [
                "数据库",
                "两个团队明确同意共享的一小部分领域模型",
                "服务器",
                "代码仓库",
            ],
            answer: 1,
            rationale: "'designates some subset of the domain model that the two teams agree to share'。",
        },
        {
            id: "w14-2-q2",
            question: "共享内核应该多大？",
            options: [
                "越大越好",
                "尽可能小，只包含必须共享的部分",
                "固定大小",
                "没有限制",
            ],
            answer: 1,
            rationale: "共享内核应尽可能小，只包含必须共享的部分。",
        },
        {
            id: "w14-2-q3",
            question: "对共享内核的变更需要什么？",
            options: [
                "单方面决定",
                "两个团队的同意和协调",
                "自动批准",
                "不能变更",
            ],
            answer: 1,
            rationale: "对共享内核的任何变更都需要两个团队的同意和协调。",
        },
        {
            id: "w14-2-q4",
            question: "共享内核的主要风险是什么？",
            options: [
                "性能下降",
                "增加系统耦合，变更影响范围大",
                "安全风险",
                "没有风险",
            ],
            answer: 1,
            rationale: "共享内核增加系统耦合，变更影响范围大。",
        },
        {
            id: "w14-2-q5",
            question: "共享内核可能成为什么？",
            options: [
                "加速器",
                "协调瓶颈",
                "自动化工具",
                "测试框架",
            ],
            answer: 1,
            rationale: "变更需要两个团队协调，可能成为瓶颈。",
        },
        {
            id: "w14-2-q6",
            question: "共享内核有什么扩大趋势？",
            options: [
                "自动缩小",
                "有扩大的趋势，需要持续治理",
                "保持不变",
                "自动消失",
            ],
            answer: 1,
            rationale: "共享内核有扩大的趋势，需要持续治理和定期审查。",
        },
        {
            id: "w14-2-q7",
            question: "共享内核需要什么版本管理策略？",
            options: [
                "不需要",
                "建立共享代码的版本管理策略",
                "自动版本",
                "随机版本",
            ],
            answer: 1,
            rationale: "建立共享代码的版本管理策略是共享内核管理的关键。",
        },
        {
            id: "w14-2-q8",
            question: "共享内核需要什么文档？",
            options: [
                "不需要文档",
                "编写共享内核的文档和使用指南",
                "只需要代码注释",
                "自动生成",
            ],
            answer: 1,
            rationale: "编写共享内核的文档和使用指南确保团队正确使用。",
        },
        {
            id: "w14-2-q9",
            question: "共享内核需要建立什么以确保概念一致？",
            options: [
                "代码规范",
                "团队间的统一语言",
                "测试框架",
                "部署流程",
            ],
            answer: 1,
            rationale: "共享内核需要建立团队间的统一语言，确保概念理解一致。",
        },
        {
            id: "w14-2-q10",
            question: "如何防止共享内核不断扩大？",
            options: [
                "不能防止",
                "定期审查共享内核的大小和必要性",
                "自动缩减",
                "忽略增长",
            ],
            answer: 1,
            rationale: "定期审查共享内核的大小和必要性防止不必要的扩大。",
        },
        {
            id: "w14-2-q11",
            question: "共享内核与 API 优先方式有什么权衡？",
            options: [
                "没有权衡",
                "共享内核更紧耦合，API 更松耦合但需要更多集成工作",
                "完全相同",
                "API 更紧耦合",
            ],
            answer: 1,
            rationale: "共享内核更紧耦合但简化某些场景，API 优先更松耦合但需要更多集成工作。",
        },
        {
            id: "w14-2-q12",
            question: "首先需要识别什么才能定义共享内核？",
            options: [
                "代码行数",
                "必须共享的领域概念",
                "团队人数",
                "服务器数量",
            ],
            answer: 1,
            rationale: "识别必须共享的领域概念是定义共享内核边界的第一步。",
        },
    ],
    "w14-3": [
        {
            id: "w14-3-q1",
            question: "Customer/Supplier 模式中谁是上游？",
            options: [
                "客户",
                "供应商",
                "两者都是",
                "都不是",
            ],
            answer: 1,
            rationale: "上游是供应商（Supplier），下游是客户（Customer）。",
        },
        {
            id: "w14-3-q2",
            question: "在 Customer/Supplier 中，下游如何影响上游？",
            options: [
                "不能影响",
                "下游优先级影响上游规划",
                "下游控制上游",
                "随机影响",
            ],
            answer: 1,
            rationale: "'downstream priorities factor into upstream planning'。",
        },
        {
            id: "w14-3-q3",
            question: "上游可以独立成功吗？",
            options: [
                "不可以",
                "可以，上游不依赖下游的成功",
                "取决于情况",
                "只在测试环境",
            ],
            answer: 1,
            rationale: "在 Customer/Supplier 中，上游可以独立成功，不依赖下游。",
        },
        {
            id: "w14-3-q4",
            question: "什么是消费者驱动契约？",
            options: [
                "供应商定义的契约",
                "由消费者（下游）定义的契约，确保上游满足需求",
                "随机契约",
                "没有契约",
            ],
            answer: 1,
            rationale: "消费者驱动契约由消费者定义，确保上游满足下游需求。",
        },
        {
            id: "w14-3-q5",
            question: "Customer/Supplier 与 Conformist 的关键区别是什么？",
            options: [
                "没有区别",
                "Customer/Supplier 是协作模式，Conformist 是非协作模式",
                "Conformist 更灵活",
                "Customer/Supplier 更被动",
            ],
            answer: 1,
            rationale: "Customer/Supplier 是协作模式（下游需求影响上游），Conformist 是非协作模式（上游不支持下游）。",
        },
        {
            id: "w14-3-q6",
            question: "有多个下游时面临什么挑战？",
            options: [
                "没有挑战",
                "需求优先级协调更复杂",
                "更简单",
                "自动解决",
            ],
            answer: 1,
            rationale: "当有多个下游时，需求优先级协调更复杂。",
        },
        {
            id: "w14-3-q7",
            question: "API 契约演进需要考虑什么？",
            options: [
                "只考虑上游",
                "下游的迁移成本",
                "不需要考虑",
                "只考虑性能",
            ],
            answer: 1,
            rationale: "API 契约的演进需要考虑下游的迁移成本。",
        },
        {
            id: "w14-3-q8",
            question: "如何有效传达下游需求？",
            options: [
                "不传达",
                "建立需求收集和优先级协商机制",
                "只发邮件",
                "等待上游询问",
            ],
            answer: 1,
            rationale: "建立需求收集和优先级协商机制是有效传达下游需求的关键。",
        },
        {
            id: "w14-3-q9",
            question: "Pact 是什么工具？",
            options: [
                "数据库工具",
                "消费者驱动契约测试工具",
                "监控工具",
                "部署工具",
            ],
            answer: 1,
            rationale: "Pact 是消费者驱动契约测试工具。",
        },
        {
            id: "w14-3-q10",
            question: "应该定义什么以明确服务级别？",
            options: [
                "代码规范",
                "SLA 和支持流程",
                "测试计划",
                "文档模板",
            ],
            answer: 1,
            rationale: "定义 SLA 和支持流程明确服务级别承诺。",
        },
        {
            id: "w14-3-q11",
            question: "如何监控 Customer/Supplier 关系的健康状况？",
            options: [
                "不需要监控",
                "监控下游满意度和需求满足率",
                "只看代码",
                "只看文档",
            ],
            answer: 1,
            rationale: "监控下游满意度和需求满足率评估关系健康状况。",
        },
        {
            id: "w14-3-q12",
            question: "上游不能满足所有下游需求时应该怎么做？",
            options: [
                "满足所有需求",
                "管理期望和优先级",
                "拒绝所有需求",
                "忽略需求",
            ],
            answer: 1,
            rationale: "上游不能满足所有下游需求，需要管理期望和优先级。",
        },
    ],
    "w14-4": [
        {
            id: "w14-4-q1",
            question: "Conformist 模式的定义是什么？",
            options: [
                "双向协作",
                "下游完全采用上游模型，即使不完全符合需求",
                "上游适应下游",
                "平等协作",
            ],
            answer: 1,
            rationale: "'downstream team conforms to the model of the upstream team despite that model not meeting their needs'。",
        },
        {
            id: "w14-4-q2",
            question: "为什么选择 Conformist 模式？",
            options: [
                "因为最优",
                "因为无法影响上游或翻译成本过高",
                "因为简单",
                "因为流行",
            ],
            answer: 1,
            rationale: "通常是因为无法影响上游或翻译成本过高时的被动选择。",
        },
        {
            id: "w14-4-q3",
            question: "Conformist 模式的优点是什么？",
            options: [
                "更灵活",
                "通过完全采用上游模型，不再需要复杂的反腐层翻译",
                "更独立",
                "性能更好",
            ],
            answer: 1,
            rationale: "通过完全采用上游模型，简化集成，不再需要复杂的反腐层翻译。",
        },
        {
            id: "w14-4-q4",
            question: "Conformist 不适用于什么关系？",
            options: [
                "Partnership",
                "Customer/Supplier 关系",
                "Shared Kernel",
                "所有关系",
            ],
            answer: 1,
            rationale: "'Conformist is not applicable in a Customer/Supplier relationship'——这是重要的语义规则。",
        },
        {
            id: "w14-4-q5",
            question: "Conformist 模式有什么模型风险？",
            options: [
                "没有风险",
                "上游模型可能不适合下游领域，导致概念混乱",
                "性能风险",
                "安全风险",
            ],
            answer: 1,
            rationale: "上游模型可能不适合下游领域，导致概念混乱（模型污染）。",
        },
        {
            id: "w14-4-q6",
            question: "下游在 Conformist 中失去什么？",
            options: [
                "性能",
                "设计决策的自主权",
                "代码",
                "数据",
            ],
            answer: 1,
            rationale: "下游完全依赖上游的设计决策，失去自主权。",
        },
        {
            id: "w14-4-q7",
            question: "上游变更对 Conformist 下游有什么影响？",
            options: [
                "没有影响",
                "直接影响下游，无缓冲",
                "下游可以选择不更新",
                "自动适应",
            ],
            answer: 1,
            rationale: "上游的任何变更都直接影响下游，无缓冲。",
        },
        {
            id: "w14-4-q8",
            question: "长期使用 Conformist 可能导致什么？",
            options: [
                "更好的设计",
                "积累技术债务，难以改变",
                "自动优化",
                "没有影响",
            ],
            answer: 1,
            rationale: "长期可能积累技术债务，难以改变。",
        },
        {
            id: "w14-4-q9",
            question: "在选择 Conformist 之前应该评估什么？",
            options: [
                "代码行数",
                "是否真的无法建立 Customer/Supplier",
                "团队人数",
                "服务器数量",
            ],
            answer: 1,
            rationale: "评估是否真的无法建立 Customer/Supplier 关系。",
        },
        {
            id: "w14-4-q10",
            question: "如何从 Conformist 演进到更好的关系？",
            options: [
                "不能演进",
                "通过建立影响力升级为 Customer/Supplier 或添加 ACL",
                "自动演进",
                "删除集成",
            ],
            answer: 1,
            rationale: "可以通过建立影响力升级为 Customer/Supplier 或添加 ACL 保护。",
        },
        {
            id: "w14-4-q11",
            question: "应该记录 Conformist 选择的什么？",
            options: [
                "代码量",
                "原因和风险",
                "性能数据",
                "团队人数",
            ],
            answer: 1,
            rationale: "记录 Conformist 选择的原因和风险帮助后续评估和改进。",
        },
        {
            id: "w14-4-q12",
            question: "第三方 SaaS 集成通常是什么模式？",
            options: [
                "Partnership",
                "Conformist，因为无法影响第三方",
                "Customer/Supplier",
                "Shared Kernel",
            ],
            answer: 1,
            rationale: "第三方 SaaS 集成通常是 Conformist，因为无法影响第三方的 API 设计。",
        },
    ],
}
