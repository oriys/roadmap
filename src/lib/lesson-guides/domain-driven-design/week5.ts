import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week5Guides: Record<string, LessonGuide> = {
    "w5-1": {
        lessonId: "w5-1",
        background: [
            "【实体定义】实体（Entity）具有'inherent identity'——固有标识，通过标识符而非属性值进行比较。",
            "【连续生命周期】实体具有连续的生命周期，有变化的历史记录，状态会随时间演变。",
            "【标识策略】常见的标识策略包括：UUID/GUID、数据库序列号、自然键（如身份证号）。",
            "【标识跨越上下文】实体的标识可以跨越多个限界上下文，但属性可能在不同上下文有不同含义。",
            "【实体示例】银行应用中的客户和账户是典型的实体——即使属性相同，不同 ID 代表不同对象。",
        ],
        keyDifficulties: [
            "【标识选择】选择合适的标识策略需要权衡：UUID 无碰撞但较长，序列号简洁但耦合数据库。",
            "【生命周期管理】实体的创建、更新、归档需要明确的生命周期管理。",
            "【跨上下文标识】在微服务环境中，如何在不同服务间关联同一实体是挑战。",
            "【实体膨胀】实体容易变得过大，需要警惕将不属于实体的责任加入其中。",
        ],
        handsOnPath: [
            "识别项目中的核心实体，列出它们的标识属性",
            "评估当前的标识策略是否合适",
            "检查实体是否有适当的生命周期方法",
            "审查实体是否过于臃肿，是否有属性应该抽取为值对象",
            "为实体编写单元测试，验证标识比较逻辑",
        ],
        selfCheck: [
            "什么是实体？它与值对象的核心区别是什么？",
            "常见的标识策略有哪些？各有什么优缺点？",
            "为什么说实体具有连续的生命周期？",
            "实体的标识如何在微服务架构中传递？",
            "什么情况下实体会变得过于臃肿？",
        ],
        extensions: [
            "学习 UUID 的不同版本和适用场景",
            "了解事件溯源中的实体标识",
            "研究跨服务的实体标识关联策略",
            "探索实体版本控制和乐观锁",
        ],
        sourceUrls: [
            "https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/",
            "https://learn.microsoft.com/en-us/azure/architecture/microservices/model/tactical-ddd",
        ],
    },
    "w5-2": {
        lessonId: "w5-2",
        background: [
            "【值对象定义】值对象（Value Object）'lack inherent identity'——缺乏固有标识，通过属性值的结构相等性进行比较。",
            "【不可变性】'Value objects should be immutable'——值对象应该是不可变的，修改时创建新实例而非改变现有实例。",
            "【可替换性】'If two value objects have the same set of attributes we can treat them interchangeably'——相同属性的值对象可以互换。",
            "【生命周期依赖】值对象不能独立存在，'must always belong to one or several entities'——必须属于一个或多个实体。",
            "【数据库存储】值对象不应该有单独的表，应'inline the fields...into the Person table'——内联到实体表中。",
        ],
        keyDifficulties: [
            "【识别方法】'mentally replace it with an integer'——如果可以用整数替换而不关心是哪个具体实例，就是值对象。",
            "【ORM 映射】在 ORM 中正确映射值对象需要特殊配置，避免生成不必要的外键关系。",
            "【集合中的值对象】实体包含值对象集合时，需要处理添加、删除、替换的语义。",
            "【原始类型痴迷】用原始类型（String、int）代替值对象是常见的反模式。",
        ],
        handsOnPath: [
            "识别项目中应该是值对象但被建模为实体的概念",
            "为常用的值类型（如金额、地址、日期范围）创建值对象类",
            "实现值对象的相等性比较和哈希码",
            "配置 ORM 将值对象内联到实体表",
            "重构原始类型痴迷的代码，用值对象替换",
        ],
        selfCheck: [
            "什么是值对象？它与实体的核心区别是什么？",
            "为什么值对象应该是不可变的？",
            "如何判断一个概念应该建模为值对象还是实体？",
            "值对象在数据库中应该如何存储？",
            "什么是原始类型痴迷？如何避免？",
        ],
        extensions: [
            "学习不同语言中值对象的实现模式",
            "了解 Record 类型与值对象的关系",
            "研究值对象的序列化和反序列化",
            "探索函数式编程中的值对象概念",
        ],
        sourceUrls: [
            "https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/",
            "https://martinfowler.com/bliki/ValueObject.html",
        ],
    },
    "w5-3": {
        lessonId: "w5-3",
        background: [
            "【优先使用值对象】'Always prefer value objects over entities in your domain model'——在领域模型中应优先使用值对象。",
            "【值对象优势】值对象不可变且轻量，更容易测试、推理和并发处理。",
            "【选择标准】核心问题：你关心的是'哪一个'（实体）还是'是什么'（值对象）？",
            "【上下文相关】同一概念在不同上下文可能是实体或值对象——如订单中的产品是引用（实体 ID），产品目录中的产品是实体。",
            "【重构方向】发现被错误建模为实体的值对象是常见的重构机会。",
        ],
        keyDifficulties: [
            "【边界情况】有些概念在实体和值对象之间不明显，需要深入业务分析。",
            "【演进变化】随着业务发展，值对象可能需要变成实体（需要跟踪历史时）。",
            "【团队认知】团队成员对实体/值对象的理解可能不一致，需要建立共识。",
            "【遗留代码】遗留系统中往往有大量错误的建模，重构需要谨慎。",
        ],
        handsOnPath: [
            "审查领域模型，用'你关心哪一个还是是什么'的问题检验每个对象",
            "列出所有被建模为实体但可能是值对象的概念",
            "与领域专家讨论这些概念的本质",
            "选择一个简单的案例进行重构实验",
            "记录重构决策和理由",
        ],
        selfCheck: [
            "为什么应该优先使用值对象？",
            "如何判断一个概念应该是实体还是值对象？",
            "同一概念在不同上下文可能有不同建模方式吗？举例说明。",
            "什么情况下值对象可能需要变成实体？",
            "发现错误建模后如何安全地重构？",
        ],
        extensions: [
            "学习领域模型重构的安全方法",
            "了解如何在不破坏兼容性的情况下演进模型",
            "研究实体与值对象的测试策略差异",
            "探索领域模型可视化工具",
        ],
        sourceUrls: [
            "https://enterprisecraftsmanship.com/posts/entity-vs-value-object-the-ultimate-list-of-differences/",
        ],
    },
    "w5-4": {
        lessonId: "w5-4",
        background: [
            "【实体实现要点】实体需要实现标识比较、相等性判断、哈希码生成，通常基于 ID 而非属性。",
            "【值对象实现要点】值对象需要实现结构相等性、不可变性、工厂方法创建。",
            "【语言支持】现代语言如 Java Record、C# record、Kotlin data class 提供值对象的原生支持。",
            "【ORM 配置】ORM 框架需要特殊配置来正确处理实体标识和值对象内联。",
            "【领域逻辑位置】业务规则应该放在实体和值对象内部，而非外部服务中。",
        ],
        keyDifficulties: [
            "【框架约束】某些 ORM 框架对值对象的支持有限，需要变通方案。",
            "【序列化问题】实体和值对象的序列化/反序列化需要特别处理。",
            "【验证位置】验证逻辑应该放在构造函数/工厂方法中，确保对象总是有效的。",
            "【集合处理】实体中的值对象集合需要特别的相等性和变更检测逻辑。",
        ],
        handsOnPath: [
            "实现一个完整的实体类，包含标识比较、生命周期方法",
            "实现一个完整的值对象类，包含不可变性、结构相等性",
            "配置 ORM 正确映射实体和值对象",
            "为实体和值对象编写全面的单元测试",
            "重构一个贫血模型，将业务逻辑移入领域对象",
        ],
        selfCheck: [
            "实体的相等性比较应该基于什么？",
            "值对象的相等性比较应该基于什么？",
            "为什么值对象的构造函数应该包含验证逻辑？",
            "如何在 ORM 中配置值对象的内联存储？",
            "业务逻辑应该放在领域对象的哪里？",
        ],
        extensions: [
            "学习不同编程语言的实体/值对象实现模式",
            "了解 DDD 代码生成工具",
            "研究领域对象的调试和日志最佳实践",
            "探索函数式 DDD 的实现方式",
        ],
        sourceUrls: [
            "https://github.com/ddd-by-examples/library",
            "https://github.com/dotnet-architecture/eShopOnContainers",
        ],
    },
}

export const week5Quizzes: Record<string, QuizQuestion[]> = {
    "w5-1": [
        {
            id: "w5-1-q1",
            question: "实体（Entity）的核心特征是什么？",
            options: [
                "不可变性",
                "固有标识，通过标识符比较",
                "没有状态",
                "必须存储在数据库中",
            ],
            answer: 1,
            rationale: "实体具有'inherent identity'——固有标识，通过标识符而非属性值进行比较。",
        },
        {
            id: "w5-1-q2",
            question: "以下哪个是常见的实体标识策略？",
            options: [
                "只用字符串",
                "UUID/GUID、数据库序列号、自然键",
                "只用自增整数",
                "不需要标识",
            ],
            answer: 1,
            rationale: "常见的标识策略包括：UUID/GUID、数据库序列号、自然键（如身份证号）。",
        },
        {
            id: "w5-1-q3",
            question: "实体的生命周期有什么特点？",
            options: [
                "没有生命周期",
                "连续的生命周期，有变化的历史记录",
                "生命周期只有创建和删除",
                "每次访问都是新实例",
            ],
            answer: 1,
            rationale: "实体具有连续的生命周期，有变化的历史记录，状态会随时间演变。",
        },
        {
            id: "w5-1-q4",
            question: "银行应用中的客户和账户为什么是实体？",
            options: [
                "因为它们有很多属性",
                "因为即使属性相同，不同 ID 代表不同对象",
                "因为它们存储在数据库中",
                "因为它们很重要",
            ],
            answer: 1,
            rationale: "客户和账户是典型的实体——即使属性相同，不同 ID 代表不同对象。",
        },
        {
            id: "w5-1-q5",
            question: "关于实体标识跨上下文，以下哪个说法是正确的？",
            options: [
                "标识不能跨越上下文",
                "标识可以跨越多个限界上下文，但属性含义可能不同",
                "每个上下文必须使用不同的标识",
                "标识只在数据库中有效",
            ],
            answer: 1,
            rationale: "实体的标识可以跨越多个限界上下文，但属性可能在不同上下文有不同含义。",
        },
        {
            id: "w5-1-q6",
            question: "UUID 作为实体标识的优点是什么？",
            options: [
                "最短",
                "无碰撞风险，不依赖数据库",
                "最快",
                "最容易记忆",
            ],
            answer: 1,
            rationale: "UUID 的优点是无碰撞风险且不依赖数据库生成，但缺点是较长。",
        },
        {
            id: "w5-1-q7",
            question: "什么是实体膨胀？",
            options: [
                "实体数据太多",
                "将不属于实体的责任加入实体，导致实体过大",
                "实体太少",
                "实体性能问题",
            ],
            answer: 1,
            rationale: "实体容易变得过大，需要警惕将不属于实体的责任加入其中。",
        },
        {
            id: "w5-1-q8",
            question: "在微服务环境中，实体标识面临什么挑战？",
            options: [
                "没有挑战",
                "如何在不同服务间关联同一实体",
                "标识太短",
                "数据库不支持",
            ],
            answer: 1,
            rationale: "在微服务环境中，如何在不同服务间关联同一实体是挑战。",
        },
        {
            id: "w5-1-q9",
            question: "实体的相等性比较应该基于什么？",
            options: [
                "所有属性",
                "标识符（ID）",
                "创建时间",
                "随机选择",
            ],
            answer: 1,
            rationale: "实体通过标识符而非属性值进行比较，两个实体 ID 相同则相等。",
        },
        {
            id: "w5-1-q10",
            question: "自然键作为实体标识有什么风险？",
            options: [
                "没有风险",
                "自然键可能变化，如身份证号更换",
                "太长",
                "数据库不支持",
            ],
            answer: 1,
            rationale: "自然键可能随业务变化，如身份证号更换、邮箱地址变更，可能导致问题。",
        },
        {
            id: "w5-1-q11",
            question: "实体的生命周期管理应该包括什么？",
            options: [
                "只有创建",
                "创建、更新、归档等明确的生命周期方法",
                "只有删除",
                "不需要管理",
            ],
            answer: 1,
            rationale: "实体的创建、更新、归档需要明确的生命周期管理。",
        },
        {
            id: "w5-1-q12",
            question: "检查实体是否膨胀时应该关注什么？",
            options: [
                "代码行数",
                "是否有属性应该抽取为值对象或其他实体",
                "文件大小",
                "注释数量",
            ],
            answer: 1,
            rationale: "审查实体是否过于臃肿，是否有属性应该抽取为值对象或拆分为其他实体。",
        },
    ],
    "w5-2": [
        {
            id: "w5-2-q1",
            question: "值对象（Value Object）的核心特征是什么？",
            options: [
                "有固有标识",
                "缺乏固有标识，通过属性值比较",
                "可变的",
                "独立存在",
            ],
            answer: 1,
            rationale: "值对象'lack inherent identity'——缺乏固有标识，通过属性值的结构相等性进行比较。",
        },
        {
            id: "w5-2-q2",
            question: "为什么值对象应该是不可变的？",
            options: [
                "性能原因",
                "修改值对象等于承认它有独立的生命周期，违背定义",
                "数据库要求",
                "安全原因",
            ],
            answer: 1,
            rationale: "'Value objects should be immutable'——修改值对象违背了值对象没有独立生命周期的定义。",
        },
        {
            id: "w5-2-q3",
            question: "如何判断一个概念应该是值对象？",
            options: [
                "看代码行数",
                "如果可以用整数替换而不关心是哪个具体实例，就是值对象",
                "看数据库表设计",
                "看是否有 ID 字段",
            ],
            answer: 1,
            rationale: "'mentally replace it with an integer'——如果可以用整数替换而不关心是哪个具体实例，就是值对象。",
        },
        {
            id: "w5-2-q4",
            question: "值对象在数据库中应该如何存储？",
            options: [
                "单独的表",
                "内联到实体表中",
                "单独的数据库",
                "不需要存储",
            ],
            answer: 1,
            rationale: "值对象不应该有单独的表，应'inline the fields...into the Person table'——内联到实体表中。",
        },
        {
            id: "w5-2-q5",
            question: "值对象的生命周期有什么特点？",
            options: [
                "独立的生命周期",
                "必须属于一个或多个实体，不能独立存在",
                "永恒存在",
                "随机生命周期",
            ],
            answer: 1,
            rationale: "值对象不能独立存在，'must always belong to one or several entities'——必须属于实体。",
        },
        {
            id: "w5-2-q6",
            question: "什么是原始类型痴迷？",
            options: [
                "使用太多类",
                "用原始类型（String、int）代替值对象的反模式",
                "不使用数据库",
                "代码太长",
            ],
            answer: 1,
            rationale: "用原始类型（String、int）代替值对象是常见的反模式，称为原始类型痴迷。",
        },
        {
            id: "w5-2-q7",
            question: "相同属性的值对象有什么特性？",
            options: [
                "不能相等",
                "可以互换使用",
                "必须有不同的 ID",
                "存储在不同的数据库",
            ],
            answer: 1,
            rationale: "'If two value objects have the same set of attributes we can treat them interchangeably'——可以互换。",
        },
        {
            id: "w5-2-q8",
            question: "值对象的典型例子是什么？",
            options: [
                "用户、订单",
                "金额、地址、日期范围、颜色",
                "数据库连接",
                "API 响应",
            ],
            answer: 1,
            rationale: "金额（Money）、地址（Address）、日期范围（DateRange）、颜色（Color）是典型的值对象。",
        },
        {
            id: "w5-2-q9",
            question: "如何修改值对象？",
            options: [
                "直接修改属性",
                "创建新实例替换",
                "使用 setter 方法",
                "删除后重建",
            ],
            answer: 1,
            rationale: "值对象是不可变的，修改时应创建新实例而非改变现有实例。",
        },
        {
            id: "w5-2-q10",
            question: "为什么值对象不应该有单独的数据库表？",
            options: [
                "性能问题",
                "单独的表会赋予人工标识，违背值对象的本质",
                "数据库不支持",
                "维护困难",
            ],
            answer: 1,
            rationale: "单独的表会通过外键等方式赋予人工标识，违背了值对象没有固有标识的本质。",
        },
        {
            id: "w5-2-q11",
            question: "在 ORM 中正确映射值对象需要什么？",
            options: [
                "默认配置即可",
                "特殊配置，避免生成不必要的外键关系",
                "不能使用 ORM",
                "使用 NoSQL 数据库",
            ],
            answer: 1,
            rationale: "在 ORM 中正确映射值对象需要特殊配置，避免生成不必要的外键关系。",
        },
        {
            id: "w5-2-q12",
            question: "值对象的验证逻辑应该放在哪里？",
            options: [
                "外部服务",
                "构造函数或工厂方法",
                "数据库触发器",
                "UI 层",
            ],
            answer: 1,
            rationale: "验证逻辑应该放在构造函数/工厂方法中，确保值对象总是有效的。",
        },
    ],
    "w5-3": [
        {
            id: "w5-3-q1",
            question: "为什么应该优先使用值对象？",
            options: [
                "代码更少",
                "不可变且轻量，更容易测试、推理和并发处理",
                "数据库性能更好",
                "框架支持更好",
            ],
            answer: 1,
            rationale: "'Always prefer value objects over entities'——值对象不可变且轻量，更容易测试、推理和并发处理。",
        },
        {
            id: "w5-3-q2",
            question: "判断概念是实体还是值对象的核心问题是什么？",
            options: [
                "代码复杂度",
                "你关心的是'哪一个'（实体）还是'是什么'（值对象）",
                "数据库表数量",
                "团队规模",
            ],
            answer: 1,
            rationale: "核心问题：你关心的是'哪一个'（实体）还是'是什么'（值对象）？",
        },
        {
            id: "w5-3-q3",
            question: "同一概念在不同上下文可能有不同建模方式吗？",
            options: [
                "不可能",
                "可以——如订单中的产品是引用（ID），产品目录中是实体",
                "必须统一",
                "只有值对象可以",
            ],
            answer: 1,
            rationale: "同一概念在不同上下文可能是实体或值对象——如订单中的产品是引用（实体 ID），产品目录中是实体。",
        },
        {
            id: "w5-3-q4",
            question: "什么是常见的重构机会？",
            options: [
                "将实体变成服务",
                "发现被错误建模为实体的值对象",
                "删除所有值对象",
                "合并所有实体",
            ],
            answer: 1,
            rationale: "发现被错误建模为实体的值对象是常见的重构机会。",
        },
        {
            id: "w5-3-q5",
            question: "什么情况下值对象可能需要变成实体？",
            options: [
                "代码太长时",
                "需要跟踪历史变化时",
                "数据库要求时",
                "永远不需要",
            ],
            answer: 1,
            rationale: "随着业务发展，当需要跟踪值的历史变化时，值对象可能需要变成实体。",
        },
        {
            id: "w5-3-q6",
            question: "团队对实体/值对象理解不一致时应该怎么做？",
            options: [
                "忽略差异",
                "建立共识，统一术语和判断标准",
                "让每个人用自己的理解",
                "不使用这些概念",
            ],
            answer: 1,
            rationale: "团队成员对实体/值对象的理解可能不一致，需要建立共识。",
        },
        {
            id: "w5-3-q7",
            question: "遗留代码中的错误建模应该如何处理？",
            options: [
                "立即全部重构",
                "谨慎渐进地重构",
                "保持不变",
                "删除重写",
            ],
            answer: 1,
            rationale: "遗留系统中往往有大量错误的建模，重构需要谨慎渐进地进行。",
        },
        {
            id: "w5-3-q8",
            question: "如何验证实体/值对象的建模决策？",
            options: [
                "只看代码",
                "与领域专家讨论概念的本质",
                "看数据库设计",
                "不需要验证",
            ],
            answer: 1,
            rationale: "与领域专家讨论这些概念的本质是验证建模决策的重要方式。",
        },
        {
            id: "w5-3-q9",
            question: "边界情况下（实体和值对象不明显）应该怎么做？",
            options: [
                "随便选一个",
                "深入业务分析，理解概念的本质",
                "总是选实体",
                "总是选值对象",
            ],
            answer: 1,
            rationale: "有些概念在实体和值对象之间不明显，需要深入业务分析。",
        },
        {
            id: "w5-3-q10",
            question: "重构实体为值对象前应该做什么？",
            options: [
                "直接修改",
                "选择一个简单的案例进行重构实验",
                "等待项目结束",
                "不需要准备",
            ],
            answer: 1,
            rationale: "应该选择一个简单的案例进行重构实验，验证方法后再推广。",
        },
        {
            id: "w5-3-q11",
            question: "为什么要记录重构决策和理由？",
            options: [
                "为了通过审计",
                "帮助团队理解设计意图，便于未来维护",
                "增加文档量",
                "没有必要",
            ],
            answer: 1,
            rationale: "记录重构决策和理由帮助团队理解设计意图，便于未来维护和演进。",
        },
        {
            id: "w5-3-q12",
            question: "用'你关心哪一个还是是什么'的问题检验对象的目的是什么？",
            options: [
                "确定数据库表",
                "确定概念应该建模为实体还是值对象",
                "确定代码位置",
                "确定团队分工",
            ],
            answer: 1,
            rationale: "这个问题帮助确定概念应该建模为实体（关心哪一个）还是值对象（关心是什么）。",
        },
    ],
    "w5-4": [
        {
            id: "w5-4-q1",
            question: "实体的相等性判断通常基于什么？",
            options: [
                "所有属性",
                "标识符（ID）",
                "创建时间",
                "类型",
            ],
            answer: 1,
            rationale: "实体需要实现标识比较、相等性判断、哈希码生成，通常基于 ID 而非属性。",
        },
        {
            id: "w5-4-q2",
            question: "值对象的相等性判断基于什么？",
            options: [
                "ID",
                "结构相等性（所有属性值）",
                "创建时间",
                "随机",
            ],
            answer: 1,
            rationale: "值对象需要实现结构相等性，基于所有属性值的比较。",
        },
        {
            id: "w5-4-q3",
            question: "哪些现代语言特性提供值对象的原生支持？",
            options: [
                "普通类",
                "Java Record、C# record、Kotlin data class",
                "接口",
                "抽象类",
            ],
            answer: 1,
            rationale: "现代语言如 Java Record、C# record、Kotlin data class 提供值对象的原生支持。",
        },
        {
            id: "w5-4-q4",
            question: "业务规则应该放在哪里？",
            options: [
                "只在服务层",
                "实体和值对象内部",
                "只在控制器",
                "只在数据库",
            ],
            answer: 1,
            rationale: "业务规则应该放在实体和值对象内部，而非外部服务中。",
        },
        {
            id: "w5-4-q5",
            question: "ORM 框架对值对象的常见限制是什么？",
            options: [
                "性能问题",
                "支持有限，需要变通方案",
                "不能存储",
                "必须有 ID",
            ],
            answer: 1,
            rationale: "某些 ORM 框架对值对象的支持有限，需要变通方案。",
        },
        {
            id: "w5-4-q6",
            question: "值对象的验证逻辑应该确保什么？",
            options: [
                "性能最优",
                "对象总是有效的",
                "代码最短",
                "没有依赖",
            ],
            answer: 1,
            rationale: "验证逻辑应该放在构造函数/工厂方法中，确保对象总是有效的。",
        },
        {
            id: "w5-4-q7",
            question: "实体中的值对象集合需要特别处理什么？",
            options: [
                "排序",
                "添加、删除、替换的语义以及变更检测",
                "分页",
                "缓存",
            ],
            answer: 1,
            rationale: "实体中的值对象集合需要特别的相等性和变更检测逻辑。",
        },
        {
            id: "w5-4-q8",
            question: "重构贫血模型的目标是什么？",
            options: [
                "减少代码",
                "将业务逻辑移入领域对象",
                "增加服务",
                "简化数据库",
            ],
            answer: 1,
            rationale: "重构贫血模型的目标是将业务逻辑移入领域对象，实现充血模型。",
        },
        {
            id: "w5-4-q9",
            question: "为实体和值对象编写单元测试应该验证什么？",
            options: [
                "只验证属性",
                "标识比较、相等性、业务逻辑",
                "只验证性能",
                "只验证序列化",
            ],
            answer: 1,
            rationale: "单元测试应该验证标识比较逻辑、相等性判断、业务逻辑等。",
        },
        {
            id: "w5-4-q10",
            question: "实体/值对象的序列化需要注意什么？",
            options: [
                "不需要注意",
                "特别处理以保持不变性和标识语义",
                "只用默认配置",
                "不能序列化",
            ],
            answer: 1,
            rationale: "实体和值对象的序列化/反序列化需要特别处理以保持不变性和标识语义。",
        },
        {
            id: "w5-4-q11",
            question: "ORM 配置值对象时的目标是什么？",
            options: [
                "创建更多表",
                "将值对象内联到实体表，避免单独的表",
                "使用 NoSQL",
                "不使用 ORM",
            ],
            answer: 1,
            rationale: "配置 ORM 将值对象内联到实体表，而非创建单独的表。",
        },
        {
            id: "w5-4-q12",
            question: "实现完整实体类的关键要素是什么？",
            options: [
                "尽量多的属性",
                "标识比较、生命周期方法、业务逻辑",
                "尽量少的代码",
                "只有 getter/setter",
            ],
            answer: 1,
            rationale: "完整的实体类应包含标识比较、生命周期方法、以及封装的业务逻辑。",
        },
    ],
}
