import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week7Guides: Record<string, LessonGuide> = {
    "w7-1": {
        lessonId: "w7-1",
        background: [
            "【仓储定义】Martin Fowler：仓储'mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects'——在领域层和数据映射层之间用类集合接口调解。",
            "【对象导向抽象】仓储封装数据库操作，通过类集合接口呈现，而非暴露原始数据访问代码。",
            "【关注点分离】仓储建立了'a clean separation and one-way dependency between the domain and data mapping layers'——领域层与数据层的单向依赖。",
            "【持久化无关】Microsoft 文档：仓储模式'keeps persistence concerns outside the domain model'——将持久化关注点排除在领域模型之外。",
            "【每个聚合根一个仓储】规则：为每个聚合或聚合根创建一个仓储类，仓储与聚合根保持一对一关系，控制不变量和事务一致性。",
        ],
        keyDifficulties: [
            "【查询规格对象】客户端不直接构建查询，而是'construct query specifications declaratively and submit them to Repository'——声明式构建查询规格。",
            "【查询与更新分离】更新必须通过仓储以维护事务一致性，但查询可以使用替代渠道（CQRS 模式）。",
            "【泛型接口约束】使用泛型基接口强制约束：'where T : IAggregateRoot'确保只有聚合根才能有仓储。",
            "【非强制模式】仓储不是 DDD 设计的必须，一些架构师更倾向于直接访问持久化层（尤其在 CQRS 中）。",
        ],
        handsOnPath: [
            "定义聚合根的标记接口 IAggregateRoot",
            "创建泛型仓储接口 IRepository<T> where T : IAggregateRoot",
            "为核心聚合实现具体仓储接口（如 IOrderRepository）",
            "实现仓储的内存版本用于单元测试",
            "使用 ORM（如 EF Core）实现生产仓储",
            "编写测试验证仓储的 CRUD 操作",
        ],
        selfCheck: [
            "什么是仓储模式？它的核心作用是什么？",
            "为什么说仓储提供类集合接口？",
            "仓储与聚合根是什么关系？",
            "查询规格对象（Query Specification）的作用是什么？",
            "仓储模式如何支持单元测试？",
        ],
        extensions: [
            "学习 Specification Pattern 与仓储结合",
            "了解仓储在 CQRS 架构中的角色变化",
            "研究 Repository 的装饰器模式（缓存、日志）",
            "探索 Generic Repository vs Specific Repository 的争论",
        ],
        sourceUrls: [
            "https://martinfowler.com/eaaCatalog/repository.html",
            "https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design",
        ],
    },
    "w7-2": {
        lessonId: "w7-2",
        background: [
            "【基础设施层实现】仓储接口定义在领域层，实现在基础设施层，体现依赖倒置原则。",
            "【Unit of Work 模式】Microsoft 文档：'A single transaction containing multiple insert, update, or delete operations'——单事务包含多个操作。",
            "【EF Core 集成】DbContext.SaveChanges() 在单事务中提交所有挂起的变更，实现 Unit of Work 模式。",
            "【ORM 封装】仓储封装 ORM 框架的复杂性，使领域层不依赖具体持久化技术。",
            "【查询优化】可以使用 Dapper 等轻量 ORM 优化读取操作，仓储不必只用一种技术。",
        ],
        keyDifficulties: [
            "【事务边界】Unit of Work 将多个更新组合为单事务，减少事务阻塞，提高性能。",
            "【延迟加载陷阱】ORM 的延迟加载可能导致 N+1 查询问题，需要显式预加载。",
            "【并发控制】仓储实现需要处理乐观锁、版本控制等并发问题。",
            "【领域模型污染】避免 ORM 的映射需求污染领域模型（如导航属性、外键属性）。",
        ],
        handsOnPath: [
            "创建 DbContext 作为 Unit of Work 实现",
            "配置实体映射，保护领域模型纯净性",
            "实现仓储的增删改查方法",
            "添加乐观锁支持（版本号或时间戳）",
            "优化查询，使用 Include 预加载相关数据",
            "编写集成测试验证持久化逻辑",
        ],
        selfCheck: [
            "Unit of Work 模式的作用是什么？",
            "仓储接口和实现应该分别放在哪一层？为什么？",
            "如何避免 ORM 污染领域模型？",
            "延迟加载有什么风险？如何避免？",
            "仓储与 DAO 模式有什么区别？",
        ],
        extensions: [
            "学习 EF Core 的值对象映射（Owned Types）",
            "了解 Dapper 与 EF Core 的混合使用",
            "研究 NoSQL 数据库的仓储实现",
            "探索仓储的缓存策略实现",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design",
        ],
    },
    "w7-3": {
        lessonId: "w7-3",
        background: [
            "【工厂定义】DDD 中的工厂负责创建新对象并验证它们，帮助识别和分离创建功能与领域对象的其他部分。",
            "【复杂创建封装】工厂是用于封装复杂领域对象实例化逻辑的创建模式，让客户端无需了解构造细节。",
            "【DDD 工厂 vs GoF 工厂】GoF 模式关注技术层面，DDD 工厂关注语义领域模型层面，意图和实现都不同。",
            "【工厂位置选择】工厂可以放在实体/值对象本身（工厂方法）或独立对象中，取决于创建逻辑的复杂度。",
            "【领域事件处理】工厂方法模式解决了'domain events being created every time the object is constructed'的问题——只在显式创建时触发事件。",
        ],
        keyDifficulties: [
            "【何时使用工厂】复杂或需要领域知识的创建过程使用工厂，简单聚合可以直接用构造函数。",
            "【EF Core 兼容】私有无参构造函数允许 EF Core 从数据库 hydrate 对象，公共静态工厂方法处理应用层创建。",
            "【不变量验证】工厂方法封装业务规则，确保对象在持久化操作前的构造一致性。",
            "【工厂所属层】工厂应该是领域层的一部分，而非应用层或基础设施层。",
        ],
        handsOnPath: [
            "识别需要工厂的复杂聚合",
            "创建私有无参构造函数支持 ORM",
            "实现公共静态工厂方法 Create()",
            "在工厂方法中添加参数验证",
            "在工厂方法中触发领域事件",
            "为工厂方法编写单元测试",
        ],
        selfCheck: [
            "什么时候应该使用工厂模式？",
            "DDD 工厂与 GoF 工厂模式有什么区别？",
            "工厂方法如何处理领域事件？",
            "工厂应该属于哪一层？",
            "如何让工厂与 EF Core 兼容？",
        ],
        extensions: [
            "学习 Builder 模式与 Factory 的结合",
            "了解 Abstract Factory 在 DDD 中的应用",
            "研究工厂的依赖注入策略",
            "探索重构：从构造函数到工厂方法",
        ],
        sourceUrls: [
            "https://www.dandoescode.com/blog/domain-driven-design-patterns-for-aggregate-creation-mastery",
        ],
    },
    "w7-4": {
        lessonId: "w7-4",
        background: [
            "【生命周期管理】仓储和工厂协作管理聚合的完整生命周期：工厂负责创建，仓储负责持久化和检索。",
            "【创建流程】应用服务使用工厂创建新聚合 → 调用仓储保存 → Unit of Work 提交事务。",
            "【检索流程】应用服务调用仓储检索聚合 → 仓储从数据库加载 → 返回重建的聚合对象。",
            "【更新流程】检索聚合 → 调用聚合方法修改状态 → 仓储/Unit of Work 保存变更。",
            "【删除流程】仓储提供删除方法，或通过软删除标记实现逻辑删除。",
        ],
        keyDifficulties: [
            "【仓储不调用工厂】从数据库重建对象时，仓储直接通过 ORM 重建，不调用工厂（避免触发领域事件）。",
            "【事务协调】多个仓储操作需要在同一 Unit of Work 中协调，确保事务一致性。",
            "【依赖注入】仓储和工厂都应通过依赖注入获取，便于测试和替换。",
            "【聚合边界】仓储操作只能针对聚合根，内部实体的访问必须通过聚合根。",
        ],
        handsOnPath: [
            "实现完整的订单创建流程：Factory.Create() → Repository.Add() → UoW.SaveChanges()",
            "实现订单检索流程：Repository.GetById()",
            "实现订单更新流程：Get → Modify → SaveChanges",
            "配置依赖注入容器注册仓储和工厂",
            "编写集成测试覆盖完整生命周期",
            "实现软删除机制",
        ],
        selfCheck: [
            "仓储和工厂如何协作管理聚合生命周期？",
            "为什么从数据库重建对象时不调用工厂？",
            "多个仓储操作如何保证事务一致性？",
            "删除聚合有哪些策略？",
            "应用服务在生命周期管理中的角色是什么？",
        ],
        extensions: [
            "学习 Saga 模式处理跨聚合操作",
            "了解领域事件在生命周期中的应用",
            "研究聚合快照与事件溯源",
            "探索微服务中的分布式仓储",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design",
            "https://www.dandoescode.com/blog/domain-driven-design-patterns-for-aggregate-creation-mastery",
        ],
    },
}

export const week7Quizzes: Record<string, QuizQuestion[]> = {
    "w7-1": [
        {
            id: "w7-1-q1",
            question: "根据 Martin Fowler 的定义，仓储模式的核心作用是什么？",
            options: [
                "直接访问数据库",
                "在领域层和数据映射层之间用类集合接口调解",
                "管理事务",
                "缓存数据",
            ],
            answer: 1,
            rationale: "Fowler 定义仓储'mediates between the domain and data mapping layers using a collection-like interface'。",
        },
        {
            id: "w7-1-q2",
            question: "关于仓储与聚合根的关系，以下哪个说法是正确的？",
            options: [
                "每个实体都有一个仓储",
                "每个聚合根一个仓储",
                "多个聚合根共享一个仓储",
                "仓储与聚合无关",
            ],
            answer: 1,
            rationale: "规则：为每个聚合或聚合根创建一个仓储类，仓储与聚合根保持一对一关系。",
        },
        {
            id: "w7-1-q3",
            question: "如何使用泛型接口约束确保只有聚合根才能有仓储？",
            options: [
                "where T : IEntity",
                "where T : IAggregateRoot",
                "where T : class",
                "不需要约束",
            ],
            answer: 1,
            rationale: "使用泛型约束 'where T : IAggregateRoot' 确保只有聚合根才能有仓储。",
        },
        {
            id: "w7-1-q4",
            question: "客户端如何与仓储交互进行查询？",
            options: [
                "直接编写 SQL",
                "声明式构建查询规格并提交给仓储",
                "调用数据库存储过程",
                "使用原始 ADO.NET",
            ],
            answer: 1,
            rationale: "客户端'construct query specifications declaratively and submit them to Repository'。",
        },
        {
            id: "w7-1-q5",
            question: "仓储模式如何支持单元测试？",
            options: [
                "不支持单元测试",
                "允许使用模拟仓储实现，消除数据库依赖",
                "必须使用真实数据库",
                "只能进行集成测试",
            ],
            answer: 1,
            rationale: "仓储模式允许用假数据的模拟仓储实现，消除数据库依赖，支持快速并行测试。",
        },
        {
            id: "w7-1-q6",
            question: "关于仓储模式的必要性，以下哪个说法是正确的？",
            options: [
                "DDD 必须使用仓储模式",
                "仓储不是 DDD 设计的必须，一些架构师更倾向于直接访问持久化层",
                "只有微服务才需要仓储",
                "仓储只用于读取操作",
            ],
            answer: 1,
            rationale: "仓储不是 DDD 设计的必须，一些架构师更倾向于直接访问持久化层（尤其在 CQRS 中）。",
        },
        {
            id: "w7-1-q7",
            question: "在 CQRS 模式中，查询操作可以如何处理？",
            options: [
                "必须通过仓储",
                "可以使用替代渠道（如直接 SQL/Dapper）",
                "不允许查询",
                "只能使用存储过程",
            ],
            answer: 1,
            rationale: "更新必须通过仓储以维护事务一致性，但查询可以使用替代渠道（CQRS 模式）。",
        },
        {
            id: "w7-1-q8",
            question: "仓储建立的依赖方向是什么？",
            options: [
                "领域层依赖数据层",
                "领域层与数据层的单向依赖（数据层依赖领域层）",
                "双向依赖",
                "没有依赖关系",
            ],
            answer: 1,
            rationale: "仓储建立了'a clean separation and one-way dependency between the domain and data mapping layers'。",
        },
        {
            id: "w7-1-q9",
            question: "仓储接口应该定义在哪一层？",
            options: [
                "基础设施层",
                "领域层",
                "应用层",
                "表现层",
            ],
            answer: 1,
            rationale: "仓储接口定义在领域层，实现在基础设施层，体现依赖倒置原则。",
        },
        {
            id: "w7-1-q10",
            question: "仓储模式相比传统 DAL 的优势是什么？",
            options: [
                "代码更少",
                "高抽象、易扩展、关注点分离、支持装饰器/代理",
                "性能更好",
                "不需要数据库",
            ],
            answer: 1,
            rationale: "仓储模式提供高抽象、易扩展性、关注点封装（缓存、日志）、通过 Unit of Work 协调事务。",
        },
        {
            id: "w7-1-q11",
            question: "仓储的'类集合接口'意味着什么？",
            options: [
                "必须返回列表",
                "提供类似 Add、Remove、Find 等集合操作，隐藏底层持久化细节",
                "只支持数组",
                "必须使用 List<T>",
            ],
            answer: 1,
            rationale: "仓储提供'类似集合的接口'，支持 Add/Remove 对象，提供'更面向对象的持久化层视图'。",
        },
        {
            id: "w7-1-q12",
            question: "仓储模式特别适用于什么场景？",
            options: [
                "简单的 CRUD 应用",
                "复杂领域模型需要从数据库细节中抽象的系统",
                "只有单个实体的系统",
                "不需要持久化的系统",
            ],
            answer: 1,
            rationale: "仓储模式在系统有复杂领域模型需要从数据库细节中抽象时特别有价值。",
        },
    ],
    "w7-2": [
        {
            id: "w7-2-q1",
            question: "Unit of Work 模式的定义是什么？",
            options: [
                "一个数据库连接",
                "单事务包含多个 insert、update 或 delete 操作",
                "一个仓储实例",
                "一个领域服务",
            ],
            answer: 1,
            rationale: "Unit of Work 是'A single transaction containing multiple insert, update, or delete operations'。",
        },
        {
            id: "w7-2-q2",
            question: "在 EF Core 中如何实现 Unit of Work 模式？",
            options: [
                "每个操作单独事务",
                "DbContext.SaveChanges() 在单事务中提交所有挂起的变更",
                "使用分布式事务",
                "手动管理连接",
            ],
            answer: 1,
            rationale: "DbContext.SaveChanges() 在单事务中提交所有挂起的变更，实现 Unit of Work 模式。",
        },
        {
            id: "w7-2-q3",
            question: "仓储实现应该放在哪一层？",
            options: [
                "领域层",
                "基础设施层",
                "应用层",
                "表现层",
            ],
            answer: 1,
            rationale: "仓储接口定义在领域层，实现在基础设施层，体现依赖倒置原则。",
        },
        {
            id: "w7-2-q4",
            question: "Unit of Work 模式有什么优势？",
            options: [
                "增加事务数量",
                "将多个更新组合为单事务，减少阻塞，提高性能",
                "简化代码",
                "减少内存使用",
            ],
            answer: 1,
            rationale: "Unit of Work 将多个更新组合为单事务，减少事务阻塞，提高应用性能，防止不一致。",
        },
        {
            id: "w7-2-q5",
            question: "ORM 延迟加载有什么风险？",
            options: [
                "内存不足",
                "N+1 查询问题",
                "事务超时",
                "数据丢失",
            ],
            answer: 1,
            rationale: "ORM 的延迟加载可能导致 N+1 查询问题，需要显式预加载（如 Include）避免。",
        },
        {
            id: "w7-2-q6",
            question: "如何避免 ORM 污染领域模型？",
            options: [
                "不使用 ORM",
                "使用映射配置（Fluent API）分离持久化关注点",
                "在实体中添加数据库字段",
                "使用原始 SQL",
            ],
            answer: 1,
            rationale: "使用 ORM 的映射配置（如 Fluent API）可以分离持久化关注点，避免在领域模型中添加导航属性、外键等 ORM 特定代码。",
        },
        {
            id: "w7-2-q7",
            question: "仓储与 DAO 模式的主要区别是什么？",
            options: [
                "没有区别",
                "仓储提供更高级的抽象、支持装饰器扩展、更好的关注点分离",
                "DAO 更高级",
                "仓储只用于读取",
            ],
            answer: 1,
            rationale: "仓储比 DAO 提供更高级的抽象，易于扩展（装饰器/代理），更好的关注点封装和事务协调。",
        },
        {
            id: "w7-2-q8",
            question: "如何处理仓储中的并发问题？",
            options: [
                "忽略并发",
                "实现乐观锁（版本号或时间戳）",
                "使用全局锁",
                "禁止并发访问",
            ],
            answer: 1,
            rationale: "仓储实现需要处理乐观锁、版本控制等并发问题，通常使用版本号或时间戳实现。",
        },
        {
            id: "w7-2-q9",
            question: "在 CQRS 架构中，读取操作可以如何优化？",
            options: [
                "只能使用仓储",
                "可以使用 Dapper 等轻量 ORM 直接查询",
                "必须使用存储过程",
                "不需要优化",
            ],
            answer: 1,
            rationale: "在 CQRS 中，读取操作可以使用 Dapper 等轻量 ORM 优化，仓储不必只用一种技术。",
        },
        {
            id: "w7-2-q10",
            question: "仓储测试的最佳实践是什么？",
            options: [
                "只使用真实数据库测试",
                "使用内存数据库或模拟仓储进行单元测试，真实数据库进行集成测试",
                "不需要测试仓储",
                "只进行手动测试",
            ],
            answer: 1,
            rationale: "仓储模式支持使用模拟仓储进行单元测试，使用内存数据库或真实数据库进行集成测试。",
        },
        {
            id: "w7-2-q11",
            question: "EF Core 的 Owned Types 用于什么？",
            options: [
                "定义外键",
                "映射值对象，将其内联到实体表中",
                "创建索引",
                "定义存储过程",
            ],
            answer: 1,
            rationale: "EF Core 的 Owned Types 用于映射值对象，将值对象的属性内联到所属实体的表中。",
        },
        {
            id: "w7-2-q12",
            question: "仓储实现中的 Include 方法用于什么？",
            options: [
                "增加记录",
                "预加载相关数据，避免 N+1 查询",
                "过滤数据",
                "排序数据",
            ],
            answer: 1,
            rationale: "Include 方法用于预加载（Eager Loading）相关数据，避免延迟加载导致的 N+1 查询问题。",
        },
    ],
    "w7-3": [
        {
            id: "w7-3-q1",
            question: "DDD 中工厂模式的主要职责是什么？",
            options: [
                "持久化对象",
                "创建新对象并验证它们",
                "查询数据",
                "删除对象",
            ],
            answer: 1,
            rationale: "DDD 中的工厂负责创建新对象并验证它们，帮助识别和分离创建功能与领域对象的其他部分。",
        },
        {
            id: "w7-3-q2",
            question: "DDD 工厂与 GoF 工厂模式的主要区别是什么？",
            options: [
                "没有区别",
                "GoF 关注技术层面，DDD 工厂关注语义领域模型层面",
                "GoF 更高级",
                "DDD 工厂只用于值对象",
            ],
            answer: 1,
            rationale: "GoF 模式关注技术层面，DDD 工厂关注语义领域模型层面，意图和实现都不同。",
        },
        {
            id: "w7-3-q3",
            question: "工厂方法模式如何解决领域事件问题？",
            options: [
                "不触发领域事件",
                "只在显式创建时触发事件，从数据库重建时不触发",
                "每次都触发事件",
                "领域事件与工厂无关",
            ],
            answer: 1,
            rationale: "工厂方法解决了'domain events being created every time the object is constructed'的问题——只在显式创建时触发事件。",
        },
        {
            id: "w7-3-q4",
            question: "什么时候应该使用工厂模式？",
            options: [
                "所有对象都用工厂",
                "复杂或需要领域知识的创建过程",
                "只用于值对象",
                "只用于实体",
            ],
            answer: 1,
            rationale: "复杂或需要领域知识的创建过程使用工厂，简单聚合可以直接用构造函数。",
        },
        {
            id: "w7-3-q5",
            question: "工厂应该属于哪一层？",
            options: [
                "基础设施层",
                "领域层",
                "应用层",
                "表现层",
            ],
            answer: 1,
            rationale: "工厂应该是领域层的一部分，而非应用层或基础设施层，因为它们包含领域知识。",
        },
        {
            id: "w7-3-q6",
            question: "如何让工厂与 EF Core 兼容？",
            options: [
                "不使用工厂",
                "私有无参构造函数供 EF Core 使用，公共静态工厂方法供应用使用",
                "只使用公共构造函数",
                "使用反射",
            ],
            answer: 1,
            rationale: "私有无参构造函数允许 EF Core 从数据库 hydrate 对象，公共静态工厂方法处理应用层创建。",
        },
        {
            id: "w7-3-q7",
            question: "工厂可以放在什么位置？",
            options: [
                "只能放在独立类中",
                "可以放在实体/值对象本身（工厂方法）或独立对象中",
                "只能放在仓储中",
                "只能放在应用服务中",
            ],
            answer: 1,
            rationale: "工厂可以放在实体/值对象本身（工厂方法）或独立对象中，取决于创建逻辑的复杂度。",
        },
        {
            id: "w7-3-q8",
            question: "工厂方法通常如何命名？",
            options: [
                "Constructor()",
                "Create() 或 CreateXxx()",
                "Get()",
                "Find()",
            ],
            answer: 1,
            rationale: "工厂方法通常命名为 Create() 或 CreateXxx()，清晰表达创建新对象的意图。",
        },
        {
            id: "w7-3-q9",
            question: "工厂方法中应该做什么？",
            options: [
                "只创建对象",
                "验证参数、初始化对象、添加领域事件",
                "持久化对象",
                "发送通知",
            ],
            answer: 1,
            rationale: "工厂方法封装业务规则：验证参数、初始化对象、确保对象在持久化前的构造一致性、添加领域事件。",
        },
        {
            id: "w7-3-q10",
            question: "相比构造函数，工厂方法的优势是什么？",
            options: [
                "代码更少",
                "可以有多个创建方法、可以返回 null、可以包含复杂逻辑",
                "性能更好",
                "不需要参数",
            ],
            answer: 1,
            rationale: "工厂方法可以有多个不同命名的创建方法、可以返回子类型或 null、可以包含复杂验证逻辑。",
        },
        {
            id: "w7-3-q11",
            question: "工厂模式与 Builder 模式的关系是什么？",
            options: [
                "是同一个模式",
                "Builder 可以与 Factory 结合，处理更复杂的分步构建场景",
                "互相排斥",
                "Builder 替代 Factory",
            ],
            answer: 1,
            rationale: "Builder 模式可以与 Factory 结合使用，Builder 处理复杂的分步构建，Factory 返回最终对象。",
        },
        {
            id: "w7-3-q12",
            question: "工厂方法在领域模型中达到了什么平衡？",
            options: [
                "性能与内存",
                "表达性、内聚性和领域事件处理之间的平衡",
                "安全与便利",
                "简单与复杂",
            ],
            answer: 1,
            rationale: "工厂方法'strikes a balance between expressiveness, cohesion, and domain event handling'——表达性、内聚性和领域事件处理的平衡。",
        },
    ],
    "w7-4": [
        {
            id: "w7-4-q1",
            question: "仓储和工厂如何协作管理聚合生命周期？",
            options: [
                "工厂负责一切",
                "工厂负责创建，仓储负责持久化和检索",
                "仓储负责一切",
                "它们不协作",
            ],
            answer: 1,
            rationale: "仓储和工厂协作管理聚合的完整生命周期：工厂负责创建，仓储负责持久化和检索。",
        },
        {
            id: "w7-4-q2",
            question: "从数据库重建对象时应该调用工厂吗？",
            options: [
                "必须调用工厂",
                "不应该调用工厂（避免触发领域事件）",
                "取决于情况",
                "只在特定条件下调用",
            ],
            answer: 1,
            rationale: "从数据库重建对象时，仓储直接通过 ORM 重建，不调用工厂（避免触发领域事件）。",
        },
        {
            id: "w7-4-q3",
            question: "聚合的创建流程是什么？",
            options: [
                "Repository.Add() → Factory.Create()",
                "Factory.Create() → Repository.Add() → UoW.SaveChanges()",
                "直接调用构造函数",
                "从数据库复制",
            ],
            answer: 1,
            rationale: "创建流程：应用服务使用工厂创建新聚合 → 调用仓储保存 → Unit of Work 提交事务。",
        },
        {
            id: "w7-4-q4",
            question: "多个仓储操作如何保证事务一致性？",
            options: [
                "每个仓储单独事务",
                "在同一 Unit of Work 中协调",
                "使用分布式事务",
                "不需要事务",
            ],
            answer: 1,
            rationale: "多个仓储操作需要在同一 Unit of Work 中协调，确保事务一致性。",
        },
        {
            id: "w7-4-q5",
            question: "应用服务在聚合生命周期管理中的角色是什么？",
            options: [
                "包含业务逻辑",
                "协调工厂、仓储和 Unit of Work，编排操作流程",
                "直接访问数据库",
                "管理用户界面",
            ],
            answer: 1,
            rationale: "应用服务协调工厂、仓储和 Unit of Work，编排操作流程，但不包含业务逻辑。",
        },
        {
            id: "w7-4-q6",
            question: "删除聚合有哪些策略？",
            options: [
                "只有物理删除",
                "物理删除（Repository.Remove）或软删除（设置删除标记）",
                "只有软删除",
                "不能删除聚合",
            ],
            answer: 1,
            rationale: "仓储提供删除方法（物理删除），或通过软删除标记实现逻辑删除，保留历史记录。",
        },
        {
            id: "w7-4-q7",
            question: "仓储和工厂应该如何获取？",
            options: [
                "直接 new 创建",
                "通过依赖注入获取，便于测试和替换",
                "使用单例模式",
                "静态方法访问",
            ],
            answer: 1,
            rationale: "仓储和工厂都应通过依赖注入获取，便于测试和替换。",
        },
        {
            id: "w7-4-q8",
            question: "更新聚合的标准流程是什么？",
            options: [
                "直接修改数据库",
                "Repository.GetById() → 调用聚合方法 → UoW.SaveChanges()",
                "创建新聚合替换",
                "使用 SQL 更新",
            ],
            answer: 1,
            rationale: "更新流程：检索聚合（Repository.GetById）→ 调用聚合方法修改状态 → 仓储/Unit of Work 保存变更。",
        },
        {
            id: "w7-4-q9",
            question: "为什么仓储只能针对聚合根操作？",
            options: [
                "技术限制",
                "内部实体的访问必须通过聚合根以保护不变量",
                "简化代码",
                "性能考虑",
            ],
            answer: 1,
            rationale: "仓储操作只能针对聚合根，内部实体的访问必须通过聚合根，以保护聚合的不变量。",
        },
        {
            id: "w7-4-q10",
            question: "领域事件在聚合生命周期中的作用是什么？",
            options: [
                "没有作用",
                "在创建和状态变更时通知其他组件",
                "只用于日志",
                "只用于调试",
            ],
            answer: 1,
            rationale: "领域事件在聚合创建和状态变更时触发，通知其他组件进行相应处理。",
        },
        {
            id: "w7-4-q11",
            question: "跨聚合操作应该如何处理？",
            options: [
                "在同一事务中修改多个聚合",
                "使用 Saga 模式或领域事件实现最终一致性",
                "忽略一致性",
                "合并为一个聚合",
            ],
            answer: 1,
            rationale: "跨聚合操作应使用 Saga 模式或领域事件实现最终一致性，而非在同一事务中修改多个聚合。",
        },
        {
            id: "w7-4-q12",
            question: "聚合快照在事件溯源中的作用是什么？",
            options: [
                "备份数据",
                "缓存聚合状态，避免从大量事件重建",
                "替代事件",
                "测试用途",
            ],
            answer: 1,
            rationale: "聚合快照缓存聚合在某个时间点的状态，避免每次都从大量历史事件重建聚合。",
        },
    ],
}
