import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week16Guides: Record<string, LessonGuide> = {
    "w16-1": {
        lessonId: "w16-1",
        background: [
            "【子域分解】'Define services corresponding to Domain-Driven Design (DDD) subdomains'——通过 DDD 的子域来定义微服务边界。",
            "【三类子域】核心子域（Core）是业务关键差异化部分；支持子域（Supporting）是相关但非差异化部分；通用子域（Generic）是非业务特定部分。",
            "【稳定架构】子域分解提供稳定的架构，因为子域相对稳定，不像业务能力可能频繁变化。",
            "【团队自治】子域分解形成跨职能、自治的开发团队，确保服务的内聚性和松耦合。",
            "【非一对一映射】限界上下文是服务边界的自然候选，但不是与微服务一对一映射。",
        ],
        keyDifficulties: [
            "【边界划分】识别正确的子域边界需要深入理解业务，迭代过程中逐步明确。",
            "【粒度选择】微服务粒度太细会增加运维复杂度，太粗会失去微服务优势。",
            "【数据所有权】确定每个微服务的数据所有权，避免数据跨服务共享。",
            "【演进策略】从单体到微服务的演进需要渐进式策略，不能一步到位。",
        ],
        handsOnPath: [
            "分析组织结构和业务领域",
            "识别核心、支持和通用子域",
            "将子域映射到潜在的微服务",
            "评估每个服务的边界和数据所有权",
            "设计服务间的通信模式",
            "制定渐进式迁移计划",
        ],
        selfCheck: [
            "什么是子域分解模式？",
            "三类子域各有什么特点？",
            "为什么限界上下文不是与微服务一对一映射？",
            "如何确定微服务的粒度？",
            "子域分解有什么优势？",
        ],
        extensions: [
            "学习 Strangler Fig 迁移模式",
            "了解 Conway 定律与团队结构",
            "研究数据网格（Data Mesh）概念",
            "探索服务网格（Service Mesh）架构",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/decomposition/decompose-by-subdomain.html",
            "https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/",
        ],
    },
    "w16-2": {
        lessonId: "w16-2",
        background: [
            "【事件驱动定义】'每个服务在更新数据时发布事件，其他服务订阅这些事件。收到事件后，服务更新自己的数据。'",
            "【一致性方案】事件驱动架构用于'维护多个服务间的数据一致性而无需使用分布式事务'。",
            "【数据库隔离】该模式与'数据库隔离'模式紧密相连，每个服务拥有独立数据库。",
            "【异步解耦】服务通过事件进行异步通信，实现松耦合的服务集成。",
            "【最终一致性】采用最终一致性模型，而非强一致性的分布式事务。",
        ],
        keyDifficulties: [
            "【编程复杂度】事件驱动的编程模型更加复杂，需要处理异步逻辑。",
            "【原子性保证】需要确保数据库更新与事件发布的原子性。",
            "【事件顺序】保证事件的顺序和幂等性处理是技术挑战。",
            "【调试困难】分布式事件流的调试和追踪比同步调用更困难。",
        ],
        handsOnPath: [
            "识别需要跨服务协调的业务流程",
            "设计领域事件的结构和命名",
            "选择消息中间件（Kafka、RabbitMQ 等）",
            "实现事件发布者和订阅者",
            "使用 Transactional Outbox 模式确保原子性",
            "实现事件的幂等性处理",
            "建立事件追踪和监控",
        ],
        selfCheck: [
            "什么是事件驱动架构？",
            "事件驱动如何维护服务间的数据一致性？",
            "如何确保数据库更新与事件发布的原子性？",
            "事件驱动的主要挑战是什么？",
            "什么是 Transactional Outbox 模式？",
        ],
        extensions: [
            "学习 Apache Kafka 的使用",
            "了解 Event Sourcing 与事件驱动的结合",
            "研究 CQRS 在事件驱动中的应用",
            "探索事件驱动的可观测性工具",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/event-driven-architecture.html",
            "https://www.confluent.io/blog/build-services-backbone-events/",
        ],
    },
    "w16-3": {
        lessonId: "w16-3",
        background: [
            "【Saga 定义】'Implement each business transaction that spans multiple services as a saga. A saga is a sequence of local transactions.'——Saga 是一系列本地事务。",
            "【补偿机制】如果某个事务违反业务规则，'the saga executes a series of compensating transactions that undo the changes'——执行补偿事务撤销变更。",
            "【编排式 Saga】Choreography-based：服务自主发布领域事件，无中央协调者。",
            "【协同式 Saga】Orchestration-based：中央编排器指挥参与者，发送命令并接收回复。",
            "【替代 2PC】Saga 模式用于替代分布式事务（2PC），实现跨服务的最终一致性。",
        ],
        keyDifficulties: [
            "【手动补偿】开发者必须显式设计补偿事务，不能依赖自动回滚。",
            "【隔离问题】并发 Saga 可能导致数据异常，需要实现自定义隔离对策。",
            "【原子更新】服务必须原子地更新数据库并发布消息，需要特殊模式支持。",
            "【复杂性】Saga 的设计和调试比传统事务更复杂。",
        ],
        handsOnPath: [
            "识别跨服务的业务事务",
            "选择编排式或协同式 Saga",
            "设计每个步骤的本地事务",
            "设计对应的补偿事务",
            "实现 Saga 编排器（如果使用协同式）",
            "处理并发和隔离问题",
            "实现 Saga 的监控和告警",
        ],
        selfCheck: [
            "什么是 Saga 模式？",
            "编排式和协同式 Saga 有什么区别？",
            "什么是补偿事务？为什么需要？",
            "Saga 有什么隔离问题？",
            "如何确保数据库更新和消息发布的原子性？",
        ],
        extensions: [
            "学习 Temporal/Cadence 工作流引擎",
            "了解 Saga 与 Event Sourcing 的结合",
            "研究 Saga 的测试策略",
            "探索 Saga 的可视化工具",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/saga.html",
            "https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga",
        ],
    },
    "w16-4": {
        lessonId: "w16-4",
        background: [
            "【API Gateway 定义】'An API gateway acts as a single entry point into the application, routing and composing requests to services'——单一入口点，路由和组合请求。",
            "【请求处理】Gateway 通过两种方式处理请求：代理路由到相应服务，或向多个服务发出请求并聚合结果。",
            "【BFF 定义】'rather than have a general-purpose API backend, instead you have one backend per user experience'——为每种用户体验创建专用后端。",
            "【客户端优化】Gateway 和 BFF 为各类客户端提供最优化接口，减少请求往返次数。",
            "【隐藏分区】向客户端隐藏微服务的分区细节，简化客户端实现。",
        ],
        keyDifficulties: [
            "【单点故障】Gateway 可能成为单点故障和性能瓶颈，需要高可用设计。",
            "【额外延迟】因额外网络跃点导致响应延迟（通常影响不大）。",
            "【复杂性增加】增加系统复杂性，需要额外的部署和运维。",
            "【BFF 重复】多个 BFF 可能产生跨 BFF 的重复代码。",
        ],
        handsOnPath: [
            "分析客户端的 API 需求",
            "设计 Gateway 的路由规则",
            "实现请求聚合逻辑",
            "为不同客户端设计 BFF（如需要）",
            "集成服务发现机制",
            "添加断路器和限流",
            "实现 Gateway 的监控和日志",
        ],
        selfCheck: [
            "什么是 API Gateway？它的主要功能是什么？",
            "什么是 BFF 模式？与通用 Gateway 有什么区别？",
            "Gateway 的主要优势是什么？",
            "Gateway 有什么潜在问题？",
            "BFF 适合什么场景？",
        ],
        extensions: [
            "学习 Kong、Nginx、Envoy 等 Gateway 实现",
            "了解 GraphQL 作为 Gateway 的选择",
            "研究 Service Mesh 与 Gateway 的关系",
            "探索无服务器 Gateway（如 AWS API Gateway）",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/apigateway.html",
            "https://samnewman.io/patterns/architectural/bff/",
        ],
    },
}

export const week16Quizzes: Record<string, QuizQuestion[]> = {
    "w16-1": [
        {
            id: "w16-1-q1",
            question: "子域分解模式建议如何定义微服务？",
            options: [
                "按技术层分解",
                "通过 DDD 的子域来定义服务边界",
                "按团队分解",
                "按数据库分解",
            ],
            answer: 1,
            rationale: "'Define services corresponding to Domain-Driven Design (DDD) subdomains'。",
        },
        {
            id: "w16-1-q2",
            question: "核心子域（Core Subdomain）的特点是什么？",
            options: [
                "非业务特定",
                "业务关键差异化部分",
                "通用功能",
                "支持性功能",
            ],
            answer: 1,
            rationale: "核心子域是业务关键差异化部分。",
        },
        {
            id: "w16-1-q3",
            question: "通用子域（Generic Subdomain）的特点是什么？",
            options: [
                "业务差异化",
                "非业务特定部分",
                "核心业务",
                "竞争优势",
            ],
            answer: 1,
            rationale: "通用子域是非业务特定部分。",
        },
        {
            id: "w16-1-q4",
            question: "子域分解为什么提供稳定的架构？",
            options: [
                "代码更少",
                "子域相对稳定，不像业务能力可能频繁变化",
                "团队更小",
                "数据库更简单",
            ],
            answer: 1,
            rationale: "子域分解提供稳定的架构，因为子域相对稳定。",
        },
        {
            id: "w16-1-q5",
            question: "限界上下文与微服务是什么关系？",
            options: [
                "一对一映射",
                "是服务边界的自然候选，但不是一对一映射",
                "没有关系",
                "完全相同",
            ],
            answer: 1,
            rationale: "限界上下文是服务边界的自然候选，但不是与微服务一对一映射。",
        },
        {
            id: "w16-1-q6",
            question: "如何识别子域？",
            options: [
                "查看代码",
                "分析组织结构、研究高层域模型，通过迭代过程识别",
                "询问开发者",
                "查看数据库",
            ],
            answer: 1,
            rationale: "识别子域的方法：分析组织结构、研究高层域模型，通过迭代过程识别。",
        },
        {
            id: "w16-1-q7",
            question: "子域分解对团队有什么影响？",
            options: [
                "团队更大",
                "形成跨职能、自治的开发团队",
                "团队更少",
                "没有影响",
            ],
            answer: 1,
            rationale: "子域分解形成跨职能、自治的开发团队。",
        },
        {
            id: "w16-1-q8",
            question: "支持子域（Supporting Subdomain）的特点是什么？",
            options: [
                "核心业务",
                "相关但非差异化部分",
                "通用功能",
                "技术基础设施",
            ],
            answer: 1,
            rationale: "支持子域是相关但非差异化部分。",
        },
        {
            id: "w16-1-q9",
            question: "微服务粒度太细会导致什么问题？",
            options: [
                "性能提升",
                "增加运维复杂度",
                "更简单",
                "没有问题",
            ],
            answer: 1,
            rationale: "微服务粒度太细会增加运维复杂度。",
        },
        {
            id: "w16-1-q10",
            question: "子域分解确保服务具有什么特性？",
            options: [
                "高耦合",
                "内聚性和松耦合",
                "大规模",
                "复杂性",
            ],
            answer: 1,
            rationale: "子域分解确保服务的内聚性和松耦合。",
        },
        {
            id: "w16-1-q11",
            question: "从单体到微服务的演进应该采用什么策略？",
            options: [
                "一步到位",
                "渐进式策略",
                "完全重写",
                "不需要策略",
            ],
            answer: 1,
            rationale: "从单体到微服务的演进需要渐进式策略，不能一步到位。",
        },
        {
            id: "w16-1-q12",
            question: "在线商城的子域示例可能包括什么？",
            options: [
                "前端和后端",
                "产品目录、库存管理、订单管理等",
                "数据库和缓存",
                "开发和测试",
            ],
            answer: 1,
            rationale: "在线商城的子域示例包括产品目录、库存管理、订单管理等。",
        },
    ],
    "w16-2": [
        {
            id: "w16-2-q1",
            question: "事件驱动架构的定义是什么？",
            options: [
                "同步调用服务",
                "每个服务更新数据时发布事件，其他服务订阅并更新自己的数据",
                "使用分布式事务",
                "直接访问其他服务的数据库",
            ],
            answer: 1,
            rationale: "'每个服务在更新数据时发布事件，其他服务订阅这些事件。收到事件后，服务更新自己的数据。'",
        },
        {
            id: "w16-2-q2",
            question: "事件驱动架构解决什么问题？",
            options: [
                "性能问题",
                "维护多个服务间的数据一致性而无需使用分布式事务",
                "安全问题",
                "存储问题",
            ],
            answer: 1,
            rationale: "事件驱动架构用于'维护多个服务间的数据一致性而无需使用分布式事务'。",
        },
        {
            id: "w16-2-q3",
            question: "事件驱动架构与什么模式紧密相连？",
            options: [
                "单体架构",
                "数据库隔离模式",
                "共享数据库",
                "同步调用",
            ],
            answer: 1,
            rationale: "该模式与'数据库隔离'模式紧密相连，每个服务拥有独立数据库。",
        },
        {
            id: "w16-2-q4",
            question: "事件驱动架构的编程模型有什么特点？",
            options: [
                "更简单",
                "更加复杂，需要处理异步逻辑",
                "与同步相同",
                "不需要编程",
            ],
            answer: 1,
            rationale: "事件驱动的编程模型更加复杂，需要处理异步逻辑。",
        },
        {
            id: "w16-2-q5",
            question: "事件驱动架构需要确保什么原子性？",
            options: [
                "只有数据库更新",
                "数据库更新与事件发布的原子性",
                "只有事件发布",
                "不需要原子性",
            ],
            answer: 1,
            rationale: "需要确保数据库更新与事件发布的原子性。",
        },
        {
            id: "w16-2-q6",
            question: "事件驱动架构采用什么一致性模型？",
            options: [
                "强一致性",
                "最终一致性",
                "实时一致性",
                "没有一致性",
            ],
            answer: 1,
            rationale: "采用最终一致性模型，而非强一致性的分布式事务。",
        },
        {
            id: "w16-2-q7",
            question: "Transactional Outbox 模式解决什么问题？",
            options: [
                "性能问题",
                "确保数据库更新与事件发布的原子性",
                "安全问题",
                "存储问题",
            ],
            answer: 1,
            rationale: "Transactional Outbox 模式用于确保数据库更新与事件发布的原子性。",
        },
        {
            id: "w16-2-q8",
            question: "事件驱动架构适用于什么场景？",
            options: [
                "所有场景",
                "无法依赖 2PC（两阶段提交）的场景",
                "简单 CRUD",
                "单体应用",
            ],
            answer: 1,
            rationale: "此模式适用于无法依赖 2PC（两阶段提交）的场景。",
        },
        {
            id: "w16-2-q9",
            question: "事件驱动架构的调试有什么挑战？",
            options: [
                "更容易",
                "分布式事件流的调试和追踪比同步调用更困难",
                "与同步相同",
                "不需要调试",
            ],
            answer: 1,
            rationale: "分布式事件流的调试和追踪比同步调用更困难。",
        },
        {
            id: "w16-2-q10",
            question: "事件的幂等性处理为什么重要？",
            options: [
                "不重要",
                "防止重复处理事件导致数据不一致",
                "提高性能",
                "减少代码",
            ],
            answer: 1,
            rationale: "幂等性处理防止重复处理事件导致数据不一致。",
        },
        {
            id: "w16-2-q11",
            question: "常用的消息中间件有哪些？",
            options: [
                "MySQL 和 PostgreSQL",
                "Kafka、RabbitMQ 等",
                "Redis 和 Memcached",
                "Nginx 和 Apache",
            ],
            answer: 1,
            rationale: "常用消息中间件包括 Kafka、RabbitMQ 等。",
        },
        {
            id: "w16-2-q12",
            question: "事件驱动架构的主要优势是什么？",
            options: [
                "强一致性",
                "使应用程序能够在不使用分布式事务的情况下维护多个服务间的数据一致性",
                "同步调用",
                "简化编程",
            ],
            answer: 1,
            rationale: "'使应用程序能够在不使用分布式事务的情况下维护多个服务间的数据一致性'。",
        },
    ],
    "w16-3": [
        {
            id: "w16-3-q1",
            question: "Saga 模式的定义是什么？",
            options: [
                "分布式事务",
                "跨多个服务的业务事务实现为一系列本地事务",
                "单一事务",
                "同步调用",
            ],
            answer: 1,
            rationale: "'A saga is a sequence of local transactions'——Saga 是一系列本地事务。",
        },
        {
            id: "w16-3-q2",
            question: "当 Saga 中的事务违反业务规则时会发生什么？",
            options: [
                "自动回滚",
                "执行补偿事务撤销变更",
                "忽略错误",
                "继续执行",
            ],
            answer: 1,
            rationale: "'the saga executes a series of compensating transactions that undo the changes'。",
        },
        {
            id: "w16-3-q3",
            question: "编排式（Choreography-based）Saga 的特点是什么？",
            options: [
                "有中央协调者",
                "服务自主发布领域事件，无中央协调者",
                "同步调用",
                "使用 2PC",
            ],
            answer: 1,
            rationale: "Choreography-based：服务自主发布领域事件，无中央协调者。",
        },
        {
            id: "w16-3-q4",
            question: "协同式（Orchestration-based）Saga 的特点是什么？",
            options: [
                "无协调者",
                "中央编排器指挥参与者，发送命令并接收回复",
                "事件驱动",
                "自动化",
            ],
            answer: 1,
            rationale: "Orchestration-based：中央编排器指挥参与者，发送命令并接收回复。",
        },
        {
            id: "w16-3-q5",
            question: "Saga 的补偿事务有什么特点？",
            options: [
                "自动生成",
                "开发者必须显式设计，不能依赖自动回滚",
                "数据库提供",
                "框架提供",
            ],
            answer: 1,
            rationale: "开发者必须显式设计补偿事务，不能依赖自动回滚。",
        },
        {
            id: "w16-3-q6",
            question: "并发 Saga 有什么问题？",
            options: [
                "性能提升",
                "可能导致数据异常，需要实现自定义隔离对策",
                "没有问题",
                "更简单",
            ],
            answer: 1,
            rationale: "并发 Saga 可能导致数据异常，需要实现自定义隔离对策。",
        },
        {
            id: "w16-3-q7",
            question: "Saga 模式用于替代什么？",
            options: [
                "本地事务",
                "分布式事务（2PC）",
                "HTTP 调用",
                "数据库",
            ],
            answer: 1,
            rationale: "Saga 模式用于替代分布式事务（2PC），实现跨服务的最终一致性。",
        },
        {
            id: "w16-3-q8",
            question: "Saga 中服务必须原子地做什么？",
            options: [
                "只更新数据库",
                "更新数据库并发布消息",
                "只发布消息",
                "不需要原子性",
            ],
            answer: 1,
            rationale: "服务必须原子地更新数据库并发布消息。",
        },
        {
            id: "w16-3-q9",
            question: "编排式 Saga 的工作流程是什么？",
            options: [
                "协调者发送命令",
                "服务创建订单、发出事件、其他服务响应事件",
                "同步调用",
                "批量处理",
            ],
            answer: 1,
            rationale: "Order Service 创建订单、发出'Order Created'事件，Customer Service 响应并发布结果事件。",
        },
        {
            id: "w16-3-q10",
            question: "协同式 Saga 中的编排器做什么？",
            options: [
                "发布事件",
                "发送命令给参与者并根据回复做决策",
                "直接修改数据库",
                "被动等待",
            ],
            answer: 1,
            rationale: "编排器发送'Reserve Credit'命令给 Customer Service，并根据回复做最终批准决策。",
        },
        {
            id: "w16-3-q11",
            question: "Saga 的设计和调试有什么特点？",
            options: [
                "比传统事务简单",
                "比传统事务更复杂",
                "与传统事务相同",
                "不需要调试",
            ],
            answer: 1,
            rationale: "Saga 的设计和调试比传统事务更复杂。",
        },
        {
            id: "w16-3-q12",
            question: "Temporal/Cadence 是什么工具？",
            options: [
                "数据库",
                "工作流引擎，用于实现 Saga",
                "消息队列",
                "监控工具",
            ],
            answer: 1,
            rationale: "Temporal/Cadence 是工作流引擎，可用于实现 Saga 模式。",
        },
    ],
    "w16-4": [
        {
            id: "w16-4-q1",
            question: "API Gateway 的定义是什么？",
            options: [
                "数据库代理",
                "作为应用程序的单一入口点，路由和组合请求到服务",
                "消息队列",
                "缓存服务器",
            ],
            answer: 1,
            rationale: "'An API gateway acts as a single entry point into the application, routing and composing requests to services'。",
        },
        {
            id: "w16-4-q2",
            question: "Gateway 通过哪两种方式处理请求？",
            options: [
                "缓存和存储",
                "代理路由到服务，或向多个服务发请求并聚合结果",
                "加密和解密",
                "验证和授权",
            ],
            answer: 1,
            rationale: "Gateway 通过代理路由到相应服务，或向多个服务发出请求并聚合结果。",
        },
        {
            id: "w16-4-q3",
            question: "BFF（Backends For Frontends）的定义是什么？",
            options: [
                "通用 API 后端",
                "为每种用户体验创建专用后端",
                "前端框架",
                "数据库",
            ],
            answer: 1,
            rationale: "'rather than have a general-purpose API backend, instead you have one backend per user experience'。",
        },
        {
            id: "w16-4-q4",
            question: "Gateway 的主要优势是什么？",
            options: [
                "增加延迟",
                "向客户端隐藏微服务的分区细节，为各类客户端提供最优化接口",
                "增加复杂性",
                "暴露内部服务",
            ],
            answer: 1,
            rationale: "Gateway 向客户端隐藏微服务的分区细节，为各类客户端提供最优化接口。",
        },
        {
            id: "w16-4-q5",
            question: "Gateway 可能带来什么问题？",
            options: [
                "更简单",
                "增加系统复杂性，因额外网络跃点导致响应延迟",
                "减少代码",
                "没有问题",
            ],
            answer: 1,
            rationale: "Gateway 增加系统复杂性，因额外网络跃点导致响应延迟（通常影响不大）。",
        },
        {
            id: "w16-4-q6",
            question: "BFF 由谁维护？",
            options: [
                "独立团队",
                "构建用户界面的团队",
                "运维团队",
                "外部供应商",
            ],
            answer: 1,
            rationale: "BFF 由构建用户界面的团队维护，能够快速迭代并独立做出架构决策。",
        },
        {
            id: "w16-4-q7",
            question: "BFF 的专一性指什么？",
            options: [
                "服务所有客户端",
                "每个 BFF 仅服务于特定的用户界面",
                "共享所有代码",
                "通用 API",
            ],
            answer: 1,
            rationale: "每个 BFF 仅服务于特定的用户界面，避免了通用 API 后端的臃肿问题。",
        },
        {
            id: "w16-4-q8",
            question: "Gateway 通常与什么模式结合使用？",
            options: [
                "单体架构",
                "断路器和服务发现",
                "共享数据库",
                "同步调用",
            ],
            answer: 1,
            rationale: "Gateway 需结合客户端或服务端服务发现模式运作，通常配合断路器增强可靠性。",
        },
        {
            id: "w16-4-q9",
            question: "BFF 适合什么场景？",
            options: [
                "所有场景",
                "需要为移动端和桌面端提供不同体验时",
                "单一客户端",
                "简单应用",
            ],
            answer: 1,
            rationale: "BFF 适合需要为移动端和桌面端提供不同体验时，或有显著的服务端数据聚合需求。",
        },
        {
            id: "w16-4-q10",
            question: "多个 BFF 可能产生什么问题？",
            options: [
                "没有问题",
                "跨 BFF 的重复代码",
                "性能提升",
                "简化部署",
            ],
            answer: 1,
            rationale: "多个 BFF 可能产生跨 BFF 的重复代码。",
        },
        {
            id: "w16-4-q11",
            question: "Gateway 的协议转换功能是什么？",
            options: [
                "加密数据",
                "将公开 API 转换为内部协议",
                "压缩数据",
                "验证数据",
            ],
            answer: 1,
            rationale: "Gateway 支持协议转换（公开 API 至内部协议）。",
        },
        {
            id: "w16-4-q12",
            question: "常见的 API Gateway 实现有哪些？",
            options: [
                "MySQL 和 PostgreSQL",
                "Kong、Nginx、Envoy 等",
                "React 和 Vue",
                "Kafka 和 RabbitMQ",
            ],
            answer: 1,
            rationale: "常见的 Gateway 实现包括 Kong、Nginx、Envoy 等。",
        },
    ],
}
