import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week9Guides: Record<string, LessonGuide> = {
    "w9-1": {
        lessonId: "w9-1",
        background: [
            "【传统分层问题】传统分层架构（表现层→业务层→数据访问层）中，依赖方向向下，领域层依赖基础设施层。",
            "【依赖倒置】领域层不应依赖基础设施，应通过接口定义依赖，实现反向依赖。",
            "【耦合风险】传统架构中数据库变更会影响业务逻辑，框架变更会影响整个系统。",
            "【知识泄漏】基础设施细节（如 ORM 映射）容易污染领域模型。",
            "【可测试性差】领域逻辑与数据库耦合，难以进行单元测试。",
        ],
        keyDifficulties: [
            "【思维转变】从'业务依赖数据库'转变为'数据库依赖业务'需要思维转换。",
            "【接口设计】需要在领域层定义仓储接口，而非直接使用 ORM。",
            "【框架约束】某些框架（如 ORM）的约束可能与领域模型设计冲突。",
            "【遗留代码】在已有的传统架构系统中引入依赖倒置需要渐进重构。",
        ],
        handsOnPath: [
            "分析当前项目的依赖方向",
            "识别领域层对基础设施的直接依赖",
            "将数据访问接口定义移到领域层",
            "在基础设施层实现这些接口",
            "使用依赖注入配置实现",
            "编写不依赖数据库的领域逻辑测试",
        ],
        selfCheck: [
            "传统分层架构有什么问题？",
            "什么是依赖倒置原则？它如何改变依赖方向？",
            "为什么领域层不应该依赖基础设施层？",
            "如何通过接口实现依赖倒置？",
            "依赖倒置如何提高可测试性？",
        ],
        extensions: [
            "学习 SOLID 原则的完整内容",
            "了解控制反转（IoC）与依赖注入（DI）",
            "研究洋葱架构（Onion Architecture）",
            "探索从传统架构到整洁架构的迁移策略",
        ],
        sourceUrls: [
            "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html",
        ],
    },
    "w9-2": {
        lessonId: "w9-2",
        background: [
            "【五大目标】Uncle Bob 提出整洁架构实现五个目标：框架无关、可测试、UI 无关、数据库无关、外部代理无关。",
            "【依赖规则】核心规则：'source code dependencies can only point inwards'——源码依赖只能指向内层。",
            "【四层结构】从内到外：Entities（实体）→ Use Cases（用例）→ Interface Adapters（接口适配器）→ Frameworks & Drivers（框架和驱动）。",
            "【实体层】包含企业级业务规则，可跨多个应用复用。",
            "【用例层】包含应用特定的业务逻辑，编排实体和外部系统之间的数据流。",
        ],
        keyDifficulties: [
            "【层次划分】判断某个组件应该属于哪一层需要经验。",
            "【边界跨越】内层调用外层时，需要使用依赖倒置，通过接口而非具体实现。",
            "【数据结构】跨越边界的数据应该是'simple data structures'，不能直接暴露实体或数据库行。",
            "【过度设计风险】简单应用不需要完整的整洁架构，需要权衡。",
        ],
        handsOnPath: [
            "创建四层项目结构：Entities、UseCases、InterfaceAdapters、Infrastructure",
            "在实体层定义核心业务规则",
            "在用例层实现应用逻辑",
            "在接口适配器层实现 MVC 控制器和数据库适配",
            "配置依赖注入使依赖指向内层",
            "验证依赖规则：外层依赖内层，内层不依赖外层",
        ],
        selfCheck: [
            "整洁架构的五大目标是什么？",
            "依赖规则是什么？为什么重要？",
            "整洁架构的四层分别是什么？各自职责是什么？",
            "跨越边界的数据应该是什么形式？",
            "内层如何调用外层的功能？",
        ],
        extensions: [
            "阅读 Uncle Bob 的《Clean Architecture》书籍",
            "学习 Use Case 的详细设计模式",
            "了解 Presenter 模式与整洁架构",
            "研究整洁架构的测试策略",
        ],
        sourceUrls: [
            "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html",
        ],
    },
    "w9-3": {
        lessonId: "w9-3",
        background: [
            "【实体层代码】实体包含企业级业务规则，是最稳定的部分，不受外部变化影响。",
            "【用例层代码】用例编排业务流程，定义输入/输出边界，协调实体完成业务目标。",
            "【接口适配器层】包含 MVC 组件、Presenters、数据库映射等，负责格式转换。",
            "【框架层】包含 Web 框架、数据库、第三方工具，是最外层也是最易变的部分。",
            "【DTO 传输】使用 Data Transfer Objects 在层间传递数据，避免实体泄漏。",
        ],
        keyDifficulties: [
            "【实体 vs 数据模型】领域实体不等于数据库实体，需要分离。",
            "【用例粒度】用例的粒度划分需要经验，太粗太细都有问题。",
            "【映射成本】层间需要数据映射，增加代码量。",
            "【边界清晰度】保持层间边界清晰需要持续维护。",
        ],
        handsOnPath: [
            "创建领域实体类，只包含业务规则",
            "创建用例类（Interactor），实现 InputBoundary 接口",
            "创建 Controller 接收请求并调用用例",
            "创建 Presenter 格式化用例输出",
            "实现数据库适配器，将实体映射到数据模型",
            "使用 DTO 在各层间传递数据",
        ],
        selfCheck: [
            "实体层应该包含什么？不应该包含什么？",
            "用例层的职责是什么？",
            "为什么需要 DTO？",
            "Presenter 的作用是什么？",
            "如何保持层间边界清晰？",
        ],
        extensions: [
            "学习 Clean Architecture 的代码示例",
            "了解 Input/Output Boundary 模式",
            "研究 Gateway 模式在整洁架构中的应用",
            "探索整洁架构的目录结构最佳实践",
        ],
        sourceUrls: [
            "https://github.com/jasontaylordev/CleanArchitecture",
            "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html",
        ],
    },
    "w9-4": {
        lessonId: "w9-4",
        background: [
            "【DDD 实体映射】整洁架构的 Entities 层对应 DDD 的领域模型（实体、值对象、聚合）。",
            "【用例与应用服务】整洁架构的 Use Cases 层对应 DDD 的应用服务层。",
            "【仓储接口位置】仓储接口定义在领域层（内层），实现在基础设施层（外层）。",
            "【领域服务位置】领域服务属于领域层，与实体和值对象在同一层。",
            "【端口适配器】整洁架构与六边形架构可以结合，端口在内层，适配器在外层。",
        ],
        keyDifficulties: [
            "【概念映射】整洁架构和 DDD 术语不同但概念相似，需要理解对应关系。",
            "【聚合边界】在整洁架构中保持聚合边界需要额外关注。",
            "【领域事件位置】领域事件属于领域层，事件处理可能跨越多层。",
            "【限界上下文】每个限界上下文可以有独立的整洁架构实现。",
        ],
        handsOnPath: [
            "将 DDD 聚合放入实体层",
            "将领域服务放入实体层",
            "将应用服务实现为用例",
            "在领域层定义仓储接口",
            "在基础设施层实现仓储",
            "配置依赖注入连接各层",
        ],
        selfCheck: [
            "整洁架构的各层如何对应 DDD 的概念？",
            "仓储接口应该定义在哪里？实现在哪里？",
            "领域服务属于整洁架构的哪一层？",
            "如何在整洁架构中实现聚合边界？",
            "领域事件在整洁架构中如何处理？",
        ],
        extensions: [
            "学习 eShopOnContainers 项目的架构",
            "了解垂直切片架构（Vertical Slice Architecture）",
            "研究模块化单体（Modular Monolith）架构",
            "探索整洁架构在微服务中的应用",
        ],
        sourceUrls: [
            "https://github.com/dotnet-architecture/eShopOnContainers",
            "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html",
        ],
    },
}

export const week9Quizzes: Record<string, QuizQuestion[]> = {
    "w9-1": [
        {
            id: "w9-1-q1",
            question: "传统分层架构的主要问题是什么？",
            options: [
                "代码太多",
                "领域层依赖基础设施层，难以测试和替换",
                "层数太少",
                "没有用户界面",
            ],
            answer: 1,
            rationale: "传统分层架构中，依赖方向向下，领域层依赖基础设施层，导致难以测试和替换。",
        },
        {
            id: "w9-1-q2",
            question: "依赖倒置原则的核心思想是什么？",
            options: [
                "高层模块依赖低层模块",
                "高层模块和低层模块都应依赖抽象",
                "低层模块不需要",
                "不使用依赖",
            ],
            answer: 1,
            rationale: "依赖倒置原则：高层模块和低层模块都应依赖抽象，抽象不应依赖细节。",
        },
        {
            id: "w9-1-q3",
            question: "如何实现领域层不依赖数据库层？",
            options: [
                "删除数据库",
                "在领域层定义仓储接口，在基础设施层实现",
                "使用内存数据库",
                "不需要实现",
            ],
            answer: 1,
            rationale: "通过在领域层定义仓储接口，在基础设施层实现，实现依赖倒置。",
        },
        {
            id: "w9-1-q4",
            question: "依赖倒置如何提高可测试性？",
            options: [
                "不需要测试",
                "可以用模拟对象替换真实实现进行单元测试",
                "减少测试代码",
                "自动生成测试",
            ],
            answer: 1,
            rationale: "依赖倒置后，可以用模拟对象替换真实的基础设施实现，进行独立的单元测试。",
        },
        {
            id: "w9-1-q5",
            question: "传统架构中知识泄漏的表现是什么？",
            options: [
                "文档泄漏",
                "基础设施细节（如 ORM 映射）污染领域模型",
                "代码被复制",
                "API 被公开",
            ],
            answer: 1,
            rationale: "知识泄漏表现为基础设施细节（如 ORM 映射、数据库字段）污染领域模型。",
        },
        {
            id: "w9-1-q6",
            question: "框架耦合会带来什么风险？",
            options: [
                "性能下降",
                "框架变更会影响整个系统",
                "代码减少",
                "开发加速",
            ],
            answer: 1,
            rationale: "框架耦合意味着框架变更会影响整个系统，增加维护成本和风险。",
        },
        {
            id: "w9-1-q7",
            question: "在依赖倒置后，数据库层依赖什么？",
            options: [
                "用户界面",
                "领域层定义的接口",
                "网络层",
                "不依赖任何东西",
            ],
            answer: 1,
            rationale: "依赖倒置后，数据库层（基础设施层）实现领域层定义的接口，依赖领域层的抽象。",
        },
        {
            id: "w9-1-q8",
            question: "在遗留系统中引入依赖倒置应该怎么做？",
            options: [
                "一次性重写",
                "渐进式重构",
                "放弃遗留系统",
                "不需要引入",
            ],
            answer: 1,
            rationale: "在已有的传统架构系统中引入依赖倒置需要渐进式重构，逐步改造。",
        },
        {
            id: "w9-1-q9",
            question: "依赖注入（DI）与依赖倒置（DIP）的关系是什么？",
            options: [
                "是同一个概念",
                "DI 是实现 DIP 的一种技术手段",
                "完全无关",
                "DIP 是 DI 的实现",
            ],
            answer: 1,
            rationale: "依赖注入（DI）是实现依赖倒置原则（DIP）的一种常用技术手段。",
        },
        {
            id: "w9-1-q10",
            question: "为什么说领域模型是最稳定的部分？",
            options: [
                "代码不变",
                "业务规则相对稳定，不受技术变化影响",
                "没人修改",
                "没有依赖",
            ],
            answer: 1,
            rationale: "业务规则相对稳定，不受框架、数据库等技术变化的影响，所以领域模型是最稳定的部分。",
        },
        {
            id: "w9-1-q11",
            question: "接口应该定义在哪里？",
            options: [
                "基础设施层",
                "使用方所在的层（如领域层）",
                "任意层",
                "单独的接口层",
            ],
            answer: 1,
            rationale: "接口应该定义在使用方所在的层，例如仓储接口定义在领域层。",
        },
        {
            id: "w9-1-q12",
            question: "ORM 框架约束与领域模型冲突时应该怎么处理？",
            options: [
                "改变领域模型适应 ORM",
                "使用映射层隔离 ORM 细节，保护领域模型",
                "不使用 ORM",
                "忽略冲突",
            ],
            answer: 1,
            rationale: "应该使用映射层隔离 ORM 细节，保护领域模型不受 ORM 约束的影响。",
        },
    ],
    "w9-2": [
        {
            id: "w9-2-q1",
            question: "整洁架构的五大目标不包括以下哪个？",
            options: [
                "框架无关",
                "性能最优",
                "可测试",
                "数据库无关",
            ],
            answer: 1,
            rationale: "五大目标是：框架无关、可测试、UI 无关、数据库无关、外部代理无关。不包括性能最优。",
        },
        {
            id: "w9-2-q2",
            question: "整洁架构的依赖规则是什么？",
            options: [
                "依赖可以任意方向",
                "源码依赖只能指向内层",
                "只能指向外层",
                "没有依赖规则",
            ],
            answer: 1,
            rationale: "核心规则：'source code dependencies can only point inwards'——源码依赖只能指向内层。",
        },
        {
            id: "w9-2-q3",
            question: "整洁架构从内到外的四层分别是什么？",
            options: [
                "UI → Service → Repository → Database",
                "Entities → Use Cases → Interface Adapters → Frameworks & Drivers",
                "Controller → Service → DAO → Model",
                "View → Presenter → Model → Database",
            ],
            answer: 1,
            rationale: "从内到外：Entities（实体）→ Use Cases（用例）→ Interface Adapters（接口适配器）→ Frameworks & Drivers。",
        },
        {
            id: "w9-2-q4",
            question: "实体层（Entities）包含什么？",
            options: [
                "数据库操作",
                "企业级业务规则，可跨多个应用复用",
                "用户界面",
                "框架配置",
            ],
            answer: 1,
            rationale: "实体层包含企业级业务规则，是最稳定的部分，可跨多个应用复用。",
        },
        {
            id: "w9-2-q5",
            question: "用例层（Use Cases）的职责是什么？",
            options: [
                "管理数据库",
                "包含应用特定的业务逻辑，编排实体和外部系统之间的数据流",
                "渲染用户界面",
                "处理网络请求",
            ],
            answer: 1,
            rationale: "用例层包含应用特定的业务逻辑，编排实体和外部系统之间的数据流。",
        },
        {
            id: "w9-2-q6",
            question: "跨越边界的数据应该是什么形式？",
            options: [
                "复杂对象",
                "简单数据结构（Simple Data Structures）",
                "数据库实体",
                "框架对象",
            ],
            answer: 1,
            rationale: "跨越边界的数据应该是'simple data structures'，不能直接暴露实体或数据库行。",
        },
        {
            id: "w9-2-q7",
            question: "内层如何调用外层的功能？",
            options: [
                "直接调用",
                "通过依赖倒置，调用内层定义的接口",
                "不能调用",
                "通过全局变量",
            ],
            answer: 1,
            rationale: "内层通过依赖倒置调用外层：内层定义接口，外层实现接口。",
        },
        {
            id: "w9-2-q8",
            question: "接口适配器层包含什么？",
            options: [
                "业务规则",
                "MVC 组件、Presenters、数据库映射等格式转换",
                "框架核心",
                "实体定义",
            ],
            answer: 1,
            rationale: "接口适配器层包含 MVC 组件、Presenters、数据库映射等，负责格式转换。",
        },
        {
            id: "w9-2-q9",
            question: "框架和驱动层是什么？",
            options: [
                "最内层",
                "最外层，包含 Web 框架、数据库、第三方工具",
                "中间层",
                "不存在的层",
            ],
            answer: 1,
            rationale: "框架层是最外层，包含 Web 框架、数据库、第三方工具，是最易变的部分。",
        },
        {
            id: "w9-2-q10",
            question: "为什么简单应用不需要完整的整洁架构？",
            options: [
                "整洁架构有 bug",
                "增加了不必要的复杂度，需要权衡成本和收益",
                "简单应用不需要架构",
                "整洁架构只适合大公司",
            ],
            answer: 1,
            rationale: "简单应用使用完整的整洁架构会增加不必要的复杂度，需要权衡成本和收益。",
        },
        {
            id: "w9-2-q11",
            question: "整洁架构如何实现框架无关？",
            options: [
                "不使用框架",
                "将框架放在最外层，业务逻辑不依赖框架",
                "使用特定框架",
                "忽略框架",
            ],
            answer: 1,
            rationale: "将框架放在最外层，核心业务逻辑不依赖框架，可以更换框架而不影响业务。",
        },
        {
            id: "w9-2-q12",
            question: "整洁架构如何实现可测试性？",
            options: [
                "减少测试",
                "业务逻辑与外部系统分离，可以独立测试",
                "使用特定测试框架",
                "自动生成测试",
            ],
            answer: 1,
            rationale: "业务逻辑与 UI、数据库、外部系统分离，可以独立进行单元测试。",
        },
    ],
    "w9-3": [
        {
            id: "w9-3-q1",
            question: "实体层应该包含什么？",
            options: [
                "数据库连接",
                "只包含业务规则，不依赖外部",
                "用户界面逻辑",
                "框架配置",
            ],
            answer: 1,
            rationale: "实体层只包含业务规则，是最稳定的部分，不受外部变化影响。",
        },
        {
            id: "w9-3-q2",
            question: "用例（Interactor）实现什么接口？",
            options: [
                "Repository 接口",
                "InputBoundary 接口",
                "Database 接口",
                "Controller 接口",
            ],
            answer: 1,
            rationale: "用例类（Interactor）实现 InputBoundary 接口，定义用例的输入边界。",
        },
        {
            id: "w9-3-q3",
            question: "为什么需要 DTO（Data Transfer Object）？",
            options: [
                "增加代码量",
                "在层间传递数据，避免实体泄漏到外层",
                "提高性能",
                "简化代码",
            ],
            answer: 1,
            rationale: "使用 DTO 在层间传递数据，避免领域实体泄漏到外层，保持层间隔离。",
        },
        {
            id: "w9-3-q4",
            question: "Presenter 的作用是什么？",
            options: [
                "处理数据库",
                "格式化用例输出为视图模型",
                "执行业务逻辑",
                "管理配置",
            ],
            answer: 1,
            rationale: "Presenter 负责格式化用例输出，将其转换为适合视图的数据格式。",
        },
        {
            id: "w9-3-q5",
            question: "领域实体与数据库实体应该是什么关系？",
            options: [
                "必须相同",
                "应该分离，使用映射转换",
                "数据库实体优先",
                "不使用数据库实体",
            ],
            answer: 1,
            rationale: "领域实体不等于数据库实体，需要分离，在接口适配器层进行映射转换。",
        },
        {
            id: "w9-3-q6",
            question: "用例粒度划分的原则是什么？",
            options: [
                "越大越好",
                "一个用例对应一个业务场景，既不过粗也不过细",
                "越小越好",
                "没有原则",
            ],
            answer: 1,
            rationale: "用例粒度应对应一个完整的业务场景，太粗会混乱，太细会碎片化。",
        },
        {
            id: "w9-3-q7",
            question: "层间映射带来什么代价？",
            options: [
                "没有代价",
                "增加代码量和映射成本",
                "降低性能",
                "安全风险",
            ],
            answer: 1,
            rationale: "层间数据映射增加代码量，是整洁架构的代价之一。",
        },
        {
            id: "w9-3-q8",
            question: "Controller 在整洁架构中的职责是什么？",
            options: [
                "执行业务逻辑",
                "接收请求，调用用例，返回响应",
                "管理数据库",
                "渲染视图",
            ],
            answer: 1,
            rationale: "Controller 接收外部请求，将其转换为用例输入，调用用例，返回响应。",
        },
        {
            id: "w9-3-q9",
            question: "数据库适配器属于哪一层？",
            options: [
                "实体层",
                "接口适配器层",
                "用例层",
                "领域层",
            ],
            answer: 1,
            rationale: "数据库适配器属于接口适配器层，负责将实体映射到数据库模型。",
        },
        {
            id: "w9-3-q10",
            question: "如何保持层间边界清晰？",
            options: [
                "不使用分层",
                "持续维护，严格遵守依赖规则",
                "自动检测",
                "定期重写",
            ],
            answer: 1,
            rationale: "保持层间边界清晰需要持续维护，严格遵守依赖规则和数据传输规范。",
        },
        {
            id: "w9-3-q11",
            question: "Input/Output Boundary 模式的作用是什么？",
            options: [
                "处理网络",
                "定义用例的输入输出契约，隔离用例与外部",
                "管理数据库",
                "渲染视图",
            ],
            answer: 1,
            rationale: "Input/Output Boundary 定义用例的输入输出契约，隔离用例与外部的直接依赖。",
        },
        {
            id: "w9-3-q12",
            question: "Gateway 模式在整洁架构中的作用是什么？",
            options: [
                "路由请求",
                "封装外部系统访问，提供抽象接口",
                "管理用户",
                "处理支付",
            ],
            answer: 1,
            rationale: "Gateway 模式封装对外部系统的访问，在内层定义抽象接口，在外层实现。",
        },
    ],
    "w9-4": [
        {
            id: "w9-4-q1",
            question: "整洁架构的 Entities 层对应 DDD 的什么？",
            options: [
                "应用服务",
                "领域模型（实体、值对象、聚合）",
                "仓储",
                "控制器",
            ],
            answer: 1,
            rationale: "整洁架构的 Entities 层对应 DDD 的领域模型，包括实体、值对象、聚合。",
        },
        {
            id: "w9-4-q2",
            question: "整洁架构的 Use Cases 层对应 DDD 的什么？",
            options: [
                "领域服务",
                "应用服务层",
                "仓储",
                "实体",
            ],
            answer: 1,
            rationale: "整洁架构的 Use Cases 层对应 DDD 的应用服务层。",
        },
        {
            id: "w9-4-q3",
            question: "在整洁架构与 DDD 结合中，仓储接口应该定义在哪里？",
            options: [
                "基础设施层",
                "领域层（内层）",
                "应用层",
                "表现层",
            ],
            answer: 1,
            rationale: "仓储接口定义在领域层（内层），实现在基础设施层（外层）。",
        },
        {
            id: "w9-4-q4",
            question: "领域服务在整洁架构中属于哪一层？",
            options: [
                "用例层",
                "实体层（与实体、值对象同层）",
                "接口适配器层",
                "框架层",
            ],
            answer: 1,
            rationale: "领域服务属于领域层，与实体和值对象在同一层（Entities 层）。",
        },
        {
            id: "w9-4-q5",
            question: "整洁架构与六边形架构如何结合？",
            options: [
                "不能结合",
                "端口在内层，适配器在外层",
                "相互替代",
                "必须选择一个",
            ],
            answer: 1,
            rationale: "整洁架构与六边形架构可以结合：端口（接口）定义在内层，适配器实现在外层。",
        },
        {
            id: "w9-4-q6",
            question: "领域事件在整洁架构中属于哪一层？",
            options: [
                "框架层",
                "领域层（Entities 层）",
                "用例层",
                "表现层",
            ],
            answer: 1,
            rationale: "领域事件属于领域层（Entities 层），但事件处理可能跨越多层。",
        },
        {
            id: "w9-4-q7",
            question: "每个限界上下文可以有什么？",
            options: [
                "只能共享一个架构",
                "独立的整洁架构实现",
                "不需要架构",
                "只能使用相同的技术",
            ],
            answer: 1,
            rationale: "每个限界上下文可以有独立的整洁架构实现，根据需要选择技术栈。",
        },
        {
            id: "w9-4-q8",
            question: "聚合边界在整洁架构中如何保持？",
            options: [
                "自动保持",
                "需要额外关注，仓储只操作聚合根",
                "不需要保持",
                "由框架处理",
            ],
            answer: 1,
            rationale: "在整洁架构中保持聚合边界需要额外关注，确保仓储只操作聚合根。",
        },
        {
            id: "w9-4-q9",
            question: "垂直切片架构（Vertical Slice）与整洁架构有什么区别？",
            options: [
                "是同一个架构",
                "垂直切片按功能划分，整洁架构按层划分",
                "垂直切片更复杂",
                "没有区别",
            ],
            answer: 1,
            rationale: "垂直切片架构按功能/用例划分代码，整洁架构按技术层划分代码，是不同的组织方式。",
        },
        {
            id: "w9-4-q10",
            question: "模块化单体（Modular Monolith）与整洁架构的关系是什么？",
            options: [
                "互相排斥",
                "可以结合，每个模块内部使用整洁架构",
                "是同一个概念",
                "没有关系",
            ],
            answer: 1,
            rationale: "模块化单体可以与整洁架构结合，每个模块内部使用整洁架构组织代码。",
        },
        {
            id: "w9-4-q11",
            question: "eShopOnContainers 项目演示了什么？",
            options: [
                "简单 CRUD",
                "整洁架构与 DDD 在微服务中的结合",
                "只有前端",
                "只有数据库",
            ],
            answer: 1,
            rationale: "eShopOnContainers 是微软的参考项目，演示整洁架构与 DDD 在微服务中的结合。",
        },
        {
            id: "w9-4-q12",
            question: "整洁架构在微服务中如何应用？",
            options: [
                "不适用于微服务",
                "每个微服务可以内部使用整洁架构组织代码",
                "只用于单体",
                "需要特殊框架",
            ],
            answer: 1,
            rationale: "每个微服务可以内部使用整洁架构组织代码，保持业务逻辑与基础设施分离。",
        },
    ],
}
