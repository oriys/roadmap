import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week4Guides: Record<string, LessonGuide> = {
    "w4-1": {
        lessonId: "w4-1",
        background: [
            "【统一语言定义】Eric Evans 定义统一语言为'在开发人员和用户之间建立的通用、严谨的语言'，基于软件中使用的领域模型。",
            "【严谨性要求】统一语言需要严谨性，'because software doesn't cope well with ambiguity'——软件难以应对歧义。",
            "【测试语言】Evans 强调通过与领域专家的对话测试语言，这同时也是在测试领域模型本身。",
            "【演进特性】语言和模型应随着团队对领域理解的加深而不断演进，不是一成不变的。",
            "【消除翻译】统一语言消除了开发者语言和业务语言之间的翻译，减少沟通损耗。",
        ],
        keyDifficulties: [
            "【流畅性挑战】Evans 说'通过普遍使用基于模型的语言，不断完善直到流畅自然'——达到流畅需要持续努力。",
            "【领域专家职责】领域专家应对不当或不足以传达领域理解的用语提出异议。",
            "【开发者职责】开发者应留意可能导致设计混乱的歧义或不一致之处。",
            "【语言不一致后果】语言不一致会导致需求误解、代码与业务脱节、沟通效率低下。",
        ],
        handsOnPath: [
            "收集项目中使用的所有业务术语",
            "与领域专家确认每个术语的准确含义",
            "建立项目术语表，记录术语定义和使用场景",
            "检查代码中的命名是否与术语表一致",
            "在代码审查中关注术语使用的一致性",
        ],
        selfCheck: [
            "什么是统一语言？为什么它需要严谨性？",
            "如何通过对话测试统一语言？",
            "统一语言应该如何演进？",
            "领域专家和开发者在维护统一语言中各有什么职责？",
            "语言不一致会带来什么问题？",
        ],
        extensions: [
            "学习如何建立和维护领域词汇表",
            "了解如何在代码审查中检查语言一致性",
            "研究自动化工具检测术语不一致",
            "探索统一语言在文档和用户界面中的应用",
        ],
        sourceUrls: [
            "https://martinfowler.com/bliki/UbiquitousLanguage.html",
        ],
    },
    "w4-2": {
        lessonId: "w4-2",
        background: [
            "【协作建立】统一语言通过开发团队与领域专家的持续对话建立，不是单方面定义的。",
            "【词汇表工具】建立领域词汇表记录术语定义，作为团队共同参考的权威来源。",
            "【代码即语言】代码中的类名、方法名、变量名都应使用统一语言中的术语。",
            "【文档同步】文档、用户界面、API 都应使用统一语言，保持一致性。",
            "【会议实践】在会议中使用统一语言讨论，当发现歧义时立即澄清并更新术语表。",
        ],
        keyDifficulties: [
            "【初期混乱】项目初期语言会比较混乱，需要耐心地逐步精化。",
            "【抵触情绪】一些人可能抵触改变已有的用语习惯。",
            "【维护成本】术语表需要持续维护，否则会过时失去价值。",
            "【跨团队一致】在大型项目中保持跨团队的语言一致性是挑战。",
        ],
        handsOnPath: [
            "组织一次术语收集会议，邀请开发者和领域专家参加",
            "使用 Wiki 或共享文档建立术语表",
            "为每个术语记录：定义、示例、使用场景、反例",
            "将术语表链接到代码仓库的 README",
            "在 PR 审查模板中添加术语一致性检查项",
        ],
        selfCheck: [
            "如何组织领域专家和开发者共同建立统一语言？",
            "术语表应该包含哪些信息？",
            "如何确保代码中使用的术语与统一语言一致？",
            "如何处理团队成员对用语的分歧？",
            "如何在大型项目中保持跨团队的语言一致性？",
        ],
        extensions: [
            "学习 DDD 术语表的最佳实践",
            "了解如何使用 linting 规则检查命名规范",
            "研究 API 设计中的语言一致性",
            "探索领域事件命名的最佳实践",
        ],
        sourceUrls: [
            "https://github.com/ddd-crew/ddd-glossary",
            "https://martinfowler.com/bliki/UbiquitousLanguage.html",
        ],
    },
    "w4-3": {
        lessonId: "w4-3",
        background: [
            "【领域模型定义】Martin Fowler：领域模型是'an object model of the domain that incorporates both behavior and data'——包含行为和数据的领域对象模型。",
            "【贫血模型问题】贫血领域模型是'one of those anti-patterns that's been around for quite a long time'——领域对象只有 getter/setter，业务逻辑在服务层。",
            "【充血模型特点】充血领域模型将业务逻辑放在领域对象内，实现真正的面向对象设计。",
            "【模型驱动设计】代码应该反映领域模型，模型的变化应该反映在代码中。",
            "【模型探索过程】Evans 提出'Model Exploration Whirlpool'——模型探索漩涡，描述了模型迭代精化的过程。",
        ],
        keyDifficulties: [
            "【贫血模型诱惑】传统分层架构和 ORM 框架容易导向贫血模型。",
            "【行为归属判断】判断某个行为应该属于哪个实体有时不明显。",
            "【过度设计风险】简单场景使用复杂模型是过度设计。",
            "【模型与持久化】需要平衡领域模型的纯净性和持久化的便利性。",
        ],
        handsOnPath: [
            "审查现有代码，识别贫血模型的特征",
            "找一个业务规则密集的实体，尝试将行为移入实体",
            "重构一个 Service 方法，将逻辑分配到适当的领域对象",
            "为领域对象添加有意义的方法名，反映业务操作",
            "编写单元测试验证领域逻辑",
        ],
        selfCheck: [
            "什么是领域模型？它包含什么？",
            "什么是贫血领域模型？它有什么问题？",
            "充血领域模型与贫血模型的区别是什么？",
            "如何判断一个行为应该属于哪个领域对象？",
            "什么时候简单的贫血模型是可以接受的？",
        ],
        extensions: [
            "阅读 Martin Fowler 关于贫血领域模型的文章",
            "学习如何在 ORM 框架中实现充血模型",
            "了解领域模型与数据传输对象（DTO）的区别",
            "研究 CQRS 中的命令模型设计",
        ],
        sourceUrls: [
            "https://martinfowler.com/eaaCatalog/domainModel.html",
            "https://martinfowler.com/bliki/AnemicDomainModel.html",
        ],
    },
    "w4-4": {
        lessonId: "w4-4",
        background: [
            "【简洁性原则】领域模型应该尽可能简洁，只包含对业务有意义的概念。",
            "【可理解性原则】模型应该能被领域专家理解，而不仅仅是开发者。",
            "【可演进性原则】模型应该能够随着业务理解的深入而演进。",
            "【持续精化】Evans：'通过普遍使用基于模型的语言，不断完善直到流畅自然，我们能接近完整易懂的模型'。",
            "【反馈循环】模型 → 代码 → 运行 → 反馈 → 模型精化，形成持续改进的循环。",
        ],
        keyDifficulties: [
            "【过度抽象】过度追求抽象会导致模型难以理解。",
            "【技术术语混入】在模型中混入技术术语会影响与领域专家的沟通。",
            "【演进阻力】已有代码可能对模型演进形成阻力。",
            "【平衡取舍】需要在简洁、完整、可演进之间找到平衡。",
        ],
        handsOnPath: [
            "审查当前领域模型，移除不必要的抽象",
            "检查模型中是否有技术术语，替换为业务术语",
            "与领域专家讨论模型，收集理解难度的反馈",
            "记录模型的演进历史，追踪概念的变化",
            "建立模型变更的评审机制",
        ],
        selfCheck: [
            "领域模型的三个基本原则是什么？",
            "什么样的模型算是'简洁'的？",
            "如何验证模型是否能被领域专家理解？",
            "如何处理模型演进与现有代码的矛盾？",
            "过度抽象有什么危害？",
        ],
        extensions: [
            "学习 Model Exploration Whirlpool",
            "了解模型重构的安全方法",
            "研究如何在敏捷开发中演进领域模型",
            "探索模型版本管理的最佳实践",
        ],
        sourceUrls: [
            "https://www.domainlanguage.com/ddd/whirlpool/",
            "https://martinfowler.com/bliki/UbiquitousLanguage.html",
        ],
    },
}

export const week4Quizzes: Record<string, QuizQuestion[]> = {
    "w4-1": [
        {
            id: "w4-1-q1",
            question: "根据 Eric Evans 的定义，统一语言是什么？",
            options: [
                "一种编程语言",
                "在开发人员和用户之间建立的通用、严谨的语言",
                "一种文档格式",
                "一种测试方法",
            ],
            answer: 1,
            rationale: "Evans 定义统一语言为'在开发人员和用户之间建立的通用、严谨的语言'，基于软件中使用的领域模型。",
        },
        {
            id: "w4-1-q2",
            question: "为什么统一语言需要严谨性？",
            options: [
                "为了文档美观",
                "因为软件难以应对歧义",
                "为了通过审计",
                "为了减少代码量",
            ],
            answer: 1,
            rationale: "统一语言需要严谨性，'because software doesn't cope well with ambiguity'——软件难以应对歧义。",
        },
        {
            id: "w4-1-q3",
            question: "如何测试统一语言的有效性？",
            options: [
                "通过自动化测试",
                "通过与领域专家的对话",
                "通过代码覆盖率",
                "通过性能测试",
            ],
            answer: 1,
            rationale: "Evans 强调通过与领域专家的对话测试语言，这同时也是在测试领域模型本身。",
        },
        {
            id: "w4-1-q4",
            question: "关于统一语言的演进，以下哪个说法是正确的？",
            options: [
                "一旦确定就不应改变",
                "语言和模型应随着团队对领域理解的加深而不断演进",
                "每年更新一次",
                "只有架构师可以修改",
            ],
            answer: 1,
            rationale: "语言和模型应随着团队对领域理解的加深而不断演进，不是一成不变的。",
        },
        {
            id: "w4-1-q5",
            question: "领域专家在维护统一语言中的职责是什么？",
            options: [
                "编写代码",
                "对不当或不足以传达领域理解的用语提出异议",
                "进行代码审查",
                "部署应用",
            ],
            answer: 1,
            rationale: "领域专家应对不当或不足以传达领域理解的用语提出异议。",
        },
        {
            id: "w4-1-q6",
            question: "开发者在维护统一语言中的职责是什么？",
            options: [
                "只关注代码性能",
                "留意可能导致设计混乱的歧义或不一致之处",
                "只写文档",
                "只做测试",
            ],
            answer: 1,
            rationale: "开发者应留意可能导致设计混乱的歧义或不一致之处。",
        },
        {
            id: "w4-1-q7",
            question: "统一语言消除了什么？",
            options: [
                "所有 Bug",
                "开发者语言和业务语言之间的翻译",
                "所有文档",
                "所有测试",
            ],
            answer: 1,
            rationale: "统一语言消除了开发者语言和业务语言之间的翻译，减少沟通损耗。",
        },
        {
            id: "w4-1-q8",
            question: "Evans 说要达到什么状态才算统一语言建立成功？",
            options: [
                "文档完整",
                "普遍使用基于模型的语言，不断完善直到流畅自然",
                "代码量最少",
                "没有 Bug",
            ],
            answer: 1,
            rationale: "Evans 说'通过普遍使用基于模型的语言，不断完善直到流畅自然，我们能接近完整易懂的模型'。",
        },
        {
            id: "w4-1-q9",
            question: "语言不一致会带来什么问题？",
            options: [
                "服务器变慢",
                "需求误解、代码与业务脱节、沟通效率低下",
                "数据库损坏",
                "用户流失",
            ],
            answer: 1,
            rationale: "语言不一致会导致需求误解、代码与业务脱节、沟通效率低下。",
        },
        {
            id: "w4-1-q10",
            question: "统一语言应该基于什么？",
            options: [
                "编程语言语法",
                "软件中使用的领域模型",
                "数据库表名",
                "API 接口名称",
            ],
            answer: 1,
            rationale: "统一语言基于软件中使用的领域模型。",
        },
        {
            id: "w4-1-q11",
            question: "为什么与领域专家对话同时也是在测试领域模型？",
            options: [
                "专家会检查代码",
                "语言承载着模型的概念，语言有问题说明模型有问题",
                "专家会写测试用例",
                "专家会部署应用",
            ],
            answer: 1,
            rationale: "统一语言基于领域模型，通过对话测试语言的准确性，就是在测试模型是否准确反映了领域知识。",
        },
        {
            id: "w4-1-q12",
            question: "达到流畅的统一语言需要什么？",
            options: [
                "一次性设计完成",
                "持续努力和不断完善",
                "只需要文档",
                "只需要代码",
            ],
            answer: 1,
            rationale: "达到流畅需要持续努力，'通过普遍使用基于模型的语言，不断完善直到流畅自然'。",
        },
    ],
    "w4-2": [
        {
            id: "w4-2-q1",
            question: "统一语言应该如何建立？",
            options: [
                "由开发者单方面定义",
                "通过开发团队与领域专家的持续对话建立",
                "由项目经理定义",
                "从文档复制",
            ],
            answer: 1,
            rationale: "统一语言通过开发团队与领域专家的持续对话建立，不是单方面定义的。",
        },
        {
            id: "w4-2-q2",
            question: "领域词汇表的作用是什么？",
            options: [
                "替代代码注释",
                "记录术语定义，作为团队共同参考的权威来源",
                "生成代码",
                "进行测试",
            ],
            answer: 1,
            rationale: "建立领域词汇表记录术语定义，作为团队共同参考的权威来源。",
        },
        {
            id: "w4-2-q3",
            question: "代码中的命名应该使用什么？",
            options: [
                "技术缩写",
                "统一语言中的术语",
                "数据库字段名",
                "随机命名",
            ],
            answer: 1,
            rationale: "代码中的类名、方法名、变量名都应使用统一语言中的术语。",
        },
        {
            id: "w4-2-q4",
            question: "除了代码，还有什么应该使用统一语言？",
            options: [
                "只有代码需要",
                "文档、用户界面、API 都应使用",
                "只有文档需要",
                "只有 API 需要",
            ],
            answer: 1,
            rationale: "文档、用户界面、API 都应使用统一语言，保持一致性。",
        },
        {
            id: "w4-2-q5",
            question: "在会议中发现术语歧义时应该怎么做？",
            options: [
                "忽略继续讨论",
                "立即澄清并更新术语表",
                "会后再说",
                "让项目经理决定",
            ],
            answer: 1,
            rationale: "在会议中使用统一语言讨论，当发现歧义时立即澄清并更新术语表。",
        },
        {
            id: "w4-2-q6",
            question: "为什么术语表需要持续维护？",
            options: [
                "不需要维护",
                "否则会过时失去价值",
                "只需要创建一次",
                "可以自动维护",
            ],
            answer: 1,
            rationale: "术语表需要持续维护，否则会过时失去价值。",
        },
        {
            id: "w4-2-q7",
            question: "术语表应该记录什么信息？",
            options: [
                "只记录术语名称",
                "定义、示例、使用场景、反例",
                "只记录英文翻译",
                "只记录创建日期",
            ],
            answer: 1,
            rationale: "为每个术语记录：定义、示例、使用场景、反例，使术语表更有价值。",
        },
        {
            id: "w4-2-q8",
            question: "如何在代码审查中检查术语一致性？",
            options: [
                "不需要检查",
                "在 PR 审查模板中添加术语一致性检查项",
                "只检查代码逻辑",
                "只检查性能",
            ],
            answer: 1,
            rationale: "可以在 PR 审查模板中添加术语一致性检查项，确保代码命名与统一语言一致。",
        },
        {
            id: "w4-2-q9",
            question: "项目初期语言混乱时应该怎么办？",
            options: [
                "放弃统一语言",
                "耐心地逐步精化",
                "等项目结束再处理",
                "忽略混乱",
            ],
            answer: 1,
            rationale: "项目初期语言会比较混乱，需要耐心地逐步精化。",
        },
        {
            id: "w4-2-q10",
            question: "如何处理团队成员对用语的分歧？",
            options: [
                "让最资深的人决定",
                "协商达成共识，更新术语表",
                "投票决定",
                "保持分歧",
            ],
            answer: 1,
            rationale: "遇到分歧时应协商达成共识，并更新术语表作为权威参考。",
        },
        {
            id: "w4-2-q11",
            question: "术语表应该放在哪里？",
            options: [
                "只存在本地",
                "Wiki 或共享文档，链接到代码仓库",
                "只在邮件中",
                "只在个人笔记中",
            ],
            answer: 1,
            rationale: "使用 Wiki 或共享文档建立术语表，并将术语表链接到代码仓库的 README。",
        },
        {
            id: "w4-2-q12",
            question: "在大型项目中保持跨团队语言一致性的挑战是什么？",
            options: [
                "没有挑战",
                "不同团队可能发展出不同的用语，需要协调机制",
                "只有小项目有挑战",
                "只有新项目有挑战",
            ],
            answer: 1,
            rationale: "在大型项目中，不同团队可能发展出不同的用语，保持跨团队一致性需要额外的协调机制。",
        },
    ],
    "w4-3": [
        {
            id: "w4-3-q1",
            question: "根据 Martin Fowler，领域模型是什么？",
            options: [
                "只包含数据的对象",
                "包含行为和数据的领域对象模型",
                "只包含行为的对象",
                "数据库表的映射",
            ],
            answer: 1,
            rationale: "Fowler 定义领域模型是'an object model of the domain that incorporates both behavior and data'——包含行为和数据。",
        },
        {
            id: "w4-3-q2",
            question: "什么是贫血领域模型？",
            options: [
                "性能很差的模型",
                "领域对象只有 getter/setter，业务逻辑在服务层",
                "代码很少的模型",
                "没有测试的模型",
            ],
            answer: 1,
            rationale: "贫血领域模型是领域对象只有 getter/setter，业务逻辑全部放在服务层的反模式。",
        },
        {
            id: "w4-3-q3",
            question: "贫血领域模型是什么类型的模式？",
            options: [
                "最佳实践",
                "反模式",
                "设计模式",
                "架构模式",
            ],
            answer: 1,
            rationale: "贫血领域模型是'one of those anti-patterns that's been around for quite a long time'——一种长期存在的反模式。",
        },
        {
            id: "w4-3-q4",
            question: "充血领域模型的特点是什么？",
            options: [
                "只有数据没有行为",
                "将业务逻辑放在领域对象内",
                "只用于简单系统",
                "不需要测试",
            ],
            answer: 1,
            rationale: "充血领域模型将业务逻辑放在领域对象内，实现真正的面向对象设计。",
        },
        {
            id: "w4-3-q5",
            question: "什么容易导致贫血模型？",
            options: [
                "使用 DDD",
                "传统分层架构和 ORM 框架",
                "使用微服务",
                "使用函数式编程",
            ],
            answer: 1,
            rationale: "传统分层架构和 ORM 框架容易导向贫血模型。",
        },
        {
            id: "w4-3-q6",
            question: "代码与领域模型的关系应该是什么？",
            options: [
                "代码与模型无关",
                "代码应该反映领域模型，模型的变化应该反映在代码中",
                "模型只是文档",
                "代码比模型重要",
            ],
            answer: 1,
            rationale: "代码应该反映领域模型，模型的变化应该反映在代码中——这是模型驱动设计的核心。",
        },
        {
            id: "w4-3-q7",
            question: "判断行为应该属于哪个领域对象时的挑战是什么？",
            options: [
                "没有挑战",
                "有时不明显，需要仔细分析业务规则",
                "总是很明显",
                "不需要判断",
            ],
            answer: 1,
            rationale: "判断某个行为应该属于哪个实体有时不明显，需要仔细分析业务规则。",
        },
        {
            id: "w4-3-q8",
            question: "什么情况下简单的贫血模型可能是可接受的？",
            options: [
                "从不可接受",
                "简单的 CRUD 场景",
                "所有场景",
                "复杂业务系统",
            ],
            answer: 1,
            rationale: "简单场景使用复杂模型是过度设计，简单的 CRUD 场景贫血模型可能足够。",
        },
        {
            id: "w4-3-q9",
            question: "重构贫血模型的第一步是什么？",
            options: [
                "删除所有代码",
                "审查现有代码，识别贫血模型的特征",
                "重写整个系统",
                "添加更多服务层",
            ],
            answer: 1,
            rationale: "重构应从审查现有代码开始，识别贫血模型的特征，然后逐步将行为移入领域对象。",
        },
        {
            id: "w4-3-q10",
            question: "领域对象的方法名应该反映什么？",
            options: [
                "技术实现细节",
                "业务操作",
                "数据库操作",
                "API 调用",
            ],
            answer: 1,
            rationale: "为领域对象添加有意义的方法名，应该反映业务操作而非技术实现。",
        },
        {
            id: "w4-3-q11",
            question: "Model Exploration Whirlpool 描述的是什么？",
            options: [
                "数据库设计过程",
                "模型迭代精化的过程",
                "代码审查过程",
                "部署过程",
            ],
            answer: 1,
            rationale: "Evans 提出'Model Exploration Whirlpool'——模型探索漩涡，描述了模型迭代精化的过程。",
        },
        {
            id: "w4-3-q12",
            question: "领域模型的纯净性与持久化便利性之间需要什么？",
            options: [
                "只关注纯净性",
                "找到平衡",
                "只关注持久化",
                "两者无关",
            ],
            answer: 1,
            rationale: "需要平衡领域模型的纯净性和持久化的便利性。",
        },
    ],
    "w4-4": [
        {
            id: "w4-4-q1",
            question: "领域模型的简洁性原则意味着什么？",
            options: [
                "代码行数最少",
                "只包含对业务有意义的概念",
                "没有注释",
                "没有测试",
            ],
            answer: 1,
            rationale: "领域模型应该尽可能简洁，只包含对业务有意义的概念。",
        },
        {
            id: "w4-4-q2",
            question: "领域模型的可理解性原则意味着什么？",
            options: [
                "只有开发者能理解",
                "模型应该能被领域专家理解",
                "只有架构师能理解",
                "不需要被理解",
            ],
            answer: 1,
            rationale: "模型应该能被领域专家理解，而不仅仅是开发者。",
        },
        {
            id: "w4-4-q3",
            question: "领域模型的可演进性原则意味着什么？",
            options: [
                "模型一旦确定不能改变",
                "模型应该能够随着业务理解的深入而演进",
                "每年必须改变一次",
                "只有重大版本才能改变",
            ],
            answer: 1,
            rationale: "模型应该能够随着业务理解的深入而演进。",
        },
        {
            id: "w4-4-q4",
            question: "过度抽象会带来什么问题？",
            options: [
                "性能问题",
                "模型难以理解",
                "安全问题",
                "部署问题",
            ],
            answer: 1,
            rationale: "过度追求抽象会导致模型难以理解。",
        },
        {
            id: "w4-4-q5",
            question: "在模型中混入技术术语会有什么影响？",
            options: [
                "提高性能",
                "影响与领域专家的沟通",
                "增加安全性",
                "简化部署",
            ],
            answer: 1,
            rationale: "在模型中混入技术术语会影响与领域专家的沟通。",
        },
        {
            id: "w4-4-q6",
            question: "模型精化的反馈循环是什么？",
            options: [
                "代码 → 测试 → 部署",
                "模型 → 代码 → 运行 → 反馈 → 模型精化",
                "设计 → 开发 → 测试",
                "需求 → 设计 → 开发",
            ],
            answer: 1,
            rationale: "模型 → 代码 → 运行 → 反馈 → 模型精化，形成持续改进的循环。",
        },
        {
            id: "w4-4-q7",
            question: "已有代码可能对模型演进形成什么？",
            options: [
                "没有影响",
                "阻力",
                "加速",
                "帮助",
            ],
            answer: 1,
            rationale: "已有代码可能对模型演进形成阻力，需要谨慎处理。",
        },
        {
            id: "w4-4-q8",
            question: "如何验证模型是否能被领域专家理解？",
            options: [
                "只看代码",
                "与领域专家讨论模型，收集理解难度的反馈",
                "自己判断",
                "不需要验证",
            ],
            answer: 1,
            rationale: "与领域专家讨论模型，收集理解难度的反馈是验证可理解性的最佳方式。",
        },
        {
            id: "w4-4-q9",
            question: "在简洁、完整、可演进之间需要什么？",
            options: [
                "只关注简洁",
                "找到平衡",
                "只关注完整",
                "只关注可演进",
            ],
            answer: 1,
            rationale: "需要在简洁、完整、可演进之间找到平衡。",
        },
        {
            id: "w4-4-q10",
            question: "记录模型的演进历史有什么好处？",
            options: [
                "没有好处",
                "追踪概念的变化，理解设计决策的背景",
                "增加文档量",
                "满足审计要求",
            ],
            answer: 1,
            rationale: "记录模型的演进历史可以追踪概念的变化，帮助理解设计决策的背景。",
        },
        {
            id: "w4-4-q11",
            question: "审查当前领域模型时应该关注什么？",
            options: [
                "只关注代码性能",
                "移除不必要的抽象，检查是否有技术术语混入",
                "只关注代码行数",
                "只关注测试覆盖率",
            ],
            answer: 1,
            rationale: "审查时应移除不必要的抽象，检查模型中是否有技术术语需要替换为业务术语。",
        },
        {
            id: "w4-4-q12",
            question: "建立模型变更评审机制的目的是什么？",
            options: [
                "增加工作量",
                "确保模型变更经过深思熟虑，保持一致性",
                "减缓开发速度",
                "增加文档",
            ],
            answer: 1,
            rationale: "建立模型变更的评审机制可以确保变更经过深思熟虑，保持模型的一致性和质量。",
        },
    ],
}
