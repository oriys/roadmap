import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week3Guides: Record<string, LessonGuide> = {
    "w3-1": {
        lessonId: "w3-1",
        background: [
            "【限界上下文定义】Martin Fowler：限界上下文是 DDD 的核心战略模式，'defines a specific area within which a domain model is consistent and valid'——定义模型一致且有效的特定区域。",
            "【语义边界】同一个词在不同限界上下文中可能有完全不同的含义。Fowler 以电力公司为例，'meter'对不同部门含义截然不同。",
            "【完全统一不可行】DDD 承认'total unification of the domain model for a large system will not be feasible or cost-effective'——大系统完全统一模型既不可行也不划算。",
            "【解决方案空间】限界上下文属于解决方案空间，帮助'maintaining the integrity of domain models within certain context, by clearly defining boundaries'。",
            "【促进沟通】模型充当通用语言，帮助开发者与领域专家交流，边界清晰地分离关注点。",
        ],
        keyDifficulties: [
            "【边界由文化决定】Fowler 强调边界通常由组织文化决定——当语言改变时，模型也应改变。",
            "【概念多义性】不同上下文间需要通过映射机制协调多义概念（如'客户'在不同上下文的含义）。",
            "【与微服务的区别】限界上下文 ≠ 微服务，一个上下文可能包含多个服务，多个上下文也可能在一个服务中。",
            "【过度或不足划分】划分过细增加集成复杂度，划分过粗导致概念混淆。",
        ],
        handsOnPath: [
            "分析你当前系统中的核心业务概念",
            "识别哪些概念在不同场景下有不同含义",
            "尝试画出系统的限界上下文边界图",
            "标注上下文之间的关系和交互方式",
            "与团队讨论并验证边界划分的合理性",
        ],
        selfCheck: [
            "什么是限界上下文？它解决什么问题？",
            "为什么说完全统一大系统的域模型是不可行的？",
            "限界上下文的边界通常由什么决定？",
            "限界上下文与微服务有什么区别和联系？",
            "如何处理同一概念在不同上下文中的多义性？",
        ],
        extensions: [
            "深入学习上下文映射（Context Mapping）模式",
            "了解 Conway's Law 与限界上下文的关系",
            "研究团队拓扑（Team Topologies）与限界上下文对齐",
            "探索如何在遗留系统中识别隐含的限界上下文",
        ],
        sourceUrls: [
            "https://martinfowler.com/bliki/BoundedContext.html",
            "https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/",
        ],
    },
    "w3-2": {
        lessonId: "w3-2",
        background: [
            "【识别信号】当不同团队或部门对同一术语有不同理解时，这是限界上下文边界的信号。",
            "【组织结构启发】可以从组织结构入手识别上下文——不同部门通常对应不同的业务能力和语言。",
            "【高内聚低耦合】上下文划分应遵循高内聚、低耦合原则，按业务能力而非技术分层划分。",
            "【迭代过程】识别子域和上下文'是一个迭代过程'，需要逐步确定正确的分解方式。",
            "【业务理解优先】识别上下文需要理解业务，不能仅凭技术判断。",
        ],
        keyDifficulties: [
            "【语言边界模糊】在同一组织内，语言边界可能不够清晰，需要仔细观察。",
            "【技术思维干扰】开发者容易从技术角度（如前端/后端）而非业务角度划分。",
            "【利益相关者分歧】不同角色对边界可能有不同看法，需要协商达成共识。",
            "【演进需求】边界可能随业务发展需要调整，不是一成不变的。",
        ],
        handsOnPath: [
            "收集系统中的所有业务术语，建立术语表",
            "识别哪些术语在不同场景有不同含义",
            "访谈不同部门的用户，了解他们的语言和工作流程",
            "使用 EventStorming 发现自然的边界",
            "绘制候选的限界上下文图，标注争议区域",
        ],
        selfCheck: [
            "识别限界上下文的主要信号是什么？",
            "为什么说识别上下文是一个迭代过程？",
            "如何避免从技术角度而非业务角度划分上下文？",
            "组织结构如何帮助识别上下文边界？",
            "当不同角色对边界有分歧时如何处理？",
        ],
        extensions: [
            "学习领域故事讲述（Domain Storytelling）识别边界",
            "了解 Big Picture EventStorming 发现上下文",
            "研究如何处理跨上下文的业务流程",
            "探索上下文边界与团队边界的关系",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/decomposition/decompose-by-subdomain.html",
            "https://github.com/ddd-crew/bounded-context-canvas",
        ],
    },
    "w3-3": {
        lessonId: "w3-3",
        background: [
            "【画布定义】限界上下文画布是'设计和记录单个限界上下文设计的协作工具'，受商业模式画布启发。",
            "【核心作用】帮助团队明确界限，确保对上下文目的的共同理解，将 DDD 复杂概念转化为可视化工作表。",
            "【核心部分】包括：名称与目的、战略分类、双向通信、业务规则与假设、开放问题。",
            "【填充顺序】建议从命名和目的开始，然后可按'由外向内'（从入站通信开始）或'由内向外'（从业务规则开始）的方向填充。",
            "【多格式支持】可用 HTML、Miro、draw.io、Excalidraw、Lucidchart 等格式适应不同团队偏好。",
        ],
        keyDifficulties: [
            "【战略分类评估】需要评估上下文的重要性、商业角色和演进阶段，这需要业务洞察。",
            "【假设追踪】需要区分已确认的决策和未确认的假设，追踪设计的不确定因素。",
            "【协作组织】画布是协作工具，需要多方参与才能发挥最大价值。",
            "【持续更新】画布不是一次性产物，需要随着理解深入持续更新。",
        ],
        handsOnPath: [
            "选择一个核心业务上下文",
            "下载限界上下文画布模板（Miro 或 draw.io）",
            "填写上下文的名称和核心目的",
            "记录入站和出站消息及协作者",
            "列出关键业务规则和当前假设",
            "标注开放问题，计划后续验证",
        ],
        selfCheck: [
            "限界上下文画布的核心部分有哪些？",
            "画布建议的填充顺序是什么？",
            "战略分类需要评估哪些维度？",
            "为什么需要追踪假设和开放问题？",
            "画布应该多久更新一次？",
        ],
        extensions: [
            "学习 Bounded Context Canvas 的完整指南",
            "了解如何将画布与团队拓扑结合使用",
            "研究画布在敏捷开发中的应用",
            "探索如何用画布支持架构决策记录（ADR）",
        ],
        sourceUrls: [
            "https://github.com/ddd-crew/bounded-context-canvas",
        ],
    },
    "w3-4": {
        lessonId: "w3-4",
        background: [
            "【微服务边界原则】'微服务应不小于聚合，不大于限界上下文'——这是关于微服务边界的一般原则。",
            "【不是一一对应】限界上下文与微服务不是一一对应关系，一个上下文可能包含多个服务。",
            "【按子域分解】微服务可以根据 DDD 子域来定义，'定义与域驱动设计(DDD)子域相对应的服务'。",
            "【三大益处】按子域分解提供：稳定的架构、跨职能的自主团队、高内聚低耦合的服务。",
            "【每个微服务一个域模型】'Design a domain model for each microservice or Bounded Context'——每个微服务应有其对应的域模型。",
        ],
        keyDifficulties: [
            "【过度拆分风险】过度将上下文拆分为微服务会增加分布式系统的复杂性。",
            "【数据一致性】跨微服务的数据一致性需要额外的机制（如 Saga）来保证。",
            "【团队组织】微服务边界应与团队边界对齐，避免跨团队协调开销。",
            "【演进而非革命】应该渐进式地演进到微服务，而非一次性大规模重构。",
        ],
        handsOnPath: [
            "绘制当前系统的限界上下文图",
            "评估每个上下文是否值得拆分为独立微服务",
            "考虑团队结构与上下文的对齐",
            "识别上下文之间的集成点和数据流",
            "制定渐进式微服务化的路线图",
        ],
        selfCheck: [
            "限界上下文与微服务的关系是什么？",
            "微服务边界的一般原则是什么？",
            "按子域分解微服务有什么益处？",
            "过度拆分会带来什么问题？",
            "如何处理跨微服务的数据一致性？",
        ],
        extensions: [
            "学习 Saga 模式处理分布式事务",
            "了解 API 网关在微服务架构中的作用",
            "研究服务网格（Service Mesh）与限界上下文",
            "探索单体到微服务的演进策略",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/decomposition/decompose-by-subdomain.html",
            "https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/",
        ],
    },
}

export const week3Quizzes: Record<string, QuizQuestion[]> = {
    "w3-1": [
        {
            id: "w3-1-q1",
            question: "根据 Martin Fowler 的定义，限界上下文的主要作用是什么？",
            options: [
                "定义数据库边界",
                "定义模型一致且有效的特定区域",
                "定义 API 接口",
                "定义用户界面",
            ],
            answer: 1,
            rationale: "Fowler 定义限界上下文'defines a specific area within which a domain model is consistent and valid'——定义模型一致且有效的特定区域。",
        },
        {
            id: "w3-1-q2",
            question: "为什么 DDD 认为大系统完全统一域模型是不可行的？",
            options: [
                "技术限制",
                "既不可行也不划算，不同部分有不同的语言和概念",
                "团队太小",
                "时间不够",
            ],
            answer: 1,
            rationale: "DDD 承认'total unification of the domain model for a large system will not be feasible or cost-effective'。",
        },
        {
            id: "w3-1-q3",
            question: "Fowler 用什么例子说明同一术语在不同上下文的多义性？",
            options: [
                "用户在不同系统中的含义",
                "电力公司中'meter'对不同部门含义截然不同",
                "订单在不同阶段的含义",
                "产品在不同渠道的含义",
            ],
            answer: 1,
            rationale: "Fowler 以电力公司为例，'meter'（电表）对不同部门的含义截然不同。",
        },
        {
            id: "w3-1-q4",
            question: "限界上下文的边界通常由什么决定？",
            options: [
                "技术架构",
                "组织文化——当语言改变时，模型也应改变",
                "数据库设计",
                "服务器配置",
            ],
            answer: 1,
            rationale: "Fowler 强调边界通常由组织文化决定——当语言改变时，模型也应改变。",
        },
        {
            id: "w3-1-q5",
            question: "限界上下文与微服务的关系是什么？",
            options: [
                "必须一一对应",
                "没有关系",
                "不是一一对应，一个上下文可能包含多个服务",
                "微服务比上下文更重要",
            ],
            answer: 2,
            rationale: "限界上下文 ≠ 微服务，一个上下文可能包含多个服务，多个上下文也可能在一个服务中。",
        },
        {
            id: "w3-1-q6",
            question: "限界上下文属于 DDD 的哪个空间？",
            options: [
                "问题空间",
                "解决方案空间",
                "技术空间",
                "用户空间",
            ],
            answer: 1,
            rationale: "限界上下文属于解决方案空间，子域属于问题空间。",
        },
        {
            id: "w3-1-q7",
            question: "限界上下文如何促进团队沟通？",
            options: [
                "通过增加文档",
                "模型充当通用语言，帮助开发者与领域专家交流",
                "通过增加会议",
                "通过减少代码量",
            ],
            answer: 1,
            rationale: "模型充当通用语言，帮助开发者与领域专家交流，边界清晰地分离关注点。",
        },
        {
            id: "w3-1-q8",
            question: "上下文划分过细会带来什么问题？",
            options: [
                "代码太少",
                "增加集成复杂度",
                "团队太多",
                "文档太多",
            ],
            answer: 1,
            rationale: "划分过细增加集成复杂度，划分过粗导致概念混淆，需要找到平衡。",
        },
        {
            id: "w3-1-q9",
            question: "如何处理同一概念在不同上下文中的多义性？",
            options: [
                "强制统一所有定义",
                "通过上下文映射机制协调",
                "删除重复概念",
                "忽略不处理",
            ],
            answer: 1,
            rationale: "不同上下文间需要通过映射机制协调多义概念（如'客户'在不同上下文的含义）。",
        },
        {
            id: "w3-1-q10",
            question: "限界上下文帮助解决的核心问题是什么？",
            options: [
                "性能问题",
                "维护域模型在特定上下文内的完整性和一致性",
                "安全问题",
                "部署问题",
            ],
            answer: 1,
            rationale: "限界上下文帮助'maintaining the integrity of domain models within certain context, by clearly defining boundaries'。",
        },
        {
            id: "w3-1-q11",
            question: "当多个团队在同一系统上工作时，限界上下文如何帮助他们？",
            options: [
                "强制使用同一种编程语言",
                "允许不同团队用各自的语言工作，通过边界分离",
                "减少团队数量",
                "增加项目经理",
            ],
            answer: 1,
            rationale: "限界上下文支持多团队协作，允许不同团队用各自的语言工作，通过边界分离关注点。",
        },
        {
            id: "w3-1-q12",
            question: "限界上下文的核心价值是什么？",
            options: [
                "减少代码量",
                "通过定义清晰的模型边界来管理复杂性",
                "提高性能",
                "减少服务器成本",
            ],
            answer: 1,
            rationale: "限界上下文的核心价值是通过定义清晰的模型边界来管理大型系统的复杂性。",
        },
    ],
    "w3-2": [
        {
            id: "w3-2-q1",
            question: "识别限界上下文边界的主要信号是什么？",
            options: [
                "代码行数达到某个阈值",
                "不同团队或部门对同一术语有不同理解",
                "数据库表数量超过限制",
                "API 接口数量太多",
            ],
            answer: 1,
            rationale: "当不同团队或部门对同一术语有不同理解时，这是限界上下文边界的信号。",
        },
        {
            id: "w3-2-q2",
            question: "识别限界上下文的过程有什么特点？",
            options: [
                "一次性完成，不需要调整",
                "是一个迭代过程，需要逐步确定正确的分解方式",
                "只能由架构师完成",
                "必须在项目开始前完成",
            ],
            answer: 1,
            rationale: "文档指出识别子域和上下文'是一个迭代过程'，需要逐步确定正确的分解方式。",
        },
        {
            id: "w3-2-q3",
            question: "上下文划分应遵循什么原则？",
            options: [
                "按技术分层划分",
                "高内聚、低耦合，按业务能力划分",
                "按团队规模划分",
                "按代码量划分",
            ],
            answer: 1,
            rationale: "上下文划分应遵循高内聚、低耦合原则，按业务能力而非技术分层划分。",
        },
        {
            id: "w3-2-q4",
            question: "识别限界上下文时最需要什么？",
            options: [
                "高级编程技能",
                "理解业务",
                "熟悉数据库设计",
                "了解前端框架",
            ],
            answer: 1,
            rationale: "识别上下文需要理解业务，不能仅凭技术判断。",
        },
        {
            id: "w3-2-q5",
            question: "组织结构如何帮助识别限界上下文？",
            options: [
                "组织结构与上下文无关",
                "不同部门通常对应不同的业务能力和语言",
                "只有技术部门才有上下文",
                "上下文必须跨所有部门",
            ],
            answer: 1,
            rationale: "可以从组织结构入手识别上下文——不同部门通常对应不同的业务能力和语言。",
        },
        {
            id: "w3-2-q6",
            question: "开发者在划分上下文时容易犯什么错误？",
            options: [
                "考虑太多业务因素",
                "从技术角度（如前端/后端）而非业务角度划分",
                "与业务专家沟通太多",
                "划分太少",
            ],
            answer: 1,
            rationale: "开发者容易从技术角度（如前端/后端）而非业务角度划分，这是需要警惕的思维陷阱。",
        },
        {
            id: "w3-2-q7",
            question: "当不同角色对上下文边界有分歧时应该怎么做？",
            options: [
                "由架构师单方面决定",
                "协商达成共识",
                "忽略分歧",
                "取消上下文划分",
            ],
            answer: 1,
            rationale: "不同角色可能对边界有不同看法，需要协商达成共识。",
        },
        {
            id: "w3-2-q8",
            question: "上下文边界是否会随时间变化？",
            options: [
                "一旦确定永不改变",
                "可能随业务发展需要调整",
                "只有技术更新时才变化",
                "每年必须重新划分",
            ],
            answer: 1,
            rationale: "边界可能随业务发展需要调整，不是一成不变的。",
        },
        {
            id: "w3-2-q9",
            question: "使用 EventStorming 发现边界的原理是什么？",
            options: [
                "通过写代码发现",
                "通过可视化业务事件流发现自然的概念边界",
                "通过数据库设计发现",
                "通过 API 设计发现",
            ],
            answer: 1,
            rationale: "EventStorming 通过可视化业务事件流，帮助发现自然的概念和语言边界。",
        },
        {
            id: "w3-2-q10",
            question: "建立术语表对识别上下文有什么帮助？",
            options: [
                "没有帮助",
                "帮助识别哪些术语在不同场景有不同含义",
                "只是文档要求",
                "只对新员工有用",
            ],
            answer: 1,
            rationale: "建立术语表可以帮助识别哪些术语在不同场景有不同含义，这是上下文边界的信号。",
        },
        {
            id: "w3-2-q11",
            question: "为什么要访谈不同部门的用户来识别上下文？",
            options: [
                "收集用户反馈",
                "了解他们的语言和工作流程，发现语言边界",
                "评估用户满意度",
                "收集功能需求",
            ],
            answer: 1,
            rationale: "访谈不同部门的用户可以了解他们的语言和工作流程，从而发现语言和概念的边界。",
        },
        {
            id: "w3-2-q12",
            question: "识别到候选上下文后应该怎么做？",
            options: [
                "立即开始编码",
                "与团队讨论并验证边界划分的合理性",
                "直接交付产品",
                "忽略验证步骤",
            ],
            answer: 1,
            rationale: "识别候选上下文后应该与团队讨论并验证边界划分的合理性，标注争议区域，达成共识。",
        },
    ],
    "w3-3": [
        {
            id: "w3-3-q1",
            question: "限界上下文画布的定义是什么？",
            options: [
                "一种编程框架",
                "设计和记录单个限界上下文设计的协作工具",
                "一种测试方法",
                "一种部署工具",
            ],
            answer: 1,
            rationale: "限界上下文画布是'设计和记录单个限界上下文设计的协作工具'，受商业模式画布启发。",
        },
        {
            id: "w3-3-q2",
            question: "限界上下文画布建议从什么开始填充？",
            options: [
                "从技术实现开始",
                "从命名和目的开始阐明存在理由",
                "从数据库设计开始",
                "从 API 设计开始",
            ],
            answer: 1,
            rationale: "建议流程是从命名和目的开始阐明存在理由，然后按任意顺序填充其他部分。",
        },
        {
            id: "w3-3-q3",
            question: "限界上下文画布的核心部分不包括以下哪个？",
            options: [
                "名称与目的",
                "战略分类",
                "数据库表结构",
                "业务规则与假设",
            ],
            answer: 2,
            rationale: "画布核心部分包括：名称与目的、战略分类、双向通信、业务规则与假设、开放问题。不包括数据库表结构。",
        },
        {
            id: "w3-3-q4",
            question: "画布中'战略分类'需要评估什么？",
            options: [
                "代码质量",
                "上下文的重要性、商业角色和演进阶段",
                "团队人数",
                "服务器配置",
            ],
            answer: 1,
            rationale: "战略分类需要评估上下文的重要性、商业角色和演进阶段。",
        },
        {
            id: "w3-3-q5",
            question: "画布中'由外向内'的填充方向意味着什么？",
            options: [
                "从代码开始",
                "从入站通信开始",
                "从测试开始",
                "从部署开始",
            ],
            answer: 1,
            rationale: "可以选择'由外向内'（从入站通信开始）或'由内向外'（从业务规则开始）的设计方向。",
        },
        {
            id: "w3-3-q6",
            question: "为什么画布需要追踪假设和开放问题？",
            options: [
                "为了增加文档量",
                "帮助区分已确认的决策和未确认的假设，追踪设计的不确定因素",
                "为了通过审计",
                "没有必要追踪",
            ],
            answer: 1,
            rationale: "需要区分已确认的决策和未确认的假设，追踪设计的不确定因素，以便后续验证。",
        },
        {
            id: "w3-3-q7",
            question: "限界上下文画布支持哪些格式？",
            options: [
                "只支持 Word 文档",
                "HTML、Miro、draw.io、Excalidraw、Lucidchart 等多种格式",
                "只支持 PDF",
                "只支持代码注释",
            ],
            answer: 1,
            rationale: "画布可用多种格式（HTML、Miro、draw.io、Excalidraw、Lucidchart）来适应不同团队的工作偏好。",
        },
        {
            id: "w3-3-q8",
            question: "画布中'双向通信'部分记录什么？",
            options: [
                "团队成员联系方式",
                "入站和出站消息及协作者",
                "会议记录",
                "邮件模板",
            ],
            answer: 1,
            rationale: "双向通信部分记录入站和出站消息及协作者，明确上下文与外部的交互。",
        },
        {
            id: "w3-3-q9",
            question: "画布是协作工具，这意味着什么？",
            options: [
                "只有一个人可以编辑",
                "需要多方参与才能发挥最大价值",
                "只有架构师可以使用",
                "不需要讨论",
            ],
            answer: 1,
            rationale: "画布是协作工具，需要多方参与才能发挥最大价值。",
        },
        {
            id: "w3-3-q10",
            question: "关于画布的更新频率，以下哪个说法是正确的？",
            options: [
                "填写一次就永不改变",
                "需要随着理解深入持续更新",
                "每年更新一次",
                "只在项目结束时更新",
            ],
            answer: 1,
            rationale: "画布不是一次性产物，需要随着理解深入持续更新。",
        },
        {
            id: "w3-3-q11",
            question: "限界上下文画布受什么工具的启发？",
            options: [
                "UML 图",
                "商业模式画布",
                "甘特图",
                "流程图",
            ],
            answer: 1,
            rationale: "限界上下文画布受商业模式画布的启发，将 DDD 复杂概念转化为可视化工作表。",
        },
        {
            id: "w3-3-q12",
            question: "画布的核心目的是什么？",
            options: [
                "生成代码",
                "帮助团队明确界限，确保对上下文目的的共同理解",
                "进行性能测试",
                "部署应用",
            ],
            answer: 1,
            rationale: "画布的核心目的是帮助团队明确界限，确保对上下文目的的共同理解。",
        },
    ],
    "w3-4": [
        {
            id: "w3-4-q1",
            question: "关于微服务边界的一般原则是什么？",
            options: [
                "微服务越小越好",
                "微服务越大越好",
                "微服务应不小于聚合，不大于限界上下文",
                "微服务与上下文无关",
            ],
            answer: 2,
            rationale: "'微服务应不小于聚合，不大于限界上下文'——这是关于微服务边界的一般原则。",
        },
        {
            id: "w3-4-q2",
            question: "按子域分解微服务有什么益处？",
            options: [
                "减少代码量",
                "稳定的架构、跨职能的自主团队、高内聚低耦合的服务",
                "降低服务器成本",
                "减少测试工作",
            ],
            answer: 1,
            rationale: "按子域分解提供三大益处：稳定的架构、跨职能的自主团队、高内聚低耦合的服务。",
        },
        {
            id: "w3-4-q3",
            question: "限界上下文与微服务是什么关系？",
            options: [
                "必须一一对应",
                "不是一一对应，一个上下文可能包含多个服务",
                "微服务必须跨多个上下文",
                "完全没有关系",
            ],
            answer: 1,
            rationale: "限界上下文与微服务不是一一对应关系，一个上下文可能包含多个服务。",
        },
        {
            id: "w3-4-q4",
            question: "每个微服务应该有什么？",
            options: [
                "多个数据库",
                "其对应的域模型",
                "多个限界上下文",
                "共享的代码库",
            ],
            answer: 1,
            rationale: "'Design a domain model for each microservice or Bounded Context'——每个微服务应有其对应的域模型。",
        },
        {
            id: "w3-4-q5",
            question: "过度将上下文拆分为微服务会带来什么问题？",
            options: [
                "代码太少",
                "增加分布式系统的复杂性",
                "团队太少",
                "文档太少",
            ],
            answer: 1,
            rationale: "过度将上下文拆分为微服务会增加分布式系统的复杂性。",
        },
        {
            id: "w3-4-q6",
            question: "跨微服务的数据一致性需要什么机制？",
            options: [
                "共享数据库",
                "Saga 等分布式事务模式",
                "直接数据库访问",
                "忽略一致性",
            ],
            answer: 1,
            rationale: "跨微服务的数据一致性需要额外的机制（如 Saga）来保证。",
        },
        {
            id: "w3-4-q7",
            question: "微服务边界与团队边界的关系应该是什么？",
            options: [
                "完全无关",
                "应该对齐，避免跨团队协调开销",
                "必须跨越多个团队",
                "每个微服务需要多个团队",
            ],
            answer: 1,
            rationale: "微服务边界应与团队边界对齐，避免跨团队协调开销。",
        },
        {
            id: "w3-4-q8",
            question: "从单体迁移到微服务应该采取什么策略？",
            options: [
                "一次性全部重写",
                "渐进式演进，而非一次性大规模重构",
                "忽略单体直接新建",
                "只迁移数据库",
            ],
            answer: 1,
            rationale: "应该渐进式地演进到微服务，而非一次性大规模重构。",
        },
        {
            id: "w3-4-q9",
            question: "在评估是否将上下文拆分为微服务时，应考虑什么？",
            options: [
                "只考虑代码行数",
                "团队结构、部署需求、数据一致性要求等",
                "只考虑数据库大小",
                "只考虑用户数量",
            ],
            answer: 1,
            rationale: "应考虑团队结构、部署需求、数据一致性要求、运维能力等多方面因素。",
        },
        {
            id: "w3-4-q10",
            question: "DDD 在微服务架构中主要帮助解决什么问题？",
            options: [
                "性能问题",
                "帮助定义服务边界和领域模型",
                "安全问题",
                "部署问题",
            ],
            answer: 1,
            rationale: "DDD 帮助定义与业务对齐的服务边界和领域模型，使微服务架构更加稳定。",
        },
        {
            id: "w3-4-q11",
            question: "Microsoft 文档强调 DDD 技术适用于什么类型的微服务？",
            options: [
                "所有微服务",
                "需要处理复杂子系统、涉及不断变化业务规则的高级微服务",
                "只有前端微服务",
                "只有数据库微服务",
            ],
            answer: 1,
            rationale: "文档重点关注'需要处理复杂子系统的高级微服务'，特别是涉及领域专家知识和不断变化业务规则的系统。",
        },
        {
            id: "w3-4-q12",
            question: "制定微服务化路线图时应该注意什么？",
            options: [
                "一次性完成所有迁移",
                "识别集成点和数据流，制定渐进式路线图",
                "忽略现有系统",
                "只关注新功能",
            ],
            answer: 1,
            rationale: "应该识别上下文之间的集成点和数据流，制定渐进式微服务化的路线图。",
        },
    ],
}
