import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week18Guides: Record<string, LessonGuide> = {
    "w18-1": {
        lessonId: "w18-1",
        background: [
            "【知识消化】DDD Starter Modelling Process 第一步'Understand'：理解业务模型和用户需求，与组织目标对齐。",
            "【领域专家访谈】与领域专家的深度交流是理解业务的关键，'Domain Expert Interviews'是重要实践。",
            "【工具支持】可使用 Business Model Canvas 和 Impact Mapping 等工具辅助需求理解。",
            "【统一语言基础】在需求理解阶段就开始建立统一语言，记录关键业务术语。",
            "【迭代理解】需求理解不是一次性的，随着项目推进需要持续深化理解。",
        ],
        keyDifficulties: [
            "【沟通障碍】开发者和领域专家使用不同的语言，需要建立共同理解。",
            "【隐性知识】很多领域知识是隐性的，领域专家可能难以清晰表达。",
            "【需求变化】业务需求会随时间变化，需要持续跟踪和更新理解。",
            "【领域专家时间】领域专家通常很忙，获取他们的时间是挑战。",
        ],
        handsOnPath: [
            "识别和联系关键领域专家",
            "准备访谈问题和议程",
            "进行领域专家访谈",
            "记录关键业务术语和概念",
            "绘制业务流程草图",
            "验证理解的准确性",
            "建立统一语言词汇表",
        ],
        selfCheck: [
            "如何识别关键的领域专家？",
            "领域专家访谈应该问什么问题？",
            "如何记录和验证领域知识？",
            "什么是知识消化（Knowledge Crunching）？",
            "如何处理领域专家表达的隐性知识？",
        ],
        extensions: [
            "学习 Business Model Canvas 的使用",
            "了解 Impact Mapping 方法",
            "研究用户故事映射（User Story Mapping）",
            "探索领域知识的可视化技术",
        ],
        sourceUrls: [
            "https://github.com/ddd-crew/ddd-starter-modelling-process",
            "https://www.domainlanguage.com/ddd/",
        ],
    },
    "w18-2": {
        lessonId: "w18-2",
        background: [
            "【发现步骤】DDD Starter Modelling Process 的'Discover'步骤：使用 EventStorming 协作映射领域。",
            "【分解步骤】'Decompose'步骤：将领域分解为松耦合的子域，减少认知负担。",
            "【战略化步骤】'Strategize'步骤：识别核心域——具有最大业务差异化的领域。",
            "【Core Domain Chart】使用核心域图表帮助优先级排序和构建/购买决策。",
            "【连接步骤】'Connect'步骤：设计子域间的交互，最小化不必要的耦合。",
        ],
        keyDifficulties: [
            "【边界识别】识别正确的子域边界需要深入理解业务和技术约束。",
            "【优先级决策】在多个子域间分配资源需要明确的优先级标准。",
            "【耦合管理】设计子域间的交互时需要权衡耦合和复杂度。",
            "【迭代需要】战略设计通常需要多次迭代，不能一次完成。",
        ],
        handsOnPath: [
            "使用 EventStorming 探索领域",
            "识别子域和它们的边界",
            "使用 Core Domain Chart 分析子域类型",
            "确定核心、支持和通用子域",
            "设计子域间的交互方式",
            "使用 Domain Message Flow 验证设计",
            "绘制上下文映射图",
        ],
        selfCheck: [
            "如何使用 EventStorming 发现子域？",
            "什么是 Core Domain Chart？如何使用？",
            "如何识别核心域、支持域和通用域？",
            "子域间的交互如何设计？",
            "战略设计的产出是什么？",
        ],
        extensions: [
            "学习 Domain Message Flow Modelling",
            "了解 Context Mapping 的详细实践",
            "研究 Wardley Mapping 与 DDD 的结合",
            "探索战略设计的自动化工具",
        ],
        sourceUrls: [
            "https://github.com/ddd-crew/ddd-starter-modelling-process",
            "https://github.com/ddd-by-examples/library",
        ],
    },
    "w18-3": {
        lessonId: "w18-3",
        background: [
            "【定义步骤】DDD Starter Modelling Process 的'Define'步骤：使用 Bounded Context Canvas 定义每个上下文的角色和职责。",
            "【Bounded Context Canvas】在编码前明确上下文的输入、输出、依赖和业务规则。",
            "【Aggregate Design Canvas】指导战术实现，定义聚合的名称、描述、状态转换和不变量。",
            "【编码步骤】'Code'步骤：实现反映协作理解的领域模型。",
            "【代码即模型】代码应该准确反映领域模型，而不是偏离模型的技术实现。",
        ],
        keyDifficulties: [
            "【聚合边界】确定正确的聚合边界是复杂的设计决策。",
            "【不变量识别】识别和保护业务不变量需要深入理解业务规则。",
            "【一致性权衡】在强一致性和性能之间权衡。",
            "【技术映射】将领域概念映射到技术实现需要经验。",
        ],
        handsOnPath: [
            "为每个限界上下文填写 Bounded Context Canvas",
            "识别上下文中的聚合",
            "使用 Aggregate Design Canvas 设计聚合",
            "定义实体和值对象",
            "识别领域服务和领域事件",
            "验证设计保护业务不变量",
            "开始编写领域模型代码",
        ],
        selfCheck: [
            "什么是 Bounded Context Canvas？包含哪些部分？",
            "什么是 Aggregate Design Canvas？",
            "如何确定聚合边界？",
            "聚合应该保护什么不变量？",
            "如何验证战术设计的正确性？",
        ],
        extensions: [
            "学习 Bounded Context Canvas 的详细使用",
            "了解 Example Mapping 与战术设计的结合",
            "研究行为驱动开发（BDD）与 DDD",
            "探索领域模型的测试策略",
        ],
        sourceUrls: [
            "https://github.com/ddd-crew/aggregate-design-canvas",
            "https://github.com/ddd-by-examples/library",
        ],
    },
    "w18-4": {
        lessonId: "w18-4",
        background: [
            "【代码结构】领域模型代码应该组织在独立的领域层，与基础设施分离。",
            "【模型反映】代码应该准确反映领域模型，使用统一语言命名。",
            "【测试驱动】TDD 与 DDD 结合：先编写测试描述行为，再实现领域逻辑。",
            "【持续重构】随着理解深入，持续重构代码以更好地反映领域。",
            "【示例代码】ddd-by-examples/library 是一个完整的 DDD 实现示例。",
        ],
        keyDifficulties: [
            "【过度设计】避免在不需要的地方引入复杂的 DDD 模式。",
            "【技术债务】不恰当的设计决策会积累技术债务。",
            "【团队技能】团队需要理解 DDD 概念才能正确实现。",
            "【框架选择】选择支持 DDD 的技术栈和框架。",
        ],
        handsOnPath: [
            "设计代码的分层结构",
            "实现聚合根和实体",
            "实现值对象",
            "实现领域服务",
            "实现领域事件",
            "实现仓储接口",
            "编写领域模型的单元测试",
            "集成基础设施层",
        ],
        selfCheck: [
            "领域模型代码应该如何组织？",
            "如何确保代码反映领域模型？",
            "TDD 如何与 DDD 结合？",
            "什么时候需要重构领域模型？",
            "如何避免过度设计？",
        ],
        extensions: [
            "学习具体编程语言的 DDD 实现",
            "了解领域模型的持久化策略",
            "研究领域模型的性能优化",
            "探索领域模型的版本管理",
        ],
        sourceUrls: [
            "https://github.com/ddd-by-examples/library",
            "https://enterprisecraftsmanship.com/posts/tdd-ddd/",
        ],
    },
}

export const week18Quizzes: Record<string, QuizQuestion[]> = {
    "w18-1": [
        {
            id: "w18-1-q1",
            question: "DDD Starter Modelling Process 的第一步是什么？",
            options: [
                "编写代码",
                "Understand——理解业务模型和用户需求",
                "设计数据库",
                "创建测试",
            ],
            answer: 1,
            rationale: "第一步'Understand'：与组织目标对齐，理解业务模型和用户需求。",
        },
        {
            id: "w18-1-q2",
            question: "理解需求阶段可以使用什么工具？",
            options: [
                "代码编辑器",
                "Business Model Canvas 和 Impact Mapping",
                "数据库工具",
                "测试框架",
            ],
            answer: 1,
            rationale: "可使用 Business Model Canvas 和 Impact Mapping 等工具辅助需求理解。",
        },
        {
            id: "w18-1-q3",
            question: "与领域专家沟通的主要挑战是什么？",
            options: [
                "技术问题",
                "开发者和领域专家使用不同的语言",
                "网络问题",
                "时间不够",
            ],
            answer: 1,
            rationale: "开发者和领域专家使用不同的语言，需要建立共同理解。",
        },
        {
            id: "w18-1-q4",
            question: "什么是隐性知识？",
            options: [
                "文档中的知识",
                "领域专家难以清晰表达的知识",
                "代码中的知识",
                "测试用例",
            ],
            answer: 1,
            rationale: "很多领域知识是隐性的，领域专家可能难以清晰表达。",
        },
        {
            id: "w18-1-q5",
            question: "在需求理解阶段应该建立什么？",
            options: [
                "数据库结构",
                "统一语言基础",
                "代码框架",
                "测试计划",
            ],
            answer: 1,
            rationale: "在需求理解阶段就开始建立统一语言，记录关键业务术语。",
        },
        {
            id: "w18-1-q6",
            question: "需求理解是一次性的吗？",
            options: [
                "是",
                "不是，需要随着项目推进持续深化理解",
                "只在开始时进行",
                "只在结束时进行",
            ],
            answer: 1,
            rationale: "需求理解不是一次性的，随着项目推进需要持续深化理解。",
        },
        {
            id: "w18-1-q7",
            question: "什么是知识消化（Knowledge Crunching）？",
            options: [
                "数据处理",
                "从领域专家那里提取和理解领域知识的过程",
                "代码压缩",
                "文档整理",
            ],
            answer: 1,
            rationale: "Knowledge Crunching 是从领域专家那里提取和理解领域知识的迭代过程。",
        },
        {
            id: "w18-1-q8",
            question: "获取领域专家时间的挑战是什么？",
            options: [
                "技术问题",
                "领域专家通常很忙",
                "语言障碍",
                "地理位置",
            ],
            answer: 1,
            rationale: "领域专家通常很忙，获取他们的时间是挑战。",
        },
        {
            id: "w18-1-q9",
            question: "理解阶段的第一步应该做什么？",
            options: [
                "编写代码",
                "识别和联系关键领域专家",
                "设计数据库",
                "创建测试",
            ],
            answer: 1,
            rationale: "识别和联系关键领域专家是理解阶段的第一步。",
        },
        {
            id: "w18-1-q10",
            question: "领域专家访谈后应该做什么？",
            options: [
                "立即编码",
                "记录关键业务术语和概念",
                "忽略结果",
                "重新开始",
            ],
            answer: 1,
            rationale: "记录关键业务术语和概念是访谈后的重要步骤。",
        },
        {
            id: "w18-1-q11",
            question: "如何验证对领域的理解？",
            options: [
                "等待反馈",
                "与领域专家验证理解的准确性",
                "假设正确",
                "不需要验证",
            ],
            answer: 1,
            rationale: "验证理解的准确性是确保正确理解的关键步骤。",
        },
        {
            id: "w18-1-q12",
            question: "统一语言词汇表应该包含什么？",
            options: [
                "代码变量名",
                "关键业务术语和它们的定义",
                "数据库字段",
                "API 端点",
            ],
            answer: 1,
            rationale: "统一语言词汇表应该包含关键业务术语和它们的定义。",
        },
    ],
    "w18-2": [
        {
            id: "w18-2-q1",
            question: "DDD Starter Modelling Process 的'Discover'步骤使用什么工具？",
            options: [
                "代码编辑器",
                "EventStorming",
                "数据库工具",
                "测试框架",
            ],
            answer: 1,
            rationale: "'Discover'步骤使用 EventStorming 协作映射领域。",
        },
        {
            id: "w18-2-q2",
            question: "'Decompose'步骤的目的是什么？",
            options: [
                "编写代码",
                "将领域分解为松耦合的子域，减少认知负担",
                "设计数据库",
                "创建测试",
            ],
            answer: 1,
            rationale: "'Decompose'步骤将领域分解为松耦合的子域，减少认知负担。",
        },
        {
            id: "w18-2-q3",
            question: "'Strategize'步骤识别什么？",
            options: [
                "技术栈",
                "核心域——具有最大业务差异化的领域",
                "数据库",
                "测试策略",
            ],
            answer: 1,
            rationale: "'Strategize'步骤识别核心域——具有最大业务差异化的领域。",
        },
        {
            id: "w18-2-q4",
            question: "Core Domain Chart 帮助什么决策？",
            options: [
                "代码风格",
                "优先级排序和构建/购买决策",
                "数据库选择",
                "测试策略",
            ],
            answer: 1,
            rationale: "Core Domain Chart 帮助优先级排序和构建/购买决策。",
        },
        {
            id: "w18-2-q5",
            question: "'Connect'步骤设计什么？",
            options: [
                "网络连接",
                "子域间的交互，最小化不必要的耦合",
                "数据库连接",
                "API 连接",
            ],
            answer: 1,
            rationale: "'Connect'步骤设计子域间的交互，最小化不必要的耦合。",
        },
        {
            id: "w18-2-q6",
            question: "战略设计通常需要什么？",
            options: [
                "一次完成",
                "多次迭代",
                "只需要一天",
                "不需要规划",
            ],
            answer: 1,
            rationale: "战略设计通常需要多次迭代，不能一次完成。",
        },
        {
            id: "w18-2-q7",
            question: "Domain Message Flow Modelling 用于什么？",
            options: [
                "编写代码",
                "测试设计是否符合真实用例",
                "设计数据库",
                "创建文档",
            ],
            answer: 1,
            rationale: "Domain Message Flow Modelling 测试设计是否符合真实用例。",
        },
        {
            id: "w18-2-q8",
            question: "如何识别核心域、支持域和通用域？",
            options: [
                "随机选择",
                "分析业务差异化和竞争优势",
                "按代码量",
                "按团队大小",
            ],
            answer: 1,
            rationale: "通过分析业务差异化和竞争优势来识别核心域、支持域和通用域。",
        },
        {
            id: "w18-2-q9",
            question: "设计子域间交互时需要权衡什么？",
            options: [
                "代码风格",
                "耦合和复杂度",
                "文档长度",
                "团队人数",
            ],
            answer: 1,
            rationale: "设计子域间的交互时需要权衡耦合和复杂度。",
        },
        {
            id: "w18-2-q10",
            question: "战略设计的产出是什么？",
            options: [
                "可运行的代码",
                "子域划分、上下文映射图",
                "数据库表",
                "测试用例",
            ],
            answer: 1,
            rationale: "战略设计的产出包括子域划分和上下文映射图。",
        },
        {
            id: "w18-2-q11",
            question: "使用 EventStorming 探索领域时，首先做什么？",
            options: [
                "编写代码",
                "发现领域事件",
                "设计数据库",
                "创建测试",
            ],
            answer: 1,
            rationale: "使用 EventStorming 探索领域时，首先发现领域事件。",
        },
        {
            id: "w18-2-q12",
            question: "识别正确的子域边界需要什么？",
            options: [
                "只有技术知识",
                "深入理解业务和技术约束",
                "只有业务知识",
                "随机决定",
            ],
            answer: 1,
            rationale: "识别正确的子域边界需要深入理解业务和技术约束。",
        },
    ],
    "w18-3": [
        {
            id: "w18-3-q1",
            question: "'Define'步骤使用什么工具？",
            options: [
                "代码编辑器",
                "Bounded Context Canvas",
                "数据库工具",
                "测试框架",
            ],
            answer: 1,
            rationale: "'Define'步骤使用 Bounded Context Canvas 定义每个上下文的角色和职责。",
        },
        {
            id: "w18-3-q2",
            question: "Bounded Context Canvas 在什么之前使用？",
            options: [
                "在编码之后",
                "在编码之前",
                "在测试之后",
                "在部署之后",
            ],
            answer: 1,
            rationale: "在编码前使用 Bounded Context Canvas 明确上下文的角色和职责。",
        },
        {
            id: "w18-3-q3",
            question: "Aggregate Design Canvas 用于什么？",
            options: [
                "数据库设计",
                "指导战术实现，定义聚合的详细设计",
                "网络设计",
                "UI 设计",
            ],
            answer: 1,
            rationale: "Aggregate Design Canvas 指导战术实现，定义聚合的名称、描述、状态转换和不变量。",
        },
        {
            id: "w18-3-q4",
            question: "'Code'步骤实现什么？",
            options: [
                "任意代码",
                "反映协作理解的领域模型",
                "数据库脚本",
                "测试脚本",
            ],
            answer: 1,
            rationale: "'Code'步骤实现反映协作理解的领域模型。",
        },
        {
            id: "w18-3-q5",
            question: "代码应该如何反映领域模型？",
            options: [
                "大致相似",
                "准确反映，而不是偏离模型的技术实现",
                "完全不同",
                "部分反映",
            ],
            answer: 1,
            rationale: "代码应该准确反映领域模型，而不是偏离模型的技术实现。",
        },
        {
            id: "w18-3-q6",
            question: "确定聚合边界需要什么？",
            options: [
                "随机选择",
                "深入理解业务规则和一致性需求",
                "按代码量",
                "按表数量",
            ],
            answer: 1,
            rationale: "确定正确的聚合边界是复杂的设计决策，需要深入理解业务规则。",
        },
        {
            id: "w18-3-q7",
            question: "聚合应该保护什么？",
            options: [
                "数据库连接",
                "业务不变量",
                "网络安全",
                "代码风格",
            ],
            answer: 1,
            rationale: "验证设计保护业务不变量是战术设计的关键。",
        },
        {
            id: "w18-3-q8",
            question: "战术设计需要识别什么？",
            options: [
                "只有实体",
                "实体、值对象、领域服务和领域事件",
                "只有数据库表",
                "只有 API",
            ],
            answer: 1,
            rationale: "战术设计需要识别实体、值对象、领域服务和领域事件。",
        },
        {
            id: "w18-3-q9",
            question: "在强一致性和什么之间需要权衡？",
            options: [
                "代码风格",
                "性能",
                "文档长度",
                "团队人数",
            ],
            answer: 1,
            rationale: "在强一致性和性能之间权衡是战术设计的考量。",
        },
        {
            id: "w18-3-q10",
            question: "将领域概念映射到技术实现需要什么？",
            options: [
                "自动完成",
                "经验",
                "工具",
                "不需要映射",
            ],
            answer: 1,
            rationale: "将领域概念映射到技术实现需要经验。",
        },
        {
            id: "w18-3-q11",
            question: "Bounded Context Canvas 包含什么内容？",
            options: [
                "只有代码",
                "输入、输出、依赖和业务规则",
                "只有数据库表",
                "只有 API",
            ],
            answer: 1,
            rationale: "Bounded Context Canvas 明确上下文的输入、输出、依赖和业务规则。",
        },
        {
            id: "w18-3-q12",
            question: "如何验证战术设计的正确性？",
            options: [
                "假设正确",
                "验证设计保护业务不变量",
                "不需要验证",
                "等待反馈",
            ],
            answer: 1,
            rationale: "验证设计保护业务不变量是验证战术设计正确性的方法。",
        },
    ],
    "w18-4": [
        {
            id: "w18-4-q1",
            question: "领域模型代码应该如何组织？",
            options: [
                "与基础设施混合",
                "组织在独立的领域层，与基础设施分离",
                "放在一个文件",
                "随机分布",
            ],
            answer: 1,
            rationale: "领域模型代码应该组织在独立的领域层，与基础设施分离。",
        },
        {
            id: "w18-4-q2",
            question: "代码应该使用什么命名？",
            options: [
                "技术术语",
                "统一语言命名",
                "随机命名",
                "缩写",
            ],
            answer: 1,
            rationale: "代码应该准确反映领域模型，使用统一语言命名。",
        },
        {
            id: "w18-4-q3",
            question: "TDD 与 DDD 如何结合？",
            options: [
                "不能结合",
                "先编写测试描述行为，再实现领域逻辑",
                "先编写代码",
                "不需要测试",
            ],
            answer: 1,
            rationale: "TDD 与 DDD 结合：先编写测试描述行为，再实现领域逻辑。",
        },
        {
            id: "w18-4-q4",
            question: "什么时候应该重构领域模型？",
            options: [
                "从不重构",
                "随着理解深入，持续重构以更好地反映领域",
                "只在开始时",
                "只在结束时",
            ],
            answer: 1,
            rationale: "随着理解深入，持续重构代码以更好地反映领域。",
        },
        {
            id: "w18-4-q5",
            question: "ddd-by-examples/library 是什么？",
            options: [
                "文档网站",
                "一个完整的 DDD 实现示例",
                "测试框架",
                "数据库工具",
            ],
            answer: 1,
            rationale: "ddd-by-examples/library 是一个完整的 DDD 实现示例。",
        },
        {
            id: "w18-4-q6",
            question: "什么是过度设计？",
            options: [
                "简单设计",
                "在不需要的地方引入复杂的 DDD 模式",
                "快速开发",
                "敏捷开发",
            ],
            answer: 1,
            rationale: "过度设计是在不需要的地方引入复杂的 DDD 模式。",
        },
        {
            id: "w18-4-q7",
            question: "不恰当的设计决策会导致什么？",
            options: [
                "更好的性能",
                "技术债务积累",
                "更简单的代码",
                "更快的开发",
            ],
            answer: 1,
            rationale: "不恰当的设计决策会积累技术债务。",
        },
        {
            id: "w18-4-q8",
            question: "团队需要什么才能正确实现 DDD？",
            options: [
                "只有编码技能",
                "理解 DDD 概念",
                "只有数据库知识",
                "只有前端技能",
            ],
            answer: 1,
            rationale: "团队需要理解 DDD 概念才能正确实现。",
        },
        {
            id: "w18-4-q9",
            question: "实现领域模型代码的第一步是什么？",
            options: [
                "编写测试",
                "设计代码的分层结构",
                "部署代码",
                "编写文档",
            ],
            answer: 1,
            rationale: "设计代码的分层结构是实现领域模型代码的第一步。",
        },
        {
            id: "w18-4-q10",
            question: "仓储接口应该在哪里定义？",
            options: [
                "基础设施层",
                "领域层",
                "应用层",
                "表示层",
            ],
            answer: 1,
            rationale: "仓储接口应该在领域层定义，实现在基础设施层。",
        },
        {
            id: "w18-4-q11",
            question: "领域模型的单元测试测试什么？",
            options: [
                "数据库连接",
                "领域逻辑和业务规则",
                "网络连接",
                "UI 显示",
            ],
            answer: 1,
            rationale: "领域模型的单元测试测试领域逻辑和业务规则。",
        },
        {
            id: "w18-4-q12",
            question: "如何避免过度设计？",
            options: [
                "使用所有 DDD 模式",
                "只在需要的地方应用 DDD 模式",
                "不使用任何模式",
                "复制其他项目",
            ],
            answer: 1,
            rationale: "避免过度设计的方法是只在需要的地方应用 DDD 模式。",
        },
    ],
}
