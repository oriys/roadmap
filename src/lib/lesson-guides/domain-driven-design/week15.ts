import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week15Guides: Record<string, LessonGuide> = {
    "w15-1": {
        lessonId: "w15-1",
        background: [
            "【ACL 定义】反腐层是'a set of defensive patterns placed between the domain model and other bounded contexts or third party dependencies'——放置在领域模型与其他上下文或第三方依赖之间的防御性模式集合。",
            "【核心目的】ACL 的意图是'prevent the intrusion of foreign concepts and models into the domain model'——防止外部概念和模型侵入领域模型。",
            "【设计模式】ACL 层通常由 Facade 和 Adapter 等设计模式组成，用于将外部 API 和领域模型映射到内部类型和接口。",
            "【翻译机制】ACL 作为适配器或门面，将外部系统的调用转换为新接口，保护领域模型的纯净性。",
            "【下游实现】ACL 总是在下游上下文中实现，用于隔离和翻译上游的模型。",
        ],
        keyDifficulties: [
            "【性能开销】额外的翻译处理可能引入延迟，需要评估和缓解性能影响。",
            "【复杂度增加】实现 ACL 增加代码、测试和文档开销——避免过度工程。",
            "【边界定义】确定 ACL 的边界和职责范围，避免职责过重或过轻。",
            "【双向翻译】需要处理请求和响应的双向翻译，保持语义一致性。",
        ],
        handsOnPath: [
            "识别需要隔离的外部系统或上下文",
            "定义领域模型需要的接口和类型",
            "实现 Adapter 将外部模型转换为内部模型",
            "实现 Facade 简化与外部系统的交互",
            "添加错误处理和异常转换",
            "编写单元测试验证翻译正确性",
            "监控 ACL 的性能影响",
        ],
        selfCheck: [
            "什么是反腐层？它保护什么？",
            "ACL 应该在哪一方实现？为什么？",
            "ACL 通常使用哪些设计模式？",
            "ACL 有什么性能考量？",
            "什么时候应该使用 ACL？",
        ],
        extensions: [
            "学习 Adapter 和 Facade 模式的实现",
            "了解 ACL 在微服务迁移中的应用",
            "研究 ACL 与 API 网关的关系",
            "探索 ACL 的测试策略",
        ],
        sourceUrls: [
            "https://deviq.com/domain-driven-design/anti-corruption-layer/",
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer",
        ],
    },
    "w15-2": {
        lessonId: "w15-2",
        background: [
            "【OHS 定义】Open Host Service：'describes a relationship between two bounded contexts'——上游提供开放的、文档化的协议供多个下游集成。",
            "【上游角色】OHS 用于上游上下文的角色定义，使用 OHS 缩写表示。",
            "【协议标准化】OHS 提供可访问的协议供下游团队采用，不需要为每个下游定制。",
            "【多下游支持】与 Customer/Supplier 不同，OHS 设计用于服务多个下游消费者。",
            "【语义约束】'The Open Host Service pattern is not applicable in a Customer/Supplier relationship'——OHS 不适用于 Customer/Supplier 关系。",
        ],
        keyDifficulties: [
            "【API 设计】设计通用的 API 满足多个下游的需求，同时保持简洁。",
            "【版本管理】OHS 的变更影响多个下游，需要谨慎的版本管理策略。",
            "【文档维护】保持协议文档的准确和更新是持续的挑战。",
            "【向后兼容】变更时需要考虑对所有下游的向后兼容性。",
        ],
        handsOnPath: [
            "识别可以作为 OHS 公开的服务",
            "设计通用的 API 接口",
            "实现 API 并添加版本控制",
            "编写 API 文档（OpenAPI/Swagger）",
            "建立变更通知机制",
            "实现 API 监控和分析",
        ],
        selfCheck: [
            "什么是 Open Host Service？",
            "OHS 为什么不适用于 Customer/Supplier 关系？",
            "OHS 如何支持多个下游消费者？",
            "OHS 的 API 版本管理有什么挑战？",
            "OHS 与 Published Language 如何配合？",
        ],
        extensions: [
            "学习 OpenAPI/Swagger 规范",
            "了解 API 网关作为 OHS 的实现",
            "研究 GraphQL 作为 OHS 的选择",
            "探索 OHS 的监控和分析",
        ],
        sourceUrls: [
            "https://contextmapper.org/docs/open-host-service/",
            "https://deviq.com/domain-driven-design/context-mapping/",
        ],
    },
    "w15-3": {
        lessonId: "w15-3",
        background: [
            "【PL 定义】Published Language：'describes a relationship between two bounded contexts'——使用标准化的交换格式实现上下文间清晰通信。",
            "【上游角色】PL 作为上游上下文的角色在关系中使用，用 PL 缩写表示。",
            "【标准格式】PL 可以是 JSON、XML、Protobuf 等标准化格式，或领域特定的交换格式。",
            "【与 OHS 结合】PL 常与 Open Host Service 结合使用，OHS 提供 API，PL 定义数据格式。",
            "【共享理解】PL 确保上下游对数据结构和语义有共同理解。",
        ],
        keyDifficulties: [
            "【格式选择】选择合适的格式（JSON、XML、Protobuf）需要权衡性能、可读性和工具支持。",
            "【Schema 演化】PL 的 Schema 变更需要管理，确保向后兼容。",
            "【语义对齐】确保 PL 的语义在所有消费者中一致理解。",
            "【文档同步】保持 PL 文档与实现同步是持续挑战。",
        ],
        handsOnPath: [
            "分析上下文间的数据交换需求",
            "选择合适的交换格式（JSON/XML/Protobuf）",
            "定义 Schema 和数据结构",
            "实现序列化和反序列化",
            "编写 Schema 文档",
            "建立 Schema 版本管理流程",
            "测试不同版本的兼容性",
        ],
        selfCheck: [
            "什么是 Published Language？",
            "PL 常用哪些标准格式？",
            "PL 与 OHS 如何配合使用？",
            "PL 的 Schema 演化有什么挑战？",
            "如何确保 PL 的语义一致性？",
        ],
        extensions: [
            "学习 JSON Schema 和 XML Schema",
            "了解 Protocol Buffers 和 gRPC",
            "研究 Schema Registry 的使用",
            "探索 AsyncAPI 规范",
        ],
        sourceUrls: [
            "https://contextmapper.org/docs/published-language/",
            "https://deviq.com/domain-driven-design/context-mapping/",
        ],
    },
    "w15-4": {
        lessonId: "w15-4",
        background: [
            "【Separate Ways 定义】Eric Evans：'Declare a bounded context to have no connection to the others at all'——声明上下文与其他上下文完全没有连接。",
            "【无显著关系】当两个上下文没有显著关系时，它们可以分离，各自独立发展。",
            "【集成成本】选择 Separate Ways 是因为'integration always has an associated cost'——集成总有成本，有时复制逻辑比集成更合理。",
            "【Big Ball of Mud 定义】'the code is as gross as the name implies...aggregates muddied together with no clear understanding of bounded contexts'——代码混乱，聚合混杂，没有清晰的上下文边界。",
            "【泥球特征】紧耦合的代码库，没有清晰的架构边界，关注点没有分离。",
        ],
        keyDifficulties: [
            "【重复 vs 集成】评估重复逻辑的成本与集成复杂度的权衡。",
            "【隐性耦合】即使选择 Separate Ways，仍可能在 UI 或中间件层意外连接。",
            "【识别泥球】识别系统中的 Big Ball of Mud 区域需要经验和分析。",
            "【泥球治理】处理泥球需要渐进式重构，不能一蹴而就。",
        ],
        handsOnPath: [
            "分析上下文间的依赖关系",
            "评估集成成本与收益",
            "识别可以选择 Separate Ways 的上下文",
            "识别系统中的 Big Ball of Mud 区域",
            "为泥球区域制定重构计划",
            "建立边界防止泥球扩散",
            "渐进式提取独立的上下文",
        ],
        selfCheck: [
            "什么时候应该选择 Separate Ways？",
            "Separate Ways 有什么风险？",
            "什么是 Big Ball of Mud？",
            "如何识别 Big Ball of Mud？",
            "如何防止泥球扩散？",
        ],
        extensions: [
            "学习遗留系统的重构策略",
            "了解 Strangler Fig 模式",
            "研究渐进式架构演进",
            "探索技术债务管理",
        ],
        sourceUrls: [
            "https://deviq.com/domain-driven-design/context-mapping/",
            "https://github.com/ddd-crew/context-mapping",
        ],
    },
}

export const week15Quizzes: Record<string, QuizQuestion[]> = {
    "w15-1": [
        {
            id: "w15-1-q1",
            question: "反腐层（ACL）的定义是什么？",
            options: [
                "数据库访问层",
                "放置在领域模型与其他上下文或第三方依赖之间的防御性模式集合",
                "用户界面层",
                "业务逻辑层",
            ],
            answer: 1,
            rationale: "ACL 是'a set of defensive patterns placed between the domain model and other bounded contexts or third party dependencies'。",
        },
        {
            id: "w15-1-q2",
            question: "ACL 的核心目的是什么？",
            options: [
                "提高性能",
                "防止外部概念和模型侵入领域模型",
                "减少代码量",
                "简化部署",
            ],
            answer: 1,
            rationale: "ACL 的意图是'prevent the intrusion of foreign concepts and models into the domain model'。",
        },
        {
            id: "w15-1-q3",
            question: "ACL 通常使用哪些设计模式？",
            options: [
                "Singleton 和 Factory",
                "Facade 和 Adapter",
                "Observer 和 Strategy",
                "Builder 和 Prototype",
            ],
            answer: 1,
            rationale: "ACL 层通常由 Facade 和 Adapter 等设计模式组成。",
        },
        {
            id: "w15-1-q4",
            question: "ACL 应该在哪一方实现？",
            options: [
                "上游上下文",
                "下游上下文",
                "两边都实现",
                "第三方",
            ],
            answer: 1,
            rationale: "ACL 总是在下游上下文中实现，用于隔离和翻译上游的模型。",
        },
        {
            id: "w15-1-q5",
            question: "ACL 有什么性能考量？",
            options: [
                "没有性能影响",
                "额外的翻译处理可能引入延迟",
                "一定会提高性能",
                "只影响启动时间",
            ],
            answer: 1,
            rationale: "额外的翻译处理可能引入延迟，需要评估和缓解性能影响。",
        },
        {
            id: "w15-1-q6",
            question: "ACL 保护什么？",
            options: [
                "数据库",
                "领域模型的纯净性和完整性",
                "网络安全",
                "用户数据",
            ],
            answer: 1,
            rationale: "ACL preserves the integrity of the domain model by isolating it from external concepts。",
        },
        {
            id: "w15-1-q7",
            question: "ACL 的三个主要组件是什么？",
            options: [
                "Controller、Service、Repository",
                "Domain Model、Adapter、External System",
                "UI、Logic、Data",
                "Input、Process、Output",
            ],
            answer: 1,
            rationale: "ACL 的主要组件是 Domain Model（受保护的核心）、Adapter（翻译机制）、External System（外部依赖）。",
        },
        {
            id: "w15-1-q8",
            question: "ACL 如何处理请求？",
            options: [
                "直接转发",
                "通过 Adapter 翻译请求和响应",
                "缓存所有请求",
                "拒绝所有请求",
            ],
            answer: 1,
            rationale: "ACL 通过 Adapter 将领域请求翻译为外部格式，再将响应翻译回领域语义。",
        },
        {
            id: "w15-1-q9",
            question: "使用 ACL 有什么复杂度代价？",
            options: [
                "没有代价",
                "增加代码、测试和文档开销",
                "减少代码量",
                "简化测试",
            ],
            answer: 1,
            rationale: "实现 ACL 增加代码、测试和文档开销——应避免过度工程。",
        },
        {
            id: "w15-1-q10",
            question: "ACL 促进什么类型的耦合？",
            options: [
                "紧耦合",
                "松耦合，使领域模型独立于外部系统",
                "强耦合",
                "没有影响",
            ],
            answer: 1,
            rationale: "ACL promotes loose coupling enabling the domain model to be independent of external systems。",
        },
        {
            id: "w15-1-q11",
            question: "什么时候应该使用 ACL？",
            options: [
                "所有情况",
                "当两个子系统有不同语义但需要通信时",
                "从不使用",
                "只在新项目中",
            ],
            answer: 1,
            rationale: "当两个或多个子系统有不同语义但仍需要通信时，ACL 模式非常有用。",
        },
        {
            id: "w15-1-q12",
            question: "ACL 在微服务迁移中的作用是什么？",
            options: [
                "没有作用",
                "在单体应用中作为类实现，隔离已迁移的服务",
                "只用于新服务",
                "替代所有服务",
            ],
            answer: 1,
            rationale: "ACL can be implemented inside the monolithic application as a class that's specific to the service that was migrated。",
        },
    ],
    "w15-2": [
        {
            id: "w15-2-q1",
            question: "Open Host Service（OHS）模式描述什么？",
            options: [
                "数据库连接",
                "两个界限上下文之间的关系",
                "用户认证",
                "日志记录",
            ],
            answer: 1,
            rationale: "'The Open Host Service pattern describes a relationship between two bounded contexts'。",
        },
        {
            id: "w15-2-q2",
            question: "OHS 用于什么角色的上下文？",
            options: [
                "下游上下文",
                "上游上下文",
                "所有上下文",
                "独立上下文",
            ],
            answer: 1,
            rationale: "OHS 用于上游上下文的角色定义。",
        },
        {
            id: "w15-2-q3",
            question: "OHS 不适用于什么关系？",
            options: [
                "Partnership",
                "Customer/Supplier 关系",
                "Conformist",
                "Shared Kernel",
            ],
            answer: 1,
            rationale: "'The Open Host Service pattern is not applicable in a Customer/Supplier relationship'。",
        },
        {
            id: "w15-2-q4",
            question: "OHS 与 Customer/Supplier 的主要区别是什么？",
            options: [
                "没有区别",
                "OHS 设计用于服务多个下游，不需要为每个下游定制",
                "OHS 更简单",
                "Customer/Supplier 服务更多下游",
            ],
            answer: 1,
            rationale: "OHS 提供通用协议供多个下游采用，不需要为每个下游定制。",
        },
        {
            id: "w15-2-q5",
            question: "OHS 的主要优势是什么？",
            options: [
                "减少代码",
                "提供标准化的可访问协议供下游团队采用",
                "提高安全性",
                "减少数据库访问",
            ],
            answer: 1,
            rationale: "OHS 提供可访问的协议供下游团队采用。",
        },
        {
            id: "w15-2-q6",
            question: "OHS 的 API 变更有什么挑战？",
            options: [
                "没有挑战",
                "影响多个下游，需要谨慎的版本管理策略",
                "自动处理",
                "只影响上游",
            ],
            answer: 1,
            rationale: "OHS 的变更影响多个下游，需要谨慎的版本管理策略。",
        },
        {
            id: "w15-2-q7",
            question: "OHS 在 CML 语法中用什么缩写表示？",
            options: [
                "OS",
                "OHS",
                "OPEN",
                "HOST",
            ],
            answer: 1,
            rationale: "该模式使用 OHS 缩写表示。",
        },
        {
            id: "w15-2-q8",
            question: "OHS 常与什么模式配合使用？",
            options: [
                "Conformist",
                "ACL（反腐层）和 Published Language",
                "Shared Kernel",
                "Big Ball of Mud",
            ],
            answer: 1,
            rationale: "文档显示 OHS 常与 ACL 和 Published Language 配合使用。",
        },
        {
            id: "w15-2-q9",
            question: "OHS 的文档维护有什么挑战？",
            options: [
                "不需要文档",
                "保持协议文档的准确和更新是持续的挑战",
                "自动生成",
                "一次性工作",
            ],
            answer: 1,
            rationale: "保持协议文档的准确和更新是持续的挑战。",
        },
        {
            id: "w15-2-q10",
            question: "OHS 的 API 设计有什么要求？",
            options: [
                "为每个下游定制",
                "设计通用的 API 满足多个下游的需求",
                "只考虑性能",
                "忽略下游需求",
            ],
            answer: 1,
            rationale: "设计通用的 API 满足多个下游的需求，同时保持简洁。",
        },
        {
            id: "w15-2-q11",
            question: "实现 OHS 时应该添加什么？",
            options: [
                "更多数据库",
                "API 版本控制和文档",
                "更多服务器",
                "更多代码",
            ],
            answer: 1,
            rationale: "实现 OHS 应包括版本控制和 API 文档（如 OpenAPI/Swagger）。",
        },
        {
            id: "w15-2-q12",
            question: "OHS 可以通过什么技术实现？",
            options: [
                "只能 SOAP",
                "RESTful HTTP、SOAP、GraphQL 等",
                "只能文件传输",
                "只能数据库连接",
            ],
            answer: 1,
            rationale: "示例中显示 implementationTechnology 可以是 SOAP、RESTful HTTP 等。",
        },
    ],
    "w15-3": [
        {
            id: "w15-3-q1",
            question: "Published Language（PL）模式的定义是什么？",
            options: [
                "编程语言选择",
                "使用标准化的交换格式实现上下文间清晰通信",
                "文档编写规范",
                "代码注释规范",
            ],
            answer: 1,
            rationale: "PL 使用标准化的交换格式（如 JSON、XML、Protobuf）实现上下文间清晰通信。",
        },
        {
            id: "w15-3-q2",
            question: "PL 用于什么角色的上下文？",
            options: [
                "下游上下文",
                "上游上下文",
                "所有上下文",
                "第三方",
            ],
            answer: 1,
            rationale: "PL 作为上游上下文的角色在关系中使用。",
        },
        {
            id: "w15-3-q3",
            question: "PL 常用哪些标准格式？",
            options: [
                "Word 和 Excel",
                "JSON、XML、Protobuf",
                "PNG 和 JPEG",
                "MP3 和 MP4",
            ],
            answer: 1,
            rationale: "PL 可以是 JSON、XML、Protobuf 等标准化格式。",
        },
        {
            id: "w15-3-q4",
            question: "PL 与 OHS 如何配合？",
            options: [
                "不能配合",
                "OHS 提供 API，PL 定义数据格式",
                "完全相同",
                "互相替代",
            ],
            answer: 1,
            rationale: "PL 常与 Open Host Service 结合使用，OHS 提供 API，PL 定义数据格式。",
        },
        {
            id: "w15-3-q5",
            question: "PL 在 CML 语法中用什么缩写表示？",
            options: [
                "LANG",
                "PL",
                "PUB",
                "PUBLISH",
            ],
            answer: 1,
            rationale: "在 CML 语法中用 PL 表示。",
        },
        {
            id: "w15-3-q6",
            question: "PL 的 Schema 变更有什么挑战？",
            options: [
                "没有挑战",
                "需要管理 Schema 演化，确保向后兼容",
                "自动处理",
                "不需要管理",
            ],
            answer: 1,
            rationale: "PL 的 Schema 变更需要管理，确保向后兼容。",
        },
        {
            id: "w15-3-q7",
            question: "选择 PL 格式需要权衡什么？",
            options: [
                "只考虑性能",
                "性能、可读性和工具支持",
                "只考虑代码量",
                "只考虑团队偏好",
            ],
            answer: 1,
            rationale: "选择合适的格式（JSON、XML、Protobuf）需要权衡性能、可读性和工具支持。",
        },
        {
            id: "w15-3-q8",
            question: "PL 确保什么？",
            options: [
                "代码质量",
                "上下游对数据结构和语义有共同理解",
                "性能优化",
                "安全加密",
            ],
            answer: 1,
            rationale: "PL 确保上下游对数据结构和语义有共同理解。",
        },
        {
            id: "w15-3-q9",
            question: "PL 的文档同步有什么挑战？",
            options: [
                "没有挑战",
                "保持 PL 文档与实现同步是持续挑战",
                "自动同步",
                "一次性工作",
            ],
            answer: 1,
            rationale: "保持 PL 文档与实现同步是持续挑战。",
        },
        {
            id: "w15-3-q10",
            question: "Protocol Buffers 与 JSON 相比有什么特点？",
            options: [
                "更易读",
                "更高效的二进制格式，支持 Schema 演化",
                "更简单",
                "不支持 Schema",
            ],
            answer: 1,
            rationale: "Protobuf 是高效的二进制格式，支持 Schema 演化。",
        },
        {
            id: "w15-3-q11",
            question: "实现 PL 时需要做什么？",
            options: [
                "只定义格式",
                "定义 Schema、实现序列化/反序列化、编写文档",
                "只写代码",
                "只测试",
            ],
            answer: 1,
            rationale: "实现 PL 需要定义 Schema、实现序列化/反序列化、编写文档。",
        },
        {
            id: "w15-3-q12",
            question: "Schema Registry 的作用是什么？",
            options: [
                "存储代码",
                "集中管理和版本控制 Schema",
                "存储文档",
                "存储配置",
            ],
            answer: 1,
            rationale: "Schema Registry 用于集中管理和版本控制 Schema。",
        },
    ],
    "w15-4": [
        {
            id: "w15-4-q1",
            question: "Eric Evans 对 Separate Ways 的定义是什么？",
            options: [
                "紧密集成",
                "声明上下文与其他上下文完全没有连接",
                "共享所有代码",
                "合并上下文",
            ],
            answer: 1,
            rationale: "'Declare a bounded context to have no connection to the others at all'。",
        },
        {
            id: "w15-4-q2",
            question: "为什么选择 Separate Ways？",
            options: [
                "因为最简单",
                "因为集成总有成本，有时复制逻辑比集成更合理",
                "因为没有其他选择",
                "因为团队要求",
            ],
            answer: 1,
            rationale: "'integration always has an associated cost'——集成总有成本，有时复制逻辑比集成更合理。",
        },
        {
            id: "w15-4-q3",
            question: "Separate Ways 的通信和承诺级别是什么？",
            options: [
                "高",
                "低",
                "中等",
                "不确定",
            ],
            answer: 1,
            rationale: "Separate Ways 的特点是：Level of communication and commitment: Low。",
        },
        {
            id: "w15-4-q4",
            question: "什么是 Big Ball of Mud？",
            options: [
                "最佳实践",
                "代码混乱，聚合混杂，没有清晰的上下文边界的反模式",
                "设计模式",
                "架构风格",
            ],
            answer: 1,
            rationale: "'the code is as gross as the name implies...aggregates muddied together with no clear understanding of bounded contexts'。",
        },
        {
            id: "w15-4-q5",
            question: "Big Ball of Mud 的团队关系特征是什么？",
            options: [
                "清晰合作",
                "混乱——所有关系类型的混合",
                "独立工作",
                "紧密协作",
            ],
            answer: 1,
            rationale: "Team Relationship: Chaos—a mixture of all relationship types combined。",
        },
        {
            id: "w15-4-q6",
            question: "如何识别 Big Ball of Mud？",
            options: [
                "代码量大",
                "紧耦合代码库，没有清晰架构边界，关注点没有分离",
                "团队人多",
                "功能丰富",
            ],
            answer: 1,
            rationale: "紧耦合的代码库，没有清晰的架构边界，关注点没有分离是泥球的特征。",
        },
        {
            id: "w15-4-q7",
            question: "选择 Separate Ways 后仍可能发生什么？",
            options: [
                "完全隔离",
                "在 UI 或中间件层意外连接",
                "自动集成",
                "无法分离",
            ],
            answer: 1,
            rationale: "即使选择 Separate Ways，仍可能在 UI 或中间件层意外连接。",
        },
        {
            id: "w15-4-q8",
            question: "处理 Big Ball of Mud 需要什么策略？",
            options: [
                "一次性重写",
                "渐进式重构，不能一蹴而就",
                "忽略它",
                "删除系统",
            ],
            answer: 1,
            rationale: "处理泥球需要渐进式重构，不能一蹴而就。",
        },
        {
            id: "w15-4-q9",
            question: "Big Ball of Mud 中的调试有什么问题？",
            options: [
                "没有问题",
                "调试变得混乱——必须跨互连的代码路径追踪 bug",
                "更容易",
                "自动调试",
            ],
            answer: 1,
            rationale: "Debugging becomes chaotic—developers must trace bugs across interconnected code paths。",
        },
        {
            id: "w15-4-q10",
            question: "如何防止 Big Ball of Mud 扩散？",
            options: [
                "不需要防止",
                "建立边界，明确上下文所有权",
                "增加代码",
                "合并团队",
            ],
            answer: 1,
            rationale: "建立边界防止泥球扩散，明确团队所有权。",
        },
        {
            id: "w15-4-q11",
            question: "Separate Ways 意味着什么级别的控制？",
            options: [
                "高控制",
                "低控制——对涉及的系统控制有限",
                "完全控制",
                "无控制",
            ],
            answer: 1,
            rationale: "Level of control over the involved systems: Low。",
        },
        {
            id: "w15-4-q12",
            question: "处理 Big Ball of Mud 的第一步是什么？",
            options: [
                "重写所有代码",
                "识别和建立上下文边界",
                "增加团队",
                "购买工具",
            ],
            answer: 1,
            rationale: "Address it by establishing bounded contexts, defining clear team ownership。",
        },
    ],
}
