import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week12Guides: Record<string, LessonGuide> = {
    "w12-1": {
        lessonId: "w12-1",
        background: [
            "【事件溯源定义】Martin Fowler：'Capture all changes to an application state as a sequence of events'——将应用状态的所有变更捕获为事件序列。",
            "【与 CRUD 区别】传统方式只保存当前状态，'we see just the final state'；事件溯源保存完整变化历史，'we also capture each event'。",
            "【事件即真相】不存储当前状态，而是存储导致状态变化的所有事件，事件日志成为单一事实来源。",
            "【状态重建】通过重放事件序列，可以重建任意时间点的状态。",
            "【追溯能力】能够追踪数据演变过程，而非仅知道最终状态，提供完整的审计跟踪。",
        ],
        keyDifficulties: [
            "【思维转变】从'存储状态'到'存储事件'需要根本性的思维转变。",
            "【事件不可变】事件一旦存储就不能修改，错误只能通过补偿事件修正。",
            "【复杂度增加】事件溯源是高复杂度的架构决策，不适合大多数应用。",
            "【最终一致性】与 CQRS 结合时，读模型是最终一致的，存在延迟。",
        ],
        handsOnPath: [
            "理解当前系统对审计跟踪和状态回溯的需求",
            "设计领域事件的结构",
            "实现事件的持久化存储",
            "实现从事件重建状态的逻辑",
            "评估事件溯源的复杂度是否值得",
        ],
        selfCheck: [
            "什么是事件溯源？它与传统 CRUD 有什么区别？",
            "为什么说事件是不可变的？",
            "如何从事件重建状态？",
            "事件溯源的主要优势是什么？",
            "事件溯源适合什么场景？",
        ],
        extensions: [
            "学习 EventStoreDB 等专用事件存储",
            "了解事件溯源与审计合规的关系",
            "研究事件溯源的调试和排错",
            "探索事件溯源的性能考量",
        ],
        sourceUrls: [
            "https://martinfowler.com/eaaDev/EventSourcing.html",
            "https://www.eventstore.com/event-sourcing",
        ],
    },
    "w12-2": {
        lessonId: "w12-2",
        background: [
            "【追加存储】事件存储是追加写入（append-only）的不可变存储，事件一旦写入永不修改。",
            "【事件流】每个聚合有自己的事件流（Event Stream），包含该聚合的所有事件。",
            "【事件结构】事件包含：事件类型、时间戳、版本号、聚合 ID、事件数据。",
            "【乐观并发】使用版本号实现乐观并发控制，防止并发写入冲突。",
            "【事件顺序】事件顺序至关重要，使用时间戳和增量标识符维护顺序。",
        ],
        keyDifficulties: [
            "【版本冲突】并发修改同一聚合时的版本冲突处理。",
            "【事件顺序保证】在多线程环境中维护事件的正确顺序。",
            "【存储选择】关系数据库 vs 专用事件存储（如 EventStoreDB）的权衡。",
            "【事件粒度】事件粒度的选择——太粗或太细都有问题。",
        ],
        handsOnPath: [
            "设计事件存储的数据模型",
            "实现追加事件的方法",
            "实现按聚合 ID 读取事件流",
            "添加乐观并发控制（版本检查）",
            "实现事件的序列化和反序列化",
            "测试并发写入场景",
        ],
        selfCheck: [
            "什么是事件流？每个聚合有多少个事件流？",
            "事件应该包含哪些信息？",
            "如何实现乐观并发控制？",
            "为什么事件顺序很重要？",
            "关系数据库和专用事件存储各有什么优缺点？",
        ],
        extensions: [
            "学习 EventStoreDB 的特性和用法",
            "了解事件存储的分区策略",
            "研究事件存储的备份和恢复",
            "探索分布式事件存储的挑战",
        ],
        sourceUrls: [
            "https://www.eventstore.com/docs",
            "https://www.eventstore.com/blog/event-sourcing-and-cqrs",
        ],
    },
    "w12-3": {
        lessonId: "w12-3",
        background: [
            "【快照定义】快照是聚合在某个时间点的状态缓存，避免每次都从所有事件重建。",
            "【快照策略】'For large event streams, create snapshots at intervals'——对于大量事件的流，定期创建快照。",
            "【状态重建公式】当前状态 = 快照状态 + 重放快照后的事件。",
            "【性能优化】快照显著减少状态重建时间，特别是对于长生命周期的聚合。",
            "【快照频率】根据事件增长速度和重建性能需求决定快照频率。",
        ],
        keyDifficulties: [
            "【快照时机】何时创建快照——基于事件数量、时间间隔还是其他触发条件。",
            "【快照一致性】确保快照与事件流的一致性。",
            "【快照演化】当聚合结构变化时，旧快照如何处理。",
            "【存储成本】快照增加存储空间，需要权衡存储成本和重建性能。",
        ],
        handsOnPath: [
            "分析哪些聚合需要快照",
            "设计快照的数据结构",
            "实现快照的创建逻辑",
            "修改状态重建逻辑：先加载快照，再重放后续事件",
            "实现快照清理策略",
            "测量快照对性能的影响",
        ],
        selfCheck: [
            "什么是快照？它解决什么问题？",
            "当前状态如何从快照和事件重建？",
            "何时应该创建快照？",
            "快照演化如何处理？",
            "快照的存储成本如何权衡？",
        ],
        extensions: [
            "学习快照的懒加载策略",
            "了解快照压缩技术",
            "研究快照与缓存的结合",
            "探索分布式系统中的快照同步",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing",
            "https://www.eventstore.com/blog/event-sourcing-and-cqrs",
        ],
    },
    "w12-4": {
        lessonId: "w12-4",
        background: [
            "【事件版本化】当事件结构变化时，需要支持多个事件版本。",
            "【向后兼容】事件处理器需要能够处理旧版本的事件。",
            "【事件升级】Upcasting——将旧版本事件转换为新版本格式。",
            "【Schema 演化】事件的 Schema 演化需要谨慎设计，保持不可变性。",
            "【版本戳】在事件中包含版本标识，帮助处理器识别版本。",
        ],
        keyDifficulties: [
            "【破坏性变更】某些变更可能破坏历史事件的解析。",
            "【多版本处理】同时处理多个版本的事件增加复杂度。",
            "【事件重命名】重命名事件类型需要特殊处理。",
            "【删除字段】删除字段可能导致旧事件无法正确解析。",
        ],
        handsOnPath: [
            "在事件中添加版本字段",
            "实现事件的 Upcasting 逻辑",
            "设计向后兼容的事件 Schema",
            "编写多版本事件的处理器",
            "测试事件演化的正确性",
            "建立事件变更的审批流程",
        ],
        selfCheck: [
            "为什么需要事件版本化？",
            "什么是 Upcasting？它如何工作？",
            "如何设计向后兼容的事件变更？",
            "哪些变更是破坏性的？如何避免？",
            "版本戳的作用是什么？",
        ],
        extensions: [
            "学习 Avro 等支持 Schema 演化的序列化格式",
            "了解事件注册表（Event Registry）",
            "研究事件的语义版本控制",
            "探索事件流的重写和迁移",
        ],
        sourceUrls: [
            "https://www.eventstore.com/blog/event-versioning",
            "https://blog.confluent.io/2016/07/27/apache-avro-schema-evolution-and-compatibility/",
        ],
    },
}

export const week12Quizzes: Record<string, QuizQuestion[]> = {
    "w12-1": [
        {
            id: "w12-1-q1",
            question: "根据 Martin Fowler，事件溯源的定义是什么？",
            options: [
                "存储当前状态",
                "将应用状态的所有变更捕获为事件序列",
                "只存储最新事件",
                "删除历史数据",
            ],
            answer: 1,
            rationale: "Martin Fowler：'Capture all changes to an application state as a sequence of events'。",
        },
        {
            id: "w12-1-q2",
            question: "事件溯源与传统 CRUD 的主要区别是什么？",
            options: [
                "没有区别",
                "传统方式只保存当前状态，事件溯源保存完整变化历史",
                "事件溯源更简单",
                "CRUD 更复杂",
            ],
            answer: 1,
            rationale: "传统方式只保存当前状态，'we see just the final state'；事件溯源保存完整变化历史。",
        },
        {
            id: "w12-1-q3",
            question: "在事件溯源中，什么是'单一事实来源'？",
            options: [
                "数据库表",
                "事件日志",
                "缓存",
                "API",
            ],
            answer: 1,
            rationale: "事件日志成为单一事实来源（Single Source of Truth）。",
        },
        {
            id: "w12-1-q4",
            question: "如何获取任意时间点的状态？",
            options: [
                "查询数据库",
                "重放事件序列到该时间点",
                "读取缓存",
                "不可能获取",
            ],
            answer: 1,
            rationale: "通过重放事件序列，可以重建任意时间点的状态。",
        },
        {
            id: "w12-1-q5",
            question: "事件一旦存储后可以修改吗？",
            options: [
                "可以随时修改",
                "不能修改，错误只能通过补偿事件修正",
                "可以删除",
                "可以更新",
            ],
            answer: 1,
            rationale: "事件一旦存储就不能修改，错误只能通过补偿事件修正。",
        },
        {
            id: "w12-1-q6",
            question: "事件溯源提供什么审计能力？",
            options: [
                "没有审计能力",
                "完整的审计跟踪，能够追踪数据演变过程",
                "只记录最终状态",
                "只记录错误",
            ],
            answer: 1,
            rationale: "能够追踪数据演变过程，而非仅知道最终状态，提供完整的审计跟踪。",
        },
        {
            id: "w12-1-q7",
            question: "事件溯源的主要思维转变是什么？",
            options: [
                "从对象到函数",
                "从'存储状态'到'存储事件'",
                "从同步到异步",
                "从单体到微服务",
            ],
            answer: 1,
            rationale: "从'存储状态'到'存储事件'需要根本性的思维转变。",
        },
        {
            id: "w12-1-q8",
            question: "事件溯源适合什么类型的应用？",
            options: [
                "所有应用",
                "需要审计跟踪、状态回溯的复杂应用",
                "简单 CRUD 应用",
                "静态网站",
            ],
            answer: 1,
            rationale: "事件溯源适合需要审计跟踪和状态回溯的复杂应用，不适合大多数简单应用。",
        },
        {
            id: "w12-1-q9",
            question: "事件溯源与 CQRS 结合时的一致性特点是什么？",
            options: [
                "强一致性",
                "最终一致性，读模型存在延迟",
                "没有一致性",
                "实时一致性",
            ],
            answer: 1,
            rationale: "与 CQRS 结合时，读模型是最终一致的，存在延迟。",
        },
        {
            id: "w12-1-q10",
            question: "事件溯源的三项关键功能是什么？",
            options: [
                "增删改",
                "完整重建、时间查询、事件回放",
                "读写分离",
                "负载均衡",
            ],
            answer: 1,
            rationale: "事件溯源提供：完整重建、时间查询、事件回放三项关键功能。",
        },
        {
            id: "w12-1-q11",
            question: "事件溯源是什么级别的架构决策？",
            options: [
                "低复杂度",
                "高复杂度的架构决策",
                "无关紧要",
                "可以随时改变",
            ],
            answer: 1,
            rationale: "事件溯源是高复杂度的架构决策，不适合大多数应用。",
        },
        {
            id: "w12-1-q12",
            question: "事件处理逻辑可以放在哪里？",
            options: [
                "只能在控制器",
                "事件对象本身或独立处理器中",
                "只能在数据库",
                "只能在 UI",
            ],
            answer: 1,
            rationale: "关键设计决策包括将处理逻辑放在事件对象本身或独立处理器中。",
        },
    ],
    "w12-2": [
        {
            id: "w12-2-q1",
            question: "事件存储的写入模式是什么？",
            options: [
                "随机写入",
                "追加写入（append-only），事件永不修改",
                "覆盖写入",
                "批量删除",
            ],
            answer: 1,
            rationale: "事件存储是追加写入（append-only）的不可变存储，事件一旦写入永不修改。",
        },
        {
            id: "w12-2-q2",
            question: "什么是事件流（Event Stream）？",
            options: [
                "所有事件的集合",
                "每个聚合自己的事件序列",
                "数据库表",
                "消息队列",
            ],
            answer: 1,
            rationale: "每个聚合有自己的事件流（Event Stream），包含该聚合的所有事件。",
        },
        {
            id: "w12-2-q3",
            question: "事件应该包含哪些信息？",
            options: [
                "只有数据",
                "事件类型、时间戳、版本号、聚合 ID、事件数据",
                "只有 ID",
                "只有时间戳",
            ],
            answer: 1,
            rationale: "事件包含：事件类型、时间戳、版本号、聚合 ID、事件数据。",
        },
        {
            id: "w12-2-q4",
            question: "如何实现乐观并发控制？",
            options: [
                "使用锁",
                "使用版本号检查，防止并发写入冲突",
                "不需要并发控制",
                "使用分布式事务",
            ],
            answer: 1,
            rationale: "使用版本号实现乐观并发控制，防止并发写入冲突。",
        },
        {
            id: "w12-2-q5",
            question: "为什么事件顺序很重要？",
            options: [
                "不重要",
                "维护实体状态一致性需要正确的事件顺序",
                "只影响性能",
                "只影响存储",
            ],
            answer: 1,
            rationale: "事件顺序至关重要，使用时间戳和增量标识符维护顺序以保证状态一致性。",
        },
        {
            id: "w12-2-q6",
            question: "如何维护事件的正确顺序？",
            options: [
                "随机排序",
                "使用时间戳和增量标识符",
                "按 ID 排序",
                "不需要维护",
            ],
            answer: 1,
            rationale: "使用时间戳和增量标识符维护事件顺序。",
        },
        {
            id: "w12-2-q7",
            question: "关系数据库和专用事件存储各有什么特点？",
            options: [
                "没有区别",
                "关系数据库更通用，专用存储（如 EventStoreDB）针对事件优化",
                "关系数据库更好",
                "专用存储更简单",
            ],
            answer: 1,
            rationale: "关系数据库更通用，专用事件存储（如 EventStoreDB）针对事件场景优化。",
        },
        {
            id: "w12-2-q8",
            question: "并发修改同一聚合时会发生什么？",
            options: [
                "自动合并",
                "版本冲突，需要处理",
                "覆盖写入",
                "不会发生",
            ],
            answer: 1,
            rationale: "并发修改同一聚合时会发生版本冲突，需要处理。",
        },
        {
            id: "w12-2-q9",
            question: "事件的粒度应该如何选择？",
            options: [
                "越细越好",
                "需要权衡，太粗或太细都有问题",
                "越粗越好",
                "固定粒度",
            ],
            answer: 1,
            rationale: "事件粒度的选择需要权衡——太粗或太细都有问题。",
        },
        {
            id: "w12-2-q10",
            question: "事件需要序列化吗？",
            options: [
                "不需要",
                "需要实现事件的序列化和反序列化",
                "自动序列化",
                "只需要反序列化",
            ],
            answer: 1,
            rationale: "实现事件的序列化和反序列化是事件存储的关键步骤。",
        },
        {
            id: "w12-2-q11",
            question: "如何读取聚合的事件？",
            options: [
                "全表扫描",
                "按聚合 ID 读取事件流",
                "随机读取",
                "只读最新",
            ],
            answer: 1,
            rationale: "实现按聚合 ID 读取事件流。",
        },
        {
            id: "w12-2-q12",
            question: "在多线程环境中事件顺序有什么挑战？",
            options: [
                "没有挑战",
                "防止竞态条件，维护正确顺序",
                "性能下降",
                "内存增加",
            ],
            answer: 1,
            rationale: "在多线程环境中维护事件的正确顺序需要防止竞态条件。",
        },
    ],
    "w12-3": [
        {
            id: "w12-3-q1",
            question: "什么是快照（Snapshot）？",
            options: [
                "数据备份",
                "聚合在某个时间点的状态缓存",
                "事件日志",
                "数据库表",
            ],
            answer: 1,
            rationale: "快照是聚合在某个时间点的状态缓存，避免每次都从所有事件重建。",
        },
        {
            id: "w12-3-q2",
            question: "当前状态如何从快照重建？",
            options: [
                "只用快照",
                "当前状态 = 快照状态 + 重放快照后的事件",
                "只用事件",
                "随机计算",
            ],
            answer: 1,
            rationale: "当前状态 = 快照状态 + 重放快照后的事件。",
        },
        {
            id: "w12-3-q3",
            question: "何时应该创建快照？",
            options: [
                "每次事件后",
                "对于大量事件的流，定期创建",
                "从不创建",
                "只在启动时",
            ],
            answer: 1,
            rationale: "'For large event streams, create snapshots at intervals'——对于大量事件的流，定期创建快照。",
        },
        {
            id: "w12-3-q4",
            question: "快照的主要目的是什么？",
            options: [
                "减少存储",
                "显著减少状态重建时间",
                "增加安全性",
                "简化代码",
            ],
            answer: 1,
            rationale: "快照显著减少状态重建时间，特别是对于长生命周期的聚合。",
        },
        {
            id: "w12-3-q5",
            question: "快照频率应该基于什么决定？",
            options: [
                "固定间隔",
                "根据事件增长速度和重建性能需求",
                "每天一次",
                "每小时一次",
            ],
            answer: 1,
            rationale: "根据事件增长速度和重建性能需求决定快照频率。",
        },
        {
            id: "w12-3-q6",
            question: "当聚合结构变化时，旧快照如何处理？",
            options: [
                "删除所有快照",
                "需要处理快照演化",
                "忽略",
                "自动更新",
            ],
            answer: 1,
            rationale: "当聚合结构变化时，旧快照需要处理演化问题。",
        },
        {
            id: "w12-3-q7",
            question: "快照增加了什么成本？",
            options: [
                "计算成本",
                "存储空间成本",
                "网络成本",
                "没有成本",
            ],
            answer: 1,
            rationale: "快照增加存储空间，需要权衡存储成本和重建性能。",
        },
        {
            id: "w12-3-q8",
            question: "哪些聚合需要快照？",
            options: [
                "所有聚合",
                "事件数量多、重建时间长的聚合",
                "没有聚合需要",
                "只有根聚合",
            ],
            answer: 1,
            rationale: "分析哪些聚合需要快照——通常是事件数量多、重建时间长的聚合。",
        },
        {
            id: "w12-3-q9",
            question: "加载聚合状态的修改后流程是什么？",
            options: [
                "重放所有事件",
                "先加载快照，再重放快照后的事件",
                "只加载快照",
                "只加载最新事件",
            ],
            answer: 1,
            rationale: "修改状态重建逻辑：先加载快照，再重放后续事件。",
        },
        {
            id: "w12-3-q10",
            question: "如何确保快照与事件流的一致性？",
            options: [
                "不需要确保",
                "快照必须对应某个已知的事件版本",
                "自动一致",
                "手动同步",
            ],
            answer: 1,
            rationale: "确保快照与事件流的一致性是重要考量，快照必须对应某个已知的事件版本。",
        },
        {
            id: "w12-3-q11",
            question: "快照的触发条件可以是什么？",
            options: [
                "只能基于时间",
                "事件数量、时间间隔或其他触发条件",
                "只能手动",
                "只能基于事件数量",
            ],
            answer: 1,
            rationale: "何时创建快照可以基于事件数量、时间间隔或其他触发条件。",
        },
        {
            id: "w12-3-q12",
            question: "快照清理策略的目的是什么？",
            options: [
                "增加存储",
                "控制存储成本，删除过期快照",
                "提高性能",
                "增加安全性",
            ],
            answer: 1,
            rationale: "实现快照清理策略以控制存储成本。",
        },
    ],
    "w12-4": [
        {
            id: "w12-4-q1",
            question: "为什么需要事件版本化？",
            options: [
                "性能优化",
                "当事件结构变化时，需要支持多个事件版本",
                "减少存储",
                "简化代码",
            ],
            answer: 1,
            rationale: "当事件结构变化时，需要支持多个事件版本。",
        },
        {
            id: "w12-4-q2",
            question: "什么是 Upcasting？",
            options: [
                "类型转换",
                "将旧版本事件转换为新版本格式",
                "数据压缩",
                "事件删除",
            ],
            answer: 1,
            rationale: "Upcasting——将旧版本事件转换为新版本格式。",
        },
        {
            id: "w12-4-q3",
            question: "事件处理器需要能够处理什么？",
            options: [
                "只处理最新版本",
                "旧版本的事件",
                "只处理今天的事件",
                "只处理错误事件",
            ],
            answer: 1,
            rationale: "事件处理器需要能够处理旧版本的事件，保证向后兼容。",
        },
        {
            id: "w12-4-q4",
            question: "版本戳的作用是什么？",
            options: [
                "时间记录",
                "帮助处理器识别事件版本",
                "数据校验",
                "性能优化",
            ],
            answer: 1,
            rationale: "在事件中包含版本标识，帮助处理器识别版本。",
        },
        {
            id: "w12-4-q5",
            question: "哪些变更可能是破坏性的？",
            options: [
                "添加可选字段",
                "删除字段、重命名事件类型",
                "添加注释",
                "修改文档",
            ],
            answer: 1,
            rationale: "删除字段可能导致旧事件无法正确解析，重命名事件类型需要特殊处理。",
        },
        {
            id: "w12-4-q6",
            question: "如何设计向后兼容的事件变更？",
            options: [
                "任意修改",
                "添加新字段而非删除旧字段，使用默认值",
                "删除所有旧事件",
                "不能修改",
            ],
            answer: 1,
            rationale: "设计向后兼容的事件 Schema，添加新字段而非删除旧字段。",
        },
        {
            id: "w12-4-q7",
            question: "同时处理多个版本的事件有什么影响？",
            options: [
                "没有影响",
                "增加处理器复杂度",
                "减少代码",
                "提高性能",
            ],
            answer: 1,
            rationale: "同时处理多个版本的事件增加复杂度。",
        },
        {
            id: "w12-4-q8",
            question: "Avro 等序列化格式的优势是什么？",
            options: [
                "速度快",
                "支持 Schema 演化",
                "体积小",
                "简单",
            ],
            answer: 1,
            rationale: "Avro 等序列化格式支持 Schema 演化，适合事件版本管理。",
        },
        {
            id: "w12-4-q9",
            question: "事件注册表（Event Registry）的作用是什么？",
            options: [
                "存储事件",
                "管理事件类型和版本的元数据",
                "处理事件",
                "删除事件",
            ],
            answer: 1,
            rationale: "事件注册表管理事件类型和版本的元数据。",
        },
        {
            id: "w12-4-q10",
            question: "事件变更应该建立什么流程？",
            options: [
                "无需流程",
                "事件变更的审批流程",
                "自动变更",
                "随意变更",
            ],
            answer: 1,
            rationale: "建立事件变更的审批流程确保变更的安全性。",
        },
        {
            id: "w12-4-q11",
            question: "测试事件演化时应该验证什么？",
            options: [
                "只验证新版本",
                "旧版本事件能否正确解析和处理",
                "只验证性能",
                "只验证存储",
            ],
            answer: 1,
            rationale: "测试事件演化的正确性，确保旧版本事件能正确解析和处理。",
        },
        {
            id: "w12-4-q12",
            question: "更新历史事件有什么风险？",
            options: [
                "没有风险",
                "可能破坏不可变性原则",
                "提高性能",
                "减少存储",
            ],
            answer: 1,
            rationale: "更新历史事件有破坏不可变性原则的风险。",
        },
    ],
}
