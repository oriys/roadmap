import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week3Guides: Record<string, LessonGuide> = {
    "w3-1": {
        lessonId: "w3-1",
        background: [
            "【模式起源】Martin Fowler 在 2001 年昆士兰雨林度假时观察绞杀榕藤蔓后构思了这个隐喻：这种植物在宿主树上发芽，逐渐吸取养分直到自给自足，最终取代宿主——这与遗留软件现代化有惊人的相似之处。",
            "【模式定义】microservices.io：Strangler 应用包含两类服务：Replacement services（替换原有功能）和 New feature services（实现新功能，向利益相关者展示微服务价值）。",
            "【四步流程】Azure 文档定义四个阶段：1) Façade Introduction（引入代理）2) Incremental Migration（逐步迁移）3) Complete Migration（完成迁移）4) Cleanup（清理门面）。",
            "【四大活动】Fowler 团队总结四个高层活动：建立清晰的期望结果、识别系统'接缝'（seams）、增量替换组件、通过新开发实践和团队重组推动组织变革。",
            "【核心价值】Fowler：'Reduced Risk'（较小的替换意味着较低的失败风险）、'Earlier Value'（业务从完成的组件中逐步获得回报）、'Learning'（每个替换阶段为后续决策提供信息）。",
        ],
        keyDifficulties: [
            "【Big Bang 反模式】microservices.io 警告：不要使用 'Big Bang' 重写——虽然听起来诱人，但风险极高，很可能以失败告终。",
            "【门面瓶颈】Azure 文档：确保门面不会成为单点故障或性能瓶颈（'Ensure the façade doesn't become a single point of failure or performance bottleneck'）。",
            "【共享资源】Azure 强调迁移期间两个系统需要同时访问共享服务和数据存储，这需要仔细规划。",
            "【不适用场景】Azure：当请求无法被拦截、小型系统完全替换更简单、或需要快速淘汰原系统时，不适合使用此模式。",
            "【临时架构】Fowler 提醒：必须接受临时的过渡架构——迁移过程中系统会处于不完美状态。",
        ],
        handsOnPath: [
            "识别适合提取的功能：从边缘服务开始（如认证、用户配置文件），避免核心业务逻辑。",
            "设计门面/代理层：决定使用 API Gateway、反向代理还是应用层路由。",
            "实现第一个替换服务：选择依赖最少的模块，构建独立服务。",
            "配置请求路由：门面初始将大部分请求路由到遗留系统，逐步迁移到新服务。",
            "建立监控和回滚机制：监控新旧系统的性能和错误率，保持快速回滚能力。",
            "迭代迁移：每次迁移一小部分功能，验证后再继续。",
            "退役遗留代码：功能完全迁移后，移除旧代码和门面。",
        ],
        selfCheck: [
            "Strangler Fig 模式的灵感来源是什么？这个隐喻如何映射到软件现代化？",
            "Azure 文档描述的四步迁移流程是什么？",
            "Strangler 应用包含哪两类服务？各自的作用是什么？",
            "为什么 'Big Bang' 重写被认为是反模式？",
            "什么情况下不适合使用 Strangler Fig 模式？",
            "Fowler 团队总结的四个高层活动是什么？",
            "如何避免门面成为性能瓶颈？",
        ],
        extensions: [
            "研究 Azure 的数据库迁移示例：ETL 同步、Shadow Write、最终切换。",
            "探索如何结合 Feature Toggles 实现更细粒度的流量控制。",
            "学习 Blue-Green Deployment 与 Strangler Fig 的结合使用。",
            "了解如何使用 Service Mesh 实现更智能的请求路由。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/refactoring/strangler-application.html",
            "https://martinfowler.com/bliki/StranglerFigApplication.html",
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/strangler-fig",
        ],
    },
    "w3-2": {
        lessonId: "w3-2",
        background: [
            "【问题定义】microservices.io：'How do you prevent a legacy monolith's domain model from polluting the domain model of a new service'——遗留系统的概念和数据结构会污染新服务的领域模型。",
            "【模式来源】Azure 文档：该模式最早由 Eric Evans 在《Domain-Driven Design》中描述，用于在不同语义的子系统之间建立门面或适配器层。",
            "【解决方案】microservices.io：'Define an anti-corruption layer, which translates between the two domain models'——ACL 作为保护边界层执行双向翻译。",
            "【工作原理】ACL 接收使用新服务领域模型的请求，翻译为遗留系统格式，接收遗留响应并转换回新模型——隔离内部架构与外部依赖。",
            "【实现方式】Azure：可实现为应用内组件或独立服务，包含所有翻译逻辑，通信使用各系统的原生数据模型和方法。",
        ],
        keyDifficulties: [
            "【性能影响】Azure 警告：ACL 可能增加系统间调用的延迟（'May add latency to inter-system calls'）。",
            "【维护成本】ACL 是额外需要管理的服务，增加了运维复杂性。",
            "【范围决策】需要决定 ACL 是处理所有通信还是只处理部分通信。",
            "【永久性决策】需要决定 ACL 是临时的（迁移期间）还是永久的——有时保留 ACL 作为遗留客户端适配器是合理的。",
            "【数据一致性】Azure：必须维护和监控事务完整性（'Maintain and monitor transaction integrity'）。",
        ],
        handsOnPath: [
            "识别新旧系统间的集成点：列出所有需要翻译的 API 调用和数据交换。",
            "设计翻译逻辑：为每个集成点定义新模型到旧模型的映射规则。",
            "实现 ACL 组件：可以是库、API 网关插件或独立服务。",
            "处理数据格式转换：字段映射、类型转换、枚举值翻译等。",
            "实现错误翻译：将遗留系统的错误码转换为新服务的错误模型。",
            "添加监控和日志：跟踪翻译性能、错误率、数据一致性。",
            "定期评估：随着迁移进展，评估是否可以简化或移除 ACL。",
        ],
        selfCheck: [
            "防腐层（Anti-corruption Layer）解决什么问题？",
            "ACL 的工作原理是什么？数据如何在新旧系统间流转？",
            "ACL 可以实现为哪些形式？",
            "使用 ACL 的主要考虑因素有哪些？",
            "什么情况下应该保留 ACL 作为永久组件？",
            "ACL 与 DDD 的关系是什么？",
            "如何避免 ACL 成为性能瓶颈？",
        ],
        extensions: [
            "研究 Adapter Pattern 与 ACL 的关系和区别。",
            "探索使用 API Gateway 实现 ACL 功能的方案。",
            "学习 Event-Driven ACL：通过事件而非同步调用进行翻译。",
            "了解 ACL 在多系统集成场景中的应用（如多个遗留系统）。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/refactoring/anti-corruption-layer.html",
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer",
            "https://martinfowler.com/articles/break-monolith-into-microservices.html",
        ],
    },
    "w3-3": {
        lessonId: "w3-3",
        background: [
            "【Database per Service】microservices.io：每个微服务维护自己的私有数据库，只能通过服务 API 访问。实现方式包括：每服务私有表、每服务独立 Schema、每服务独立数据库服务器。",
            "【数据库重构】Fowler 书籍：数据库重构引入独特挑战，不仅需要改变结构，还需要 'manage continual migration of the data itself'——数据本身的持续迁移。",
            "【Sam Newman 方法】《Monolith to Microservices》涵盖多种数据迁移模式：Shared database、Database wrapping service、数据同步、Tracer Write、表拆分、外键转应用逻辑、Saga 分布式事务。",
            "【核心挑战】microservices.io 列出两大挑战：Complex transactions（跨服务分布式事务困难）和 Cross-service queries（跨数据库连接查询困难）。",
            "【技术多样性】Database per Service 的好处之一是服务可以使用最适合需求的数据库：ElasticSearch 用于文本搜索、Neo4j 用于图数据等。",
        ],
        keyDifficulties: [
            "【分布式事务】microservices.io：跨多个服务的分布式事务应该避免，改用 Saga 模式实现最终一致性。",
            "【跨服务查询】跨数据库连接数据困难——需要使用 API Composition 或 CQRS 维护跨服务的物化视图。",
            "【引用完整性】Newman 强调需要处理 'the impact of breaking referential and transactional integrity'——打破引用和事务完整性的影响。",
            "【运维复杂性】管理多个 SQL 和 NoSQL 数据库增加运维开销。",
            "【Tracer Write 模式】用于验证数据一致性：新系统写入新数据库时，同时影子写入（shadow write）旧数据库以验证一致性。",
        ],
        handsOnPath: [
            "分析当前数据库结构：识别哪些表属于哪个业务能力/子域。",
            "识别跨域引用：哪些表有跨域的外键关系？这些需要转换为应用级逻辑。",
            "规划迁移顺序：从依赖最少的数据开始，逐步解耦。",
            "实现数据同步：使用 CDC（Change Data Capture）或 ETL 保持新旧数据同步。",
            "应用 Tracer Write：新系统写入时同时更新新旧数据库，验证一致性。",
            "实现 API Composition 或 CQRS：解决跨服务查询需求。",
            "监控数据一致性：建立机制检测和修复数据不一致。",
        ],
        selfCheck: [
            "Database per Service 模式的三种实现方式是什么？",
            "为什么每个微服务应该有独立的数据库？",
            "Database per Service 的主要挑战是什么？",
            "Saga 模式如何解决分布式事务问题？",
            "API Composition 和 CQRS 如何解决跨服务查询问题？",
            "什么是 Tracer Write 模式？它解决什么问题？",
            "如何处理遗留系统中的外键关系？",
        ],
        extensions: [
            "深入学习 Saga 模式的编排式和协同式实现。",
            "研究 Debezium 等 CDC 工具在数据同步中的应用。",
            "探索 Event Sourcing 作为数据管理的替代方案。",
            "了解双写（Dual Write）的风险和如何避免。",
        ],
        sourceUrls: [
            "https://martinfowler.com/books/refactoringDatabases.html",
            "https://microservices.io/patterns/data/database-per-service.html",
            "https://samnewman.io/books/monolith-to-microservices/",
        ],
    },
    "w3-4": {
        lessonId: "w3-4",
        background: [
            "【八大原则】Fowler 文章总结八个迁移原则：1) Warm Up with Simple, Decoupled Capabilities 2) Minimize Monolith Dependencies 3) Split Sticky Capabilities Early 4) Decouple Vertically with Data 5) Prioritize Business-Critical Capabilities 6) Rewrite Over Reuse 7) Start Macro Then Micro 8) Evolve Atomically。",
            "【七大反模式】microservices.io 列出七个采用反模式：Magic Pixie Dust、Microservices as the Goal、Scattershot Adoption、Flying Before Walking、Technology Focus、More the Merrier、Red Flag Law。",
            "【边缘服务优先】Fowler：'First, decouple simple edge services'——开始时最大的风险是无法正确运维微服务，所以用边缘服务来实践运维先决条件。",
            "【垂直解耦】Fowler：'Without decoupling the data, the architecture is not microservices'——必须将服务连同数据一起提取，重定向所有消费者到新 API。",
            "【重写优于复用】Fowler：遗留代码带有样板代码、糟糕的领域建模和高毒性——重写为新服务通常比提取有毒代码更有价值。",
        ],
        keyDifficulties: [
            "【Magic Pixie Dust】反模式：认为撒一点微服务就能解决所有开发问题，而不解决根本问题。",
            "【分布式单体】如果只解耦门面而数据保持集中，会创建分布式单体——比原来更糟糕。",
            "【Flying Before Walking】反模式：在掌握基础（干净代码、良好设计、自动化测试）之前就尝试采用高级微服务技术。",
            "【未完成迁移】Fowler 警告的反模式：构建新服务、为新消费者使用，但从不退役旧代码路径——导致双重维护。",
            "【过度细分】More the Merrier 反模式：没有充分理由就创建过度细粒度的微服务架构——服务数量应与团队独立发布、监控和运维能力匹配。",
        ],
        handsOnPath: [
            "评估团队成熟度：是否具备干净代码、自动化测试、CI/CD 等基础能力？",
            "选择第一个迁移目标：优先选择边缘服务、低风险、高业务价值的模块。",
            "建立运维基础设施：部署流水线、监控系统、服务发现等。",
            "实施垂直切分：将功能和数据一起迁移，避免只迁移门面。",
            "建立退役机制：新服务稳定后，有计划地移除旧代码。",
            "迭代评估：每次迁移后评估架构适应度，确保整体改进。",
            "培养团队文化：从项目制转向产品制，实践 'You Build It, You Run It'。",
        ],
        selfCheck: [
            "Fowler 文章的八大迁移原则是什么？",
            "七大微服务采用反模式是什么？",
            "为什么应该从边缘服务开始迁移？",
            "'Without decoupling the data, the architecture is not microservices' 是什么意思？",
            "为什么重写通常优于复用遗留代码？",
            "什么是 'Flying Before Walking' 反模式？如何避免？",
            "如何判断是否过度细分（More the Merrier）？",
        ],
        extensions: [
            "研究 Spotify、Netflix、Amazon 等公司的微服务迁移案例。",
            "探索 Fitness Functions 如何评估架构演进的健康度。",
            "学习 Team Topologies 如何影响迁移策略。",
            "了解 Inverse Conway Maneuver 在迁移中的应用。",
        ],
        sourceUrls: [
            "https://martinfowler.com/articles/break-monolith-into-microservices.html",
            "https://microservices.io/refactoring/",
            "https://microservices.io/microservices/antipatterns/-/the/series/2019/06/18/microservices-adoption-antipatterns.html",
        ],
    },
}

export const week3Quizzes: Record<string, QuizQuestion[]> = {
    "w3-1": [
        {
            id: "w3-1-q1",
            question: "Strangler Fig 模式的名称灵感来自什么？",
            options: [
                "一种编程技术",
                "Martin Fowler 观察到的绞杀榕藤蔓",
                "一种数据库迁移策略",
                "一种网络协议",
            ],
            answer: 1,
            rationale: "Fowler 在 2001 年昆士兰雨林度假时观察绞杀榕藤蔓后构思了这个隐喻——这种植物逐渐取代宿主树。",
        },
        {
            id: "w3-1-q2",
            question: "根据 microservices.io，Strangler 应用包含哪两类服务？",
            options: [
                "前端服务和后端服务",
                "Replacement services 和 New feature services",
                "核心服务和边缘服务",
                "同步服务和异步服务",
            ],
            answer: 1,
            rationale: "microservices.io 定义 Strangler 应用包含：Replacement services（替换原有功能）和 New feature services（实现新功能）。",
        },
        {
            id: "w3-1-q3",
            question: "Azure 文档描述的 Strangler Fig 四步流程的第一步是什么？",
            options: [
                "Complete Migration",
                "Incremental Migration",
                "Façade Introduction",
                "Cleanup",
            ],
            answer: 2,
            rationale: "Azure 四步流程是：1) Façade Introduction 2) Incremental Migration 3) Complete Migration 4) Cleanup。",
        },
        {
            id: "w3-1-q4",
            question: "为什么 'Big Bang' 重写被认为是反模式？",
            options: [
                "成本太高",
                "虽然听起来诱人，但风险极高，很可能以失败告终",
                "技术上不可能实现",
                "需要太多人力",
            ],
            answer: 1,
            rationale: "microservices.io 警告：Big Bang 重写 'Although it sounds appealing, it is extremely risky and will likely end in failure'。",
        },
        {
            id: "w3-1-q5",
            question: "Fowler 描述的 Strangler Fig 的三大价值是什么？",
            options: [
                "Speed, Cost, Quality",
                "Reduced Risk, Earlier Value, Learning",
                "Scalability, Performance, Security",
                "Simplicity, Flexibility, Reliability",
            ],
            answer: 1,
            rationale: "Fowler 列出三大价值：Reduced Risk（降低风险）、Earlier Value（更早获得价值）、Learning（学习改进）。",
        },
        {
            id: "w3-1-q6",
            question: "根据 Azure 文档，什么情况下不适合使用 Strangler Fig 模式？",
            options: [
                "大型复杂系统",
                "需要长期迁移的系统",
                "请求无法被拦截的系统",
                "有多个团队的组织",
            ],
            answer: 2,
            rationale: "Azure 指出不适用场景包括：请求无法被拦截、小型系统直接替换更简单、需要快速淘汰原系统。",
        },
        {
            id: "w3-1-q7",
            question: "Azure 文档强调在迁移期间需要注意什么关于门面的问题？",
            options: [
                "门面的颜色",
                "门面不要成为单点故障或性能瓶颈",
                "门面必须用 Java 编写",
                "门面必须是开源的",
            ],
            answer: 1,
            rationale: "Azure 强调 'Ensure the façade doesn't become a single point of failure or performance bottleneck'。",
        },
        {
            id: "w3-1-q8",
            question: "Fowler 团队总结的四个高层活动中，'识别系统接缝（seams）' 的目的是什么？",
            options: [
                "提高系统性能",
                "将单体代码分解为可替换的组件",
                "减少代码行数",
                "简化测试",
            ],
            answer: 1,
            rationale: "Fowler 描述识别 seams 的目的是 'break monolithic code into replaceable components'。",
        },
        {
            id: "w3-1-q9",
            question: "Azure 文档中的数据库迁移示例，Shadow Write 阶段的特点是什么？",
            options: [
                "只写入新数据库",
                "只写入旧数据库",
                "新系统同时更新新旧数据库（并行写入）",
                "不进行任何写入",
            ],
            answer: 2,
            rationale: "Azure 描述 Shadow Write 阶段：'new system performs shadow writes (updates both in parallel)'。",
        },
        {
            id: "w3-1-q10",
            question: "Fowler 为什么强调需要接受'临时的过渡架构'？",
            options: [
                "因为完美的架构不存在",
                "迁移过程中系统会处于不完美状态，这是正常的",
                "为了节省成本",
                "为了加快开发速度",
            ],
            answer: 1,
            rationale: "Fowler 提醒必须 'accepting temporary transitional architecture'——迁移过程中系统会处于不完美状态。",
        },
        {
            id: "w3-1-q11",
            question: "根据 Azure Well-Architected Framework，Strangler Fig 如何支持 Reliability？",
            options: [
                "通过增加服务器数量",
                "通过增量变更而非大规模系统变更来降低风险",
                "通过使用更可靠的硬件",
                "通过减少代码量",
            ],
            answer: 1,
            rationale: "Azure 指出 Reliability 好处：'Mitigates risks through incremental changes vs. large systemic changes'。",
        },
        {
            id: "w3-1-q12",
            question: "Azure 文档建议在清理阶段可以考虑什么替代完全移除门面？",
            options: [
                "增强门面功能",
                "保留门面作为遗留客户端适配器",
                "将门面开源",
                "出售门面",
            ],
            answer: 1,
            rationale: "Azure 建议 'Consider maintaining the façade as a legacy client adapter rather than removing it'。",
        },
    ],
    "w3-2": [
        {
            id: "w3-2-q1",
            question: "防腐层（Anti-corruption Layer）解决什么问题？",
            options: [
                "防止安全攻击",
                "防止遗留系统的领域模型污染新服务的领域模型",
                "防止数据丢失",
                "防止性能下降",
            ],
            answer: 1,
            rationale: "microservices.io 定义问题为 'How do you prevent a legacy monolith's domain model from polluting the domain model of a new service'。",
        },
        {
            id: "w3-2-q2",
            question: "防腐层模式最早由谁在哪本书中描述？",
            options: [
                "Martin Fowler 在《Refactoring》中",
                "Eric Evans 在《Domain-Driven Design》中",
                "Sam Newman 在《Building Microservices》中",
                "Chris Richardson 在《Microservices Patterns》中",
            ],
            answer: 1,
            rationale: "Azure 文档指出 ACL 'First described by Eric Evans in Domain-Driven Design'。",
        },
        {
            id: "w3-2-q3",
            question: "防腐层可以实现为哪些形式？",
            options: [
                "只能是独立服务",
                "只能是应用内组件",
                "应用内组件或独立服务",
                "只能是数据库触发器",
            ],
            answer: 2,
            rationale: "Azure 指出 ACL 'Can be implemented as: Component within the application, Independent service'。",
        },
        {
            id: "w3-2-q4",
            question: "Azure 文档列出的 ACL 使用考虑因素中，哪个涉及性能？",
            options: [
                "维护成本",
                "可能增加系统间调用的延迟",
                "安全性",
                "可扩展性",
            ],
            answer: 1,
            rationale: "Azure 警告 ACL 'May add latency to inter-system calls'。",
        },
        {
            id: "w3-2-q5",
            question: "什么情况下不应该使用 ACL？",
            options: [
                "迁移计划跨多个阶段",
                "两个子系统有不同的语义",
                "系统之间没有显著的语义差异",
                "需要长期集成",
            ],
            answer: 2,
            rationale: "Azure 指出 'Not suitable when: No significant semantic differences between systems exist'。",
        },
        {
            id: "w3-2-q6",
            question: "根据 Fowler 文章，为什么新服务应该避免依赖单体的数据、逻辑或 API？",
            options: [
                "因为单体性能差",
                "依赖会使新服务耦合到单体的发布周期，失去独立发布的好处",
                "因为单体代码质量低",
                "因为单体使用旧技术",
            ],
            answer: 1,
            rationale: "Fowler 解释：依赖单体的数据、逻辑、API 'couples the service to the monolith's release cycle, prohibiting this benefit'。",
        },
        {
            id: "w3-2-q7",
            question: "ACL 需要做出什么关于范围的决策？",
            options: [
                "使用哪种编程语言",
                "处理所有通信还是只处理部分通信",
                "部署在哪个数据中心",
                "使用哪种数据库",
            ],
            answer: 1,
            rationale: "Azure 列出需要 'Determine if layer handles all or subset of communications'。",
        },
        {
            id: "w3-2-q8",
            question: "根据 Azure 的 Well-Architected Framework，ACL 如何支持 Operational Excellence？",
            options: [
                "减少运维人员",
                "确保新组件设计不受遗留实现影响，减少技术债务",
                "自动化所有操作",
                "消除手动测试",
            ],
            answer: 1,
            rationale: "Azure 指出 ACL 'Ensures new component design remains uninfluenced by legacy implementations' 和 'Reduces technical debt in new components'。",
        },
        {
            id: "w3-2-q9",
            question: "ACL 的典型架构是什么？",
            options: [
                "直接连接新旧系统",
                "Subsystem A ↔ Anti-Corruption Layer ↔ Subsystem B",
                "只连接到新系统",
                "只连接到旧系统",
            ],
            answer: 1,
            rationale: "Azure 描述架构为 'Subsystem A ↔ Anti-Corruption Layer ↔ Subsystem B'，ACL 位于中间进行翻译。",
        },
        {
            id: "w3-2-q10",
            question: "Fowler 文章建议建立什么类型的依赖关系？",
            options: [
                "新服务依赖单体",
                "单体调用新服务（反向依赖）",
                "双向依赖",
                "不要任何依赖",
            ],
            answer: 1,
            rationale: "Fowler 建议 'establish reverse dependencies where the monolith calls new services—preserving independent release cycles'。",
        },
        {
            id: "w3-2-q11",
            question: "ACL 与哪些其他模式相关？",
            options: [
                "Factory 和 Singleton",
                "Strangler Fig 和 Messaging Bridge",
                "Observer 和 Strategy",
                "MVC 和 MVP",
            ],
            answer: 1,
            rationale: "Azure 列出相关模式：'Strangler Fig pattern, Messaging Bridge pattern'。",
        },
        {
            id: "w3-2-q12",
            question: "关于 ACL 的永久性，需要决策什么？",
            options: [
                "使用什么技术栈",
                "是临时的（迁移期间）还是永久的",
                "部署几个实例",
                "使用什么云服务商",
            ],
            answer: 1,
            rationale: "Azure 指出需要 'Decide if temporary (during migration) or permanent'。",
        },
    ],
    "w3-3": [
        {
            id: "w3-3-q1",
            question: "Database per Service 模式有哪三种实现方式？",
            options: [
                "主从复制、分片、集群",
                "每服务私有表、每服务独立 Schema、每服务独立数据库服务器",
                "SQL、NoSQL、NewSQL",
                "本地、云端、混合",
            ],
            answer: 1,
            rationale: "microservices.io 列出三种实现：'Private tables per service, Schema per service, Database server per service'。",
        },
        {
            id: "w3-3-q2",
            question: "Database per Service 模式的主要好处之一是什么？",
            options: [
                "降低存储成本",
                "服务可以使用最适合需求的数据库技术",
                "简化备份",
                "减少查询复杂度",
            ],
            answer: 1,
            rationale: "microservices.io 指出 'Technology flexibility: Services can use databases suited to their specific needs'。",
        },
        {
            id: "w3-3-q3",
            question: "跨多个服务的分布式事务应该如何处理？",
            options: [
                "使用 Two-Phase Commit",
                "使用 Saga 模式实现最终一致性",
                "忽略事务",
                "使用全局锁",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'Distributed transactions: Use the Saga pattern for eventual consistency'。",
        },
        {
            id: "w3-3-q4",
            question: "跨服务查询问题应该如何解决？",
            options: [
                "直接跨数据库 JOIN",
                "使用 API Composition 或 CQRS",
                "忽略查询需求",
                "使用存储过程",
            ],
            answer: 1,
            rationale: "microservices.io 建议：'Cross-service queries: Employ API Composition or CQRS to maintain materialized views across services'。",
        },
        {
            id: "w3-3-q5",
            question: "根据 Fowler 的书，数据库重构面临的独特挑战是什么？",
            options: [
                "只需要改变结构",
                "需要管理数据本身的持续迁移，而不仅是结构变化",
                "不需要考虑性能",
                "可以忽略数据一致性",
            ],
            answer: 1,
            rationale: "Fowler 书指出数据库重构需要 'manage continual migration of the data itself'。",
        },
        {
            id: "w3-3-q6",
            question: "Sam Newman 的书中提到的 Tracer Write 模式是什么？",
            options: [
                "追踪写入性能",
                "用于验证新旧数据库数据一致性的写入模式",
                "追踪用户行为",
                "追踪错误日志",
            ],
            answer: 1,
            rationale: "Newman 书描述 Tracer Write 是 'pattern for validating data consistency'。",
        },
        {
            id: "w3-3-q7",
            question: "为什么 Database per Service 增加了运维复杂性？",
            options: [
                "需要更多程序员",
                "需要管理多个 SQL 和 NoSQL 数据库",
                "需要更多办公空间",
                "需要更多会议",
            ],
            answer: 1,
            rationale: "microservices.io 指出缺点：'Managing multiple SQL and NoSQL databases increases overhead'。",
        },
        {
            id: "w3-3-q8",
            question: "Newman 的书强调需要处理什么的影响？",
            options: [
                "网络延迟",
                "打破引用和事务完整性",
                "用户界面变化",
                "团队规模",
            ],
            answer: 1,
            rationale: "Newman 强调需要处理 'the impact of breaking referential and transactional integrity'。",
        },
        {
            id: "w3-3-q9",
            question: "CQRS 在解决跨服务查询问题时的作用是什么？",
            options: [
                "加密数据",
                "维护跨服务的物化视图",
                "压缩数据",
                "删除重复数据",
            ],
            answer: 1,
            rationale: "microservices.io 解释 CQRS 用于 'maintain materialized views across services'。",
        },
        {
            id: "w3-3-q10",
            question: "Sam Newman 书中提到的数据同步方式包括什么？",
            options: [
                "只有手动同步",
                "应用级进程进行数据同步",
                "不需要同步",
                "只有硬件同步",
            ],
            answer: 1,
            rationale: "Newman 书提到 'Data synchronization techniques via application-level processes'。",
        },
        {
            id: "w3-3-q11",
            question: "遗留系统中的外键关系应该如何处理？",
            options: [
                "保持不变",
                "转换为应用级逻辑",
                "删除所有外键",
                "使用全局外键",
            ],
            answer: 1,
            rationale: "Newman 书提到 'Converting foreign-key relationships to application-level logic'。",
        },
        {
            id: "w3-3-q12",
            question: "Database per Service 如何实现松耦合？",
            options: [
                "通过共享更多数据",
                "一个服务的数据库变更不影响其他服务",
                "通过减少服务数量",
                "通过增加 DBA 数量",
            ],
            answer: 1,
            rationale: "microservices.io 指出好处：'Loose coupling: Database changes in one service don't affect others'。",
        },
    ],
    "w3-4": [
        {
            id: "w3-4-q1",
            question: "Fowler 文章的第一条迁移原则是什么？",
            options: [
                "先拆分数据库",
                "从简单、解耦的边缘能力开始热身",
                "重写所有代码",
                "先招聘更多人",
            ],
            answer: 1,
            rationale: "Fowler 第一条原则是 'Warm Up with Simple, Decoupled Capabilities'——从边缘服务开始实践运维。",
        },
        {
            id: "w3-4-q2",
            question: "'Magic Pixie Dust' 反模式是什么？",
            options: [
                "使用魔法编程",
                "认为微服务能自动解决所有开发问题，而不解决根本问题",
                "使用太多框架",
                "代码太简单",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Assuming microservices alone will solve developmental challenges without addressing underlying issues'。",
        },
        {
            id: "w3-4-q3",
            question: "Fowler 为什么说 'Without decoupling the data, the architecture is not microservices'？",
            options: [
                "数据不重要",
                "必须将服务连同数据一起提取，否则只是门面解耦",
                "数据库太贵",
                "数据迁移太慢",
            ],
            answer: 1,
            rationale: "Fowler 强调必须垂直解耦，包括数据——只解耦门面而数据保持集中会创建分布式单体。",
        },
        {
            id: "w3-4-q4",
            question: "'Flying Before Walking' 反模式描述的是什么情况？",
            options: [
                "飞行测试失败",
                "在掌握基础（干净代码、良好设计、自动化测试）之前就采用高级微服务技术",
                "走路太慢",
                "飞机旅行太多",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Adopting advanced microservices techniques without mastering fundamentals like clean code, solid design, and automated testing'。",
        },
        {
            id: "w3-4-q5",
            question: "为什么 Fowler 建议重写优于复用遗留代码？",
            options: [
                "重写更便宜",
                "遗留代码带有样板代码、糟糕的领域建模和高毒性",
                "重写更快",
                "公司政策要求",
            ],
            answer: 1,
            rationale: "Fowler 指出：'Legacy code carries boilerplate, poor domain modeling, and high toxicity. Rewriting...often delivers greater value'。",
        },
        {
            id: "w3-4-q6",
            question: "'More the Merrier' 反模式是什么？",
            options: [
                "团队人数太多",
                "没有充分理由就创建过度细粒度的微服务架构",
                "使用太多工具",
                "开会太多",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Creating excessively fine-grained microservice architectures without justification'。",
        },
        {
            id: "w3-4-q7",
            question: "Fowler 为什么建议从边缘服务开始迁移？",
            options: [
                "边缘服务最简单",
                "开始时最大风险是无法正确运维微服务，用边缘服务实践运维",
                "边缘服务最赚钱",
                "边缘服务用户最少",
            ],
            answer: 1,
            rationale: "Fowler 解释：'at the beginning of the journey, the delivery teams' biggest risk is failing to operate the microservices properly'。",
        },
        {
            id: "w3-4-q8",
            question: "'Scattershot Adoption' 反模式是什么？",
            options: [
                "使用散弹枪",
                "多个团队独立尝试微服务迁移而没有组织协调",
                "随机选择技术",
                "随机招聘",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Multiple teams attempting microservices migration independently without organizational coordination'。",
        },
        {
            id: "w3-4-q9",
            question: "Fowler 的 'Evolve Atomically' 原则是什么意思？",
            options: [
                "使用原子操作",
                "每次迁移步骤必须改进架构适应度，完成完整周期",
                "只修改原子大小的代码",
                "使用原子数据库",
            ],
            answer: 1,
            rationale: "Fowler 解释：'Each migration step must improve architecture fitness. Complete full cycles: build service → redirect consumers → retire old code'。",
        },
        {
            id: "w3-4-q10",
            question: "Fowler 列出的未完成迁移反模式是什么？",
            options: [
                "构建太多服务",
                "构建新服务但从不退役旧代码路径",
                "迁移太快",
                "迁移太慢",
            ],
            answer: 1,
            rationale: "Fowler 警告：'An anti-pattern is to decouple the new service...and never retire the old' 导致双重维护。",
        },
        {
            id: "w3-4-q11",
            question: "'Start Macro, Then Micro' 原则是什么意思？",
            options: [
                "使用大型服务器",
                "从较大的服务开始，随着运维成熟度提高再进一步分解",
                "宏观经济分析",
                "使用 Microsoft Office",
            ],
            answer: 1,
            rationale: "Fowler 建议：'Begin with larger services around logical domains. Decompose further only as operational maturity increases'。",
        },
        {
            id: "w3-4-q12",
            question: "'Red Flag Law' 反模式是什么？",
            options: [
                "使用红旗标记代码",
                "在微服务框架内保持单体的开发流程和组织结构",
                "遵守交通法规",
                "使用红色主题",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Maintaining monolithic development processes and organizational structures within a microservices framework'。",
        },
    ],
}
