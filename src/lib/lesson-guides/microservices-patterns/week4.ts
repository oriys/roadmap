import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week4Guides: Record<string, LessonGuide> = {
    "w4-1": {
        lessonId: "w4-1",
        background: [
            "【模式定义】microservices.io：'A service's database is private to that service and accessible only via its API'——服务的数据库是私有的，只能通过其 API 访问。",
            "【三种实现】模式提供三种实现选项：Private-tables-per-service（每服务私有表）、Schema-per-service（每服务独立 Schema）、Database-server-per-service（每服务独立数据库服务器）。",
            "【松耦合保证】核心好处是确保服务之间松散耦合：'Changes to one service's database does not impact any other services'——数据库变更不影响其他服务。",
            "【技术多样性】各服务可采用最适合的数据库技术（Polyglot Persistence）：ElasticSearch 用于文本搜索、Neo4j 用于图数据、Redis 用于缓存等。",
            "【访问控制】建议为每个服务分配独立数据库账户，通过访问控制机制强制执行数据隐私。",
        ],
        keyDifficulties: [
            "【跨服务事务】microservices.io：跨服务事务实现复杂，'应避免分布式事务'——使用 Saga 模式实现最终一致性。",
            "【跨服务查询】多数据库联接查询困难——需采用 API Composition 或 CQRS 模式解决。",
            "【运维复杂性】需管理多个 SQL 和 NoSQL 数据库，增加运维开销。",
            "【数据一致性】Azure 文档：'同一数据在多处存储'导致冗余，需要管理数据同步延迟（最终一致性）。",
            "【单一事实来源】Azure 强调：必须明确定义 'Single Source of Truth'，避免数据冲突——例如订单服务是交易历史的权威数据源。",
        ],
        handsOnPath: [
            "识别数据所有权：为每个服务定义其拥有的数据实体和表。",
            "选择数据库技术：根据服务需求选择关系型、文档型、图数据库等。",
            "配置独立数据库账户：为每个服务创建专属的数据库用户和权限。",
            "设计服务 API：确保数据只能通过 API 访问，禁止直接数据库访问。",
            "实现事件发布：服务在数据变更时发布领域事件，供其他服务订阅。",
            "建立监控：监控每个数据库的性能、容量和可用性。",
        ],
        selfCheck: [
            "Database per Service 模式的三种实现方式是什么？",
            "为什么数据库私有化能确保服务松耦合？",
            "什么是 Polyglot Persistence？为什么它在这个模式中很重要？",
            "跨服务事务和查询的挑战是什么？有哪些解决方案？",
            "什么是 Single Source of Truth？为什么它很重要？",
            "如何通过访问控制强制数据隐私？",
        ],
        extensions: [
            "研究如何使用 CDC（Change Data Capture）实现跨服务数据同步。",
            "探索不同云提供商的托管数据库服务选型。",
            "学习 Debezium 等工具在 Polyglot Persistence 中的应用。",
            "了解数据网格（Data Mesh）架构与 Database per Service 的关系。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/database-per-service.html",
            "https://learn.microsoft.com/en-us/azure/architecture/microservices/design/data-considerations",
        ],
    },
    "w4-2": {
        lessonId: "w4-2",
        background: [
            "【模式定义】microservices.io：Shared Database 是 'a (single) database that is shared by multiple services. Each service freely accesses data owned by other services using local ACID transactions'。",
            "【核心优势】使用熟悉的 ACID 事务强制数据一致性：'Developers can use straightforward ACID transactions to enforce data consistency'。",
            "【运维简单】单一数据库比多个分布式数据库更容易运维：'A single database is easier to operate'。",
            "【简化查询】可以轻松执行复杂的 JOIN 查询，无需在服务间交换数据。",
            "【迁移过渡】AWS 指出：这是从单体迁移到微服务的有效过渡模式——先拆分业务逻辑，再逐步拆分数据库。",
        ],
        keyDifficulties: [
            "【开发耦合】microservices.io：Schema 变更需要跨团队协调：'a developer working on OrderService will need to coordinate schema changes with developers of other services'——减慢开发速度。",
            "【运行时干扰】服务可能相互阻塞：'if long running CustomerService transaction holds a lock on the ORDER table then the OrderService will be blocked'。",
            "【技术限制】'Single database might not satisfy the data storage and access requirements of all services'——限制了关系型和 NoSQL 的选择。",
            "【扩展性问题】共享数据库难以独立扩展，数据库成为单点故障：'the database will be a single point of failure'。",
            "【适用边界】适合小型系统、迁移过渡期、强一致性需求场景——不适合大规模微服务系统。",
        ],
        handsOnPath: [
            "评估当前系统：识别哪些服务共享数据库，分析耦合程度。",
            "划分逻辑边界：在共享数据库中为每个服务划分逻辑表分区。",
            "设计迁移计划：规划从共享数据库到 Database per Service 的演进路径。",
            "识别热点表：找出被多个服务频繁访问的表，这些是解耦的优先目标。",
            "建立协调机制：如果必须共享，建立 Schema 变更的协调流程。",
            "监控锁竞争：监控数据库锁等待，识别服务间的运行时干扰。",
        ],
        selfCheck: [
            "Shared Database 模式的核心定义是什么？",
            "使用共享数据库的主要好处有哪些？",
            "开发耦合和运行时耦合分别指什么？",
            "为什么共享数据库限制了技术选型？",
            "在什么场景下 Shared Database 是合理的选择？",
            "如何从 Shared Database 迁移到 Database per Service？",
        ],
        extensions: [
            "研究 AWS 关于共享数据库的迁移策略。",
            "探索如何使用数据库视图隔离服务间的数据访问。",
            "学习 Schema 版本管理工具（如 Flyway、Liquibase）在共享数据库中的应用。",
            "了解多租户数据库模式与共享数据库的异同。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/shared-database.html",
            "https://docs.aws.amazon.com/prescriptive-guidance/latest/modernization-data-persistence/shared-database.html",
        ],
    },
    "w4-3": {
        lessonId: "w4-3",
        background: [
            "【模式定义】microservices.io：'Invoke the services that own the data and perform an in-memory join'——调用拥有数据的服务并在内存中执行联接。",
            "【问题背景】采用微服务架构和数据库分离后，跨多个服务的数据查询变得复杂：'How to implement queries in a microservice architecture?'",
            "【实现方式】定义一个 API Composer 执行查询：调用多个服务获取数据，在内存中整合结果，返回给客户端。",
            "【API Gateway 角色】API Gateway 通常充当 Composer 角色，负责路由和组合请求到多个后端服务。",
            "【Aggregator 模式】企业集成模式定义 Aggregator 为 'stateful filter that collects and stores individual messages until a complete set of related messages has been received'。",
        ],
        keyDifficulties: [
            "【性能风险】microservices.io 警告：'Some queries would result in inefficient, in-memory joins of large datasets'——大数据集的内存联接效率低下。",
            "【完整性条件】Aggregator 需要决定何时收集完足够的数据：Wait for All（等待全部）、Time Out（超时）、First Best（最快响应）等策略。",
            "【关联匹配】需要确定哪些响应属于同一个查询请求——通过 Correlation ID 关联。",
            "【聚合算法】如何组合多个服务的响应成一个结果——需要设计合适的合并逻辑。",
            "【替代方案】对于复杂查询，CQRS 模式可能是更好的选择——预先计算和存储查询结果。",
        ],
        handsOnPath: [
            "识别跨服务查询：列出需要从多个服务获取数据的查询场景。",
            "设计 Composer：决定使用 API Gateway 还是独立的聚合服务。",
            "定义聚合逻辑：为每种查询设计数据合并算法。",
            "实现并行调用：使用异步 I/O 并行调用多个服务提高性能。",
            "处理部分失败：设计服务不可用时的降级策略。",
            "优化性能：添加缓存、分页、限制结果集大小。",
        ],
        selfCheck: [
            "API Composition 模式解决什么问题？",
            "API Composer 的工作流程是什么？",
            "API Gateway 如何充当 Composer 角色？",
            "Aggregator 模式的三个关键设计考虑是什么？",
            "有哪些完整性条件策略？各适用于什么场景？",
            "API Composition 的主要性能风险是什么？",
            "什么时候应该考虑使用 CQRS 替代 API Composition？",
        ],
        extensions: [
            "研究 GraphQL 作为 API Composition 的实现方式。",
            "探索使用响应式编程（Reactive Streams）实现高效的并行调用。",
            "学习 BFF（Backend for Frontend）模式与 API Composition 的结合。",
            "了解分布式缓存在 API Composition 中的应用。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/api-composition.html",
            "https://microservices.io/patterns/apigateway.html",
            "https://www.enterpriseintegrationpatterns.com/patterns/messaging/Aggregator.html",
        ],
    },
    "w4-4": {
        lessonId: "w4-4",
        background: [
            "【模式定义】microservices.io：'维护服务中的可查询数据副本，该服务实现命令'——Command-side Replica 允许命令服务本地维护所需数据的副本。",
            "【问题场景】当一个服务执行命令但依赖其他服务的数据时，同步调用会增加延迟和耦合。",
            "【实现机制】通过订阅提供者服务发布的领域事件，在命令服务本地维护只读数据副本。",
            "【典型案例】订单服务需要餐厅菜单数据进行验证和定价——通过维护菜单副本避免每次调用餐厅服务。",
            "【与 CQRS 关系】该模式在结构上与 CQRS 相同——都是通过事件驱动维护数据副本。",
        ],
        keyDifficulties: [
            "【复杂性增加】命令服务需要维护副本数据库，提供者服务必须发布事件——增加了系统复杂性。",
            "【最终一致性】副本数据与源数据之间存在同步延迟——需要接受最终一致性。",
            "【物化视图】Azure 文档：物化视图是 '预先生成并存储格式化后的数据视图'——完全可丢弃，可从源数据重建。",
            "【更新策略】物化视图的更新策略：事件驱动（源数据变化时刷新）、定时更新（按计划刷新）、手动更新（显式触发）。",
            "【存储考量】物化视图不必与源数据在同一存储——可以使用不同的数据库技术和存储位置。",
        ],
        handsOnPath: [
            "识别数据依赖：找出命令服务需要的外部服务数据。",
            "设计副本 Schema：定义本地副本存储的数据结构，只包含必要字段。",
            "实现事件订阅：订阅提供者服务的领域事件。",
            "维护数据同步：根据事件更新本地副本。",
            "处理初始化：服务启动时如何获取初始数据（全量同步或增量重放）。",
            "监控一致性：检测和处理副本与源数据的不一致。",
        ],
        selfCheck: [
            "Command-side Replica 模式解决什么问题？",
            "该模式如何减少运行时耦合和网络交互？",
            "物化视图的定义和特点是什么？",
            "物化视图有哪些更新策略？各适用于什么场景？",
            "Command-side Replica 与 CQRS 的关系是什么？",
            "使用该模式的主要权衡是什么？",
        ],
        extensions: [
            "研究 CQRS 模式的详细实现。",
            "探索 Event Sourcing 与 Command-side Replica 的结合。",
            "学习如何使用 Kafka Streams 或 KTable 实现状态存储。",
            "了解 CDC（Change Data Capture）作为事件来源的替代方案。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/command-side-replica.html",
            "https://microservices.io/patterns/data/cqrs.html",
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/materialized-view",
        ],
    },
}

export const week4Quizzes: Record<string, QuizQuestion[]> = {
    "w4-1": [
        {
            id: "w4-1-q1",
            question: "根据 microservices.io，Database per Service 模式的核心定义是什么？",
            options: [
                "所有服务共享一个数据库",
                "服务的数据库是私有的，只能通过其 API 访问",
                "数据库可以被任何服务直接访问",
                "每个服务必须使用相同的数据库技术",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'A service's database is private to that service and accessible only via its API'。",
        },
        {
            id: "w4-1-q2",
            question: "Database per Service 模式提供哪三种实现方式？",
            options: [
                "主从复制、分片、集群",
                "SQL、NoSQL、NewSQL",
                "Private-tables-per-service、Schema-per-service、Database-server-per-service",
                "本地、云端、混合",
            ],
            answer: 2,
            rationale: "microservices.io 列出三种实现：Private-tables-per-service、Schema-per-service、Database-server-per-service。",
        },
        {
            id: "w4-1-q3",
            question: "什么是 Polyglot Persistence？",
            options: [
                "使用多种编程语言",
                "在同一应用中使用多种数据存储技术",
                "数据多语言翻译",
                "多地区数据同步",
            ],
            answer: 1,
            rationale: "Azure 文档定义 Polyglot Persistence 为在同一应用中使用多种数据存储技术，根据服务需求选择最佳方案。",
        },
        {
            id: "w4-1-q4",
            question: "Database per Service 模式如何保证服务松耦合？",
            options: [
                "通过共享数据库连接池",
                "通过限制 API 调用次数",
                "数据库变更不影响其他服务",
                "通过使用相同的数据模型",
            ],
            answer: 2,
            rationale: "microservices.io 指出：'Changes to one service's database does not impact any other services'。",
        },
        {
            id: "w4-1-q5",
            question: "跨服务事务的推荐解决方案是什么？",
            options: [
                "使用 Two-Phase Commit",
                "使用 Saga 模式实现最终一致性",
                "直接跨数据库事务",
                "忽略事务一致性",
            ],
            answer: 1,
            rationale: "microservices.io 建议：跨服务事务应避免分布式事务，使用 Saga 模式实现最终一致性。",
        },
        {
            id: "w4-1-q6",
            question: "Azure 文档中，什么是 'Single Source of Truth'？",
            options: [
                "只有一个数据库",
                "明确定义每种数据的权威数据源",
                "单一的 API 入口",
                "唯一的配置中心",
            ],
            answer: 1,
            rationale: "Azure 强调必须明确定义 Single Source of Truth，例如订单服务是交易历史的权威数据源，其他服务持有副本。",
        },
        {
            id: "w4-1-q7",
            question: "为什么建议为每个服务分配独立的数据库账户？",
            options: [
                "简化密码管理",
                "通过访问控制强制数据隐私",
                "提高数据库性能",
                "减少许可证成本",
            ],
            answer: 1,
            rationale: "microservices.io 建议为每个服务分配独立数据库账户，通过访问控制机制强制执行数据隐私。",
        },
        {
            id: "w4-1-q8",
            question: "跨服务查询的推荐解决方案有哪些？",
            options: [
                "直接跨数据库 JOIN",
                "API Composition 或 CQRS",
                "共享数据库视图",
                "存储过程",
            ],
            answer: 1,
            rationale: "microservices.io 推荐使用 API Composition 或 CQRS 模式解决跨服务查询问题。",
        },
        {
            id: "w4-1-q9",
            question: "Database per Service 模式的主要运维挑战是什么？",
            options: [
                "数据库太少",
                "需管理多个 SQL 和 NoSQL 数据库",
                "性能太好",
                "技术选型太简单",
            ],
            answer: 1,
            rationale: "microservices.io 指出主要挑战之一是需管理多个 SQL 和 NoSQL 数据库，增加运维开销。",
        },
        {
            id: "w4-1-q10",
            question: "Azure 文档建议在什么场景使用强一致性？",
            options: [
                "推荐服务和分析报表",
                "金融交易和订单确认",
                "日志收集",
                "静态内容缓存",
            ],
            answer: 1,
            rationale: "Azure 文档指出强一致性场景包括金融交易、订单确认，而推荐服务和分析报表可以使用最终一致性。",
        },
        {
            id: "w4-1-q11",
            question: "事件驱动架构在 Database per Service 中的作用是什么？",
            options: [
                "替代数据库",
                "服务发布领域事件，其他服务订阅并构建物化视图",
                "直接同步数据库",
                "替代 API 调用",
            ],
            answer: 1,
            rationale: "Azure 描述事件驱动架构：服务发布领域事件，其他服务订阅事件，构建物化视图支持查询。",
        },
        {
            id: "w4-1-q12",
            question: "无人机交付系统案例中，投递服务选择 Redis 的原因是什么？",
            options: [
                "成本最低",
                "高读写吞吐量、实时状态查询、简单键值查询",
                "支持复杂 JOIN",
                "支持 ACID 事务",
            ],
            answer: 1,
            rationale: "Azure 案例解释投递服务选择 Redis 是因为需要高读写吞吐量、实时状态查询、简单键值查询。",
        },
    ],
    "w4-2": [
        {
            id: "w4-2-q1",
            question: "根据 microservices.io，Shared Database 模式的定义是什么？",
            options: [
                "每个服务有独立数据库",
                "多个服务共享单一数据库，使用本地 ACID 事务访问其他服务的数据",
                "数据库分片",
                "数据库集群",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'a (single) database that is shared by multiple services. Each service freely accesses data owned by other services using local ACID transactions'。",
        },
        {
            id: "w4-2-q2",
            question: "Shared Database 模式的主要优势是什么？",
            options: [
                "高扩展性",
                "使用熟悉的 ACID 事务强制数据一致性",
                "技术多样性",
                "完全解耦",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'Developers can use straightforward ACID transactions to enforce data consistency'。",
        },
        {
            id: "w4-2-q3",
            question: "什么是开发时耦合（Development time coupling）？",
            options: [
                "代码编译慢",
                "Schema 变更需要跨团队协调",
                "部署时间长",
                "测试复杂",
            ],
            answer: 1,
            rationale: "microservices.io 解释：'a developer working on OrderService will need to coordinate schema changes with developers of other services'。",
        },
        {
            id: "w4-2-q4",
            question: "什么是运行时耦合（Runtime coupling）？",
            options: [
                "服务启动慢",
                "服务可能相互阻塞，如长事务持有锁",
                "网络延迟高",
                "内存不足",
            ],
            answer: 1,
            rationale: "microservices.io 举例：'if long running CustomerService transaction holds a lock on the ORDER table then the OrderService will be blocked'。",
        },
        {
            id: "w4-2-q5",
            question: "为什么 Shared Database 限制了技术选型？",
            options: [
                "成本太高",
                "单一数据库可能无法满足所有服务的数据存储和访问需求",
                "技术太新",
                "学习曲线太陡",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'Single database might not satisfy the data storage and access requirements of all services'。",
        },
        {
            id: "w4-2-q6",
            question: "AWS 认为 Shared Database 适合什么场景？",
            options: [
                "大规模分布式系统",
                "从单体迁移到微服务的过渡期",
                "高并发系统",
                "实时系统",
            ],
            answer: 1,
            rationale: "AWS 指出 Shared Database 是从单体迁移到微服务的有效过渡模式——先拆分业务逻辑，再逐步拆分数据库。",
        },
        {
            id: "w4-2-q7",
            question: "Shared Database 的扩展性问题是什么？",
            options: [
                "扩展太容易",
                "共享数据库难以独立扩展，成为单点故障",
                "需要太多服务器",
                "网络带宽不足",
            ],
            answer: 1,
            rationale: "文档指出：'Microservices with shared databases can't easily scale. The database will be a single point of failure'。",
        },
        {
            id: "w4-2-q8",
            question: "从 Shared Database 迁移到 Database per Service 的建议步骤是什么？",
            options: [
                "一次性重写",
                "先拆分业务逻辑，再在共享数据库中逻辑分区表，最后拆分数据库",
                "只改数据库不改代码",
                "创建新系统替换",
            ],
            answer: 1,
            rationale: "AWS 建议：先拆分业务逻辑为独立微服务，在共享数据库中逻辑分区表，最后引入 Database per Service。",
        },
        {
            id: "w4-2-q9",
            question: "什么情况下选择 Shared Database 是合理的？",
            options: [
                "需要高度自治的大型系统",
                "小型系统、强一致性需求、不想大规模重构",
                "需要使用多种数据库技术",
                "团队规模很大",
            ],
            answer: 1,
            rationale: "文档指出 Shared Database 适合：小型系统、迁移过渡期、强一致性需求、不想大规模重构现有代码。",
        },
        {
            id: "w4-2-q10",
            question: "Shared Database 相比 Database per Service 的优势是什么？",
            options: [
                "更好的扩展性",
                "可以轻松执行复杂的 JOIN 查询",
                "技术多样性",
                "团队独立性",
            ],
            answer: 1,
            rationale: "文档指出 Shared Database 可以轻松执行复杂的 JOIN 查询，无需在服务间交换数据。",
        },
        {
            id: "w4-2-q11",
            question: "Database per Service 在什么场景下优于 Shared Database？",
            options: [
                "小型简单应用",
                "大规模应用，需要高服务自治和独立扩展",
                "强一致性要求",
                "团队很小",
            ],
            answer: 1,
            rationale: "文档指出 Database per Service 适合大规模应用，需要高服务自治、独立扩展、Polyglot Persistence。",
        },
        {
            id: "w4-2-q12",
            question: "Netflix 和 Amazon 使用什么数据库模式？",
            options: [
                "只使用 Shared Database",
                "Database per Service",
                "只使用 NoSQL",
                "不使用数据库",
            ],
            answer: 1,
            rationale: "文档提到 Netflix 和 Amazon 使用 Database per Service 模式，这在大规模微服务系统中很常见。",
        },
    ],
    "w4-3": [
        {
            id: "w4-3-q1",
            question: "API Composition 模式的核心思想是什么？",
            options: [
                "直接跨数据库查询",
                "调用拥有数据的服务并在内存中执行联接",
                "使用存储过程",
                "共享数据库视图",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Invoke the services that own the data and perform an in-memory join'。",
        },
        {
            id: "w4-3-q2",
            question: "API Composition 解决什么问题？",
            options: [
                "服务部署",
                "微服务架构中如何实现跨服务的数据查询",
                "服务监控",
                "服务安全",
            ],
            answer: 1,
            rationale: "microservices.io 指出该模式回答：'How to implement queries in a microservice architecture?'",
        },
        {
            id: "w4-3-q3",
            question: "API Gateway 在 API Composition 中扮演什么角色？",
            options: [
                "数据库代理",
                "通常充当 Composer，负责路由和组合请求到多个后端服务",
                "缓存服务器",
                "消息队列",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'An API gateway acts as single entry point, routing and composing requests to services'。",
        },
        {
            id: "w4-3-q4",
            question: "API Composition 的主要性能风险是什么？",
            options: [
                "网络延迟",
                "某些查询可能导致大数据集的低效内存联接",
                "CPU 使用率高",
                "磁盘 I/O 瓶颈",
            ],
            answer: 1,
            rationale: "microservices.io 警告：'Some queries would result in inefficient, in-memory joins of large datasets'。",
        },
        {
            id: "w4-3-q5",
            question: "Aggregator 模式的定义是什么？",
            options: [
                "简单的消息路由",
                "有状态过滤器，收集和存储消息直到收到完整的相关消息集",
                "消息加密",
                "消息压缩",
            ],
            answer: 1,
            rationale: "企业集成模式定义 Aggregator 为 'stateful filter that collects and stores individual messages until a complete set of related messages has been received'。",
        },
        {
            id: "w4-3-q6",
            question: "Aggregator 设计需要考虑的三个关键因素是什么？",
            options: [
                "性能、安全、可用性",
                "Correlation（关联）、Completeness Condition（完整性条件）、Aggregation Algorithm（聚合算法）",
                "延迟、吞吐量、错误率",
                "存储、计算、网络",
            ],
            answer: 1,
            rationale: "企业集成模式列出三个关键设计考虑：Correlation、Completeness Condition、Aggregation Algorithm。",
        },
        {
            id: "w4-3-q7",
            question: "'Wait for All' 完整性策略的特点是什么？",
            options: [
                "最快但不完整",
                "收集所有预期响应，最慢但最彻底",
                "只等待第一个响应",
                "随机选择响应",
            ],
            answer: 1,
            rationale: "企业集成模式描述 Wait for All 策略：'Collects every expected response; slowest but most thorough'。",
        },
        {
            id: "w4-3-q8",
            question: "什么情况下应该考虑使用 CQRS 替代 API Composition？",
            options: [
                "查询简单时",
                "复杂查询导致大数据集内存联接效率低下时",
                "服务数量少时",
                "数据量小时",
            ],
            answer: 1,
            rationale: "microservices.io 指出 CQRS 是 API Composition 的替代方案，适用于复杂查询场景。",
        },
        {
            id: "w4-3-q9",
            question: "'Time Out' 完整性策略适用于什么场景？",
            options: [
                "需要所有响应的场景",
                "处理在时间窗口内收到的响应，适用于竞价场景",
                "只需要一个响应",
                "不需要响应",
            ],
            answer: 1,
            rationale: "企业集成模式描述 Time Out 策略：'Processes responses received within a time window; useful for bidding scenarios'。",
        },
        {
            id: "w4-3-q10",
            question: "'First Best' 完整性策略的特点是什么？",
            options: [
                "等待所有响应",
                "处理最快的响应，优先考虑速度而非完整性",
                "等待最慢的响应",
                "随机选择",
            ],
            answer: 1,
            rationale: "企业集成模式描述 First Best 策略：'Acts on the fastest response; prioritizes speed over comprehensiveness'。",
        },
        {
            id: "w4-3-q11",
            question: "API Gateway 的核心职责包括什么？",
            options: [
                "只做负载均衡",
                "路由请求、组合响应、协议转换、安全验证",
                "只做缓存",
                "只做监控",
            ],
            answer: 1,
            rationale: "microservices.io 列出 API Gateway 的职责：routing, composition, protocol translation, security verification。",
        },
        {
            id: "w4-3-q12",
            question: "API Gateway 使用什么技术处理高负载？",
            options: [
                "同步阻塞 I/O",
                "事件驱动/响应式方法，如 NIO 库（Netty、Spring Reactor）",
                "多进程",
                "轮询",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'an event-driven/reactive approach is best if it must scale to handle high loads'，推荐 NIO 库。",
        },
    ],
    "w4-4": [
        {
            id: "w4-4-q1",
            question: "Command-side Replica 模式的目标是什么？",
            options: [
                "共享数据库",
                "在命令服务中维护可查询的数据副本",
                "删除数据",
                "压缩数据",
            ],
            answer: 1,
            rationale: "microservices.io 定义该模式的目标是 '维护服务中的可查询数据副本，该服务实现命令'。",
        },
        {
            id: "w4-4-q2",
            question: "该模式解决什么问题？",
            options: [
                "数据备份",
                "命令服务执行命令时依赖其他服务数据，同步调用增加延迟和耦合",
                "数据加密",
                "数据压缩",
            ],
            answer: 1,
            rationale: "microservices.io 指出问题：当服务执行命令但依赖其他服务的数据时，同步调用会增加延迟和耦合。",
        },
        {
            id: "w4-4-q3",
            question: "Command-side Replica 如何保持数据副本更新？",
            options: [
                "定期全量同步",
                "通过订阅提供者服务发布的领域事件",
                "直接访问源数据库",
                "手动更新",
            ],
            answer: 1,
            rationale: "microservices.io 描述：副本数据库 '通过订阅提供者服务发布的域事件来保持更新'。",
        },
        {
            id: "w4-4-q4",
            question: "订单服务使用该模式的典型案例是什么？",
            options: [
                "订单服务存储所有数据",
                "订单服务本地维护餐厅菜单副本，避免每次调用餐厅服务",
                "订单服务不需要外部数据",
                "订单服务直接修改餐厅数据",
            ],
            answer: 1,
            rationale: "microservices.io 举例：订单服务需要菜单数据进行验证和定价，通过维护本地副本避免每次查询远程服务。",
        },
        {
            id: "w4-4-q5",
            question: "Command-side Replica 与 CQRS 的关系是什么？",
            options: [
                "完全不同",
                "在结构上相同，都是通过事件驱动维护数据副本",
                "是 CQRS 的替代",
                "CQRS 不使用事件",
            ],
            answer: 1,
            rationale: "microservices.io 指出：该模式 '在结构上与 CQRS 相同'——都是通过事件驱动维护数据副本。",
        },
        {
            id: "w4-4-q6",
            question: "根据 Azure 文档，物化视图的定义是什么？",
            options: [
                "实时查询视图",
                "预先生成并存储格式化后的数据视图",
                "临时表",
                "索引表",
            ],
            answer: 1,
            rationale: "Azure 定义物化视图为 '预先生成并存储格式化后的数据视图，以支持高效的查询操作'。",
        },
        {
            id: "w4-4-q7",
            question: "物化视图的关键特点是什么？",
            options: [
                "必须与源数据同步",
                "完全可丢弃，可从源数据完全重建",
                "必须实时更新",
                "必须存储在同一数据库",
            ],
            answer: 1,
            rationale: "Azure 强调物化视图 '完全可丢弃（可从源数据完全重建）'，是专门的缓存。",
        },
        {
            id: "w4-4-q8",
            question: "物化视图的更新策略有哪些？",
            options: [
                "只有实时更新",
                "事件驱动、定时更新、手动更新",
                "只有手动更新",
                "只有批量更新",
            ],
            answer: 1,
            rationale: "Azure 列出三种更新策略：事件驱动（源数据变化时刷新）、定时更新（按计划刷新）、手动更新（显式触发）。",
        },
        {
            id: "w4-4-q9",
            question: "什么情况下不适合使用物化视图？",
            options: [
                "源数据复杂",
                "源数据变化频繁，数据一致性是首要优先级",
                "查询复杂",
                "数据量大",
            ],
            answer: 1,
            rationale: "Azure 指出不适用场景：源数据变化频繁（更新开销大）、数据一致性是首要优先级。",
        },
        {
            id: "w4-4-q10",
            question: "使用 Command-side Replica 的主要权衡是什么？",
            options: [
                "减少了复杂性",
                "减少运行时耦合但增加系统复杂性，需要接受最终一致性",
                "增加了耦合",
                "完全消除延迟",
            ],
            answer: 1,
            rationale: "microservices.io 指出：该模式减少运行时耦合和网络交互，但增加复杂性，命令服务需维护副本，提供者需发布事件。",
        },
        {
            id: "w4-4-q11",
            question: "物化视图可以存储在哪里？",
            options: [
                "必须与源数据在同一存储",
                "不必与源数据在同一存储，可使用不同数据库技术",
                "只能在内存中",
                "只能在同一服务器",
            ],
            answer: 1,
            rationale: "Azure 指出物化视图 '不必与源数据在同一存储或分区'，可以使用不同的数据库技术。",
        },
        {
            id: "w4-4-q12",
            question: "物化视图与 CQRS 和 Event Sourcing 的关系是什么？",
            options: [
                "没有关系",
                "CQRS 通过响应数据变化事件更新物化视图，与 Event Sourcing 结合维护视图",
                "互相替代",
                "不能一起使用",
            ],
            answer: 1,
            rationale: "Azure 指出相关模式：CQRS 通过响应数据变化事件更新物化视图，Event Sourcing 与 CQRS 结合维护视图。",
        },
    ],
}
