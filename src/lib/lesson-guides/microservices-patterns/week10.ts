import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week10Guides: Record<string, LessonGuide> = {
    "w10-1": {
        lessonId: "w10-1",
        background: [
            "【模式定义】microservices.io：Circuit Breaker 是防止 'network or service failure from cascading to other services' 的设计模式——防止故障级联。",
            "【三态模型】Fowler：Circuit Breaker 有三个状态——Closed（正常）、Open（熔断）、Half-Open（探测），通过状态转换控制请求流量。",
            "【工作原理】当连续失败超过阈值时熔断器 'trips'（跳闸），在超时期间立即拒绝所有请求，超时后允许少量测试请求。",
            "【解决问题】当远程服务不可用或延迟极高时，调用方可能浪费宝贵资源（如线程）等待响应，最终导致故障级联。",
            "【Netflix 实现】Netflix Hystrix 通过 `@HystrixCommand` 注解实现熔断器功能，现已被 Resilience4j 取代。",
        ],
        keyDifficulties: [
            "【超时配置】microservices.io：'Determining appropriate timeout values proves challenging'——配置超时值具有挑战性，可能导致误判或延迟增加。",
            "【阈值设置】Resilience4j：需要配置 failureRateThreshold（失败率阈值）和 slowCallRateThreshold（慢调用阈值）。",
            "【滑动窗口】Resilience4j 提供两种滑动窗口：Count-based（基于调用次数）和 Time-based（基于时间）。",
            "【Half-Open 策略】需要决定 permittedNumberOfCallsInHalfOpenState——探测阶段允许多少测试请求。",
            "【降级策略】熔断打开时需要提供 fallback 逻辑，返回缓存数据、默认值或友好错误。",
        ],
        handsOnPath: [
            "添加 Resilience4j 依赖：引入 resilience4j-circuitbreaker 模块。",
            "配置熔断器参数：设置失败率阈值、滑动窗口大小、等待时间。",
            "装饰远程调用：使用 CircuitBreaker.decorateFunction() 包装调用。",
            "实现 Fallback：定义熔断打开时的降级逻辑。",
            "添加监控：集成 Prometheus 或 Actuator 监控熔断器状态。",
            "测试状态转换：模拟故障，观察 Closed → Open → Half-Open → Closed 转换。",
        ],
        selfCheck: [
            "Circuit Breaker 模式的定义和目的是什么？",
            "熔断器的三个状态分别是什么？各状态的行为是什么？",
            "什么时候熔断器会从 Closed 转换到 Open？",
            "Half-Open 状态的作用是什么？",
            "Resilience4j 提供哪两种滑动窗口类型？",
            "熔断器打开时应该如何处理请求？",
        ],
        extensions: [
            "研究 Istio 的熔断器实现。",
            "探索 Spring Cloud Circuit Breaker 抽象层。",
            "学习熔断器与限流器的配合使用。",
            "了解分布式熔断器的挑战和解决方案。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/reliability/circuit-breaker.html",
            "https://martinfowler.com/bliki/CircuitBreaker.html",
            "https://resilience4j.readme.io/docs/circuitbreaker",
        ],
    },
    "w10-2": {
        lessonId: "w10-2",
        background: [
            "【Retry 定义】Azure：Retry 模式通过 'transparently retrying failed operations' 处理瞬态故障，提高应用稳定性。",
            "【瞬态故障】云环境中的瞬态故障（网络丢包、服务暂时不可用、超时）通常是短暂的，重试后可能成功。",
            "【三种策略】Cancel（取消，非瞬态故障）、Retry Immediately（立即重试，罕见故障）、Retry After Delay（延迟重试，常见故障）。",
            "【指数退避】AWS：Exponential Backoff 通过逐步增加重试间隔，避免多个客户端同时重试导致的 '惊群效应'。",
            "【Jitter（抖动）】AWS：在退避时间上添加随机抖动，进一步分散重试请求，减少碰撞。",
        ],
        keyDifficulties: [
            "【幂等性要求】Azure：'Ensure operations are idempotent'——重试可能多次执行操作，导致非预期的副作用。",
            "【超时级联】在多层调用中，需要协调各层超时设置，避免下层超时比上层长导致资源浪费。",
            "【何时不重试】Azure：长期故障、非瞬态故障（业务逻辑错误）、可扩展性问题不应使用重试。",
            "【重试层级】避免嵌套重试逻辑，'avoid nested retry logic with multiple layers'。",
            "【日志策略】Azure：早期失败记录为 informational，只记录最后一次重试失败为 error，避免告警泛滥。",
        ],
        handsOnPath: [
            "识别瞬态故障：区分可重试错误（网络超时、503）和不可重试错误（400、401）。",
            "配置 Retry 策略：设置最大重试次数、初始间隔、最大间隔。",
            "实现指数退避：每次重试间隔翻倍，如 1s → 2s → 4s → 8s。",
            "添加 Jitter：在退避时间上添加随机值，如 delay * (1 + random(0, 0.5))。",
            "配置超时：为每次调用设置合理的超时时间。",
            "测试重试逻辑：模拟瞬态故障，验证重试行为和指数退避。",
        ],
        selfCheck: [
            "Retry 模式的定义是什么？",
            "什么是瞬态故障？为什么可以重试？",
            "三种重试策略分别是什么？",
            "什么是指数退避？为什么需要它？",
            "什么是 Jitter？它解决什么问题？",
            "什么情况下不应该使用重试？",
        ],
        extensions: [
            "研究 Polly (.NET) 的重试策略实现。",
            "探索 Circuit Breaker 与 Retry 的配合。",
            "学习分布式系统中的超时设计原则。",
            "了解 HTTP 429 Too Many Requests 的处理策略。",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/retry",
            "https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/",
        ],
    },
    "w10-3": {
        lessonId: "w10-3",
        background: [
            "【模式定义】Azure：Bulkhead 模式将应用元素隔离到池中，'so that if one fails, the others continue to function'。",
            "【船舱隔板】名称来源于船舶设计——如果一个船舱进水，只有该舱被淹没，不会导致整船沉没。",
            "【解决问题】云应用中，一个服务的过载或故障可能耗尽共享资源，影响所有消费者。",
            "【隔离策略】Azure：根据消费者负载、可用性要求、业务和技术需求将服务实例和资源分区到隔离组。",
            "【Resilience4j 实现】提供两种 Bulkhead：SemaphoreBulkhead（信号量）和 FixedThreadPoolBulkhead（固定线程池）。",
        ],
        keyDifficulties: [
            "【资源效率】Azure：隔离可能导致资源利用效率降低，需要权衡隔离级别与成本。",
            "【复杂性增加】引入隔离增加了系统复杂性和管理开销。",
            "【信号量 vs 线程池】Resilience4j：SemaphoreBulkhead 更轻量但不提供线程池；ThreadPoolBulkhead 提供独立线程池但开销更大。",
            "【配置参数】需要配置 maxConcurrentCalls（最大并发）和 maxWaitDuration（最大等待时间）。",
            "【监控需求】需要监控每个隔离分区的性能和 SLA，确保资源分配合理。",
        ],
        handsOnPath: [
            "识别隔离边界：根据业务域和技术需求划分隔离组。",
            "选择隔离类型：选择 SemaphoreBulkhead 或 ThreadPoolBulkhead。",
            "配置参数：设置 maxConcurrentCalls、maxWaitDuration、queueCapacity。",
            "装饰调用：使用 Bulkhead.decorateCallable() 包装调用。",
            "处理拒绝：实现 BulkheadFullException 的处理逻辑。",
            "监控分区：集成监控系统跟踪每个 Bulkhead 的使用情况。",
        ],
        selfCheck: [
            "Bulkhead 模式的定义是什么？名称来源是什么？",
            "Bulkhead 解决什么问题？",
            "Resilience4j 提供哪两种 Bulkhead 实现？",
            "SemaphoreBulkhead 和 ThreadPoolBulkhead 的区别是什么？",
            "什么情况下不适合使用 Bulkhead？",
            "如何确定合理的隔离边界？",
        ],
        extensions: [
            "研究 Kubernetes 的资源限制（limits/requests）作为 Bulkhead。",
            "探索进程级隔离和容器级隔离。",
            "学习 Bulkhead 与 Circuit Breaker 的配合。",
            "了解服务网格中的隔离策略。",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/bulkhead",
            "https://resilience4j.readme.io/docs/bulkhead",
        ],
    },
    "w10-4": {
        lessonId: "w10-4",
        background: [
            "【Resilience4j 定义】Resilience4j 是 'a lightweight fault tolerance library designed for functional programming'——为函数式编程设计的轻量级容错库。",
            "【六大模块】Resilience4j 提供六个核心模块：CircuitBreaker、RateLimiter、Bulkhead、Retry、TimeLimiter、Cache。",
            "【函数式设计】使用高阶函数装饰函数接口、Lambda 表达式和方法引用，添加弹性能力。",
            "【模块化优势】开发者可以只选择需要的装饰器，而不是采用全套解决方案。",
            "【Hystrix 废弃】Netflix Hystrix 已停止维护，官方推荐迁移到 Resilience4j。",
        ],
        keyDifficulties: [
            "【装饰器顺序】多个装饰器组合时，顺序很重要：Retry(CircuitBreaker(Bulkhead(Function)))。",
            "【配置管理】每个模块有大量配置参数，需要根据业务场景调优。",
            "【Spring Boot 集成】使用 spring-boot-starter 时，配置方式与原生 API 有差异。",
            "【响应式支持】需要区分同步 API 和响应式 API（RxJava、Project Reactor）的使用方式。",
            "【监控集成】需要配置 Actuator 端点和 Prometheus 指标导出。",
        ],
        handsOnPath: [
            "添加依赖：引入 resilience4j-spring-boot3-starter 或核心模块。",
            "配置 CircuitBreaker：在 application.yml 中定义熔断器配置。",
            "配置 Retry：定义重试策略和退避算法。",
            "配置 Bulkhead：设置并发限制和队列大小。",
            "组合装饰器：使用 @CircuitBreaker @Retry @Bulkhead 注解组合。",
            "暴露监控端点：配置 Actuator 端点和 Prometheus 指标。",
        ],
        selfCheck: [
            "Resilience4j 的定义是什么？它与 Hystrix 的关系？",
            "Resilience4j 提供哪六个核心模块？",
            "如何组合多个弹性装饰器？顺序重要吗？",
            "Resilience4j 的函数式设计有什么优势？",
            "如何在 Spring Boot 中使用 Resilience4j？",
            "如何监控 Resilience4j 的运行状态？",
        ],
        extensions: [
            "研究 Resilience4j 的响应式支持。",
            "探索 Resilience4j 与 Feign 的集成。",
            "学习 Resilience4j 的自定义事件监听器。",
            "了解 Resilience4j 与 Spring Cloud Gateway 的集成。",
        ],
        sourceUrls: [
            "https://resilience4j.readme.io/docs/getting-started",
            "https://github.com/Netflix/Hystrix/wiki",
            "https://spring.io/projects/spring-cloud-circuitbreaker",
        ],
    },
}

export const week10Quizzes: Record<string, QuizQuestion[]> = {
    "w10-1": [
        {
            id: "w10-1-q1",
            question: "根据 microservices.io，Circuit Breaker 模式的目的是什么？",
            options: [
                "提高性能",
                "防止网络或服务故障级联到其他服务",
                "数据加密",
                "负载均衡",
            ],
            answer: 1,
            rationale: "microservices.io 定义：Circuit Breaker 防止 'network or service failure from cascading to other services'。",
        },
        {
            id: "w10-1-q2",
            question: "根据 Fowler，Circuit Breaker 有哪三个状态？",
            options: [
                "Start、Stop、Pause",
                "Closed、Open、Half-Open",
                "On、Off、Standby",
                "Active、Inactive、Pending",
            ],
            answer: 1,
            rationale: "Fowler 描述熔断器的三个状态：Closed（正常）、Open（熔断）、Half-Open（探测）。",
        },
        {
            id: "w10-1-q3",
            question: "在 Closed 状态下，熔断器的行为是什么？",
            options: [
                "拒绝所有请求",
                "正常传递请求，监控失败计数",
                "只允许部分请求",
                "随机拒绝请求",
            ],
            answer: 1,
            rationale: "Fowler：Closed 是正常状态，'calls pass through to the protected function'，同时监控失败率。",
        },
        {
            id: "w10-1-q4",
            question: "什么情况下熔断器从 Closed 转换到 Open？",
            options: [
                "定时转换",
                "连续失败超过阈值",
                "手动触发",
                "随机转换",
            ],
            answer: 1,
            rationale: "当连续失败超过配置的阈值时，熔断器 'trips'（跳闸）进入 Open 状态。",
        },
        {
            id: "w10-1-q5",
            question: "Half-Open 状态的作用是什么？",
            options: [
                "永久拒绝请求",
                "允许少量测试请求，探测服务是否恢复",
                "记录日志",
                "清除缓存",
            ],
            answer: 1,
            rationale: "Fowler：Half-Open 状态 'test whether the underlying service has recovered through trial calls'。",
        },
        {
            id: "w10-1-q6",
            question: "Resilience4j CircuitBreaker 提供哪两种滑动窗口类型？",
            options: [
                "固定窗口和滚动窗口",
                "Count-based（基于次数）和 Time-based（基于时间）",
                "同步窗口和异步窗口",
                "单一窗口和多重窗口",
            ],
            answer: 1,
            rationale: "Resilience4j 提供 Count-based（跟踪最近 N 次调用）和 Time-based（跟踪 N 秒内调用）两种滑动窗口。",
        },
        {
            id: "w10-1-q7",
            question: "Resilience4j 的 failureRateThreshold 默认值是多少？",
            options: [
                "25%",
                "50%",
                "75%",
                "100%",
            ],
            answer: 1,
            rationale: "Resilience4j 文档：failureRateThreshold 默认值为 50%，超过此阈值触发 Open 状态。",
        },
        {
            id: "w10-1-q8",
            question: "熔断器打开时应该如何处理请求？",
            options: [
                "无限等待",
                "立即失败并执行 fallback 逻辑",
                "转发到其他服务",
                "记录后丢弃",
            ],
            answer: 1,
            rationale: "熔断器打开时应立即失败（快速失败），并执行 fallback 逻辑返回缓存数据、默认值或友好错误。",
        },
        {
            id: "w10-1-q9",
            question: "配置熔断器超时值的主要挑战是什么？",
            options: [
                "技术限制",
                "可能导致误判或延迟增加",
                "成本太高",
                "不支持自定义",
            ],
            answer: 1,
            rationale: "microservices.io：'Determining appropriate timeout values proves challenging'，可能导致误判或延迟增加。",
        },
        {
            id: "w10-1-q10",
            question: "Resilience4j 的 waitDurationInOpenState 默认值是多少？",
            options: [
                "30 秒",
                "60 秒",
                "90 秒",
                "120 秒",
            ],
            answer: 1,
            rationale: "Resilience4j 文档：waitDurationInOpenState 默认值为 60,000ms（60 秒），Open 状态等待此时间后转 Half-Open。",
        },
        {
            id: "w10-1-q11",
            question: "Netflix 的熔断器实现叫什么？现在推荐什么替代？",
            options: [
                "Zuul，Spring Cloud Gateway",
                "Hystrix，Resilience4j",
                "Ribbon，LoadBalancer",
                "Eureka，Consul",
            ],
            answer: 1,
            rationale: "Netflix Hystrix 是著名的熔断器实现，已停止维护，官方推荐迁移到 Resilience4j。",
        },
        {
            id: "w10-1-q12",
            question: "什么是 slowCallRateThreshold？",
            options: [
                "失败率阈值",
                "慢调用占比阈值，超过则触发熔断",
                "并发数阈值",
                "队列长度阈值",
            ],
            answer: 1,
            rationale: "Resilience4j：slowCallRateThreshold 定义慢调用占比阈值，当慢调用比例超过此值时也会触发熔断。",
        },
    ],
    "w10-2": [
        {
            id: "w10-2-q1",
            question: "根据 Azure，Retry 模式的定义是什么？",
            options: [
                "永久重试失败操作",
                "透明地重试失败操作以处理瞬态故障",
                "只重试一次",
                "不重试任何操作",
            ],
            answer: 1,
            rationale: "Azure 定义：Retry 模式通过 'transparently retrying failed operations' 处理瞬态故障。",
        },
        {
            id: "w10-2-q2",
            question: "什么是瞬态故障？",
            options: [
                "永久性硬件故障",
                "短暂的、通常会自行恢复的故障，如网络丢包、超时",
                "软件 Bug",
                "配置错误",
            ],
            answer: 1,
            rationale: "瞬态故障是云环境中常见的短暂故障（网络丢包、服务暂时不可用、超时），通常会自行恢复。",
        },
        {
            id: "w10-2-q3",
            question: "Azure 描述的三种重试策略是什么？",
            options: [
                "快速、中速、慢速",
                "Cancel、Retry Immediately、Retry After Delay",
                "同步、异步、混合",
                "本地、远程、混合",
            ],
            answer: 1,
            rationale: "Azure 列出三种策略：Cancel（取消）、Retry Immediately（立即重试）、Retry After Delay（延迟重试）。",
        },
        {
            id: "w10-2-q4",
            question: "什么是指数退避（Exponential Backoff）？",
            options: [
                "每次重试间隔相同",
                "每次重试间隔逐步增加（如翻倍）",
                "随机间隔",
                "立即重试",
            ],
            answer: 1,
            rationale: "指数退避是每次重试间隔逐步增加的策略，如 1s → 2s → 4s → 8s，避免多客户端同时重试。",
        },
        {
            id: "w10-2-q5",
            question: "什么是 Jitter（抖动）？它解决什么问题？",
            options: [
                "固定延迟",
                "在退避时间上添加随机值，分散重试请求减少碰撞",
                "减少延迟",
                "增加吞吐量",
            ],
            answer: 1,
            rationale: "Jitter 在退避时间上添加随机抖动，进一步分散重试请求，减少多客户端同时重试导致的碰撞。",
        },
        {
            id: "w10-2-q6",
            question: "为什么重试操作必须是幂等的？",
            options: [
                "提高性能",
                "重试可能多次执行操作，非幂等操作会导致非预期副作用",
                "减少代码量",
                "简化测试",
            ],
            answer: 1,
            rationale: "Azure：'Ensure operations are idempotent'——重试可能多次执行操作，非幂等操作（如扣款）会导致副作用。",
        },
        {
            id: "w10-2-q7",
            question: "什么情况下不应该使用重试？",
            options: [
                "网络超时",
                "长期故障、非瞬态故障（业务逻辑错误）、可扩展性问题",
                "服务暂时不可用",
                "503 错误",
            ],
            answer: 1,
            rationale: "Azure：长期故障、非瞬态故障（内部逻辑错误）、可扩展性问题不应使用重试。",
        },
        {
            id: "w10-2-q8",
            question: "Azure 建议的日志策略是什么？",
            options: [
                "记录所有重试为错误",
                "早期失败记录为 informational，最后一次重试失败记录为 error",
                "不记录任何日志",
                "只记录成功",
            ],
            answer: 1,
            rationale: "Azure：'Log early failures as informational entries'，'Log only the failure of the last retry attempt as an actual error'。",
        },
        {
            id: "w10-2-q9",
            question: "为什么应该避免嵌套重试逻辑？",
            options: [
                "性能原因",
                "多层重试会导致重试次数指数增长",
                "代码更简单",
                "不支持嵌套",
            ],
            answer: 1,
            rationale: "Azure：'avoid nested retry logic with multiple layers'——嵌套重试会导致总重试次数指数增长。",
        },
        {
            id: "w10-2-q10",
            question: "Retry 模式应该与什么模式配合使用？",
            options: [
                "只能单独使用",
                "Circuit Breaker 模式，处理长期故障",
                "只能用数据库模式",
                "只能用缓存模式",
            ],
            answer: 1,
            rationale: "Azure：'Combine with Circuit Breaker pattern' for long-lasting failures——配合熔断器处理长期故障。",
        },
        {
            id: "w10-2-q11",
            question: "哪些框架提供了重试策略实现？",
            options: [
                "只有手工实现",
                "Polly (.NET)、Resilience4j (Java)",
                "只有数据库框架",
                "只有前端框架",
            ],
            answer: 1,
            rationale: "Azure 推荐：'Use frameworks like Polly (.NET) or Resilience4j (Java) instead of custom logic'。",
        },
        {
            id: "w10-2-q12",
            question: "HTTP 429 错误表示什么？应该如何处理？",
            options: [
                "服务器错误",
                "请求过多（限流），应根据 Retry-After 头延迟重试",
                "客户端错误",
                "网络错误",
            ],
            answer: 1,
            rationale: "HTTP 429 Too Many Requests 表示被限流，应根据 Retry-After 响应头延迟重试。",
        },
    ],
    "w10-3": [
        {
            id: "w10-3-q1",
            question: "根据 Azure，Bulkhead 模式的定义是什么？",
            options: [
                "合并所有资源",
                "将应用元素隔离到池中，一个失败其他继续运行",
                "共享所有资源",
                "删除失败组件",
            ],
            answer: 1,
            rationale: "Azure：Bulkhead 模式将应用元素隔离到池中，'so that if one fails, the others continue to function'。",
        },
        {
            id: "w10-3-q2",
            question: "Bulkhead 模式的名称来源是什么？",
            options: [
                "电路设计",
                "船舶设计——船舱隔板防止一个舱进水导致整船沉没",
                "建筑设计",
                "软件设计",
            ],
            answer: 1,
            rationale: "名称来源于船舶设计——如果一个船舱进水，隔板确保只有该舱被淹没，不会导致整船沉没。",
        },
        {
            id: "w10-3-q3",
            question: "Bulkhead 模式解决什么问题？",
            options: [
                "性能优化",
                "一个服务的过载或故障耗尽共享资源，影响所有消费者",
                "数据安全",
                "网络延迟",
            ],
            answer: 1,
            rationale: "云应用中，一个服务的过载或故障可能耗尽共享资源（如线程池），影响所有消费者。",
        },
        {
            id: "w10-3-q4",
            question: "Resilience4j 提供哪两种 Bulkhead 实现？",
            options: [
                "同步和异步 Bulkhead",
                "SemaphoreBulkhead 和 FixedThreadPoolBulkhead",
                "本地和远程 Bulkhead",
                "单线程和多线程 Bulkhead",
            ],
            answer: 1,
            rationale: "Resilience4j：'a SemaphoreBulkhead which uses Semaphores' 和 'a FixedThreadPoolBulkhead which uses a bounded queue and a fixed thread pool'。",
        },
        {
            id: "w10-3-q5",
            question: "SemaphoreBulkhead 的 maxConcurrentCalls 默认值是多少？",
            options: [
                "10",
                "25",
                "50",
                "100",
            ],
            answer: 1,
            rationale: "Resilience4j 文档：maxConcurrentCalls 的默认值为 25。",
        },
        {
            id: "w10-3-q6",
            question: "SemaphoreBulkhead 和 ThreadPoolBulkhead 的主要区别是什么？",
            options: [
                "没有区别",
                "SemaphoreBulkhead 更轻量但不提供线程池；ThreadPoolBulkhead 提供独立线程池",
                "功能相同但名称不同",
                "一个用于 Java，一个用于其他语言",
            ],
            answer: 1,
            rationale: "SemaphoreBulkhead 使用信号量控制并发，不提供线程池；ThreadPoolBulkhead 使用独立的固定线程池和有界队列。",
        },
        {
            id: "w10-3-q7",
            question: "什么情况下不适合使用 Bulkhead？",
            options: [
                "需要高可用",
                "资源效率下降不可接受、复杂性增加不合理时",
                "分布式系统",
                "微服务架构",
            ],
            answer: 1,
            rationale: "Azure：'Not suitable when: Resource inefficiency is unacceptable' 或 'Added complexity isn't justified'。",
        },
        {
            id: "w10-3-q8",
            question: "Azure 建议 Bulkhead 与哪些模式配合使用？",
            options: [
                "只能单独使用",
                "Retry、Circuit Breaker、Throttling",
                "只能用数据库模式",
                "只能用缓存模式",
            ],
            answer: 1,
            rationale: "Azure：'Combine with retry, circuit breaker, and throttling patterns'。",
        },
        {
            id: "w10-3-q9",
            question: "如何确定 Bulkhead 的隔离边界？",
            options: [
                "随机划分",
                "根据业务域、技术需求和有界上下文划分",
                "每个类一个隔离",
                "不需要划分",
            ],
            answer: 1,
            rationale: "Azure：'Define partitions around business/technical requirements and bounded contexts'。",
        },
        {
            id: "w10-3-q10",
            question: "Kubernetes 中如何实现 Bulkhead？",
            options: [
                "不支持",
                "通过 Pod 的 resources.limits 和 requests 限制 CPU 和内存",
                "只能用 Resilience4j",
                "需要额外插件",
            ],
            answer: 1,
            rationale: "Azure 示例：Kubernetes Pod 可以通过 resources.limits 和 requests 定义 CPU 和内存边界，实现资源隔离。",
        },
        {
            id: "w10-3-q11",
            question: "当 Bulkhead 满时会发生什么？",
            options: [
                "请求等待无限时间",
                "抛出 BulkheadFullException，请求被拒绝",
                "请求被转发",
                "请求被缓存",
            ],
            answer: 1,
            rationale: "当 Bulkhead 达到最大并发数且等待时间超过 maxWaitDuration 时，会抛出 BulkheadFullException。",
        },
        {
            id: "w10-3-q12",
            question: "Azure 建议监控 Bulkhead 的什么指标？",
            options: [
                "只监控错误",
                "每个隔离分区的性能和 SLA",
                "只监控成功",
                "不需要监控",
            ],
            answer: 1,
            rationale: "Azure：'Monitor each partition's performance and SLA'——监控每个隔离分区的性能和 SLA。",
        },
    ],
    "w10-4": [
        {
            id: "w10-4-q1",
            question: "Resilience4j 的定义是什么？",
            options: [
                "数据库框架",
                "为函数式编程设计的轻量级容错库",
                "消息队列",
                "服务发现框架",
            ],
            answer: 1,
            rationale: "Resilience4j 是 'a lightweight fault tolerance library designed for functional programming'。",
        },
        {
            id: "w10-4-q2",
            question: "Resilience4j 提供哪六个核心模块？",
            options: [
                "只有 CircuitBreaker",
                "CircuitBreaker、RateLimiter、Bulkhead、Retry、TimeLimiter、Cache",
                "只有 Retry 和 Bulkhead",
                "只有安全模块",
            ],
            answer: 1,
            rationale: "Resilience4j 提供六个核心模块：CircuitBreaker、RateLimiter、Bulkhead、Retry、TimeLimiter、Cache。",
        },
        {
            id: "w10-4-q3",
            question: "Resilience4j 需要什么 Java 版本？",
            options: [
                "Java 8",
                "Java 17 或更高",
                "Java 11",
                "任何版本",
            ],
            answer: 1,
            rationale: "Resilience4j 文档：'Resilience4j version 2 requires Java 17 or later'。",
        },
        {
            id: "w10-4-q4",
            question: "Resilience4j 的函数式设计有什么优势？",
            options: [
                "更慢",
                "使用高阶函数装饰，开发者可以只选择需要的装饰器",
                "更复杂",
                "只能用 Java",
            ],
            answer: 1,
            rationale: "Resilience4j 使用高阶函数装饰函数接口，开发者可以只选择需要的装饰器而非全套方案。",
        },
        {
            id: "w10-4-q5",
            question: "Netflix Hystrix 的现状是什么？",
            options: [
                "持续开发",
                "已停止维护，推荐迁移到 Resilience4j",
                "刚发布",
                "与 Resilience4j 合并",
            ],
            answer: 1,
            rationale: "Netflix Hystrix 已停止维护，官方推荐迁移到 Resilience4j。",
        },
        {
            id: "w10-4-q6",
            question: "多个装饰器组合时的正确顺序是什么？",
            options: [
                "顺序不重要",
                "Retry(CircuitBreaker(Bulkhead(Function)))——从外到内",
                "随机顺序",
                "按字母顺序",
            ],
            answer: 1,
            rationale: "装饰器顺序重要：Retry 在最外层，CircuitBreaker 在中间，Bulkhead 在最内层保护实际调用。",
        },
        {
            id: "w10-4-q7",
            question: "Resilience4j 的 TimeLimiter 模块用于什么？",
            options: [
                "限制调用次数",
                "对操作强制执行超时约束",
                "限制内存使用",
                "限制网络带宽",
            ],
            answer: 1,
            rationale: "Resilience4j：TimeLimiter 'Enforces timeout constraints on operations'——对操作强制执行超时约束。",
        },
        {
            id: "w10-4-q8",
            question: "Resilience4j 的 RateLimiter 模块用于什么？",
            options: [
                "熔断保护",
                "控制请求吞吐量，避免服务过载",
                "重试失败请求",
                "缓存结果",
            ],
            answer: 1,
            rationale: "Resilience4j：RateLimiter 'Controls request throughput to avoid overwhelming services'。",
        },
        {
            id: "w10-4-q9",
            question: "如何在 Spring Boot 中使用 Resilience4j？",
            options: [
                "只能用原生 API",
                "使用 spring-boot-starter 和 @CircuitBreaker 等注解",
                "不支持 Spring Boot",
                "需要自己实现",
            ],
            answer: 1,
            rationale: "Resilience4j 提供 Spring Boot starters，可以通过 @CircuitBreaker、@Retry 等注解使用。",
        },
        {
            id: "w10-4-q10",
            question: "Resilience4j 支持哪些响应式框架？",
            options: [
                "不支持响应式",
                "RxJava 2/3、Spring Reactor",
                "只支持同步",
                "只支持 RxJava",
            ],
            answer: 1,
            rationale: "Resilience4j 支持 'Reactive frameworks (RxJava 2/3, Spring Reactor)'。",
        },
        {
            id: "w10-4-q11",
            question: "如何监控 Resilience4j 的运行状态？",
            options: [
                "不支持监控",
                "集成 Actuator 端点和 Prometheus 指标",
                "只能手动检查",
                "只能用日志",
            ],
            answer: 1,
            rationale: "Resilience4j 可以集成 Spring Boot Actuator 暴露端点，并导出 Prometheus 指标进行监控。",
        },
        {
            id: "w10-4-q12",
            question: "Resilience4j 与 Hystrix 相比的主要优势是什么？",
            options: [
                "功能更少",
                "轻量、模块化、函数式设计、活跃维护",
                "更复杂",
                "只支持 Java 8",
            ],
            answer: 1,
            rationale: "Resilience4j 比 Hystrix 更轻量、模块化，采用函数式设计，且仍在活跃维护中。",
        },
    ],
}
