import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week9Guides: Record<string, LessonGuide> = {
    "w9-1": {
        lessonId: "w9-1",
        background: [
            "【模式定义】microservices.io：Service Registry 是 'a database of services, their instances and their locations'——服务、实例及其位置的数据库。",
            "【核心功能】提供管理 API 供服务实例注册和注销，提供查询 API 供客户端发现可用服务实例。",
            "【实现技术】常见实现包括：Consul（HashiCorp）、Eureka（Netflix）、etcd、Zookeeper、Kubernetes DNS/API。",
            "【Consul 特点】HashiCorp Consul 提供多数据中心支持、健康检查、KV 存储、服务网格能力，使用 Gossip 协议和 Raft 共识。",
            "【Kubernetes 方式】Kubernetes 使用内置的 Service 资源和 DNS 实现服务发现，无需独立的 Service Registry。",
        ],
        keyDifficulties: [
            "【高可用要求】microservices.io：Service Registry 必须高可用，否则整个系统无法正常运行。",
            "【一致性挑战】分布式注册表需要处理网络分区、节点故障等问题，通常使用 Raft 或 Gossip 协议。",
            "【健康检查】Consul 提供多种健康检查方式：HTTP、gRPC、TCP、Script、Docker、TTL——需要根据服务特点选择。",
            "【服务元数据】除了地址和端口，还需要管理服务版本、标签、权重等元数据。",
            "【安全性】Consul 支持 ACL 和 mTLS，在生产环境中必须配置访问控制。",
        ],
        handsOnPath: [
            "部署 Service Registry：选择 Consul 或 Eureka，使用 Docker 快速部署。",
            "配置健康检查：为服务定义 HTTP 或 TCP 健康检查。",
            "注册服务实例：通过 API 或配置文件注册服务。",
            "查询服务：使用 DNS 或 HTTP API 查询可用实例。",
            "测试故障转移：模拟实例故障，观察注册表的响应。",
            "配置安全：启用 ACL 和 TLS 保护注册表访问。",
        ],
        selfCheck: [
            "Service Registry 的定义和核心功能是什么？",
            "常见的 Service Registry 实现有哪些？",
            "Consul 提供哪些健康检查方式？",
            "为什么 Service Registry 必须高可用？",
            "Kubernetes 如何实现服务发现？",
            "Service Registry 需要存储哪些信息？",
        ],
        extensions: [
            "研究 Consul Connect 的服务网格能力。",
            "探索多数据中心服务发现的实现。",
            "学习 etcd 在 Kubernetes 中的角色。",
            "了解服务发现与负载均衡的结合。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/service-registry.html",
            "https://developer.hashicorp.com/consul/docs/concepts/service-discovery",
            "https://github.com/Netflix/eureka/wiki",
        ],
    },
    "w9-2": {
        lessonId: "w9-2",
        background: [
            "【模式定义】microservices.io：Client-side Discovery 中，'the client queries a service registry to obtain a list of service instance locations'——客户端查询注册表获取服务实例列表。",
            "【工作流程】客户端直接查询 Service Registry，获取可用实例列表，然后使用负载均衡算法选择一个实例发送请求。",
            "【核心优势】相对简单直接，'relatively straightforward'，客户端可以做出智能、应用特定的负载均衡决策。",
            "【实现示例】Netflix OSS 提供了完整实现：Eureka（Service Registry）+ Ribbon（客户端负载均衡器）。",
            "【gRPC 支持】gRPC 内置客户端负载均衡支持，可以直接与 Service Registry 集成。",
        ],
        keyDifficulties: [
            "【客户端耦合】microservices.io：'Couples the client to the Service Registry'——客户端需要了解和集成注册表。",
            "【多语言挑战】需要为每种客户端语言/框架实现服务发现逻辑：'Must implement client-side service discovery logic for each language/framework'。",
            "【负载均衡策略】客户端需要实现负载均衡算法：轮询、随机、加权、最少连接等。",
            "【缓存一致性】客户端缓存服务实例列表可能导致访问已下线实例。",
            "【健康感知】客户端需要处理请求失败并更新本地缓存。",
        ],
        handsOnPath: [
            "集成 Service Registry 客户端：在服务中添加 Consul 或 Eureka 客户端依赖。",
            "实现服务查询：调用注册表 API 获取服务实例列表。",
            "实现负载均衡：选择并实现负载均衡算法。",
            "配置缓存策略：设置实例列表的缓存时间和刷新机制。",
            "处理故障转移：实现请求失败后的重试和实例切换。",
            "测试发现流程：验证服务上下线时客户端的响应。",
        ],
        selfCheck: [
            "Client-side Discovery 模式的定义是什么？",
            "客户端发现的工作流程是怎样的？",
            "Client-side Discovery 的主要优势是什么？",
            "Client-side Discovery 的主要劣势是什么？",
            "Netflix OSS 提供了哪些组件实现客户端发现？",
            "为什么需要为每种语言实现发现逻辑？",
        ],
        extensions: [
            "研究 Spring Cloud LoadBalancer 的实现。",
            "探索 gRPC 的客户端负载均衡机制。",
            "学习 Envoy 的服务发现集成。",
            "了解客户端发现在 Service Mesh 中的演变。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/client-side-discovery.html",
            "https://spring.io/guides/gs/spring-cloud-loadbalancer/",
            "https://grpc.io/blog/grpc-load-balancing/",
        ],
    },
    "w9-3": {
        lessonId: "w9-3",
        background: [
            "【模式定义】microservices.io：Server-side Discovery 中，'the client makes a request to a router, which queries the service registry and load balances requests'——客户端请求路由器，由路由器查询注册表并负载均衡。",
            "【核心组件】需要一个路由器（或负载均衡器）作为中间层，客户端只需知道路由器地址。",
            "【Kubernetes 实现】Kubernetes 是典型的 Server-side Discovery：'Kubernetes has a built-in Service Registry and service discovery mechanism'。",
            "【kube-proxy】Kubernetes 每个节点运行 kube-proxy，通过 iptables 或 IPVS 规则将请求路由到后端 Pod。",
            "【DNS 发现】Kubernetes 为每个 Service 创建 DNS 记录，格式为 <service-name>.<namespace>.svc.cluster.local。",
        ],
        keyDifficulties: [
            "【额外组件】microservices.io：'Router must be highly available'——路由器本身必须高可用，增加了系统复杂性。",
            "【网络跳数】请求需要经过路由器，增加了网络跳数和延迟。",
            "【路由器能力】路由器必须支持所有需要的通信协议（HTTP、gRPC、WebSocket 等）。",
            "【Service 类型】Kubernetes 提供多种 Service 类型：ClusterIP、NodePort、LoadBalancer、ExternalName。",
            "【无头服务】Headless Service（clusterIP: None）允许客户端直接发现 Pod IP，绕过负载均衡。",
        ],
        handsOnPath: [
            "创建 Kubernetes Service：定义 ClusterIP 类型的 Service 暴露 Deployment。",
            "验证 DNS 发现：在 Pod 内使用 nslookup 查询 Service DNS。",
            "测试负载均衡：发送多个请求，观察请求分发到不同 Pod。",
            "配置 NodePort：创建 NodePort Service 允许外部访问。",
            "使用 Headless Service：创建无头服务实现客户端负载均衡。",
            "配置 Ingress：使用 Ingress Controller 实现 HTTP 路由。",
        ],
        selfCheck: [
            "Server-side Discovery 模式的定义是什么？",
            "Server-side Discovery 的核心组件是什么？",
            "Kubernetes 如何实现服务发现？",
            "Server-side Discovery 相比 Client-side 的优势是什么？",
            "Kubernetes Service 有哪几种类型？",
            "什么是 Headless Service？什么场景使用？",
        ],
        extensions: [
            "研究 Kubernetes Ingress 和 Gateway API。",
            "探索 Service Mesh（Istio）的服务发现。",
            "学习 AWS ECS 的服务发现机制。",
            "了解 kube-proxy 的 iptables 和 IPVS 模式。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/server-side-discovery.html",
            "https://kubernetes.io/docs/concepts/services-networking/service/",
            "https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html",
        ],
    },
    "w9-4": {
        lessonId: "w9-4",
        background: [
            "【Self Registration 定义】microservices.io：'A service instance registers itself with the service registry on startup and deregisters on shutdown'——实例启动时自注册，关闭时注销。",
            "【3rd Party Registration 定义】'A 3rd party registrar registers and deregisters service instances with the service registry'——第三方注册器管理实例的注册和注销。",
            "【Self Registration 优势】简单直接，不需要额外组件：'relatively simple and doesn't require any other system components'。",
            "【3rd Party Registration 优势】服务与注册表解耦：'Services are decoupled from the Service Registry'，服务代码更简洁。",
            "【平台支持】Kubernetes 和 Marathon 等平台内置第三方注册能力，自动管理服务实例的注册。",
        ],
        keyDifficulties: [
            "【Self Registration 耦合】microservices.io：'Couples the service to the Service Registry'——服务必须实现注册逻辑。",
            "【Self Registration 多语言】需要为每种语言实现注册逻辑：'Must implement registration logic for each language/framework'。",
            "【心跳机制】Self Registration 通常需要心跳机制维持注册状态，处理不当可能导致僵尸实例。",
            "【3rd Party Registration 复杂性】需要部署和管理额外的注册器组件：'Yet another component to setup and manage'。",
            "【故障检测】第三方注册器需要可靠地检测实例故障，及时注销失效实例。",
        ],
        handsOnPath: [
            "实现 Self Registration：在服务启动时调用注册表 API 注册实例。",
            "实现心跳机制：定期发送心跳或更新 TTL。",
            "实现优雅关闭：在服务关闭时注销实例。",
            "部署 Registrator：使用 Registrator 自动注册 Docker 容器。",
            "配置 Kubernetes：使用 Kubernetes 内置的服务发现机制。",
            "测试故障场景：模拟实例崩溃，验证注销行为。",
        ],
        selfCheck: [
            "Self Registration 模式的定义是什么？",
            "3rd Party Registration 模式的定义是什么？",
            "Self Registration 的优势和劣势是什么？",
            "3rd Party Registration 的优势和劣势是什么？",
            "什么情况下选择 Self Registration？",
            "什么情况下选择 3rd Party Registration？",
        ],
        extensions: [
            "研究 Registrator 的实现和配置。",
            "探索 Kubernetes Operator 模式与服务注册。",
            "学习服务网格中的自动注册机制。",
            "了解 Consul 的 sidecar 代理注册模式。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/self-registration.html",
            "https://microservices.io/patterns/3rd-party-registration.html",
            "https://istio.io/latest/docs/concepts/traffic-management/",
        ],
    },
}

export const week9Quizzes: Record<string, QuizQuestion[]> = {
    "w9-1": [
        {
            id: "w9-1-q1",
            question: "根据 microservices.io，Service Registry 的定义是什么？",
            options: [
                "负载均衡器",
                "服务、实例及其位置的数据库",
                "消息队列",
                "API 网关",
            ],
            answer: 1,
            rationale: "microservices.io 定义 Service Registry 为 'a database of services, their instances and their locations'。",
        },
        {
            id: "w9-1-q2",
            question: "Service Registry 提供哪两种核心 API？",
            options: [
                "读取和写入 API",
                "管理 API（注册/注销）和查询 API（发现实例）",
                "同步和异步 API",
                "内部和外部 API",
            ],
            answer: 1,
            rationale: "microservices.io 指出：提供管理 API 供服务注册和注销，提供查询 API 供客户端发现可用服务实例。",
        },
        {
            id: "w9-1-q3",
            question: "以下哪个不是常见的 Service Registry 实现？",
            options: [
                "Consul",
                "Eureka",
                "Kafka",
                "etcd",
            ],
            answer: 2,
            rationale: "Kafka 是消息队列，不是 Service Registry。常见实现包括 Consul、Eureka、etcd、Zookeeper。",
        },
        {
            id: "w9-1-q4",
            question: "为什么 Service Registry 必须高可用？",
            options: [
                "提高性能",
                "如果注册表不可用，整个系统无法正常运行",
                "减少成本",
                "简化部署",
            ],
            answer: 1,
            rationale: "microservices.io 指出 Service Registry 必须高可用，否则服务发现失败会导致整个系统无法正常运行。",
        },
        {
            id: "w9-1-q5",
            question: "Consul 提供哪些健康检查方式？",
            options: [
                "只有 HTTP",
                "HTTP、gRPC、TCP、Script、Docker、TTL",
                "只有 TCP",
                "只有心跳",
            ],
            answer: 1,
            rationale: "Consul 文档列出多种健康检查方式：HTTP、gRPC、TCP、Script、Docker、TTL。",
        },
        {
            id: "w9-1-q6",
            question: "Consul 使用什么协议实现分布式共识？",
            options: [
                "Paxos",
                "Raft",
                "2PC",
                "Gossip",
            ],
            answer: 1,
            rationale: "Consul 使用 Raft 共识协议确保数据一致性和 leader 选举。",
        },
        {
            id: "w9-1-q7",
            question: "Kubernetes 如何实现服务发现？",
            options: [
                "需要独立的 Service Registry",
                "使用内置的 Service 资源和 DNS",
                "不支持服务发现",
                "只能用 Consul",
            ],
            answer: 1,
            rationale: "Kubernetes 使用内置的 Service 资源和 DNS 实现服务发现，无需独立的 Service Registry。",
        },
        {
            id: "w9-1-q8",
            question: "Service Registry 需要存储哪些信息？",
            options: [
                "只有服务名称",
                "服务名称、实例地址、端口、健康状态、元数据",
                "只有 IP 地址",
                "只有端口",
            ],
            answer: 1,
            rationale: "Service Registry 存储服务实例的完整信息：名称、地址、端口、健康状态、版本、标签等元数据。",
        },
        {
            id: "w9-1-q9",
            question: "Consul 使用什么协议进行成员管理和故障检测？",
            options: [
                "HTTP",
                "Gossip",
                "gRPC",
                "REST",
            ],
            answer: 1,
            rationale: "Consul 使用 Gossip 协议（基于 SWIM）进行成员管理、故障检测和事件广播。",
        },
        {
            id: "w9-1-q10",
            question: "Netflix Eureka 主要用于什么场景？",
            options: [
                "消息队列",
                "微服务的服务发现和注册",
                "数据库",
                "日志聚合",
            ],
            answer: 1,
            rationale: "Netflix Eureka 是专门为微服务设计的服务发现和注册中心，是 Netflix OSS 的核心组件。",
        },
        {
            id: "w9-1-q11",
            question: "Consul 的安全特性包括哪些？",
            options: [
                "不支持安全",
                "ACL（访问控制列表）和 mTLS",
                "只有密码",
                "只有防火墙",
            ],
            answer: 1,
            rationale: "Consul 支持 ACL 进行访问控制，支持 mTLS 加密服务间通信。",
        },
        {
            id: "w9-1-q12",
            question: "Service Registry 与 API Gateway 的区别是什么？",
            options: [
                "没有区别",
                "Registry 存储服务位置信息，Gateway 是请求入口和路由",
                "Registry 更快",
                "Gateway 存储更多信息",
            ],
            answer: 1,
            rationale: "Service Registry 是服务位置信息的数据库，API Gateway 是统一入口处理路由、认证等。两者功能不同但常配合使用。",
        },
    ],
    "w9-2": [
        {
            id: "w9-2-q1",
            question: "根据 microservices.io，Client-side Discovery 模式的定义是什么？",
            options: [
                "服务端查询注册表",
                "客户端查询 Service Registry 获取服务实例列表",
                "使用 DNS 发现",
                "不需要注册表",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'the client queries a service registry to obtain a list of service instance locations'。",
        },
        {
            id: "w9-2-q2",
            question: "Client-side Discovery 的工作流程是什么？",
            options: [
                "客户端直接访问服务",
                "客户端查询注册表 → 获取实例列表 → 负载均衡选择实例 → 发送请求",
                "服务端选择实例",
                "DNS 解析",
            ],
            answer: 1,
            rationale: "客户端直接查询 Service Registry，获取可用实例列表，然后使用负载均衡算法选择一个实例发送请求。",
        },
        {
            id: "w9-2-q3",
            question: "Client-side Discovery 的主要优势是什么？",
            options: [
                "实现复杂",
                "相对简单直接，客户端可做出智能的负载均衡决策",
                "需要额外组件",
                "增加网络跳数",
            ],
            answer: 1,
            rationale: "microservices.io 指出优势：'relatively straightforward'，客户端可以做出智能、应用特定的负载均衡决策。",
        },
        {
            id: "w9-2-q4",
            question: "Client-side Discovery 的主要劣势是什么？",
            options: [
                "性能差",
                "客户端与 Service Registry 耦合，需要为每种语言实现发现逻辑",
                "不支持负载均衡",
                "只支持 HTTP",
            ],
            answer: 1,
            rationale: "microservices.io 指出劣势：'Couples the client to the Service Registry' 和 'Must implement client-side service discovery logic for each language/framework'。",
        },
        {
            id: "w9-2-q5",
            question: "Netflix OSS 提供了哪些组件实现客户端发现？",
            options: [
                "Kafka 和 Zookeeper",
                "Eureka（注册表）和 Ribbon（负载均衡器）",
                "Consul 和 Envoy",
                "etcd 和 HAProxy",
            ],
            answer: 1,
            rationale: "Netflix OSS 提供 Eureka 作为 Service Registry，Ribbon 作为客户端负载均衡器。",
        },
        {
            id: "w9-2-q6",
            question: "客户端负载均衡通常使用哪些算法？",
            options: [
                "只有随机",
                "轮询、随机、加权、最少连接等",
                "只有轮询",
                "不需要算法",
            ],
            answer: 1,
            rationale: "常见的负载均衡算法包括：轮询（Round Robin）、随机（Random）、加权（Weighted）、最少连接（Least Connections）等。",
        },
        {
            id: "w9-2-q7",
            question: "gRPC 如何支持客户端负载均衡？",
            options: [
                "不支持",
                "内置客户端负载均衡支持，可与 Service Registry 集成",
                "只能用服务端负载均衡",
                "需要单独的代理",
            ],
            answer: 1,
            rationale: "gRPC 内置客户端负载均衡支持，可以直接与 Service Registry 或名称解析服务集成。",
        },
        {
            id: "w9-2-q8",
            question: "为什么客户端需要缓存服务实例列表？",
            options: [
                "不需要缓存",
                "减少对注册表的查询次数，提高性能",
                "只是为了备份",
                "法规要求",
            ],
            answer: 1,
            rationale: "缓存服务实例列表可以减少对注册表的查询次数，提高服务发现性能，但需要处理缓存一致性问题。",
        },
        {
            id: "w9-2-q9",
            question: "客户端缓存可能导致什么问题？",
            options: [
                "性能提升",
                "访问已下线实例",
                "更快响应",
                "减少错误",
            ],
            answer: 1,
            rationale: "客户端缓存服务实例列表可能导致访问已下线实例，需要设置合理的缓存过期时间和刷新机制。",
        },
        {
            id: "w9-2-q10",
            question: "Spring Cloud LoadBalancer 是什么？",
            options: [
                "服务端负载均衡器",
                "Spring 提供的客户端负载均衡库，替代 Ribbon",
                "数据库连接池",
                "消息队列",
            ],
            answer: 1,
            rationale: "Spring Cloud LoadBalancer 是 Spring 提供的客户端负载均衡库，用于替代已废弃的 Netflix Ribbon。",
        },
        {
            id: "w9-2-q11",
            question: "Client-side Discovery 与哪些模式相关？",
            options: [
                "只有数据库模式",
                "Service Registry、Self Registration、3rd Party Registration",
                "只有安全模式",
                "只有部署模式",
            ],
            answer: 1,
            rationale: "microservices.io 指出 Client-side Discovery 与 Service Registry、Self Registration、3rd Party Registration 模式相关。",
        },
        {
            id: "w9-2-q12",
            question: "客户端请求失败时应该如何处理？",
            options: [
                "直接报错",
                "重试其他实例并更新本地缓存",
                "等待恢复",
                "重启客户端",
            ],
            answer: 1,
            rationale: "客户端需要处理请求失败，通常的做法是重试其他实例，并更新本地缓存移除失效实例。",
        },
    ],
    "w9-3": [
        {
            id: "w9-3-q1",
            question: "根据 microservices.io，Server-side Discovery 模式的定义是什么？",
            options: [
                "客户端直接查询注册表",
                "客户端请求路由器，由路由器查询注册表并负载均衡",
                "使用 DNS 发现",
                "不需要注册表",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'the client makes a request to a router, which queries the service registry and load balances requests'。",
        },
        {
            id: "w9-3-q2",
            question: "Server-side Discovery 的核心组件是什么？",
            options: [
                "客户端库",
                "路由器或负载均衡器作为中间层",
                "只需要 DNS",
                "不需要额外组件",
            ],
            answer: 1,
            rationale: "Server-side Discovery 需要一个路由器（或负载均衡器）作为中间层，客户端只需知道路由器地址。",
        },
        {
            id: "w9-3-q3",
            question: "Server-side Discovery 相比 Client-side 的主要优势是什么？",
            options: [
                "性能更高",
                "客户端更简单，无需实现发现逻辑",
                "成本更低",
                "延迟更低",
            ],
            answer: 1,
            rationale: "microservices.io 指出优势：'Simpler client since it doesn't have to deal with discovery'，客户端代码更简洁。",
        },
        {
            id: "w9-3-q4",
            question: "Kubernetes 使用什么实现服务发现？",
            options: [
                "独立的 Consul",
                "内置的 Service 资源和 DNS",
                "独立的 Eureka",
                "只能用客户端发现",
            ],
            answer: 1,
            rationale: "Kubernetes 文档指出：'Kubernetes has a built-in Service Registry and service discovery mechanism'。",
        },
        {
            id: "w9-3-q5",
            question: "Kubernetes Service 的 DNS 格式是什么？",
            options: [
                "<service>.<cluster>",
                "<service-name>.<namespace>.svc.cluster.local",
                "<pod-ip>.<namespace>",
                "<node>.<service>",
            ],
            answer: 1,
            rationale: "Kubernetes 为每个 Service 创建 DNS 记录，格式为 <service-name>.<namespace>.svc.cluster.local。",
        },
        {
            id: "w9-3-q6",
            question: "Kubernetes 提供哪几种 Service 类型？",
            options: [
                "只有 ClusterIP",
                "ClusterIP、NodePort、LoadBalancer、ExternalName",
                "只有 LoadBalancer",
                "只有 NodePort",
            ],
            answer: 1,
            rationale: "Kubernetes 提供四种 Service 类型：ClusterIP（默认）、NodePort、LoadBalancer、ExternalName。",
        },
        {
            id: "w9-3-q7",
            question: "什么是 Headless Service？",
            options: [
                "没有名称的服务",
                "clusterIP 设置为 None，允许客户端直接发现 Pod IP",
                "只有一个 Pod 的服务",
                "没有端口的服务",
            ],
            answer: 1,
            rationale: "Headless Service（clusterIP: None）允许客户端直接发现 Pod IP，绕过 kube-proxy 的负载均衡。",
        },
        {
            id: "w9-3-q8",
            question: "kube-proxy 使用什么技术实现负载均衡？",
            options: [
                "HAProxy",
                "iptables 或 IPVS 规则",
                "Nginx",
                "Envoy",
            ],
            answer: 1,
            rationale: "kube-proxy 通过 iptables 或 IPVS（IP Virtual Server）规则将请求路由到后端 Pod。",
        },
        {
            id: "w9-3-q9",
            question: "Server-side Discovery 的主要劣势是什么？",
            options: [
                "客户端太复杂",
                "路由器必须高可用，增加网络跳数",
                "不支持多语言",
                "只能用 HTTP",
            ],
            answer: 1,
            rationale: "microservices.io 指出劣势：'Router must be highly available'，并且请求需要经过路由器增加网络跳数。",
        },
        {
            id: "w9-3-q10",
            question: "ClusterIP 类型的 Service 有什么特点？",
            options: [
                "外部可访问",
                "只在集群内部可访问，是默认类型",
                "不分配 IP",
                "每个节点一个 IP",
            ],
            answer: 1,
            rationale: "ClusterIP 是 Kubernetes Service 的默认类型，只在集群内部可访问，适合内部服务通信。",
        },
        {
            id: "w9-3-q11",
            question: "NodePort Service 的作用是什么？",
            options: [
                "只在集群内访问",
                "在每个节点上开放端口，允许外部通过节点 IP 访问服务",
                "不分配端口",
                "只用于数据库",
            ],
            answer: 1,
            rationale: "NodePort Service 在每个节点上开放一个端口（30000-32767），允许外部通过 <节点IP>:<NodePort> 访问服务。",
        },
        {
            id: "w9-3-q12",
            question: "什么情况下使用 Headless Service？",
            options: [
                "所有情况",
                "需要客户端直接访问 Pod IP，如 StatefulSet 或客户端负载均衡",
                "不需要服务发现",
                "只有外部服务",
            ],
            answer: 1,
            rationale: "Headless Service 适用于需要客户端直接访问 Pod IP 的场景，如 StatefulSet 的有状态应用或实现客户端负载均衡。",
        },
    ],
    "w9-4": [
        {
            id: "w9-4-q1",
            question: "根据 microservices.io，Self Registration 模式的定义是什么？",
            options: [
                "第三方注册服务",
                "服务实例在启动时自注册，关闭时注销",
                "平台自动注册",
                "DNS 注册",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'A service instance registers itself with the service registry on startup and deregisters on shutdown'。",
        },
        {
            id: "w9-4-q2",
            question: "根据 microservices.io，3rd Party Registration 模式的定义是什么？",
            options: [
                "服务自己注册",
                "第三方注册器管理服务实例的注册和注销",
                "DNS 自动注册",
                "不需要注册",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'A 3rd party registrar registers and deregisters service instances with the service registry'。",
        },
        {
            id: "w9-4-q3",
            question: "Self Registration 的主要优势是什么？",
            options: [
                "需要额外组件",
                "简单直接，不需要额外系统组件",
                "服务更复杂",
                "需要平台支持",
            ],
            answer: 1,
            rationale: "microservices.io 指出优势：'relatively simple and doesn't require any other system components'。",
        },
        {
            id: "w9-4-q4",
            question: "Self Registration 的主要劣势是什么？",
            options: [
                "太简单",
                "服务与注册表耦合，需要为每种语言实现注册逻辑",
                "性能差",
                "不支持心跳",
            ],
            answer: 1,
            rationale: "microservices.io 指出劣势：'Couples the service to the Service Registry' 和 'Must implement registration logic for each language/framework'。",
        },
        {
            id: "w9-4-q5",
            question: "3rd Party Registration 的主要优势是什么？",
            options: [
                "服务更复杂",
                "服务与注册表解耦，服务代码更简洁",
                "需要更多代码",
                "延迟更高",
            ],
            answer: 1,
            rationale: "microservices.io 指出优势：'Services are decoupled from the Service Registry'，服务代码更简洁。",
        },
        {
            id: "w9-4-q6",
            question: "3rd Party Registration 的主要劣势是什么？",
            options: [
                "服务太复杂",
                "需要部署和管理额外的注册器组件",
                "不支持自动注销",
                "只能用 Java",
            ],
            answer: 1,
            rationale: "microservices.io 指出劣势：'Yet another component to setup and manage'。",
        },
        {
            id: "w9-4-q7",
            question: "Self Registration 通常使用什么机制维持注册状态？",
            options: [
                "轮询",
                "心跳机制或 TTL",
                "长连接",
                "不需要维持",
            ],
            answer: 1,
            rationale: "Self Registration 通常需要心跳机制或 TTL（Time To Live）来维持注册状态，确保注册表中的信息是最新的。",
        },
        {
            id: "w9-4-q8",
            question: "哪些平台内置了第三方注册能力？",
            options: [
                "没有平台支持",
                "Kubernetes 和 Marathon 等容器平台",
                "只有 AWS",
                "只有虚拟机",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'Kubernetes and Marathon automatically register and unregister services'。",
        },
        {
            id: "w9-4-q9",
            question: "Registrator 是什么？",
            options: [
                "Service Registry",
                "自动注册 Docker 容器到 Service Registry 的第三方注册器",
                "负载均衡器",
                "API 网关",
            ],
            answer: 1,
            rationale: "Registrator 是一个开源项目，能够自动检测 Docker 容器的启动和停止，并将其注册/注销到 Consul 或 etcd。",
        },
        {
            id: "w9-4-q10",
            question: "什么情况下选择 Self Registration？",
            options: [
                "使用 Kubernetes",
                "简单环境、服务数量少、不想引入额外组件",
                "大规模微服务",
                "只用 Java",
            ],
            answer: 1,
            rationale: "Self Registration 适合简单环境、服务数量少、且不想引入额外组件的场景。",
        },
        {
            id: "w9-4-q11",
            question: "什么情况下选择 3rd Party Registration？",
            options: [
                "只有一个服务",
                "使用容器平台、希望服务代码简洁、多语言环境",
                "不使用容器",
                "不需要服务发现",
            ],
            answer: 1,
            rationale: "3rd Party Registration 适合使用容器平台（如 Kubernetes）、希望服务代码简洁、或多语言环境的场景。",
        },
        {
            id: "w9-4-q12",
            question: "服务优雅关闭时应该做什么？",
            options: [
                "直接终止进程",
                "从注册表注销实例，确保不再接收新请求",
                "不需要处理",
                "只记录日志",
            ],
            answer: 1,
            rationale: "服务优雅关闭时应该从注册表注销实例，确保不再被路由新请求，避免客户端访问已下线服务。",
        },
    ],
}
