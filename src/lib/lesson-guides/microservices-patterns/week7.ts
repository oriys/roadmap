import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week7Guides: Record<string, LessonGuide> = {
    "w7-1": {
        lessonId: "w7-1",
        background: [
            "【模式定义】microservices.io：RPI 是一种服务间通信方式，'the client uses a request/reply-based protocol to make requests to a service'——客户端使用请求/响应协议向服务发送请求。",
            "【核心优势】Simple and familiar（简单且熟悉）、Request/reply is easy（请求/响应容易实现）、Simpler system since there is no intermediate broker（没有中间代理，系统更简单）。",
            "【常见技术】RPI 的实现技术包括：REST（基于 HTTP）、gRPC（基于 Protocol Buffers）、Apache Thrift。",
            "【gRPC 特点】gRPC 是 Google 开发的 RPC 框架，使用 Protocol Buffers 序列化，支持多语言，'allows client applications to directly call methods on server applications as if it was a local object'。",
            "【协议对比】Kong：REST 是默认选择，大多数开发者熟悉；gRPC 适合性能敏感场景；GraphQL 适合复杂数据需求和移动应用。",
        ],
        keyDifficulties: [
            "【交互模式受限】microservices.io：RPI 主要支持请求/响应，'does not support other patterns such as notifications, async responses, publish/subscribe'。",
            "【可用性问题】客户端和服务必须在整个交互期间都可用：'Reduced availability since the client and the service must be available for the duration'。",
            "【服务发现需求】客户端必须定位服务实例，需要配合 Client-side 或 Server-side Discovery 模式。",
            "【gRPC 浏览器支持差】Kong 指出：gRPC 'poor browser support'，不适合直接在浏览器中使用。",
            "【技术选型权衡】REST 学习曲线低但可能响应冗余；gRPC 高效但学习成本高；GraphQL 灵活但服务端复杂度增加。",
        ],
        handsOnPath: [
            "评估通信需求：识别服务间的同步调用场景，评估是否适合 RPI。",
            "定义服务契约：使用 OpenAPI（REST）或 Proto 文件（gRPC）定义 API 契约。",
            "实现服务端：根据契约实现服务端逻辑。",
            "生成客户端：使用代码生成工具创建类型安全的客户端。",
            "配置服务发现：集成 Service Registry 实现动态服务定位。",
            "添加弹性机制：配置 Circuit Breaker、超时和重试策略。",
        ],
        selfCheck: [
            "RPI 模式的定义是什么？",
            "RPI 的主要优势和劣势是什么？",
            "REST、gRPC、GraphQL 各适合什么场景？",
            "为什么 RPI 需要配合服务发现模式？",
            "gRPC 使用什么技术实现高效序列化？",
            "什么情况下应该考虑使用 Messaging 替代 RPI？",
        ],
        extensions: [
            "深入学习 Protocol Buffers 的定义和使用。",
            "研究 gRPC 的流式传输（Streaming）能力。",
            "探索 GraphQL Federation 在微服务中的应用。",
            "了解 gRPC-Web 如何解决浏览器支持问题。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/communication-style/rpi.html",
            "https://konghq.com/blog/engineering/rest-vs-grpc-vs-graphql",
            "https://grpc.io/docs/what-is-grpc/introduction/",
        ],
    },
    "w7-2": {
        lessonId: "w7-2",
        background: [
            "【模式定义】microservices.io：'Use asynchronous messaging for inter-service communication. Services communicating by exchanging messages over messaging channels'。",
            "【五种交互模式】Request/response（同步响应）、Notifications（单向通知）、Request/async response（异步响应）、Publish/subscribe（发布订阅）、Publish/async response（发布后异步响应）。",
            "【核心优势】Loose coupling（松耦合）、Enhanced availability（增强可用性，消息代理缓冲消息）、Communication flexibility（通信灵活性）。",
            "【Kafka vs RabbitMQ】Kafka 是分布式日志平台，使用 pull 模式，消息持久化；RabbitMQ 是传统消息代理，使用 push 模式，消息消费后删除。",
            "【企业集成模式】EIP 定义了消息通道、消息、管道和过滤器、消息路由器、消息翻译器、消息端点等核心模式。",
        ],
        keyDifficulties: [
            "【复杂性增加】microservices.io：'Added complexity of the message broker, which must be highly available'——需要管理高可用的消息代理。",
            "【请求/响应复杂】在异步系统中实现同步风格的请求/响应模式变得更加复杂。",
            "【Kafka 特点】Kafka 使用 topic 和 partition 实现高吞吐量和水平扩展，但学习曲线陡峭。",
            "【RabbitMQ 特点】RabbitMQ 支持复杂路由（通过 Exchange），适合任务队列，但水平扩展较复杂。",
            "【消息顺序】在分区场景下保证消息顺序需要特殊设计，通常使用分区键（Partition Key）。",
        ],
        handsOnPath: [
            "选择消息代理：根据需求选择 Kafka（高吞吐）或 RabbitMQ（复杂路由）。",
            "定义消息格式：设计消息结构，包括消息头和消息体。",
            "实现生产者：服务发布消息到指定通道。",
            "实现消费者：服务订阅通道并处理消息。",
            "配置消息持久化：确保消息不因代理故障丢失。",
            "实现错误处理：设计死信队列和重试机制。",
        ],
        selfCheck: [
            "Messaging 模式的定义是什么？",
            "五种消息交互模式分别是什么？",
            "Messaging 相比 RPI 的优势是什么？",
            "Kafka 和 RabbitMQ 的核心区别是什么？",
            "企业集成模式中的 Message Router 是什么？",
            "如何处理消息代理的高可用性？",
        ],
        extensions: [
            "深入学习 Apache Kafka 的架构和 KRaft 协议。",
            "研究 RabbitMQ 的 Exchange 类型和路由规则。",
            "探索 Event Streaming 与传统消息队列的区别。",
            "了解云原生消息服务（如 AWS SNS/SQS、Azure Service Bus）。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/communication-style/messaging.html",
            "https://www.enterpriseintegrationpatterns.com/patterns/messaging/",
            "https://aws.amazon.com/compare/the-difference-between-rabbitmq-and-kafka/",
        ],
    },
    "w7-3": {
        lessonId: "w7-3",
        background: [
            "【模式定义】microservices.io：领域事件源自 DDD，业务逻辑组织为 DDD 聚合，'emit domain events when they created or updated'——在创建或更新时发出领域事件。",
            "【Fowler 定义】Domain Event 'Captures the memory of something interesting which affects the domain'——捕获影响领域的有趣事物的记忆。",
            "【事件用途】触发其他服务的业务逻辑、维护 CQRS 视图、参与协同式 Saga、提供审计追踪。",
            "【事件驱动模式】Fowler 区分四种：Event Notification（通知）、Event-Carried State Transfer（状态携带）、Event Sourcing（事件溯源）、CQRS。",
            "【数据分类】事件包含三类数据：Source data（不可变的源数据）、Processing data（可变的处理数据）、Cached data（缓存数据）。",
        ],
        keyDifficulties: [
            "【流程不清晰】Fowler 警告 Event Notification：'when a logical flow is spread across many event handlers, it can be hard to see as the flow isn't explicit in any program text'。",
            "【松耦合代价】虽然降低了耦合，但增加了理解和调试的难度，工作流变得隐式。",
            "【状态携带复杂性】Event-Carried State Transfer 需要消费者维护自己的数据副本，管理状态复杂度增加。",
            "【事件结构演进】事件 Schema 可能随时间变化，需要考虑向前/向后兼容性。",
            "【原子发布挑战】服务必须原子地更新数据库并发布事件——需要 Transactional Outbox 模式。",
        ],
        handsOnPath: [
            "识别领域事件：分析业务流程，识别「发生了什么」而非「做什么」。",
            "定义事件结构：包含聚合 ID、事件类型、时间戳、事件数据。",
            "选择发布机制：直接发布到消息代理或使用 Transactional Outbox。",
            "实现事件处理：消费者订阅感兴趣的事件并执行业务逻辑。",
            "版本管理：设计事件 Schema 的演进策略。",
            "实现追踪：使用 Correlation ID 追踪跨服务的事件流。",
        ],
        selfCheck: [
            "Domain Event 的定义是什么？",
            "领域事件与普通消息的区别是什么？",
            "Event Notification 模式的优缺点是什么？",
            "Event-Carried State Transfer 的作用是什么？",
            "为什么需要 Transactional Outbox 来发布事件？",
            "如何处理事件 Schema 的演进？",
        ],
        extensions: [
            "研究事件风暴（Event Storming）方法论。",
            "探索 CloudEvents 规范实现事件标准化。",
            "学习事件版本管理策略（Upcasting、Lazy Transformation）。",
            "了解事件驱动架构与 Serverless 的结合。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/domain-event.html",
            "https://martinfowler.com/eaaDev/DomainEvent.html",
            "https://martinfowler.com/articles/201701-event-driven.html",
        ],
    },
    "w7-4": {
        lessonId: "w7-4",
        background: [
            "【模式定义】microservices.io：Idempotent Consumer 确保 'processing the same message multiple times produces identical results to processing it once'。",
            "【问题背景】消息代理使用 at-least-once 投递保证，可能重复投递消息，'multiple invocations can cause bugs'——如重复扣款。",
            "【幂等概念】Particular：幂等操作 'produce the same result regardless of how many times they're executed'——如电源开关的 PowerOn 命令。",
            "【Stripe 实践】Stripe 使用 Idempotency Key 实现幂等：'saving the resulting status code and body of the first request'，后续相同 Key 返回缓存结果。",
            "【24 小时窗口】Stripe：Idempotency Key 在 24 小时后可被自动清除，过期后使用相同 Key 触发新请求。",
        ],
        keyDifficulties: [
            "【实现复杂性】需要在业务逻辑中追踪已处理的消息 ID，增加系统复杂度。",
            "【存储策略】microservices.io 提供两种方案：PROCESSED_MESSAGES 表（专用追踪）或嵌入业务实体（减少表数量）。",
            "【并发问题】并发处理相同消息时需要防止竞态条件——使用数据库主键约束或乐观锁。",
            "【Key 生成】Stripe 建议使用 V4 UUID 或足够熵的随机字符串，最大 255 字符。",
            "【Outbox 模式结合】Particular：Outbox 模式将 at-least-once 投递转换为 exactly-once 处理保证。",
        ],
        handsOnPath: [
            "识别幂等需求：找出重复处理会导致错误的消息处理器。",
            "选择追踪策略：使用专用表或嵌入业务实体存储消息 ID。",
            "实现去重逻辑：在处理前检查消息 ID，使用数据库约束防止重复。",
            "处理并发：使用事务和约束处理并发去重。",
            "设计清理策略：定期清理过期的消息 ID 记录。",
            "测试重复场景：模拟消息重复投递，验证幂等性。",
        ],
        selfCheck: [
            "Idempotent Consumer 模式解决什么问题？",
            "为什么消息代理会重复投递消息？",
            "实现消息去重有哪两种存储策略？",
            "Stripe 的 Idempotency Key 如何工作？",
            "为什么 GET 和 DELETE 请求天然幂等？",
            "Outbox 模式如何与幂等消费者配合？",
        ],
        extensions: [
            "研究分布式系统中的 Exactly-Once 语义实现。",
            "探索 Kafka 的 Exactly-Once 处理能力。",
            "学习事务性消息处理模式。",
            "了解 HTTP 幂等方法（PUT、DELETE）的设计原则。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/communication-style/idempotent-consumer.html",
            "https://particular.net/blog/what-does-idempotent-mean",
            "https://docs.stripe.com/api/idempotent_requests",
        ],
    },
}

export const week7Quizzes: Record<string, QuizQuestion[]> = {
    "w7-1": [
        {
            id: "w7-1-q1",
            question: "根据 microservices.io，RPI 模式的定义是什么？",
            options: [
                "服务间的异步消息传递",
                "客户端使用请求/响应协议向服务发送请求",
                "服务间的事件驱动通信",
                "服务间的共享数据库访问",
            ],
            answer: 1,
            rationale: "microservices.io 定义 RPI：'the client uses a request/reply-based protocol to make requests to a service'。",
        },
        {
            id: "w7-1-q2",
            question: "RPI 的主要优势有哪些？",
            options: [
                "支持发布订阅和通知模式",
                "简单熟悉、请求/响应容易实现、无需中间代理",
                "高可用性和松耦合",
                "支持异步处理",
            ],
            answer: 1,
            rationale: "microservices.io 列出优势：Simple and familiar、Request/reply is easy、Simpler system since there is no intermediate broker。",
        },
        {
            id: "w7-1-q3",
            question: "RPI 的主要劣势是什么？",
            options: [
                "学习曲线陡峭",
                "客户端和服务必须在整个交互期间都可用",
                "需要复杂的消息代理",
                "只支持异步通信",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'Reduced availability since the client and the service must be available for the duration of the interaction'。",
        },
        {
            id: "w7-1-q4",
            question: "gRPC 使用什么技术实现序列化？",
            options: [
                "JSON",
                "Protocol Buffers",
                "XML",
                "YAML",
            ],
            answer: 1,
            rationale: "gRPC 官方文档说明 gRPC 主要使用 Protocol Buffers 进行序列化，效率高于文本格式。",
        },
        {
            id: "w7-1-q5",
            question: "根据 Kong，什么情况下应该选择 gRPC？",
            options: [
                "需要浏览器直接访问的公共 API",
                "性能敏感场景、IoT 设备、微服务内部通信",
                "简单的 CRUD 应用",
                "需要灵活数据查询的移动应用",
            ],
            answer: 1,
            rationale: "Kong 指出 gRPC 适用于：'Performance-critical scenarios, IoT devices, microservice communication'。",
        },
        {
            id: "w7-1-q6",
            question: "gRPC 的主要缺点是什么？",
            options: [
                "性能差",
                "浏览器支持差、学习曲线陡峭",
                "不支持多语言",
                "只能用于同步通信",
            ],
            answer: 1,
            rationale: "Kong 列出 gRPC 缺点：'poor browser support'、'Difficult to learn through experimentation'。",
        },
        {
            id: "w7-1-q7",
            question: "GraphQL 的核心优势是什么？",
            options: [
                "性能最高",
                "客户端可以只请求需要的字段，减少负载",
                "实现最简单",
                "浏览器支持最好",
            ],
            answer: 1,
            rationale: "Kong 指出 GraphQL：'Clients request only needed fields, reducing payload sizes'。",
        },
        {
            id: "w7-1-q8",
            question: "RPI 常用的实现技术有哪些？",
            options: [
                "Kafka、RabbitMQ、ActiveMQ",
                "REST、gRPC、Apache Thrift",
                "WebSocket、MQTT、AMQP",
                "GraphQL、OData、SOAP",
            ],
            answer: 1,
            rationale: "microservices.io 列出 RPI 技术：REST、gRPC、Apache Thrift。",
        },
        {
            id: "w7-1-q9",
            question: "为什么 RPI 需要配合服务发现模式？",
            options: [
                "提高性能",
                "客户端必须定位服务实例",
                "实现负载均衡",
                "保证消息顺序",
            ],
            answer: 1,
            rationale: "microservices.io 指出 RPI 的相关模式包括 Client-side/Server-side discovery，因为客户端需要定位服务实例。",
        },
        {
            id: "w7-1-q10",
            question: "gRPC 使用什么 HTTP 版本？",
            options: [
                "HTTP/1.0",
                "HTTP/2",
                "HTTP/1.1",
                "HTTP/3",
            ],
            answer: 1,
            rationale: "Kong 提到 gRPC 'Uses faster HTTP/2 protocol'。",
        },
        {
            id: "w7-1-q11",
            question: "Kong 建议在什么情况下使用 REST？",
            options: [
                "只在性能敏感场景",
                "没有特殊需求时，REST 是默认选择",
                "只在移动应用",
                "只在内部微服务通信",
            ],
            answer: 1,
            rationale: "Kong 建议：'If you don't have a compelling reason to choose otherwise, REST is probably the best option'。",
        },
        {
            id: "w7-1-q12",
            question: "RPI 不支持以下哪种交互模式？",
            options: [
                "请求/响应",
                "发布/订阅",
                "同步调用",
                "远程过程调用",
            ],
            answer: 1,
            rationale: "microservices.io 指出 RPI 'does not support other patterns such as notifications, async responses, publish/subscribe'。",
        },
    ],
    "w7-2": [
        {
            id: "w7-2-q1",
            question: "Messaging 模式的定义是什么？",
            options: [
                "服务间的同步调用",
                "服务通过消息通道交换消息的异步通信",
                "服务间的共享数据库",
                "服务间的直接 HTTP 调用",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Use asynchronous messaging for inter-service communication. Services communicating by exchanging messages over messaging channels'。",
        },
        {
            id: "w7-2-q2",
            question: "Messaging 支持的五种交互模式包括哪些？",
            options: [
                "创建、读取、更新、删除、查询",
                "Request/response、Notifications、Request/async response、Publish/subscribe、Publish/async response",
                "同步、异步、混合、批量、流式",
                "点对点、广播、组播、单播、任播",
            ],
            answer: 1,
            rationale: "microservices.io 列出五种模式：Request/response、Notifications、Request/async response、Publish/subscribe、Publish/async response。",
        },
        {
            id: "w7-2-q3",
            question: "Messaging 相比 RPI 的核心优势是什么？",
            options: [
                "实现更简单",
                "松耦合和增强可用性（消息代理缓冲消息）",
                "性能更高",
                "不需要网络",
            ],
            answer: 1,
            rationale: "microservices.io 列出优势：Loose coupling、Enhanced availability（消息代理缓冲消息）、Communication flexibility。",
        },
        {
            id: "w7-2-q4",
            question: "Kafka 和 RabbitMQ 的主要区别是什么？",
            options: [
                "Kafka 是消息队列，RabbitMQ 是数据库",
                "Kafka 是分布式日志平台使用 pull 模式，RabbitMQ 是消息代理使用 push 模式",
                "Kafka 只支持 Java，RabbitMQ 支持多语言",
                "没有本质区别",
            ],
            answer: 1,
            rationale: "AWS 对比文档指出：Kafka 是分布式日志平台使用 pull 模式，消息持久化；RabbitMQ 是消息代理使用 push 模式，消息消费后删除。",
        },
        {
            id: "w7-2-q5",
            question: "Messaging 的主要劣势是什么？",
            options: [
                "不支持异步通信",
                "需要管理高可用的消息代理，增加复杂性",
                "性能太低",
                "不支持多语言",
            ],
            answer: 1,
            rationale: "microservices.io 指出劣势：'Added complexity of the message broker, which must be highly available'。",
        },
        {
            id: "w7-2-q6",
            question: "Kafka 的消息保留策略是什么？",
            options: [
                "消费后立即删除",
                "基于时间的保留，消息保留到过期",
                "永久保留",
                "手动删除",
            ],
            answer: 1,
            rationale: "AWS 文档：'Apache Kafka appends the message to a log file, which remains until its retention period expires'。",
        },
        {
            id: "w7-2-q7",
            question: "RabbitMQ 使用什么机制实现复杂路由？",
            options: [
                "Topic 和 Partition",
                "Exchange",
                "Consumer Group",
                "ZooKeeper",
            ],
            answer: 1,
            rationale: "AWS 文档指出 RabbitMQ 通过 Exchange 实现复杂路由策略：'enables advanced routing strategies'。",
        },
        {
            id: "w7-2-q8",
            question: "企业集成模式中，Message Router 的作用是什么？",
            options: [
                "存储消息",
                "将消息从源路由到适当的目的地",
                "翻译消息格式",
                "加密消息",
            ],
            answer: 1,
            rationale: "EIP 定义 Message Router：'a central pattern for directing messages from sources to appropriate destinations'。",
        },
        {
            id: "w7-2-q9",
            question: "什么情况下选择 Kafka？",
            options: [
                "简单的任务队列",
                "高吞吐量流式处理、事件溯源、实时数据管道",
                "需要复杂路由的场景",
                "低延迟的请求响应",
            ],
            answer: 1,
            rationale: "AWS 文档：Kafka 适用于 'streaming data to multiple applications in real-time, building a data warehouse, processing data streams'。",
        },
        {
            id: "w7-2-q10",
            question: "什么情况下选择 RabbitMQ？",
            options: [
                "大数据流处理",
                "需要复杂路由、任务队列、微服务间简单通信",
                "事件溯源",
                "日志聚合",
            ],
            answer: 1,
            rationale: "AWS 文档：RabbitMQ 适用于 'complex routing options, task queues, microservices communication'。",
        },
        {
            id: "w7-2-q11",
            question: "Kafka 的水平扩展是通过什么实现的？",
            options: [
                "增加 Exchange",
                "通过 Partition 分布在多个 Broker",
                "增加 Consumer",
                "增加 Queue",
            ],
            answer: 1,
            rationale: "AWS 文档：'Kafka is designed for horizontal scaling through partition distribution across brokers'。",
        },
        {
            id: "w7-2-q12",
            question: "Message Translator 模式的作用是什么？",
            options: [
                "路由消息",
                "转换不同数据格式之间的消息内容",
                "存储消息",
                "加密消息",
            ],
            answer: 1,
            rationale: "EIP 定义 Message Translator：'enables systems using different data formats to communicate by converting message content'。",
        },
    ],
    "w7-3": [
        {
            id: "w7-3-q1",
            question: "根据 Fowler，Domain Event 的定义是什么？",
            options: [
                "数据库中的记录",
                "捕获影响领域的有趣事物的记忆",
                "API 请求",
                "日志条目",
            ],
            answer: 1,
            rationale: "Fowler 定义：Domain Event 'Captures the memory of something interesting which affects the domain'。",
        },
        {
            id: "w7-3-q2",
            question: "microservices.io 说领域事件在什么时候发出？",
            options: [
                "定时发出",
                "在 DDD 聚合创建或更新时发出",
                "用户请求时发出",
                "系统启动时发出",
            ],
            answer: 1,
            rationale: "microservices.io 指出业务逻辑组织为 DDD 聚合，'emit domain events when they created or updated'。",
        },
        {
            id: "w7-3-q3",
            question: "Fowler 区分的四种事件驱动模式是什么？",
            options: [
                "创建、读取、更新、删除",
                "Event Notification、Event-Carried State Transfer、Event Sourcing、CQRS",
                "同步、异步、批量、流式",
                "生产者、消费者、代理、通道",
            ],
            answer: 1,
            rationale: "Fowler 区分四种模式：Event Notification、Event-Carried State Transfer、Event Sourcing、CQRS。",
        },
        {
            id: "w7-3-q4",
            question: "Event Notification 模式的主要优点是什么？",
            options: [
                "高性能",
                "低耦合和简单设置",
                "强一致性",
                "易于调试",
            ],
            answer: 1,
            rationale: "Fowler 指出 Event Notification 的优点：'Low coupling and simple setup'。",
        },
        {
            id: "w7-3-q5",
            question: "Event Notification 模式的主要缺点是什么？",
            options: [
                "性能低",
                "当逻辑流分散在多个事件处理器时，流程不清晰",
                "耦合度高",
                "不支持异步",
            ],
            answer: 1,
            rationale: "Fowler 警告：'when a logical flow is spread across many event handlers, it can be hard to see as the flow isn't explicit'。",
        },
        {
            id: "w7-3-q6",
            question: "Event-Carried State Transfer 的作用是什么？",
            options: [
                "只发送通知",
                "在事件中携带完整数据，消费者无需查询源系统",
                "只用于日志",
                "只用于审计",
            ],
            answer: 1,
            rationale: "Fowler 描述：'Rather than querying the source system for data, recipients receive complete information via events'。",
        },
        {
            id: "w7-3-q7",
            question: "根据 Fowler，领域事件包含哪三类数据？",
            options: [
                "头部、主体、尾部",
                "Source data（源数据）、Processing data（处理数据）、Cached data（缓存数据）",
                "请求、响应、错误",
                "创建、更新、删除",
            ],
            answer: 1,
            rationale: "Fowler 指出事件包含三类数据：Source data（不可变）、Processing data（可变）、Cached data（偶尔使用）。",
        },
        {
            id: "w7-3-q8",
            question: "为什么需要 Transactional Outbox 来发布领域事件？",
            options: [
                "提高性能",
                "服务必须原子地更新数据库并发布事件",
                "简化代码",
                "减少存储",
            ],
            answer: 1,
            rationale: "microservices.io 指出需要 Transactional Outbox 模式来确保原子地更新数据库并发布事件。",
        },
        {
            id: "w7-3-q9",
            question: "领域事件适用于哪些场景？",
            options: [
                "只用于日志",
                "触发业务逻辑、维护 CQRS 视图、参与 Saga、审计追踪",
                "只用于性能优化",
                "只用于安全审计",
            ],
            answer: 1,
            rationale: "microservices.io 列出领域事件的用途：触发其他服务业务逻辑、维护 CQRS 视图、参与协同式 Saga、提供审计追踪。",
        },
        {
            id: "w7-3-q10",
            question: "Event-Carried State Transfer 的权衡是什么？",
            options: [
                "实现简单但耦合高",
                "提高弹性和减少延迟，但消费者需要管理数据副本",
                "性能高但成本高",
                "安全但复杂",
            ],
            answer: 1,
            rationale: "Fowler 指出权衡：'Greater resilience, reduced latency'，但 'Requires recipients to maintain their own data copies'。",
        },
        {
            id: "w7-3-q11",
            question: "与 Domain Event 相关的模式有哪些？",
            options: [
                "只有数据库模式",
                "Saga、CQRS、Aggregate、Transactional Outbox、Event Sourcing",
                "只有网络模式",
                "只有安全模式",
            ],
            answer: 1,
            rationale: "microservices.io 列出相关模式：Saga 和 CQRS 创建对领域事件的需求，Aggregate 结构化业务逻辑，Transactional Outbox 发布事件。",
        },
        {
            id: "w7-3-q12",
            question: "Event Sourcing 的核心原则是什么？",
            options: [
                "存储当前状态",
                "将状态变更记录为事件，通过重放事件重建状态",
                "定期快照",
                "实时同步",
            ],
            answer: 1,
            rationale: "Fowler 描述：'whenever we make a change to the state of a system, we record that state change as an event, and we can confidently rebuild the system state by reprocessing the events'。",
        },
    ],
    "w7-4": [
        {
            id: "w7-4-q1",
            question: "Idempotent Consumer 模式的定义是什么？",
            options: [
                "只处理一次消息",
                "处理同一消息多次产生与处理一次相同的结果",
                "拒绝重复消息",
                "缓存所有消息",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'processing the same message multiple times produces identical results to processing it once'。",
        },
        {
            id: "w7-4-q2",
            question: "为什么需要 Idempotent Consumer？",
            options: [
                "提高性能",
                "消息代理使用 at-least-once 投递，可能重复投递消息",
                "减少存储",
                "简化代码",
            ],
            answer: 1,
            rationale: "microservices.io 指出问题：'Message brokers using at-least-once delivery guarantee message delivery but can invoke consumers repeatedly for the same message'。",
        },
        {
            id: "w7-4-q3",
            question: "Particular 用什么比喻解释幂等性？",
            options: [
                "数学函数",
                "电源开关的 PowerOn 命令（多次执行结果相同）",
                "银行转账",
                "数据库事务",
            ],
            answer: 1,
            rationale: "Particular 用电源开关比喻：'PowerOn and InputBluRay commands are idempotent—sending them multiple times keeps the receiver in the same state'。",
        },
        {
            id: "w7-4-q4",
            question: "microservices.io 提供的消息去重存储策略有哪些？",
            options: [
                "内存缓存和文件存储",
                "PROCESSED_MESSAGES 表（专用追踪）或嵌入业务实体",
                "只能用 Redis",
                "只能用数据库",
            ],
            answer: 1,
            rationale: "microservices.io 提供两种方案：'Separate Tracking Table'（PROCESSED_MESSAGES）或 'Embedded Storage'（嵌入业务实体）。",
        },
        {
            id: "w7-4-q5",
            question: "Stripe 的 Idempotency Key 有什么特点？",
            options: [
                "由服务器生成",
                "客户端生成的唯一标识符，最大 255 字符，24 小时后可清除",
                "永久有效",
                "只能是数字",
            ],
            answer: 1,
            rationale: "Stripe 说明：'Client-created unique identifiers (up to 255 characters)'，'Keys can be automatically removed after 24 hours'。",
        },
        {
            id: "w7-4-q6",
            question: "为什么 GET 和 DELETE 请求天然幂等？",
            options: [
                "因为它们不需要网络",
                "GET 不修改状态，DELETE 多次删除同一资源结果相同",
                "因为它们更快",
                "因为它们更安全",
            ],
            answer: 1,
            rationale: "Stripe 指出 Idempotency Key 'Not applicable to GET and DELETE requests (inherently idempotent)'。",
        },
        {
            id: "w7-4-q7",
            question: "重复处理 AccountDebited 消息会导致什么问题？",
            options: [
                "性能下降",
                "计算出错误的余额（重复扣款）",
                "网络延迟",
                "存储不足",
            ],
            answer: 1,
            rationale: "microservices.io 举例：'a consumer of an AccountDebited message that subtracts the debit amount from the current balance would calculate the incorrect balance'。",
        },
        {
            id: "w7-4-q8",
            question: "Particular 建议的解决方案是什么？",
            options: [
                "增加重试次数",
                "Outbox 模式，将 at-least-once 投递转换为 exactly-once 处理",
                "减少消息量",
                "使用更快的网络",
            ],
            answer: 1,
            rationale: "Particular 指出 Outbox 模式 'turns the message broker's at-least-once delivery guarantee into an exactly-once processing guarantee'。",
        },
        {
            id: "w7-4-q9",
            question: "PROCESSED_MESSAGES 表的主键是什么？",
            options: [
                "只有 messageID",
                "复合主键 (subscriberId, messageID)",
                "只有 subscriberId",
                "自增 ID",
            ],
            answer: 1,
            rationale: "microservices.io 描述：'Store message IDs in a dedicated PROCESSED_MESSAGES table with a composite primary key of (subscriberId, messageID)'。",
        },
        {
            id: "w7-4-q10",
            question: "Stripe 建议使用什么作为 Idempotency Key？",
            options: [
                "时间戳",
                "V4 UUID 或足够熵的随机字符串",
                "用户 ID",
                "订单号",
            ],
            answer: 1,
            rationale: "Stripe 建议：'Recommended: V4 UUIDs or random strings with sufficient entropy'。",
        },
        {
            id: "w7-4-q11",
            question: "什么情况下 Stripe 不保存幂等结果？",
            options: [
                "请求成功时",
                "参数验证失败或与并发请求冲突时",
                "请求超时时",
                "网络错误时",
            ],
            answer: 1,
            rationale: "Stripe 指出：'If incoming parameters fail validation, or the request conflicts with another request that's executing concurrently, no idempotent result is stored'。",
        },
        {
            id: "w7-4-q12",
            question: "幂等消费者如何利用数据库约束实现去重？",
            options: [
                "使用外键",
                "使用主键约束，重复 INSERT 失败后回滚",
                "使用索引",
                "使用触发器",
            ],
            answer: 1,
            rationale: "microservices.io 描述：'inserts the message ID within a database transaction. If the message was already processed, the INSERT fails due to the primary key constraint'。",
        },
    ],
}
