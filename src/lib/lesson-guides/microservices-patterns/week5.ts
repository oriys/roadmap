import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week5Guides: Record<string, LessonGuide> = {
    "w5-1": {
        lessonId: "w5-1",
        background: [
            "【模式定义】microservices.io：Saga 是 'a sequence of local transactions'——一系列本地事务，在不依赖分布式事务的情况下实现跨多个微服务的业务操作。",
            "【问题背景】当服务各自维护独立数据库（Database per Service）时，传统 ACID 事务无法跨服务强制一致性，Saga 提供替代的协调机制。",
            "【两种实现】编排式（Orchestration）：中央编排器指挥各参与服务执行操作；协同式（Choreography）：服务发布领域事件触发其他服务动作，形成链式反应。",
            "【Azure 三类事务】Compensable（可补偿：可被撤销）、Pivot（枢轴：不可返回点）、Retryable（可重试：幂等操作，确保最终一致）。",
            "【核心优势】在不使用分布式事务的情况下维护跨服务的数据一致性。",
        ],
        keyDifficulties: [
            "【手动回滚】microservices.io：开发者必须 'explicitly design compensating transactions'——显式设计补偿事务，而非依赖自动回滚。",
            "【隔离问题】并发执行多个 Saga 可能导致数据异常（Lost Updates、Dirty Reads、Fuzzy Reads），需要实现 countermeasures（对策）。",
            "【原子性挑战】服务必须原子地更新数据库并发布消息——需要使用 Transactional Outbox 模式。",
            "【客户端通知】客户端需要机制确定异步 Saga 的结果：等待、轮询或基于事件的通知。",
            "【调试复杂性】Azure：参与服务增多时 'difficult to debug'——需要完整的 Saga 工作流监控。",
        ],
        handsOnPath: [
            "识别跨服务事务：列出需要跨多个服务保持一致性的业务操作。",
            "定义本地事务序列：将每个跨服务操作分解为一系列本地事务。",
            "设计补偿事务：为每个本地事务定义对应的补偿（撤销）操作。",
            "选择实现方式：根据复杂度选择编排式或协同式。",
            "实现 Transactional Outbox：确保数据库更新和消息发布的原子性。",
            "添加监控和追踪：实现 Saga 执行状态的可观测性。",
        ],
        selfCheck: [
            "Saga 模式的定义是什么？它解决什么问题？",
            "Saga 的两种实现方式是什么？各自的特点？",
            "Azure 定义的三类事务是什么？各自的作用？",
            "为什么 Saga 需要手动设计补偿事务？",
            "Saga 的隔离问题是什么？有哪些数据异常类型？",
            "为什么服务需要原子地更新数据库并发布消息？",
        ],
        extensions: [
            "研究原始 Saga 论文（1987 年 Cornell 大学）的理论基础。",
            "探索 Saga 与 2PC（Two-Phase Commit）的对比。",
            "学习 Saga 在事件溯源架构中的应用。",
            "了解 Saga 的测试策略和端到端测试方法。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/saga.html",
            "https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga",
        ],
    },
    "w5-2": {
        lessonId: "w5-2",
        background: [
            "【定义】Temporal：编排式 Saga 中，中央服务作为 'message broker sending messages directly to individual microservices telling them what to do'。",
            "【核心特点】Azure：所有协调逻辑集中在编排器中，编排器命令其他微服务执行本地事务。",
            "【清晰流程】由于每步不需要跟踪「之前发生了什么」，'the code for individual microservices is much simpler'——单个微服务代码更简单。",
            "【多服务协作】当多个服务需要在单个 Saga 步骤中交互时，编排式更有优势。",
            "【Temporal 方法】Temporal 通过记录程序进度到日志，'automatically orchestrates for you, but also avoids that crucial drawback of a single point of failure'。",
        ],
        keyDifficulties: [
            "【单点故障】Temporal：'The glaring Achilles' heel is that the message broker is a single point of failure'——消息代理是单点故障。",
            "【复杂初始设置】编排式需要更复杂的初始架构设置。",
            "【编排器设计】需要决定是为所有 Saga 使用统一编排器还是每个 Saga 单独编排器。",
            "【状态管理】编排器需要管理 Saga 的状态和进度，包括重试和补偿逻辑。",
            "【Temporal 确定性约束】Temporal：工作流必须遵守 'deterministic constraints to maintain consistent replay behavior'。",
        ],
        handsOnPath: [
            "设计编排器服务：决定编排器的职责边界和状态管理方式。",
            "定义 Saga 步骤：为每个步骤定义请求、响应和补偿消息。",
            "实现状态机：编排器使用状态机管理 Saga 的生命周期。",
            "处理失败和重试：实现超时、重试和补偿逻辑。",
            "评估 Temporal 或 Camunda：考虑使用现成的工作流引擎。",
            "实现可观测性：记录每步执行状态和完整的事件历史。",
        ],
        selfCheck: [
            "编排式 Saga 的核心特点是什么？",
            "为什么编排式让单个微服务代码更简单？",
            "编排式的主要缺点是什么？如何缓解？",
            "什么情况下编排式比协同式更适合？",
            "Temporal 如何避免单点故障问题？",
            "编排器的状态管理需要考虑哪些方面？",
        ],
        extensions: [
            "深入学习 Temporal 工作流引擎的架构和使用。",
            "研究 Camunda 在编排式 Saga 中的应用。",
            "探索 AWS Step Functions 作为编排器的实现。",
            "了解编排器的高可用设计模式。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/saga.html",
            "https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga",
            "https://temporal.io/blog/to-choreograph-or-orchestrate-your-saga-that-is-the-question",
        ],
    },
    "w5-3": {
        lessonId: "w5-3",
        background: [
            "【定义】microservices.io：协同式 Saga 中，服务发布领域事件触发其他服务动作：'Each microservice emits an event after completing its task. Other services listen for events they care about and react accordingly'。",
            "【分散架构】Temporal：'Each microservice has local knowledge, and shares information about state changes with other services via message passing'——去中心化的协作方式。",
            "【无单点故障】AWS：协同式避免了单点故障，服务间松耦合。",
            "【适用场景】AWS：'适用于少数参与者'，当参与者过多时变得难以管理。",
            "【自然演进】Temporal：协同式是 'Natural fit for monolith-to-microservices transitions'——适合单体到微服务的迁移过渡。",
        ],
        keyDifficulties: [
            "【流程不清晰】Temporal：'Control flow becomes unclear across codebases'——控制流在代码库间不清晰。",
            "【调试困难】Temporal：'Difficult to debug sequential event chains'——难以调试顺序事件链。",
            "【依赖问题】当任务有顺序依赖时，协同式会变得复杂：'Problematic when tasks have ordering dependencies'。",
            "【逻辑分散】Temporal：'Business logic scattered throughout the system'——业务逻辑分散在整个系统中。",
            "【复杂性增长】AWS：'As the number of microservices increases, saga choreography can become difficult to manage'。",
        ],
        handsOnPath: [
            "定义领域事件：为每个服务定义发布的事件类型和事件负载。",
            "设计事件流：绘制服务间的事件流图，明确谁发布、谁订阅。",
            "实现事件发布：使用消息队列（如 Kafka、RabbitMQ）发布事件。",
            "实现事件订阅：服务订阅感兴趣的事件并做出响应。",
            "处理补偿事件：定义失败时的补偿事件和处理逻辑。",
            "实现可观测性：使用 Correlation ID 追踪完整的事件链。",
        ],
        selfCheck: [
            "协同式 Saga 的核心特点是什么？",
            "协同式如何避免单点故障？",
            "协同式的主要缺点是什么？",
            "什么情况下协同式比编排式更适合？",
            "如何解决控制流不清晰的问题？",
            "为什么参与者过多时协同式会变得难以管理？",
        ],
        extensions: [
            "研究 AWS EventBridge 在协同式 Saga 中的应用。",
            "探索如何使用分布式追踪（如 Jaeger）监控事件链。",
            "学习 Event Sourcing 与协同式 Saga 的结合。",
            "了解如何从协同式迁移到编排式。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/saga.html",
            "https://temporal.io/blog/to-choreograph-or-orchestrate-your-saga-that-is-the-question",
            "https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/saga-choreography.html",
        ],
    },
    "w5-4": {
        lessonId: "w5-4",
        background: [
            "【模式定义】Azure：补偿事务是 '用于处理最终一致性操作的设计模式'，当某一步失败时执行补偿操作撤销之前步骤完成的工作。",
            "【核心原则】在原始操作的每一步中，系统记录如何撤销该步骤；失败时工作流回退，按记录的补偿逻辑撤销各步骤。",
            "【灵活顺序】Azure：'补偿事务不必完全按原操作的相反顺序执行'——某些撤销步骤可并行执行以提高效率。",
            "【业务规则】Azure：补偿逻辑需考虑特定的业务规则，如退款政策——不仅仅是恢复原始状态。",
            "【隔离异常对策】microservices.io：Semantic lock（语义锁）、Commutative updates（可交换更新）、Pessimistic view（悲观视图）、Reread value（重读值）、Version file（版本文件）。",
        ],
        keyDifficulties: [
            "【幂等性要求】Azure：'补偿步骤应定义为幂等命令，确保失败重试时安全'。",
            "【故障检测】Azure：需要实现超时机制，处理阻塞而非立即失败的情况。",
            "【信息保留】Azure：基础设施需保留撤销所需的信息。",
            "【并发问题】其他并发实例可能已修改了数据，撤销逻辑需要考虑这种情况。",
            "【Lost Updates 异常】一个 Saga 的更新被另一个 Saga 覆盖——使用语义锁或版本管理解决。",
            "【Dirty Reads 异常】读取另一个 Saga 未完成的修改——使用悲观视图或重读值解决。",
        ],
        handsOnPath: [
            "为每个本地事务设计补偿逻辑：明确如何撤销每步操作。",
            "实现幂等补偿：确保补偿操作可以安全重试。",
            "使用中间状态：如订单状态从 SUBMITTED → PENDING → APPROVED，使用中间状态防止 Dirty Reads。",
            "实现超时机制：检测阻塞的操作并触发补偿。",
            "记录审计信息：保存足够的信息支持补偿和问题排查。",
            "测试失败场景：模拟各种失败情况，验证补偿逻辑正确执行。",
        ],
        selfCheck: [
            "补偿事务模式的定义和目的是什么？",
            "为什么补偿步骤需要是幂等的？",
            "Saga 的隔离异常有哪些类型？",
            "有哪些对策（countermeasures）解决隔离异常？",
            "语义锁（Semantic Lock）如何工作？",
            "为什么补偿顺序可以灵活调整？",
        ],
        extensions: [
            "研究 Saga 论文中的原始补偿事务理论。",
            "探索乐观锁和悲观锁在 Saga 中的应用。",
            "学习如何使用事件溯源实现自然的补偿机制。",
            "了解 Saga 在金融交易中的实际应用案例。",
        ],
        sourceUrls: [
            "https://learn.microsoft.com/en-us/azure/architecture/patterns/compensating-transaction",
            "https://microservices.io/patterns/data/saga.html",
        ],
    },
}

export const week5Quizzes: Record<string, QuizQuestion[]> = {
    "w5-1": [
        {
            id: "w5-1-q1",
            question: "根据 microservices.io，Saga 模式的定义是什么？",
            options: [
                "一种分布式数据库",
                "一系列本地事务，在不依赖分布式事务的情况下实现跨服务业务操作",
                "一种消息队列",
                "一种缓存策略",
            ],
            answer: 1,
            rationale: "microservices.io 定义 Saga 为 'a sequence of local transactions'——一系列本地事务。",
        },
        {
            id: "w5-1-q2",
            question: "Saga 模式的两种实现方式是什么？",
            options: [
                "同步和异步",
                "编排式（Orchestration）和协同式（Choreography）",
                "主动和被动",
                "集中和分布",
            ],
            answer: 1,
            rationale: "microservices.io 列出两种实现：Orchestration-based 和 Choreography-based。",
        },
        {
            id: "w5-1-q3",
            question: "Azure 定义的三类 Saga 事务是什么？",
            options: [
                "创建、更新、删除",
                "可补偿（Compensable）、枢轴（Pivot）、可重试（Retryable）",
                "同步、异步、混合",
                "本地、远程、分布式",
            ],
            answer: 1,
            rationale: "Azure 定义三类事务：Compensable（可补偿）、Pivot（枢轴）、Retryable（可重试）。",
        },
        {
            id: "w5-1-q4",
            question: "为什么 Saga 需要手动设计补偿事务？",
            options: [
                "自动回滚太慢",
                "分布式系统中无法依赖自动回滚，需要显式设计补偿操作",
                "为了节省成本",
                "数据库不支持事务",
            ],
            answer: 1,
            rationale: "microservices.io 指出开发者必须 'explicitly design compensating transactions'，因为分布式系统无法依赖自动回滚。",
        },
        {
            id: "w5-1-q5",
            question: "Saga 的隔离问题会导致哪些数据异常？",
            options: [
                "只有性能问题",
                "Lost Updates、Dirty Reads、Fuzzy Reads",
                "只有网络延迟",
                "只有安全问题",
            ],
            answer: 1,
            rationale: "文档列出并发 Saga 可能导致的数据异常：Lost Updates、Dirty Reads、Fuzzy/Nonrepeatable Reads。",
        },
        {
            id: "w5-1-q6",
            question: "为什么服务需要原子地更新数据库并发布消息？",
            options: [
                "提高性能",
                "确保数据库更新和消息发布的一致性，避免部分成功",
                "简化代码",
                "减少存储空间",
            ],
            answer: 1,
            rationale: "microservices.io 指出服务必须 'atomically update databases AND publish messages'，需要使用 Transactional Outbox 模式。",
        },
        {
            id: "w5-1-q7",
            question: "枢轴事务（Pivot Transaction）的特点是什么？",
            options: [
                "可以随时撤销",
                "是不可返回点，成功后可补偿交易不再适用",
                "最快的事务",
                "最简单的事务",
            ],
            answer: 1,
            rationale: "Azure 定义 Pivot 为不可返回点，'成功后，可补偿交易不再适用'。",
        },
        {
            id: "w5-1-q8",
            question: "可重试事务（Retryable Transaction）的特点是什么？",
            options: [
                "不能重试",
                "幂等操作，确保系统最终达到一致状态",
                "只能执行一次",
                "必须成功",
            ],
            answer: 1,
            rationale: "Azure 定义 Retryable 为幂等操作，'确保系统最终达到一致状态'。",
        },
        {
            id: "w5-1-q9",
            question: "客户端如何知道异步 Saga 的结果？",
            options: [
                "Saga 总是同步的",
                "等待、轮询或基于事件的通知",
                "客户端不需要知道结果",
                "通过数据库查询",
            ],
            answer: 1,
            rationale: "microservices.io 指出客户端需要机制确定 Saga 结果：'waiting, polling, or event-based notification'。",
        },
        {
            id: "w5-1-q10",
            question: "为什么 Saga 调试复杂？",
            options: [
                "代码太少",
                "参与服务增多时难以追踪工作流",
                "日志太多",
                "网络太快",
            ],
            answer: 1,
            rationale: "Azure 指出参与服务增多时 'difficult to debug'，需要完整的 Saga 工作流监控。",
        },
        {
            id: "w5-1-q11",
            question: "Saga 与 2PC（Two-Phase Commit）的主要区别是什么？",
            options: [
                "Saga 更快",
                "Saga 使用最终一致性而非强一致性，不锁定资源",
                "Saga 更简单",
                "Saga 只能用于单体应用",
            ],
            answer: 1,
            rationale: "Saga 使用一系列本地事务和补偿实现最终一致性，而 2PC 锁定资源实现强一致性，在微服务中不可行。",
        },
        {
            id: "w5-1-q12",
            question: "Transactional Outbox 模式在 Saga 中的作用是什么？",
            options: [
                "提高性能",
                "确保数据库更新和消息发布的原子性",
                "减少存储",
                "简化代码",
            ],
            answer: 1,
            rationale: "microservices.io 指出服务需要原子地更新数据库并发布消息，Transactional Outbox 模式解决这个问题。",
        },
    ],
    "w5-2": [
        {
            id: "w5-2-q1",
            question: "编排式 Saga 的核心特点是什么？",
            options: [
                "去中心化",
                "中央编排器指挥各参与服务执行操作",
                "无协调者",
                "完全自治",
            ],
            answer: 1,
            rationale: "Temporal 描述编排式中，中央服务作为 'message broker sending messages directly to individual microservices telling them what to do'。",
        },
        {
            id: "w5-2-q2",
            question: "为什么编排式让单个微服务代码更简单？",
            options: [
                "微服务代码量少",
                "每步不需要跟踪'之前发生了什么'",
                "使用更简单的语言",
                "不需要数据库",
            ],
            answer: 1,
            rationale: "Azure 指出由于每步不需要跟踪「之前发生了什么」，'the code for individual microservices is much simpler'。",
        },
        {
            id: "w5-2-q3",
            question: "编排式 Saga 的主要缺点是什么？",
            options: [
                "代码太复杂",
                "消息代理是单点故障",
                "性能太差",
                "不支持补偿",
            ],
            answer: 1,
            rationale: "Temporal 指出：'The glaring Achilles' heel is that the message broker is a single point of failure'。",
        },
        {
            id: "w5-2-q4",
            question: "什么情况下编排式比协同式更适合？",
            options: [
                "服务数量少时",
                "多个服务需要在单个 Saga 步骤中交互时",
                "不需要补偿时",
                "流程非常简单时",
            ],
            answer: 1,
            rationale: "Azure 指出编排式 'works well when multiple services need to interact in a single saga step'。",
        },
        {
            id: "w5-2-q5",
            question: "Temporal 如何避免单点故障问题？",
            options: [
                "不使用编排器",
                "通过记录程序进度到日志实现自动编排",
                "使用多个消息队列",
                "使用缓存",
            ],
            answer: 1,
            rationale: "Temporal 通过记录程序进度到日志，'automatically orchestrates for you, but also avoids that crucial drawback of a single point of failure'。",
        },
        {
            id: "w5-2-q6",
            question: "编排器的状态管理需要考虑什么？",
            options: [
                "只需要考虑性能",
                "管理 Saga 的状态和进度，包括重试和补偿逻辑",
                "只需要考虑存储",
                "不需要状态管理",
            ],
            answer: 1,
            rationale: "编排器需要管理 Saga 的状态和进度，包括重试和补偿逻辑，通常使用状态机实现。",
        },
        {
            id: "w5-2-q7",
            question: "Temporal 工作流的关键组件有哪些？",
            options: [
                "只有代码",
                "Workflow Definition、Workflow Type、Workflow Execution",
                "只有配置",
                "只有数据库",
            ],
            answer: 1,
            rationale: "Temporal 定义三个关键概念：Workflow Definition（代码）、Workflow Type（标识符）、Workflow Execution（运行实例）。",
        },
        {
            id: "w5-2-q8",
            question: "Temporal 工作流必须遵守什么约束？",
            options: [
                "性能约束",
                "确定性约束，以维护一致的重放行为",
                "存储约束",
                "网络约束",
            ],
            answer: 1,
            rationale: "Temporal 指出工作流必须遵守 'deterministic constraints to maintain consistent replay behavior'。",
        },
        {
            id: "w5-2-q9",
            question: "编排式 Saga 的初始设置有什么特点？",
            options: [
                "非常简单",
                "需要更复杂的初始架构设置",
                "不需要任何设置",
                "自动完成",
            ],
            answer: 1,
            rationale: "Temporal 指出编排式 'More complex initial setup'，但长期来看更容易维护。",
        },
        {
            id: "w5-2-q10",
            question: "什么是统一编排器 vs 独立编排器的选择？",
            options: [
                "技术栈选择",
                "为所有 Saga 使用统一编排器还是每个 Saga 单独编排器",
                "部署方式选择",
                "数据库选择",
            ],
            answer: 1,
            rationale: "需要决定是为所有 Saga 使用统一编排器还是每个 Saga/工作流单独编排器。",
        },
        {
            id: "w5-2-q11",
            question: "Temporal 的关键特点是什么？",
            options: [
                "只能用于简单流程",
                "工作流可以运行多年，即使底层基础设施失败也能自动恢复",
                "不支持补偿",
                "只支持 Java",
            ],
            answer: 1,
            rationale: "Temporal 指出 'They can run—and keeping running—for years, even if the underlying infrastructure fails'。",
        },
        {
            id: "w5-2-q12",
            question: "编排式 vs 协同式的关键权衡是什么？",
            options: [
                "只有性能差异",
                "早期倾向协同式的轻量，但从一开始使用编排式往往更容易构建",
                "没有区别",
                "只有成本差异",
            ],
            answer: 1,
            rationale: "Temporal 指出：'orchestration is often easier to build when one uses it from the start'——从一开始使用编排式往往更容易。",
        },
    ],
    "w5-3": [
        {
            id: "w5-3-q1",
            question: "协同式 Saga 的核心特点是什么？",
            options: [
                "中央控制",
                "服务发布领域事件触发其他服务动作，无中央协调器",
                "同步调用",
                "共享数据库",
            ],
            answer: 1,
            rationale: "microservices.io 描述：'Each microservice emits an event after completing its task. Other services listen for events they care about and react accordingly'。",
        },
        {
            id: "w5-3-q2",
            question: "协同式 Saga 如何避免单点故障？",
            options: [
                "使用多个数据库",
                "去中心化架构，服务间松耦合",
                "使用缓存",
                "使用负载均衡",
            ],
            answer: 1,
            rationale: "AWS 指出协同式避免了单点故障，服务间松耦合，无需中央协调器。",
        },
        {
            id: "w5-3-q3",
            question: "协同式 Saga 的主要缺点是什么？",
            options: [
                "太简单",
                "控制流在代码库间不清晰，难以调试",
                "性能太好",
                "不支持事件",
            ],
            answer: 1,
            rationale: "Temporal 指出：'Control flow becomes unclear across codebases' 和 'Difficult to debug sequential event chains'。",
        },
        {
            id: "w5-3-q4",
            question: "什么情况下协同式比编排式更适合？",
            options: [
                "复杂的多步骤流程",
                "少数参与者、简单工作流、需要松耦合",
                "需要严格顺序",
                "需要集中控制",
            ],
            answer: 1,
            rationale: "AWS 指出协同式 '适用于少数参与者'，Temporal 指出适合 'highly independent microservices'。",
        },
        {
            id: "w5-3-q5",
            question: "为什么参与者过多时协同式会变得难以管理？",
            options: [
                "网络带宽不足",
                "服务间交互数量增加，难以追踪依赖关系",
                "存储不足",
                "计算资源不足",
            ],
            answer: 1,
            rationale: "AWS 指出：'As the number of microservices increases, saga choreography can become difficult to manage because of the number of interactions'。",
        },
        {
            id: "w5-3-q6",
            question: "协同式 Saga 为什么适合单体到微服务的迁移？",
            options: [
                "代码更少",
                "自然适配，服务逐步解耦的过程",
                "性能更好",
                "成本更低",
            ],
            answer: 1,
            rationale: "Temporal 指出协同式是 'Natural fit for monolith-to-microservices transitions'。",
        },
        {
            id: "w5-3-q7",
            question: "协同式 Saga 中业务逻辑的特点是什么？",
            options: [
                "集中在一处",
                "分散在整个系统中",
                "没有业务逻辑",
                "自动生成",
            ],
            answer: 1,
            rationale: "Temporal 指出：'Business logic scattered throughout the system'。",
        },
        {
            id: "w5-3-q8",
            question: "AWS EventBridge 在协同式 Saga 中扮演什么角色？",
            options: [
                "数据库",
                "事件驱动的消息中介",
                "缓存",
                "负载均衡器",
            ],
            answer: 1,
            rationale: "AWS 描述使用 EventBridge 作为事件驱动的消息中介，实现服务间的事件传递。",
        },
        {
            id: "w5-3-q9",
            question: "协同式 Saga 如何处理补偿？",
            options: [
                "不支持补偿",
                "失败时发布补偿事件，触发补偿操作",
                "自动回滚",
                "手动干预",
            ],
            answer: 1,
            rationale: "AWS 描述：失败时触发补偿操作，如 'Payment Failed → C2 (Inventory reversal) → C1 (Order cancellation)'。",
        },
        {
            id: "w5-3-q10",
            question: "如何解决协同式 Saga 的控制流不清晰问题？",
            options: [
                "减少服务数量",
                "使用 Correlation ID 追踪完整的事件链",
                "使用更快的网络",
                "增加日志",
            ],
            answer: 1,
            rationale: "使用 Correlation ID 追踪完整的事件链，实现端到端的可观测性。",
        },
        {
            id: "w5-3-q11",
            question: "协同式 Saga 对服务间耦合有什么影响？",
            options: [
                "增加耦合",
                "减少耦合，服务间通过事件松耦合",
                "没有影响",
                "完全解耦",
            ],
            answer: 1,
            rationale: "Temporal 指出协同式 'Decentralized and decoupled architecture'，服务间松耦合。",
        },
        {
            id: "w5-3-q12",
            question: "混合方法如何结合编排式和协同式？",
            options: [
                "不可能结合",
                "简单流程用协同式，复杂流程用编排式",
                "只能选一种",
                "自动切换",
            ],
            answer: 1,
            rationale: "文档指出：'simple flows handled by choreography and complex flows handled by orchestration'。",
        },
    ],
    "w5-4": [
        {
            id: "w5-4-q1",
            question: "补偿事务模式的定义是什么？",
            options: [
                "一种性能优化模式",
                "用于处理最终一致性操作，失败时执行补偿操作撤销之前步骤",
                "一种缓存模式",
                "一种安全模式",
            ],
            answer: 1,
            rationale: "Azure 定义补偿事务是 '用于处理最终一致性操作的设计模式'，失败时执行补偿操作。",
        },
        {
            id: "w5-4-q2",
            question: "为什么补偿步骤需要是幂等的？",
            options: [
                "提高性能",
                "确保失败重试时安全，多次执行产生相同结果",
                "减少存储",
                "简化代码",
            ],
            answer: 1,
            rationale: "Azure 指出：'补偿步骤应定义为幂等命令，确保失败重试时安全'。",
        },
        {
            id: "w5-4-q3",
            question: "Lost Updates 异常是什么？",
            options: [
                "数据丢失",
                "一个 Saga 的更新被另一个 Saga 覆盖",
                "网络丢包",
                "日志丢失",
            ],
            answer: 1,
            rationale: "文档定义 Lost Updates：'When one saga modifies data without considering changes made by another saga, resulting in overwritten or missing updates'。",
        },
        {
            id: "w5-4-q4",
            question: "Dirty Reads 异常是什么？",
            options: [
                "读取脏数据",
                "读取另一个 Saga 未完成的修改",
                "读取过期数据",
                "读取错误数据",
            ],
            answer: 1,
            rationale: "文档定义 Dirty Reads：'When a saga or transaction reads data that another saga has modified, but the modification isn't complete'。",
        },
        {
            id: "w5-4-q5",
            question: "语义锁（Semantic Lock）是什么？",
            options: [
                "数据库锁",
                "应用级锁，使用中间状态标记数据正在被 Saga 处理",
                "文件锁",
                "网络锁",
            ],
            answer: 1,
            rationale: "语义锁是应用级锁，例如订单状态从 SUBMITTED → PENDING → APPROVED，使用中间状态防止异常。",
        },
        {
            id: "w5-4-q6",
            question: "为什么补偿顺序可以灵活调整？",
            options: [
                "没有依赖关系",
                "某些撤销步骤可并行执行以提高效率",
                "顺序不重要",
                "自动确定顺序",
            ],
            answer: 1,
            rationale: "Azure 指出：'补偿事务不必完全按原操作的相反顺序执行'——某些撤销步骤可并行执行。",
        },
        {
            id: "w5-4-q7",
            question: "Reread Value 对策解决什么问题？",
            options: [
                "性能问题",
                "通过重读数据验证未被修改来防止脏写",
                "存储问题",
                "网络问题",
            ],
            answer: 1,
            rationale: "文档描述 Reread Value：'Prevent dirty writes by rereading data to verify that it's unchanged before overwriting it'。",
        },
        {
            id: "w5-4-q8",
            question: "补偿逻辑为什么需要考虑业务规则？",
            options: [
                "简化实现",
                "撤销操作可能涉及退款政策等业务规则，不仅是恢复原始状态",
                "提高性能",
                "减少代码",
            ],
            answer: 1,
            rationale: "Azure 指出补偿逻辑需考虑特定的业务规则，如退款政策——'也许提供备选酒店比完全取消更优'。",
        },
        {
            id: "w5-4-q9",
            question: "Version File 对策的作用是什么？",
            options: [
                "版本控制",
                "记录更新使其可以重排序",
                "文件备份",
                "日志记录",
            ],
            answer: 1,
            rationale: "文档描述 Version File：'Record the updates to a record so that they can be reordered'。",
        },
        {
            id: "w5-4-q10",
            question: "Pessimistic View 对策是什么？",
            options: [
                "悲观的态度",
                "重排 Saga 步骤以最小化业务风险",
                "增加锁",
                "减少并发",
            ],
            answer: 1,
            rationale: "文档描述 Pessimistic View：'Reorder the steps of a saga to minimize business risk'。",
        },
        {
            id: "w5-4-q11",
            question: "什么时候需要人工干预补偿？",
            options: [
                "总是需要",
                "当补偿事务本身失败且无法自动恢复时",
                "从不需要",
                "每次补偿都需要",
            ],
            answer: 1,
            rationale: "Azure 指出需要时进行人工干预，特别是补偿事务本身失败时需要手动处理。",
        },
        {
            id: "w5-4-q12",
            question: "By Value 对策的作用是什么？",
            options: [
                "按值传递",
                "根据请求的业务风险动态选择并发机制",
                "值排序",
                "值计算",
            ],
            answer: 1,
            rationale: "文档描述 By Value：'Use each request's business risk to dynamically select the concurrency mechanism'。",
        },
    ],
}
