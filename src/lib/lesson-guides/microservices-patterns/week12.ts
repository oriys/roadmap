import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week12Guides: Record<string, LessonGuide> = {
    "w12-1": {
        lessonId: "w12-1",
        background: [
            "【Service per Container】microservices.io：'Package the service as a container image and deploy each service instance as a container'——每个服务打包为容器镜像并作为容器实例部署。",
            "【容器优势】容器提供隔离性、资源限制、快速启动，是微服务部署的事实标准。",
            "【Serverless 定义】microservices.io：'Use a deployment infrastructure that hides any concept of servers'——使用隐藏服务器概念的部署基础设施。",
            "【Serverless 优势】'Eliminates the need to spend time on the undifferentiated heavy lifting of managing low-level infrastructure'——消除管理底层基础设施的负担。",
            "【部署平台】microservices.io：Service Deployment Platform 'automates the deployment of services' 并提供服务管理、监控、日志等功能。",
        ],
        keyDifficulties: [
            "【容器编排】单独使用容器不够，需要 Kubernetes 等编排平台管理服务发现、负载均衡、自动伸缩。",
            "【Serverless 限制】microservices.io 警告：'requests must complete within a timeout' 和 'services must be stateless'——超时限制和无状态要求。",
            "【冷启动问题】Serverless 函数首次调用可能有延迟（冷启动），影响延迟敏感的应用。",
            "【成本模型】容器按预留资源计费，Serverless 按调用次数和执行时间计费——需要根据流量模式选择。",
            "【调试复杂性】Serverless 的分布式特性增加了调试和故障排查的难度。",
        ],
        handsOnPath: [
            "编写 Dockerfile：为服务创建优化的多阶段构建 Dockerfile。",
            "构建镜像：使用 docker build 构建并推送到镜像仓库。",
            "部署到 Kubernetes：创建 Deployment 和 Service 资源。",
            "部署到 Serverless：使用 AWS Lambda 或 Cloud Functions 部署函数。",
            "配置自动伸缩：设置 HPA（Horizontal Pod Autoscaler）或 Serverless 并发限制。",
            "比较成本和性能：分析不同部署方式的成本和延迟。",
        ],
        selfCheck: [
            "Service per Container 模式的定义是什么？",
            "Serverless Deployment 的主要优势是什么？",
            "Serverless 有哪些限制？",
            "什么情况下选择容器部署？什么情况下选择 Serverless？",
            "什么是冷启动问题？如何缓解？",
            "Service Deployment Platform 提供哪些功能？",
        ],
        extensions: [
            "研究 Kubernetes Operator 模式自动化服务管理。",
            "探索 Knative 实现容器化 Serverless。",
            "学习 AWS Fargate 的无服务器容器方案。",
            "了解边缘计算（Edge Computing）的部署模式。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/deployment/service-per-container.html",
            "https://microservices.io/patterns/deployment/serverless-deployment.html",
            "https://microservices.io/patterns/deployment/service-deployment-platform.html",
        ],
    },
    "w12-2": {
        lessonId: "w12-2",
        background: [
            "【Microservice Chassis 定义】microservices.io：'Build services on a framework or collection of frameworks that handle cross-cutting concerns'——在处理横切关注点的框架上构建服务。",
            "【解决的问题】每个服务都需要处理 'externalized configuration, logging, health checks, metrics, service registration and discovery, circuit breakers' 等横切关注点。",
            "【不重复造轮】microservices.io：'It is too time consuming to implement these concerns from scratch for each service you develop'——从头实现这些关注点太耗时。",
            "【Externalized Configuration】microservices.io：'Externalize configuration such as database location and credentials'——外部化数据库位置和凭证等配置。",
            "【实现示例】Java/Spring 生态有 Spring Boot + Spring Cloud；Go 有 Go Kit、Micro；其他语言也有对应框架。",
        ],
        keyDifficulties: [
            "【语言绑定】microservices.io 警告：'Microservice chassis creates a technology lock-in for your services'——绑定到特定语言/框架。",
            "【多语言挑战】'You need a microservice chassis for each programming language/framework you want to use'——每种语言需要对应的 chassis。",
            "【配置管理复杂性】外部化配置需要处理：配置中心选型、安全存储、动态刷新、版本管理。",
            "【框架学习成本】Spring Cloud 功能强大但学习曲线陡峭；轻量框架功能可能不够完整。",
            "【Service Template 替代】对于多语言团队，可以使用 Service Template 模式创建代码模板而非框架依赖。",
        ],
        handsOnPath: [
            "选择 Chassis 框架：根据团队语言栈选择 Spring Boot、Go Kit 或其他框架。",
            "配置外部化：使用 Spring Cloud Config 或 Consul 存储配置。",
            "集成健康检查：实现 /health 端点并集成到部署平台。",
            "添加指标导出：集成 Micrometer 或 Prometheus 客户端。",
            "配置服务注册：集成 Consul 或 Eureka 客户端。",
            "创建 Service Template：为团队创建服务脚手架模板。",
        ],
        selfCheck: [
            "Microservice Chassis 模式的定义是什么？",
            "Chassis 解决哪些横切关注点？",
            "Microservice Chassis 的主要劣势是什么？",
            "Externalized Configuration 为什么重要？",
            "Service Template 与 Microservice Chassis 的区别是什么？",
            "常见的 Microservice Chassis 实现有哪些？",
        ],
        extensions: [
            "研究 Dapr（Distributed Application Runtime）的 sidecar 方式。",
            "探索 Service Mesh 如何处理横切关注点。",
            "学习 Spring Cloud Alibaba 的微服务组件。",
            "了解 Quarkus 和 Micronaut 的云原生特性。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/microservice-chassis.html",
            "https://microservices.io/patterns/externalized-configuration.html",
            "https://microservices.io/patterns/service-template.html",
        ],
    },
    "w12-3": {
        lessonId: "w12-3",
        background: [
            "【Log Aggregation 定义】microservices.io：'Use a centralized logging service that aggregates logs from each service instance'——使用集中日志服务聚合各服务实例的日志。",
            "【解决的问题】微服务产生大量日志分散在多个实例，'The log files are scattered across the hosts'——需要集中查看和搜索。",
            "【Distributed Tracing 定义】microservices.io：'Assign each external request a unique external request id. Pass the id to all services'——为每个外部请求分配唯一 ID 并传递给所有服务。",
            "【Application Metrics 定义】microservices.io：'Services report metrics to a central server that provides aggregation, visualization, and alerting'——服务向中央服务器报告指标。",
            "【三大支柱】可观测性三大支柱：Logs（事件）、Metrics（聚合数值）、Traces（请求路径）——三者互补。",
        ],
        keyDifficulties: [
            "【日志量挑战】microservices.io：日志聚合需要处理高吞吐量、存储成本、查询性能。",
            "【Trace 传播】分布式追踪需要在所有服务间传播 Trace ID，使用标准如 W3C Trace Context 或 B3。",
            "【指标选择】需要选择有意义的指标：请求量、错误率、延迟（RED 方法）或 USE 方法。",
            "【采样策略】高流量系统无法记录所有 Trace，需要智能采样策略。",
            "【工具选型】ELK/EFK（日志）、Prometheus/Grafana（指标）、Jaeger/Zipkin（追踪）——需要集成。",
        ],
        handsOnPath: [
            "部署日志聚合：使用 EFK（Elasticsearch、Fluentd、Kibana）或 Loki 部署日志系统。",
            "配置日志 Agent：在每个节点部署 Fluentd 或 Fluent Bit 收集日志。",
            "集成分布式追踪：添加 OpenTelemetry SDK 并配置 Trace 导出。",
            "部署 Jaeger：部署 Jaeger 作为追踪后端并配置采样。",
            "配置指标收集：部署 Prometheus 并配置服务发现。",
            "创建 Dashboard：在 Grafana 中创建服务监控仪表板。",
        ],
        selfCheck: [
            "Log Aggregation 模式的定义是什么？",
            "Distributed Tracing 如何工作？",
            "Application Metrics 报告什么信息？",
            "可观测性的三大支柱是什么？",
            "什么是 RED 方法？什么是 USE 方法？",
            "常用的可观测性工具栈有哪些？",
        ],
        extensions: [
            "研究 OpenTelemetry 统一可观测性数据收集。",
            "探索 SLI/SLO/SLA 和错误预算。",
            "学习 Continuous Profiling 和火焰图分析。",
            "了解 AIOps 和智能告警。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/observability/log-aggregation.html",
            "https://microservices.io/patterns/observability/distributed-tracing.html",
            "https://microservices.io/patterns/observability/application-metrics.html",
        ],
    },
    "w12-4": {
        lessonId: "w12-4",
        background: [
            "【Health Check API 定义】microservices.io：'A service has a health check API endpoint (e.g. GET /health) that returns the health of the service'——服务暴露健康检查端点返回服务健康状态。",
            "【健康检查用途】部署基础设施（如 Kubernetes）使用健康检查决定是否路由流量到实例，以及是否重启不健康实例。",
            "【两种探针】Kubernetes 区分 Liveness Probe（存活探针，失败则重启）和 Readiness Probe（就绪探针，失败则停止流量）。",
            "【Exception Tracking 定义】microservices.io：'Services report exceptions to a centralized exception tracking service that aggregates and tracks exceptions'——服务向集中异常追踪服务报告异常。",
            "【异常追踪优势】集中追踪异常可以发现趋势、去重、关联到用户和请求，比扫描日志更高效。",
        ],
        keyDifficulties: [
            "【健康检查深度】浅层检查（服务进程存活）vs 深层检查（依赖可用性）——需要权衡响应时间和准确性。",
            "【级联故障风险】microservices.io 警告：深层健康检查可能导致级联故障——一个依赖不可用导致所有服务被标记为不健康。",
            "【探针配置】需要正确配置 initialDelaySeconds、periodSeconds、failureThreshold，避免误杀或延迟检测。",
            "【异常去重】同一异常可能在多个实例重复出现，需要智能聚合和去重。",
            "【告警疲劳】过多告警导致团队忽视，需要设置合理的告警阈值和分级。",
        ],
        handsOnPath: [
            "实现健康检查端点：创建 /health 或 /healthz 端点返回服务状态。",
            "实现依赖检查：检查数据库、缓存等依赖的连接状态。",
            "配置 Kubernetes 探针：在 Deployment 中配置 livenessProbe 和 readinessProbe。",
            "集成异常追踪：集成 Sentry 或类似服务捕获和报告异常。",
            "配置告警规则：在 Prometheus/Alertmanager 中配置告警。",
            "创建 Runbook：为常见告警编写处理手册。",
        ],
        selfCheck: [
            "Health Check API 模式的定义是什么？",
            "Liveness Probe 和 Readiness Probe 的区别是什么？",
            "深层健康检查的风险是什么？",
            "Exception Tracking 的优势是什么？",
            "如何避免告警疲劳？",
            "健康检查应该检查哪些内容？",
        ],
        extensions: [
            "研究 Startup Probe 处理慢启动应用。",
            "探索 PagerDuty/OpsGenie 的 On-Call 管理。",
            "学习 Chaos Engineering 验证系统弹性。",
            "了解 SRE（Site Reliability Engineering）实践。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/observability/health-check-api.html",
            "https://microservices.io/patterns/observability/exception-tracking.html",
            "https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/",
        ],
    },
}

export const week12Quizzes: Record<string, QuizQuestion[]> = {
    "w12-1": [
        {
            id: "w12-1-q1",
            question: "根据 microservices.io，Service per Container 模式的定义是什么？",
            options: [
                "每个容器运行多个服务",
                "将服务打包为容器镜像并作为容器实例部署",
                "使用虚拟机部署服务",
                "直接在物理机上部署服务",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Package the service as a container image and deploy each service instance as a container'。",
        },
        {
            id: "w12-1-q2",
            question: "根据 microservices.io，Serverless Deployment 的主要优势是什么？",
            options: [
                "更高的性能",
                "消除管理底层基础设施的负担",
                "更低的延迟",
                "更好的安全性",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'Eliminates the need to spend time on the undifferentiated heavy lifting of managing low-level infrastructure'。",
        },
        {
            id: "w12-1-q3",
            question: "Serverless Deployment 的主要限制有哪些？",
            options: [
                "不支持任何语言",
                "请求必须在超时内完成，服务必须无状态",
                "只能部署 Java 服务",
                "不支持 HTTP 协议",
            ],
            answer: 1,
            rationale: "microservices.io 警告：'requests must complete within a timeout' 和 'services must be stateless'。",
        },
        {
            id: "w12-1-q4",
            question: "什么是冷启动问题？",
            options: [
                "服务器温度过低",
                "Serverless 函数首次调用时的延迟",
                "数据库连接失败",
                "网络超时",
            ],
            answer: 1,
            rationale: "Serverless 函数在首次调用或长时间未调用后，需要初始化运行环境，导致额外延迟。",
        },
        {
            id: "w12-1-q5",
            question: "Service Deployment Platform 提供哪些功能？",
            options: [
                "只提供部署功能",
                "自动化部署、服务管理、监控、日志等功能",
                "只提供监控功能",
                "只提供日志功能",
            ],
            answer: 1,
            rationale: "microservices.io 指出 Service Deployment Platform 'automates the deployment of services' 并提供服务管理、监控、日志等功能。",
        },
        {
            id: "w12-1-q6",
            question: "容器部署相比虚拟机的优势是什么？",
            options: [
                "更大的隔离性",
                "更快的启动速度和更低的资源开销",
                "更好的安全性",
                "更简单的配置",
            ],
            answer: 1,
            rationale: "容器提供快速启动、轻量级隔离和资源限制，比虚拟机更高效。",
        },
        {
            id: "w12-1-q7",
            question: "什么情况下更适合使用 Serverless 部署？",
            options: [
                "持续高负载的服务",
                "流量波动大、有明显空闲期的服务",
                "需要长连接的服务",
                "需要大量状态的服务",
            ],
            answer: 1,
            rationale: "Serverless 按调用计费，适合流量波动大的场景；持续高负载使用容器更经济。",
        },
        {
            id: "w12-1-q8",
            question: "Kubernetes 中 HPA 的作用是什么？",
            options: [
                "健康检查",
                "根据负载自动调整 Pod 副本数",
                "服务发现",
                "日志收集",
            ],
            answer: 1,
            rationale: "HPA（Horizontal Pod Autoscaler）根据 CPU、内存或自定义指标自动调整 Pod 副本数。",
        },
        {
            id: "w12-1-q9",
            question: "多阶段构建 Dockerfile 的优势是什么？",
            options: [
                "构建更慢",
                "最终镜像更小，不包含构建工具",
                "更难调试",
                "不支持任何语言",
            ],
            answer: 1,
            rationale: "多阶段构建将构建环境和运行环境分离，最终镜像只包含运行时必要文件，体积更小。",
        },
        {
            id: "w12-1-q10",
            question: "AWS Lambda 的执行时间限制是多少？",
            options: [
                "1 分钟",
                "15 分钟",
                "1 小时",
                "无限制",
            ],
            answer: 1,
            rationale: "AWS Lambda 函数的最大执行时间为 15 分钟，超过此时间会被强制终止。",
        },
        {
            id: "w12-1-q11",
            question: "Knative 是什么？",
            options: [
                "容器运行时",
                "在 Kubernetes 上实现 Serverless 的平台",
                "消息队列",
                "数据库",
            ],
            answer: 1,
            rationale: "Knative 是在 Kubernetes 上运行的 Serverless 平台，提供自动伸缩（包括缩放到零）。",
        },
        {
            id: "w12-1-q12",
            question: "容器和 Serverless 的计费模式有什么区别？",
            options: [
                "完全相同",
                "容器按预留资源计费，Serverless 按调用次数和执行时间计费",
                "都按调用次数计费",
                "都按预留资源计费",
            ],
            answer: 1,
            rationale: "容器通常按预留的 CPU、内存等资源计费；Serverless 按实际调用次数和执行时间计费。",
        },
    ],
    "w12-2": [
        {
            id: "w12-2-q1",
            question: "根据 microservices.io，Microservice Chassis 模式的定义是什么？",
            options: [
                "硬件底座",
                "在处理横切关注点的框架上构建服务",
                "容器编排平台",
                "消息队列框架",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Build services on a framework or collection of frameworks that handle cross-cutting concerns'。",
        },
        {
            id: "w12-2-q2",
            question: "Microservice Chassis 处理哪些横切关注点？",
            options: [
                "只处理日志",
                "配置、日志、健康检查、指标、服务注册发现、熔断器等",
                "只处理认证",
                "只处理数据库",
            ],
            answer: 1,
            rationale: "microservices.io 列出：'externalized configuration, logging, health checks, metrics, service registration and discovery, circuit breakers'。",
        },
        {
            id: "w12-2-q3",
            question: "Microservice Chassis 的主要劣势是什么？",
            options: [
                "性能太低",
                "绑定到特定语言/框架，每种语言需要对应的 chassis",
                "功能太少",
                "不支持云部署",
            ],
            answer: 1,
            rationale: "microservices.io 警告：'Microservice chassis creates a technology lock-in' 和 'You need a microservice chassis for each programming language/framework'。",
        },
        {
            id: "w12-2-q4",
            question: "Externalized Configuration 的定义是什么？",
            options: [
                "将配置硬编码在代码中",
                "将数据库位置和凭证等配置外部化",
                "不使用配置",
                "只在启动时读取配置",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Externalize configuration such as database location and credentials'。",
        },
        {
            id: "w12-2-q5",
            question: "Java/Spring 生态的 Microservice Chassis 是什么？",
            options: [
                "Django",
                "Spring Boot + Spring Cloud",
                "Ruby on Rails",
                "Express.js",
            ],
            answer: 1,
            rationale: "Java/Spring 生态的 Microservice Chassis 包括 Spring Boot 和 Spring Cloud 组件。",
        },
        {
            id: "w12-2-q6",
            question: "Service Template 与 Microservice Chassis 的区别是什么？",
            options: [
                "没有区别",
                "Template 是代码模板，Chassis 是框架依赖",
                "Template 更复杂",
                "Chassis 不需要代码",
            ],
            answer: 1,
            rationale: "Service Template 创建代码脚手架模板，减少框架依赖；Microservice Chassis 是运行时框架依赖。",
        },
        {
            id: "w12-2-q7",
            question: "外部化配置需要处理哪些问题？",
            options: [
                "只需要存储配置",
                "配置中心选型、安全存储、动态刷新、版本管理",
                "只需要读取配置",
                "不需要考虑安全",
            ],
            answer: 1,
            rationale: "外部化配置需要处理：配置中心选型（Consul、Spring Cloud Config）、安全存储敏感信息、动态刷新、版本管理。",
        },
        {
            id: "w12-2-q8",
            question: "Go 语言的 Microservice Chassis 有哪些？",
            options: [
                "Spring Boot",
                "Go Kit、Micro",
                "Django",
                "Express",
            ],
            answer: 1,
            rationale: "Go 语言的 Microservice Chassis 实现包括 Go Kit 和 Micro 框架。",
        },
        {
            id: "w12-2-q9",
            question: "为什么不应该从头实现横切关注点？",
            options: [
                "技术限制",
                "太耗时，且容易出错",
                "法规要求",
                "不可能实现",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'It is too time consuming to implement these concerns from scratch for each service you develop'。",
        },
        {
            id: "w12-2-q10",
            question: "Dapr 是什么？",
            options: [
                "数据库",
                "分布式应用运行时，使用 sidecar 方式处理横切关注点",
                "消息队列",
                "容器运行时",
            ],
            answer: 1,
            rationale: "Dapr（Distributed Application Runtime）通过 sidecar 代理方式处理横切关注点，语言无关。",
        },
        {
            id: "w12-2-q11",
            question: "Spring Cloud Config 的作用是什么？",
            options: [
                "服务发现",
                "集中管理微服务配置",
                "负载均衡",
                "熔断器",
            ],
            answer: 1,
            rationale: "Spring Cloud Config 提供集中化的配置管理，支持 Git、文件系统等后端存储配置。",
        },
        {
            id: "w12-2-q12",
            question: "多语言微服务环境应该如何处理横切关注点？",
            options: [
                "为每种语言实现完整的 Chassis",
                "使用 Service Mesh 或 Dapr 等语言无关方案",
                "只使用一种语言",
                "不处理横切关注点",
            ],
            answer: 1,
            rationale: "多语言环境可以使用 Service Mesh（如 Istio）或 Dapr 等语言无关的方案，通过 sidecar 处理横切关注点。",
        },
    ],
    "w12-3": [
        {
            id: "w12-3-q1",
            question: "根据 microservices.io，Log Aggregation 模式的定义是什么？",
            options: [
                "在每个服务本地存储日志",
                "使用集中日志服务聚合各服务实例的日志",
                "删除所有日志",
                "只保留错误日志",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Use a centralized logging service that aggregates logs from each service instance'。",
        },
        {
            id: "w12-3-q2",
            question: "Distributed Tracing 如何工作？",
            options: [
                "随机生成请求 ID",
                "为每个外部请求分配唯一 ID 并传递给所有服务",
                "不使用任何 ID",
                "只在网关生成 ID",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Assign each external request a unique external request id. Pass the id to all services'。",
        },
        {
            id: "w12-3-q3",
            question: "Application Metrics 模式的定义是什么？",
            options: [
                "不收集任何指标",
                "服务向中央服务器报告指标，提供聚合、可视化和告警",
                "只收集 CPU 使用率",
                "只在本地显示指标",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Services report metrics to a central server that provides aggregation, visualization, and alerting'。",
        },
        {
            id: "w12-3-q4",
            question: "可观测性的三大支柱是什么？",
            options: [
                "CPU、内存、磁盘",
                "Logs、Metrics、Traces",
                "HTTP、TCP、UDP",
                "读、写、删除",
            ],
            answer: 1,
            rationale: "可观测性三大支柱：Logs（事件日志）、Metrics（聚合数值指标）、Traces（分布式请求追踪）。",
        },
        {
            id: "w12-3-q5",
            question: "什么是 RED 方法？",
            options: [
                "颜色编码方法",
                "Rate（请求率）、Errors（错误率）、Duration（延迟）",
                "日志分析方法",
                "代码审查方法",
            ],
            answer: 1,
            rationale: "RED 方法关注三个关键指标：Rate（请求率）、Errors（错误率）、Duration（请求延迟）。",
        },
        {
            id: "w12-3-q6",
            question: "ELK/EFK 栈中的组件分别是什么？",
            options: [
                "数据库组件",
                "Elasticsearch（存储搜索）、Logstash/Fluentd（收集）、Kibana（可视化）",
                "网络组件",
                "安全组件",
            ],
            answer: 1,
            rationale: "ELK 栈：Elasticsearch（存储和搜索）、Logstash（日志收集处理）、Kibana（可视化）；EFK 用 Fluentd 替代 Logstash。",
        },
        {
            id: "w12-3-q7",
            question: "分布式追踪的采样策略为什么重要？",
            options: [
                "不重要",
                "高流量系统无法记录所有 Trace，需要智能采样平衡成本和可见性",
                "只是为了减少代码",
                "法规要求",
            ],
            answer: 1,
            rationale: "高流量系统记录所有 Trace 成本过高，需要采样策略（如基于错误、延迟或概率采样）平衡成本和可见性。",
        },
        {
            id: "w12-3-q8",
            question: "W3C Trace Context 是什么？",
            options: [
                "日志格式",
                "分布式追踪的标准 HTTP 头格式，用于传播 Trace ID",
                "指标格式",
                "配置格式",
            ],
            answer: 1,
            rationale: "W3C Trace Context 是分布式追踪的标准，定义了 traceparent 和 tracestate HTTP 头用于传播追踪信息。",
        },
        {
            id: "w12-3-q9",
            question: "Jaeger 和 Zipkin 是什么？",
            options: [
                "日志系统",
                "分布式追踪系统",
                "指标系统",
                "配置系统",
            ],
            answer: 1,
            rationale: "Jaeger 和 Zipkin 都是开源的分布式追踪系统，用于收集、存储和可视化 Trace 数据。",
        },
        {
            id: "w12-3-q10",
            question: "OpenTelemetry 的作用是什么？",
            options: [
                "只收集日志",
                "统一收集 Logs、Metrics、Traces 的开源标准和 SDK",
                "只收集指标",
                "只做告警",
            ],
            answer: 1,
            rationale: "OpenTelemetry 是 CNCF 项目，提供统一的 API、SDK 和工具收集 Logs、Metrics、Traces。",
        },
        {
            id: "w12-3-q11",
            question: "Prometheus 的数据模型是什么？",
            options: [
                "关系型数据库",
                "时间序列数据库，使用标签（labels）标识指标",
                "文档数据库",
                "图数据库",
            ],
            answer: 1,
            rationale: "Prometheus 使用时间序列数据模型，每个指标由名称和键值对标签（labels）标识。",
        },
        {
            id: "w12-3-q12",
            question: "日志聚合面临的主要挑战是什么？",
            options: [
                "日志太少",
                "高吞吐量、存储成本、查询性能",
                "格式太统一",
                "没有挑战",
            ],
            answer: 1,
            rationale: "日志聚合需要处理：高吞吐量（微服务产生大量日志）、存储成本、查询性能等挑战。",
        },
    ],
    "w12-4": [
        {
            id: "w12-4-q1",
            question: "根据 microservices.io，Health Check API 模式的定义是什么？",
            options: [
                "检查代码质量",
                "服务暴露健康检查端点返回服务健康状态",
                "检查数据库",
                "检查网络",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'A service has a health check API endpoint (e.g. GET /health) that returns the health of the service'。",
        },
        {
            id: "w12-4-q2",
            question: "Kubernetes 的 Liveness Probe 和 Readiness Probe 的区别是什么？",
            options: [
                "没有区别",
                "Liveness 失败重启容器，Readiness 失败停止路由流量",
                "Readiness 失败重启容器",
                "都会重启容器",
            ],
            answer: 1,
            rationale: "Liveness Probe 失败会重启容器；Readiness Probe 失败会将 Pod 从 Service 端点移除，停止路由流量。",
        },
        {
            id: "w12-4-q3",
            question: "深层健康检查的风险是什么？",
            options: [
                "检查太快",
                "一个依赖不可用可能导致所有服务被标记为不健康",
                "检查太简单",
                "没有风险",
            ],
            answer: 1,
            rationale: "microservices.io 警告：深层健康检查可能导致级联故障——一个依赖不可用导致所有服务被标记为不健康。",
        },
        {
            id: "w12-4-q4",
            question: "Exception Tracking 的定义是什么？",
            options: [
                "忽略所有异常",
                "服务向集中异常追踪服务报告异常",
                "只记录本地日志",
                "只发送邮件",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Services report exceptions to a centralized exception tracking service that aggregates and tracks exceptions'。",
        },
        {
            id: "w12-4-q5",
            question: "健康检查应该检查哪些内容？",
            options: [
                "只检查进程存活",
                "服务状态、依赖连接（数据库、缓存等）",
                "只检查 CPU",
                "只检查内存",
            ],
            answer: 1,
            rationale: "健康检查应包括：服务进程状态、数据库连接、缓存连接、必要的外部依赖等。",
        },
        {
            id: "w12-4-q6",
            question: "Kubernetes 中 initialDelaySeconds 的作用是什么？",
            options: [
                "设置超时时间",
                "设置首次探测前的等待时间，让应用完成启动",
                "设置探测间隔",
                "设置失败阈值",
            ],
            answer: 1,
            rationale: "initialDelaySeconds 指定容器启动后等待多少秒才开始探测，避免在应用启动过程中误判。",
        },
        {
            id: "w12-4-q7",
            question: "如何避免告警疲劳？",
            options: [
                "关闭所有告警",
                "设置合理的告警阈值和分级",
                "只发送邮件",
                "忽略所有告警",
            ],
            answer: 1,
            rationale: "避免告警疲劳需要：设置合理的阈值、告警分级（P1-P4）、去重、静默策略等。",
        },
        {
            id: "w12-4-q8",
            question: "Sentry 是什么类型的工具？",
            options: [
                "日志聚合工具",
                "异常追踪工具",
                "指标收集工具",
                "分布式追踪工具",
            ],
            answer: 1,
            rationale: "Sentry 是异常追踪工具，用于捕获、聚合和分析应用异常。",
        },
        {
            id: "w12-4-q9",
            question: "Startup Probe 的作用是什么？",
            options: [
                "替代 Liveness Probe",
                "处理慢启动应用，在启动完成前禁用其他探针",
                "替代 Readiness Probe",
                "检查网络",
            ],
            answer: 1,
            rationale: "Startup Probe 用于慢启动应用，在启动完成前禁用 Liveness 和 Readiness 探针，避免被误杀。",
        },
        {
            id: "w12-4-q10",
            question: "浅层健康检查和深层健康检查的区别是什么？",
            options: [
                "没有区别",
                "浅层只检查进程存活，深层检查依赖可用性",
                "深层更快",
                "浅层更准确",
            ],
            answer: 1,
            rationale: "浅层检查只验证服务进程存活；深层检查还验证数据库、缓存等依赖的可用性。",
        },
        {
            id: "w12-4-q11",
            question: "Runbook 是什么？",
            options: [
                "运行日志",
                "告警处理手册，描述如何响应特定告警",
                "代码文档",
                "测试计划",
            ],
            answer: 1,
            rationale: "Runbook 是告警处理手册，描述如何诊断和解决特定告警，帮助 On-Call 工程师快速响应。",
        },
        {
            id: "w12-4-q12",
            question: "异常追踪相比日志扫描的优势是什么？",
            options: [
                "更慢",
                "自动聚合、去重、关联到用户和请求，更高效",
                "信息更少",
                "不需要集成",
            ],
            answer: 1,
            rationale: "异常追踪可以自动聚合相同异常、去重、关联到用户和请求上下文，比手动扫描日志更高效。",
        },
    ],
}
