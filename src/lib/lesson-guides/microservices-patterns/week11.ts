import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week11Guides: Record<string, LessonGuide> = {
    "w11-1": {
        lessonId: "w11-1",
        background: [
            "【测试金字塔】Fowler：测试金字塔建议 'Write lots of small and fast unit tests. Write some more coarse-grained tests and very few high-level tests'。",
            "【三层结构】单元测试（底层，最多）→ 集成测试（中层）→ 端到端测试（顶层，最少），越往下越快越便宜。",
            "【微服务挑战】Fowler：'Once these additional network partitions have been introduced, the testing strategies that applied for monolithic applications need to be reconsidered'。",
            "【五种测试类型】微服务测试包括：Unit Testing、Integration Testing、Component Testing、Contract Testing、End-to-End Testing。",
            "【速度与范围】测试越往下，速度越快、隔离性越好；测试越往上，覆盖范围越广但速度越慢、越脆弱。",
        ],
        keyDifficulties: [
            "【避免重复】Fowler：'Push tests as far down the pyramid as feasible'——避免在多层重复测试相同逻辑。",
            "【端到端测试问题】E2E 测试 'difficult, slow, brittle, and expensive'——难以维护且不稳定。",
            "【测试行为而非实现】Fowler：'Test behavior, not implementation'——测试实现细节会导致脆弱测试。",
            "【集成测试范围】集成测试应聚焦单个集成点，不是测试整个系统。",
            "【探索性测试】自动化无法替代手动探索性测试，它能发现设计和可用性问题。",
        ],
        handsOnPath: [
            "设计测试策略：根据服务特点规划测试金字塔各层的比例。",
            "编写单元测试：使用 JUnit/Jest 等框架测试业务逻辑。",
            "编写集成测试：测试数据库、缓存等外部依赖的集成。",
            "使用 Testcontainers：启动真实数据库容器进行集成测试。",
            "设置 CI 流水线：配置测试在每次提交时自动运行。",
            "监控测试覆盖率：使用工具跟踪测试覆盖率变化。",
        ],
        selfCheck: [
            "测试金字塔的三层结构是什么？",
            "为什么单元测试应该是最多的？",
            "微服务架构对测试策略有什么影响？",
            "端到端测试有什么缺点？",
            "为什么应该测试行为而非实现？",
            "探索性测试的作用是什么？",
        ],
        extensions: [
            "研究测试替身（Test Doubles）的类型：Stub、Mock、Fake、Spy。",
            "探索测试驱动开发（TDD）在微服务中的应用。",
            "学习行为驱动开发（BDD）和 Cucumber。",
            "了解混沌工程和故障注入测试。",
        ],
        sourceUrls: [
            "https://martinfowler.com/articles/microservice-testing/",
            "https://martinfowler.com/articles/practical-test-pyramid.html",
            "https://microservices.io/testing/index.html",
        ],
    },
    "w11-2": {
        lessonId: "w11-2",
        background: [
            "【模式定义】消费者驱动契约测试是由消费服务的开发者编写测试套件，验证提供者服务满足消费者的期望。",
            "【核心问题】microservices.io：'How to easily test that a service provides an API that its clients expect?'",
            "【消费者驱动】Pact：消费者定义契约（期望），提供者验证是否符合契约，'only parts of the communication that are actually used by the consumer(s) get tested'。",
            "【契约测试优势】Fowler：契约测试可以 'alert teams when external service contracts change, preventing surprise production failures'。",
            "【Pact 工具】Pact 是 'code-first consumer-driven contract testing tool'，在测试执行期间自动生成契约。",
        ],
        keyDifficulties: [
            "【测试双重性】契约测试需要在两端运行：消费者端生成契约，提供者端验证契约。",
            "【契约共享】需要机制共享契约（通常使用 Pact Broker 或 Git 仓库）。",
            "【版本管理】多个消费者可能有不同版本的契约，提供者需要满足所有活跃契约。",
            "【实例测试 vs 模式测试】Fowler：契约测试 'verify the format and structure of service responses rather than specific data values'。",
            "【团队协作】需要消费者和提供者团队的协作，共同维护契约。",
        ],
        handsOnPath: [
            "定义消费者期望：在消费者端编写测试定义对提供者的期望。",
            "生成契约文件：运行消费者测试，生成 Pact 契约文件。",
            "发布契约：将契约发布到 Pact Broker 或共享仓库。",
            "提供者验证：在提供者端运行验证测试，确保满足所有消费者契约。",
            "集成 CI/CD：将契约测试集成到持续集成流水线。",
            "处理契约变更：建立契约变更的通知和协商流程。",
        ],
        selfCheck: [
            "消费者驱动契约测试的定义是什么？",
            "为什么叫「消费者驱动」？",
            "Pact 是什么？它如何工作？",
            "契约测试与端到端测试的区别是什么？",
            "契约测试如何帮助团队协作？",
            "如何处理多个消费者的契约？",
        ],
        extensions: [
            "研究 Spring Cloud Contract 的使用。",
            "探索 Pact Broker 的高级功能。",
            "学习异步消息的契约测试（Pact Message）。",
            "了解 OpenAPI 规范与契约测试的关系。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/testing/service-integration-contract-test.html",
            "https://docs.pact.io/",
            "https://martinfowler.com/bliki/ContractTest.html",
        ],
    },
    "w11-3": {
        lessonId: "w11-3",
        background: [
            "【模式定义】microservices.io：Service Component Test 是 'A test suite that tests a service in isolation using test doubles for any services that it invokes'。",
            "【解决问题】端到端测试（跨多服务）'difficult, slow, brittle, and expensive'，组件测试在隔离环境中测试单个服务。",
            "【核心优势】microservices.io：'Testing a service in isolation is easier, faster, more reliable and cheap'。",
            "【Testcontainers】Testcontainers 是 'an open source library for providing throwaway, lightweight instances of databases, message brokers' 等依赖。",
            "【测试范围】组件测试验证服务的完整功能，包括 API 端点、业务逻辑、数据库交互。",
        ],
        keyDifficulties: [
            "【假阳性风险】microservices.io 警告：'Tests might pass but the application will fail in production'——隔离测试可能遗漏集成问题。",
            "【测试替身准确性】测试替身必须准确模拟真实服务的行为，否则测试结果不可靠。",
            "【环境管理】需要管理测试环境中的容器、数据库、消息队列等依赖。",
            "【数据准备】需要为测试准备一致的初始数据状态。",
            "【与契约测试配合】组件测试应与契约测试配合，确保测试替身与真实服务行为一致。",
        ],
        handsOnPath: [
            "配置 Testcontainers：在测试中启动数据库、缓存等容器化依赖。",
            "创建测试替身：为外部服务创建 Mock 或 Stub。",
            "编写组件测试：测试服务的 API 端点和完整业务流程。",
            "准备测试数据：使用数据迁移或脚本初始化测试数据。",
            "配置测试隔离：确保每个测试独立，不相互影响。",
            "优化测试性能：使用容器复用减少启动时间。",
        ],
        selfCheck: [
            "Service Component Test 模式的定义是什么？",
            "组件测试与端到端测试的区别是什么？",
            "组件测试的主要优势是什么？",
            "组件测试的主要风险是什么？",
            "Testcontainers 是什么？它解决什么问题？",
            "如何确保测试替身的准确性？",
        ],
        extensions: [
            "研究 WireMock 创建服务替身。",
            "探索 Spring Boot Test 的 @SpringBootTest 注解。",
            "学习数据库测试的事务回滚策略。",
            "了解测试环境的容器编排。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/testing/service-component-test.html",
            "https://testcontainers.com/",
            "https://martinfowler.com/articles/microservice-testing/#testing-component-introduction",
        ],
    },
    "w11-4": {
        lessonId: "w11-4",
        background: [
            "【模式定义】microservices.io：Consumer-side Contract Test 是 'Verify that the client of a service can communicate with the service'。",
            "【测试目的】验证服务客户端能够正确地与服务通信，确保客户端代码的正确性。",
            "【与契约测试互补】消费者端测试验证客户端，提供者端契约测试验证服务端，两者共同保证集成正确性。",
            "【测试双重验证】Fowler：契约测试 'check that all the calls against your test doubles return the same results as a call to the external service would'。",
            "【服务虚拟化】使用 WireMock 等工具创建服务模拟，支持消费者端测试。",
        ],
        keyDifficulties: [
            "【替身与真实服务同步】测试替身的行为必须与真实服务保持同步，否则测试毫无意义。",
            "【变更管理】外部服务的变更可能导致测试替身过时，需要及时更新。",
            "【录制回放】可以使用录制/回放模式从真实服务录制响应，用于测试。",
            "【异步 API 测试】消息队列和事件驱动的 API 测试更复杂。",
            "【边界条件】需要测试各种边界条件和错误响应。",
        ],
        handsOnPath: [
            "创建服务模拟：使用 WireMock 创建外部服务的模拟。",
            "定义响应映射：配置各种请求对应的响应。",
            "编写客户端测试：测试客户端代码与模拟服务的交互。",
            "测试错误场景：模拟超时、错误响应等异常情况。",
            "同步契约：确保模拟行为与真实服务契约一致。",
            "自动化验证：定期运行测试验证客户端正确性。",
        ],
        selfCheck: [
            "Consumer-side Contract Test 模式的定义是什么？",
            "消费者端测试与提供者端契约测试的关系是什么？",
            "为什么测试替身必须与真实服务保持同步？",
            "WireMock 是什么？它的作用是什么？",
            "如何处理外部服务的变更？",
            "录制/回放模式是什么？",
        ],
        extensions: [
            "研究 WireMock 的高级功能（状态机、延迟响应）。",
            "探索 Self Initializing Fake 模式。",
            "学习 Hoverfly 等服务虚拟化工具。",
            "了解 API 模拟与测试的最佳实践。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/testing/consumer-side-contract-test.html",
            "https://wiremock.org/docs/getting-started/",
            "https://martinfowler.com/bliki/SelfInitializingFake.html",
        ],
    },
}

export const week11Quizzes: Record<string, QuizQuestion[]> = {
    "w11-1": [
        {
            id: "w11-1-q1",
            question: "根据 Fowler，测试金字塔的核心建议是什么？",
            options: [
                "所有测试应该数量相等",
                "大量单元测试、一些集成测试、很少的端到端测试",
                "端到端测试应该最多",
                "只需要集成测试",
            ],
            answer: 1,
            rationale: "Fowler：'Write lots of small and fast unit tests. Write some more coarse-grained tests and very few high-level tests'。",
        },
        {
            id: "w11-1-q2",
            question: "测试金字塔的三层从下到上分别是什么？",
            options: [
                "端到端测试 → 集成测试 → 单元测试",
                "单元测试 → 集成测试 → 端到端测试",
                "集成测试 → 单元测试 → 端到端测试",
                "单元测试 → 端到端测试 → 集成测试",
            ],
            answer: 1,
            rationale: "测试金字塔从下到上：单元测试（最多）→ 集成测试 → 端到端测试（最少）。",
        },
        {
            id: "w11-1-q3",
            question: "为什么单元测试应该是最多的？",
            options: [
                "因为最复杂",
                "因为快速、便宜、隔离性好",
                "因为覆盖最广",
                "因为最可靠",
            ],
            answer: 1,
            rationale: "单元测试快速执行、成本低廉、隔离性好，所以应该作为测试的基础，数量最多。",
        },
        {
            id: "w11-1-q4",
            question: "微服务架构对测试策略有什么影响？",
            options: [
                "不需要改变",
                "需要重新考虑，因为引入了网络分区和分布式复杂性",
                "只需要更多测试",
                "只需要端到端测试",
            ],
            answer: 1,
            rationale: "Fowler：'Once these additional network partitions have been introduced, the testing strategies that applied for monolithic applications need to be reconsidered'。",
        },
        {
            id: "w11-1-q5",
            question: "端到端测试的主要缺点是什么？",
            options: [
                "太简单",
                "困难、缓慢、脆弱、昂贵",
                "覆盖范围小",
                "不够全面",
            ],
            answer: 1,
            rationale: "端到端测试 'difficult, slow, brittle, and expensive'——难以维护且不稳定。",
        },
        {
            id: "w11-1-q6",
            question: "Fowler 建议将测试推到金字塔的哪个位置？",
            options: [
                "尽可能往上",
                "尽可能往下（Push tests as far down the pyramid as feasible）",
                "保持在中间",
                "位置不重要",
            ],
            answer: 1,
            rationale: "Fowler：'Push tests as far down the pyramid as feasible'——尽可能使用更底层、更快的测试。",
        },
        {
            id: "w11-1-q7",
            question: "为什么应该测试行为而非实现？",
            options: [
                "更容易编写",
                "测试实现细节会导致脆弱测试，重构时容易失败",
                "测试更快",
                "覆盖更多代码",
            ],
            answer: 1,
            rationale: "Fowler：'Test behavior, not implementation'——测试实现细节会导致脆弱测试，重构时容易失败。",
        },
        {
            id: "w11-1-q8",
            question: "微服务测试的五种类型是什么？",
            options: [
                "黑盒、白盒、灰盒、回归、冒烟",
                "Unit Testing、Integration Testing、Component Testing、Contract Testing、End-to-End Testing",
                "功能、性能、安全、兼容、可用性",
                "静态、动态、手动、自动、半自动",
            ],
            answer: 1,
            rationale: "微服务测试包括：Unit Testing、Integration Testing、Component Testing、Contract Testing、End-to-End Testing。",
        },
        {
            id: "w11-1-q9",
            question: "集成测试应该聚焦什么？",
            options: [
                "整个系统",
                "单个集成点（如数据库、外部 API）",
                "所有服务",
                "用户界面",
            ],
            answer: 1,
            rationale: "Fowler：集成测试应聚焦单个集成点，'focuses narrowly on single integration points'。",
        },
        {
            id: "w11-1-q10",
            question: "探索性测试的作用是什么？",
            options: [
                "替代自动化测试",
                "发现设计和可用性问题，自动化无法替代",
                "提高覆盖率",
                "减少测试时间",
            ],
            answer: 1,
            rationale: "Fowler：'Use exploratory testing: Manual testing catches design and usability issues automation misses'。",
        },
        {
            id: "w11-1-q11",
            question: "测试替身（Test Doubles）有哪些类型？",
            options: [
                "只有 Mock",
                "Stub、Mock、Fake、Spy",
                "只有 Stub",
                "只有 Fake",
            ],
            answer: 1,
            rationale: "测试替身的常见类型包括：Stub（存根）、Mock（模拟）、Fake（伪造）、Spy（间谍）。",
        },
        {
            id: "w11-1-q12",
            question: "Fowler 建议在集成测试中如何处理外部依赖？",
            options: [
                "总是使用 Mock",
                "在本地运行真实依赖（如本地 MySQL 数据库）",
                "跳过外部依赖测试",
                "只在生产环境测试",
            ],
            answer: 1,
            rationale: "Fowler：'spin up a local MySQL database, test against a local ext4 filesystem'——在本地运行真实依赖。",
        },
    ],
    "w11-2": [
        {
            id: "w11-2-q1",
            question: "消费者驱动契约测试的定义是什么？",
            options: [
                "提供者定义所有契约",
                "消费者编写测试套件验证提供者满足期望",
                "不需要测试",
                "只测试消费者",
            ],
            answer: 1,
            rationale: "消费者驱动契约测试是由消费服务的开发者编写测试套件，验证提供者服务满足消费者的期望。",
        },
        {
            id: "w11-2-q2",
            question: "为什么叫「消费者驱动」？",
            options: [
                "因为消费者付费",
                "因为消费者定义契约（期望），提供者验证是否符合",
                "因为消费者运行测试",
                "因为消费者更重要",
            ],
            answer: 1,
            rationale: "Pact：消费者定义契约（期望），提供者验证是否符合契约，消费者驱动契约定义。",
        },
        {
            id: "w11-2-q3",
            question: "Pact 是什么？",
            options: [
                "消息队列",
                "代码优先的消费者驱动契约测试工具",
                "数据库",
                "负载均衡器",
            ],
            answer: 1,
            rationale: "Pact 是 'code-first consumer-driven contract testing tool'，在测试执行期间自动生成契约。",
        },
        {
            id: "w11-2-q4",
            question: "契约测试与端到端测试的主要区别是什么？",
            options: [
                "没有区别",
                "契约测试可以独立测试每个服务，E2E 需要所有服务运行",
                "契约测试更慢",
                "E2E 更可靠",
            ],
            answer: 1,
            rationale: "契约测试可以独立测试每个服务（消费者和提供者分别测试），无需同时运行所有服务。",
        },
        {
            id: "w11-2-q5",
            question: "契约测试验证什么内容？",
            options: [
                "具体数据值",
                "响应的格式和结构",
                "性能指标",
                "安全性",
            ],
            answer: 1,
            rationale: "Fowler：契约测试 'verify the format and structure of service responses rather than specific data values'。",
        },
        {
            id: "w11-2-q6",
            question: "Pact 的契约何时生成？",
            options: [
                "手动编写",
                "在消费者测试执行期间自动生成",
                "由提供者生成",
                "从 OpenAPI 规范生成",
            ],
            answer: 1,
            rationale: "Pact：'The contract is generated during the execution of the automated consumer tests'。",
        },
        {
            id: "w11-2-q7",
            question: "契约测试如何帮助团队协作？",
            options: [
                "不需要协作",
                "消费者和提供者团队共同维护契约，在变更前协商",
                "只有消费者负责",
                "只有提供者负责",
            ],
            answer: 1,
            rationale: "契约测试鼓励消费者和提供者团队的协作，共同维护契约，变更前需要协商。",
        },
        {
            id: "w11-2-q8",
            question: "如何共享契约文件？",
            options: [
                "通过邮件",
                "使用 Pact Broker 或 Git 仓库",
                "口头传达",
                "不需要共享",
            ],
            answer: 1,
            rationale: "契约文件通常通过 Pact Broker（专用服务）或 Git 仓库共享。",
        },
        {
            id: "w11-2-q9",
            question: "消费者驱动契约测试的主要优势是什么？",
            options: [
                "测试更慢",
                "只测试实际使用的部分，允许提供者灵活修改未使用行为",
                "需要更多代码",
                "更复杂",
            ],
            answer: 1,
            rationale: "Pact：'only parts of the communication that are actually used by the consumer(s) get tested'，允许提供者灵活修改未使用的行为。",
        },
        {
            id: "w11-2-q10",
            question: "Spring Cloud Contract 是什么？",
            options: [
                "消息队列",
                "Spring 生态的契约测试工具",
                "数据库",
                "服务发现",
            ],
            answer: 1,
            rationale: "Spring Cloud Contract 是 Spring 生态的契约测试工具，支持服务集成契约测试。",
        },
        {
            id: "w11-2-q11",
            question: "Pact 的「contract by example」是什么意思？",
            options: [
                "只需要一个例子",
                "每个测试用例描述一个具体的请求/响应对",
                "使用静态规范",
                "不需要例子",
            ],
            answer: 1,
            rationale: "Pact 是 'contract by example'——每个测试用例描述一个具体的请求/响应对，而非完整的 API 规范。",
        },
        {
            id: "w11-2-q12",
            question: "多个消费者的契约如何处理？",
            options: [
                "只保留一个",
                "提供者需要满足所有活跃消费者的契约",
                "消费者自己协调",
                "忽略差异",
            ],
            answer: 1,
            rationale: "多个消费者可能有不同版本的契约，提供者需要运行验证测试确保满足所有活跃消费者的契约。",
        },
    ],
    "w11-3": [
        {
            id: "w11-3-q1",
            question: "根据 microservices.io，Service Component Test 的定义是什么？",
            options: [
                "测试所有服务",
                "使用测试替身在隔离环境中测试单个服务",
                "只测试 UI",
                "只测试数据库",
            ],
            answer: 1,
            rationale: "microservices.io：'A test suite that tests a service in isolation using test doubles for any services that it invokes'。",
        },
        {
            id: "w11-3-q2",
            question: "组件测试相比端到端测试的优势是什么？",
            options: [
                "覆盖范围更广",
                "更容易、更快、更可靠、更便宜",
                "更准确",
                "不需要代码",
            ],
            answer: 1,
            rationale: "microservices.io：'Testing a service in isolation is easier, faster, more reliable and cheap'。",
        },
        {
            id: "w11-3-q3",
            question: "组件测试的主要风险是什么？",
            options: [
                "太慢",
                "测试通过但生产环境可能失败",
                "太复杂",
                "成本太高",
            ],
            answer: 1,
            rationale: "microservices.io 警告：'Tests might pass but the application will fail in production'。",
        },
        {
            id: "w11-3-q4",
            question: "Testcontainers 是什么？",
            options: [
                "容器编排工具",
                "提供轻量级、一次性容器实例（数据库、消息队列等）的测试库",
                "监控工具",
                "部署工具",
            ],
            answer: 1,
            rationale: "Testcontainers 是 'an open source library for providing throwaway, lightweight instances of databases, message brokers'。",
        },
        {
            id: "w11-3-q5",
            question: "Testcontainers 支持多少种编程语言？",
            options: [
                "只有 Java",
                "11+ 种语言（Java、Go、.NET、Node.js、Python 等）",
                "只有 2 种",
                "只有 JavaScript",
            ],
            answer: 1,
            rationale: "Testcontainers 支持 11+ 种编程语言：Java、Go、.NET、Node.js、Python、Rust、PHP、Ruby 等。",
        },
        {
            id: "w11-3-q6",
            question: "Testcontainers 需要什么环境？",
            options: [
                "Kubernetes",
                "只需要 Docker",
                "专用服务器",
                "云环境",
            ],
            answer: 1,
            rationale: "Testcontainers 'requires only Docker to function'——只需要 Docker 即可运行。",
        },
        {
            id: "w11-3-q7",
            question: "如何确保测试替身的准确性？",
            options: [
                "不需要确保",
                "使用契约测试验证替身行为与真实服务一致",
                "手动检查",
                "忽略差异",
            ],
            answer: 1,
            rationale: "组件测试应与契约测试配合，使用契约测试验证测试替身的行为与真实服务一致。",
        },
        {
            id: "w11-3-q8",
            question: "组件测试验证什么范围？",
            options: [
                "只有 API 端点",
                "服务的完整功能：API 端点、业务逻辑、数据库交互",
                "只有数据库",
                "只有业务逻辑",
            ],
            answer: 1,
            rationale: "组件测试验证服务的完整功能，包括 API 端点、业务逻辑、数据库交互等。",
        },
        {
            id: "w11-3-q9",
            question: "哪些公司使用 Testcontainers？",
            options: [
                "只有小公司",
                "Spotify、Netflix、Uber、JetBrains、Capital One 等",
                "没有公司使用",
                "只有初创公司",
            ],
            answer: 1,
            rationale: "Testcontainers 被 Spotify、Netflix、Uber、JetBrains、Capital One 等主要公司使用。",
        },
        {
            id: "w11-3-q10",
            question: "Testcontainers 支持哪些容器化服务？",
            options: [
                "只有数据库",
                "50+ 种服务：PostgreSQL、Kafka、MongoDB、Kubernetes、Elasticsearch 等",
                "只有消息队列",
                "只有 Web 服务器",
            ],
            answer: 1,
            rationale: "Testcontainers 支持 50+ 种容器化服务，包括 PostgreSQL、Kafka、MongoDB、Kubernetes、Elasticsearch、MySQL 等。",
        },
        {
            id: "w11-3-q11",
            question: "组件测试中如何处理外部服务依赖？",
            options: [
                "调用真实服务",
                "使用测试替身（Mock/Stub）模拟外部服务",
                "跳过测试",
                "等待服务可用",
            ],
            answer: 1,
            rationale: "组件测试使用测试替身为外部服务创建 Mock 或 Stub，实现隔离测试。",
        },
        {
            id: "w11-3-q12",
            question: "Spring Cloud Contract 在组件测试中的作用是什么？",
            options: [
                "替代所有测试",
                "支持契约测试，确保测试替身与真实服务行为一致",
                "只用于部署",
                "只用于监控",
            ],
            answer: 1,
            rationale: "microservices.io 提到 Spring Cloud Contract 是支持服务组件测试的开源项目。",
        },
    ],
    "w11-4": [
        {
            id: "w11-4-q1",
            question: "根据 microservices.io，Consumer-side Contract Test 的定义是什么？",
            options: [
                "测试服务端",
                "验证服务客户端能够与服务正确通信",
                "测试数据库",
                "测试消息队列",
            ],
            answer: 1,
            rationale: "microservices.io：'Verify that the client of a service can communicate with the service'。",
        },
        {
            id: "w11-4-q2",
            question: "消费者端测试与提供者端契约测试的关系是什么？",
            options: [
                "相互替代",
                "互补——消费者端测试验证客户端，提供者端验证服务端",
                "完全相同",
                "没有关系",
            ],
            answer: 1,
            rationale: "消费者端测试验证客户端代码，提供者端契约测试验证服务端，两者共同保证集成正确性。",
        },
        {
            id: "w11-4-q3",
            question: "为什么测试替身必须与真实服务保持同步？",
            options: [
                "不需要同步",
                "否则测试结果不可靠，可能隐藏真实问题",
                "只是建议",
                "性能原因",
            ],
            answer: 1,
            rationale: "测试替身的行为必须与真实服务保持同步，否则测试通过但生产环境可能失败。",
        },
        {
            id: "w11-4-q4",
            question: "WireMock 是什么？",
            options: [
                "数据库",
                "HTTP 服务模拟工具，用于创建外部服务的测试替身",
                "消息队列",
                "负载均衡器",
            ],
            answer: 1,
            rationale: "WireMock 是 HTTP 服务模拟工具，用于创建外部服务的测试替身，支持消费者端测试。",
        },
        {
            id: "w11-4-q5",
            question: "根据 Fowler，契约测试如何检查测试替身的正确性？",
            options: [
                "手动检查",
                "检查对测试替身的调用是否与对外部服务的调用返回相同结果",
                "不需要检查",
                "只看代码覆盖率",
            ],
            answer: 1,
            rationale: "Fowler：契约测试 'check that all the calls against your test doubles return the same results as a call to the external service would'。",
        },
        {
            id: "w11-4-q6",
            question: "如何处理外部服务的变更？",
            options: [
                "忽略变更",
                "将契约测试分享给外部服务团队，变更前运行验证",
                "停止测试",
                "重写所有代码",
            ],
            answer: 1,
            rationale: "Fowler 建议将契约测试分享给外部服务团队，让他们在变更前运行测试，避免破坏性变更。",
        },
        {
            id: "w11-4-q7",
            question: "录制/回放模式是什么？",
            options: [
                "视频录制",
                "从真实服务录制响应，用于创建测试替身",
                "代码录制",
                "日志录制",
            ],
            answer: 1,
            rationale: "录制/回放模式是从真实服务录制实际响应，然后用这些响应创建测试替身。",
        },
        {
            id: "w11-4-q8",
            question: "消费者端测试应该测试什么场景？",
            options: [
                "只测试成功场景",
                "正常响应、超时、错误响应等各种边界条件",
                "只测试错误场景",
                "不需要场景",
            ],
            answer: 1,
            rationale: "消费者端测试应该测试各种边界条件，包括正常响应、超时、错误响应等异常情况。",
        },
        {
            id: "w11-4-q9",
            question: "契约测试可以如何安排运行？",
            options: [
                "只能在 CI 中",
                "可以独立于部署流水线，与外部服务的变更节奏同步",
                "只能手动运行",
                "只能在生产环境",
            ],
            answer: 1,
            rationale: "Fowler：'These tests can run independently from deployment pipelines, synced instead with the external service's change rhythm'。",
        },
        {
            id: "w11-4-q10",
            question: "Self Initializing Fake 是什么？",
            options: [
                "自动生成代码",
                "首次运行时从真实服务录制响应，之后作为测试替身使用",
                "自动部署",
                "自动测试",
            ],
            answer: 1,
            rationale: "Self Initializing Fake 首次运行时调用真实服务并录制响应，之后作为测试替身使用。",
        },
        {
            id: "w11-4-q11",
            question: "消费者端测试中如何模拟超时？",
            options: [
                "不需要模拟",
                "使用 WireMock 配置延迟响应",
                "真实超时",
                "跳过测试",
            ],
            answer: 1,
            rationale: "WireMock 等工具支持配置延迟响应，用于模拟超时和网络延迟场景。",
        },
        {
            id: "w11-4-q12",
            question: "消费者端测试与提供者端测试都通过时意味着什么？",
            options: [
                "没有意义",
                "消费者和提供者可以安全集成",
                "只能说明消费者正确",
                "只能说明提供者正确",
            ],
            answer: 1,
            rationale: "当消费者端测试和提供者端契约测试都通过时，说明消费者和提供者遵守相同的契约，可以安全集成。",
        },
    ],
}
