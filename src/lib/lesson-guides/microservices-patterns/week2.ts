import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week2Guides: Record<string, LessonGuide> = {
    "w2-1": {
        lessonId: "w2-1",
        background: [
            "【模式定义】microservices.io：'Define services around business capabilities'——业务能力是组织内生成价值的功能，如订单管理、客户管理、产品目录管理等。",
            "【业务能力定义】LeanIX：业务能力代表 'the capacity, materials, and expertise an organization needs to perform core functions'——关注组织做什么，而非如何做。",
            "【稳定性特征】业务能力模型具有高度稳定性：'Business capabilities are relatively static because you are defining the what which rarely changes'——与不断变化的业务流程形成对比。",
            "【设计原则】该模式应用两个面向对象原则：Single Responsibility Principle（服务应只有一个变更理由）和 Common Closure Principle（相关功能的变更只影响一个服务）。",
            "【Azure 四步法】Microsoft 建议的微服务边界识别流程：1) 从限界上下文开始 2) 检查聚合 3) 考虑领域服务 4) 评估非功能性需求。",
        ],
        keyDifficulties: [
            "【识别挑战】microservices.io 警告：识别业务能力 'requires understanding organizational purpose, structure, and processes'——需要深入了解业务。",
            "【边界验证】Microsoft 提供验证标准：Single Responsibility（单一职责）、Minimal Chattiness（最小通信）、Team Independence（团队独立）、Independent Deployment（独立部署）。",
            "【What vs How】关键区别：业务能力是 'what' 组织做什么，业务流程是 'how' 如何做——20年前没有在线销售渠道，但销售、履约、计费的能力没变。",
            "【层级结构】最佳实践是约 10 个顶层能力，分为三个组织层级。能力可以有支撑和包含的子能力，如 'Marketing' 包含 'Brand Management'、'Advertising' 等。",
            "【粒度权衡】Microsoft 建议 'Start Coarse-Grained'——从粗粒度开始更容易，拆分服务比跨服务重构简单。",
        ],
        handsOnPath: [
            "列出组织的核心业务功能：识别 5-10 个高层级关键能力，如产品管理、订单管理、库存管理。",
            "为每个能力定义子能力：建立 2-3 层的层级结构，确保互斥且完整覆盖。",
            "映射到现有系统：识别当前哪些系统支撑哪些能力，发现重叠和缺口。",
            "使用热力图评估：标记战略重要性、当前成熟度、需要增强的能力。",
            "验证服务边界：使用 Microsoft 的验证标准检查每个候选服务。",
            "绘制依赖图：识别能力之间的数据流和协作关系。",
        ],
        selfCheck: [
            "业务能力的定义是什么？它与业务流程有什么区别？",
            "microservices.io 模式应用了哪两个面向对象设计原则？",
            "Microsoft 建议的四步微服务边界识别流程是什么？",
            "为什么业务能力模型被认为是稳定的？请举例说明。",
            "验证微服务边界的六个标准是什么？",
            "为什么建议从粗粒度服务开始而非细粒度？",
            "如何使用热力图评估业务能力的优先级？",
        ],
        extensions: [
            "研究 TOGAF 业务能力模型框架。",
            "探索业务能力与应用组合管理（APM）的关系。",
            "了解价值流映射（Value Stream Mapping）如何补充业务能力分析。",
            "学习 Wardley Mapping 作为战略分析工具。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/decomposition/decompose-by-business-capability.html",
            "https://learn.microsoft.com/en-us/azure/architecture/microservices/model/microservice-boundaries",
            "https://www.leanix.net/en/wiki/ea/business-capability",
        ],
    },
    "w2-2": {
        lessonId: "w2-2",
        background: [
            "【模式定义】microservices.io：'Define services corresponding to Domain-Driven Design (DDD) subdomains'——每个子域代表一个独特的业务领域，服务与这些边界对齐。",
            "【三类子域】DDD 将子域分为三类：Core（核心域：关键业务差异化因素）、Supporting（支撑域：运营相关但非差异化）、Generic（通用域：可用现成方案解决）。",
            "【DDD 核心理念】InfoQ 文档：'The most complicated aspect of large software projects is not the implementation, it is the real world domain that the software serves'——领域理解比实现更重要。",
            "【通用语言】Ubiquitous Language 是 'a language that both domain experts and developers consistently use'——共享词汇决定项目成功，如果难以用这种语言解释概念，说明领域模型有遗漏。",
            "【事件风暴】EventStorming 是 'a flexible workshop format for collaborative exploration of complex business domains'——通过协作建模发现服务边界和领域分离点。",
        ],
        keyDifficulties: [
            "【识别挑战】microservices.io：识别子域 'Requires deep business understanding; needs iterative analysis of organizational structure and domain models'。",
            "【Core vs Supporting】核心域需要最高优先级和最好的开发者，支撑域可能调整现有方案，通用域可用现成工具——资源分配要区分对待。",
            "【Problem vs Solution】子域是问题空间（problem-space），限界上下文是解决方案空间（solution-space）——多个限界上下文可能存在于一个子域中，反之亦然。",
            "【事件风暴产出】EventStorming 帮助 'highlight architectural boundaries to allow robust and flexible evolution'——通过映射事件流发现不同利益相关者视角的分歧点。",
            "【迭代本质】Microsoft 强调 'Domain-driven design is iterative'——服务边界不是一次性决定的，随着理解演进而调整。",
        ],
        handsOnPath: [
            "组织事件风暴工作坊：邀请领域专家和开发者，准备便签纸和大白板。",
            "识别领域事件：用橙色便签标记业务中发生的重要事件，如 '订单已创建'、'支付已完成'。",
            "分组相关事件：找出事件的自然分组，这些分组暗示子域边界。",
            "分类子域：将识别出的子域分类为核心域、支撑域或通用域。",
            "为核心域投入最多资源：这是业务差异化的关键，需要最好的团队。",
            "评估通用域的现成方案：身份管理、支付处理等可能有成熟的第三方解决方案。",
        ],
        selfCheck: [
            "DDD 的三类子域是什么？各自的特点和资源分配策略？",
            "什么是通用语言（Ubiquitous Language）？为什么它决定项目成功？",
            "事件风暴的定义和目的是什么？",
            "子域（Subdomain）和限界上下文（Bounded Context）有什么区别？",
            "如何通过事件风暴识别服务边界？",
            "为什么说领域理解比技术实现更重要？",
            "DDD 中 'problem-space' 和 'solution-space' 的区别是什么？",
        ],
        extensions: [
            "阅读 Eric Evans 的《Domain-Driven Design》原著。",
            "学习 Alberto Brandolini 的 EventStorming 书籍和方法论。",
            "探索 Big Picture EventStorming vs Process Level EventStorming 的区别。",
            "研究如何将事件风暴产出转化为实际的服务设计。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/decomposition/decompose-by-subdomain.html",
            "https://www.infoq.com/minibooks/domain-driven-design-quickly/",
            "https://www.eventstorming.com/",
        ],
    },
    "w2-3": {
        lessonId: "w2-3",
        background: [
            "【定义】Martin Fowler：Bounded Context 是 DDD 的核心模式，将大型系统模型划分为不同区域，每个区域维护自己的统一模型——'total unification of the domain model for a large system will not be feasible or cost-effective'。",
            "【多义词问题】不同组织群体对同一概念使用微妙不同的词汇（多义词 polysemes）：Fowler 举例电力公司中 'meter' 意味着电网连接、客户连接或物理设备——造成持续的组织混乱。",
            "【上下文映射】Context Map 文档化边界、通信方法、模型翻译和上下文间的保护机制，通常使用依赖图显示上游-下游关系。",
            "【七种集成模式】Vaadin 文档列出七种主要模式：Partnership、Shared Kernel、Customer-Supplier、Conformist、Anticorruption Layer、Open Host Service、Separate Ways。",
            "【防腐层】Anti-Corruption Layer (ACL) 是 '在上下文边界的显式翻译机制'——保护下游上下文免受上游模型变更影响，管理模型间的微妙差异。",
        ],
        keyDifficulties: [
            "【边界划分】Fowler：边界主要由人类文化和语言变化划定——技术边界是次要的，理解组织动态更重要。",
            "【上下游关系】上游上下文影响下游，反之可能不成立——这反映依赖关系、调度或响应性因素。",
            "【Conformist 模式】下游接受上游上下文 'as-is' 而不协商变更——当上游团队没有动机支持下游需求时使用。",
            "【Partnership vs Customer-Supplier】Partnership 是平等合作，共同目标；Customer-Supplier 是正式的上下游关系，带有协商需求。",
            "【Context 内变体】Fowler 指出上下文可以存在于单个应用内（如内存模型 vs 关系数据库模型）——不仅是服务边界。",
        ],
        handsOnPath: [
            "绘制当前系统的上下文地图：识别所有主要领域区域及其边界。",
            "标记上游/下游关系：箭头从上游指向下游，标注依赖方向。",
            "识别多义词：找出在不同上下文中意义不同的术语，如 'Customer'、'Account'、'Product'。",
            "为每对上下文选择集成模式：Partnership、Customer-Supplier、Conformist、ACL 等。",
            "设计防腐层：为关键边界定义翻译和适配逻辑。",
            "记录上下文通信协议：API、事件、共享数据等。",
        ],
        selfCheck: [
            "Bounded Context 的定义和目的是什么？",
            "为什么 'total unification of the domain model' 对大型系统不可行？",
            "多义词（Polysemes）问题是什么？请举例说明。",
            "上下文映射（Context Mapping）的作用是什么？",
            "七种上下文集成模式分别是什么？各适用于什么场景？",
            "防腐层（Anti-Corruption Layer）解决什么问题？",
            "上游/下游关系意味着什么？",
        ],
        extensions: [
            "研究微服务中防腐层的具体实现方式。",
            "探索 Open Host Service 模式与 API Gateway 的关系。",
            "学习如何使用 Domain Events 实现上下文间的松耦合通信。",
            "了解 Conway's Law 如何影响上下文边界的划分。",
        ],
        sourceUrls: [
            "https://martinfowler.com/bliki/BoundedContext.html",
            "https://www.infoq.com/articles/ddd-contextmapping/",
            "https://vaadin.com/blog/ddd-part-1-strategic-domain-driven-design",
        ],
    },
    "w2-4": {
        lessonId: "w2-4",
        background: [
            "【Self-contained Service 问题】microservices.io：'How should a service collaborate with other services when handling a synchronous request?'——同步请求/响应通信降低可用性，因为任何协作服务不可用都会导致整个操作失败。",
            "【Self-contained Service 方案】'Design a service so that it can respond to a synchronous request without waiting for the response from any other service'——通过合并功能或使用 CQRS/Saga 异步模式实现。",
            "【Service per Team】microservices.io：'Each service is owned by a team, which has sole responsibility for making changes'——一个团队理想情况下管理一个服务，代码库大小应在认知容量内。",
            "【Team Topologies 四种团队类型】1) Stream-aligned（流对齐：端到端拥有价值流）2) Platform（平台：为其他团队提供服务）3) Enabling（赋能：临时技能建设支持）4) Complicated Subsystem（复杂子系统：需要专业知识）。",
            "【三种交互模式】Collaboration（紧密合作，高成本）、X-as-a-Service（提供和消费，低成本）、Facilitation（辅导指导，临时性）。",
        ],
        keyDifficulties: [
            "【Self-contained 权衡】好处是提高可用性和响应时间；代价是 CQRS/Saga 增加运维复杂性、API 不直观（客户端需轮询结果）、代码库变大。",
            "【团队规模】典型 5-9 人的跨职能团队——小到足够自治，大到有完整能力栈。",
            "【Conway's Law】'organizational structure mirrors system architecture'——松耦合的团队构建松耦合的系统，组织设计和系统设计必须一致。",
            "【Stream-aligned 责任】'You Built It, You Run It'——团队拥有价值流的端到端结果，消除向其他部门的移交。",
            "【Thinnest Viable Platform】平台团队应提供 '刚好足够的能力'——避免臃肿的平台减慢流对齐团队的速度。",
        ],
        handsOnPath: [
            "评估当前团队结构：每个团队负责多少服务？服务是否在团队认知容量内？",
            "识别跨服务协作：哪些操作需要同步调用多个服务？这些是 Self-contained Service 的候选。",
            "为关键服务评估 Self-contained 可行性：能否通过 CQRS 维护数据副本？能否用 Saga 实现异步一致性？",
            "映射团队类型：当前团队属于哪种 Team Topologies 类型？是否有缺失的团队类型？",
            "定义团队交互模式：每对团队之间的交互是 Collaboration、X-as-a-Service 还是 Facilitation？",
            "识别平台需求：哪些通用能力应该由平台团队提供？",
        ],
        selfCheck: [
            "Self-contained Service 模式解决什么问题？",
            "实现 Self-contained Service 的两种方法是什么？",
            "Service per Team 模式的核心原则是什么？",
            "Team Topologies 定义的四种团队类型是什么？各自的职责？",
            "三种团队交互模式是什么？各适用于什么场景？",
            "什么是 'Thinnest Viable Platform'？为什么重要？",
            "Conway's Law 如何影响团队和服务的组织？",
        ],
        extensions: [
            "阅读《Team Topologies》完整书籍，深入理解团队设计。",
            "研究 Spotify 的 Squad、Tribe、Chapter、Guild 模型。",
            "探索如何使用 Inverse Conway Maneuver 有意设计组织结构。",
            "学习 SRE（Site Reliability Engineering）团队如何融入 Team Topologies。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/decomposition/self-contained-service.html",
            "https://microservices.io/patterns/decomposition/service-per-team.html",
            "https://teamtopologies.com/key-concepts",
        ],
    },
}

export const week2Quizzes: Record<string, QuizQuestion[]> = {
    "w2-1": [
        {
            id: "w2-1-q1",
            question: "根据 microservices.io，'Decompose by Business Capability' 模式的核心思想是什么？",
            options: [
                "按技术栈划分服务",
                "围绕业务能力构建服务，业务能力是组织内生成价值的功能",
                "按数据库表划分服务",
                "按团队人数划分服务",
            ],
            answer: 1,
            rationale: "microservices.io 定义该模式为 'Define services around business capabilities'——业务能力是组织内生成价值的功能。",
        },
        {
            id: "w2-1-q2",
            question: "业务能力（Business Capability）与业务流程（Business Process）的关键区别是什么？",
            options: [
                "业务能力更复杂",
                "业务能力关注'做什么'（what），业务流程关注'如何做'（how）",
                "业务流程更稳定",
                "它们是同一概念的不同名称",
            ],
            answer: 1,
            rationale: "LeanIX 强调业务能力是 'what' 组织做什么，而业务流程是 'how' 如何做——能力相对稳定，流程随技术和需求变化。",
        },
        {
            id: "w2-1-q3",
            question: "Microsoft Azure 建议的微服务边界识别四步法的第一步是什么？",
            options: [
                "评估非功能性需求",
                "检查聚合（Aggregates）",
                "从限界上下文（Bounded Context）开始",
                "考虑领域服务",
            ],
            answer: 2,
            rationale: "Microsoft 建议的四步法是：1) 从限界上下文开始 2) 检查聚合 3) 考虑领域服务 4) 评估非功能性需求。",
        },
        {
            id: "w2-1-q4",
            question: "该模式应用的两个面向对象设计原则是什么？",
            options: [
                "开闭原则和里氏替换原则",
                "单一职责原则和共同闭包原则",
                "依赖倒置原则和接口隔离原则",
                "迪米特法则和组合复用原则",
            ],
            answer: 1,
            rationale: "microservices.io 指出该模式应用 Single Responsibility Principle 和 Common Closure Principle。",
        },
        {
            id: "w2-1-q5",
            question: "为什么业务能力模型被认为是 '稳定的'？",
            options: [
                "因为它使用最新技术",
                "因为它定义的是'做什么'，这很少改变，而'如何做'会随技术演进",
                "因为它不需要维护",
                "因为它是由管理层决定的",
            ],
            answer: 1,
            rationale: "LeanIX 解释：'Business capabilities are relatively static because you are defining the what which rarely changes'——零售的销售能力20年没变，但在线销售渠道是新的。",
        },
        {
            id: "w2-1-q6",
            question: "Microsoft 提供的验证微服务边界标准中，'Minimal Chattiness' 指什么？",
            options: [
                "团队沟通要最小化",
                "避免服务间过多的调用",
                "代码注释要最少",
                "日志输出要最少",
            ],
            answer: 1,
            rationale: "Microsoft 验证标准中 'Minimal Chattiness' 意味着避免服务间过多的调用（excessive inter-service calls）。",
        },
        {
            id: "w2-1-q7",
            question: "最佳实践建议业务能力模型应该有多少个顶层能力？",
            options: [
                "2-3 个",
                "约 10 个",
                "50 个以上",
                "越多越好",
            ],
            answer: 1,
            rationale: "LeanIX 指出最佳实践是 '~10 top-level capabilities with three organizational levels'。",
        },
        {
            id: "w2-1-q8",
            question: "Microsoft 为什么建议 'Start Coarse-Grained'（从粗粒度开始）？",
            options: [
                "粗粒度服务性能更好",
                "拆分服务比跨服务重构简单",
                "粗粒度服务更便宜",
                "这是行业标准",
            ],
            answer: 1,
            rationale: "Microsoft 强调 'Easier to split services than refactor across existing ones'——从粗粒度开始更容易演进。",
        },
        {
            id: "w2-1-q9",
            question: "以下哪个是在线商店的典型业务能力？",
            options: [
                "MySQL 数据库管理",
                "产品目录管理、库存管理、订单管理",
                "React 组件开发",
                "Jenkins 流水线配置",
            ],
            answer: 1,
            rationale: "microservices.io 举例在线商店的业务能力包括：Product catalog management、Inventory management、Order management、Delivery management。",
        },
        {
            id: "w2-1-q10",
            question: "业务能力映射（Capability Mapping）如何帮助 IT 投资决策？",
            options: [
                "自动选择技术栈",
                "通过热力图标记需要增强的能力，引导 IT 投资重点",
                "计算每个能力的成本",
                "预测未来收入",
            ],
            answer: 1,
            rationale: "LeanIX 描述使用热力图 'highlighting or color-coding the business capabilities that should become the primary focus of future IT investments'。",
        },
        {
            id: "w2-1-q11",
            question: "Microsoft 验证标准中的 'Team Independence' 要求什么？",
            options: [
                "团队不需要沟通",
                "服务足够小，可以由独立团队开发",
                "每个团队使用不同的编程语言",
                "团队在不同地点工作",
            ],
            answer: 1,
            rationale: "Microsoft 验证标准要求服务 'Small enough for independent team development'。",
        },
        {
            id: "w2-1-q12",
            question: "业务能力的 'Mutually Exclusive' 和 'Cumulatively Exhaustive' 原则意味着什么？",
            options: [
                "能力之间要竞争",
                "能力不重叠且完整覆盖组织所有功能",
                "能力要相互依赖",
                "能力要按字母排序",
            ],
            answer: 1,
            rationale: "LeanIX 解释：Mutually Exclusive 保证无冗余（counting everything once），Cumulatively Exhaustive 确保无遗漏（everything a company does is considered）。",
        },
    ],
    "w2-2": [
        {
            id: "w2-2-q1",
            question: "根据 microservices.io，'Decompose by Subdomain' 模式的核心是什么？",
            options: [
                "按数据库表定义服务",
                "按 DDD 子域定义服务，每个子域代表独特的业务领域",
                "按团队定义服务",
                "按 API 端点定义服务",
            ],
            answer: 1,
            rationale: "microservices.io 定义该模式为 'Define services corresponding to Domain-Driven Design (DDD) subdomains'。",
        },
        {
            id: "w2-2-q2",
            question: "DDD 将子域分为哪三类？",
            options: [
                "前端、后端、数据库",
                "核心域（Core）、支撑域（Supporting）、通用域（Generic）",
                "高、中、低优先级",
                "内部、外部、共享",
            ],
            answer: 1,
            rationale: "microservices.io 列出三类子域：Core（关键业务差异化因素）、Supporting（运营相关但非差异化）、Generic（可用现成方案）。",
        },
        {
            id: "w2-2-q3",
            question: "根据 DDD，核心域（Core Domain）应该如何对待？",
            options: [
                "外包给第三方",
                "使用现成的解决方案",
                "投入最高优先级和最好的开发者",
                "最后考虑",
            ],
            answer: 2,
            rationale: "Vaadin 文档指出核心域 'Make organizations unique; require highest priority and best developers'。",
        },
        {
            id: "w2-2-q4",
            question: "什么是通用语言（Ubiquitous Language）？",
            options: [
                "一种编程语言",
                "领域专家和开发者一致使用的共享术语",
                "文档标准",
                "API 规范",
            ],
            answer: 1,
            rationale: "Vaadin 定义通用语言为 'a language that both domain experts and developers consistently use to describe and discuss the domain'。",
        },
        {
            id: "w2-2-q5",
            question: "EventStorming 的定义是什么？",
            options: [
                "一种编程方法",
                "一种灵活的协作探索复杂业务领域的工作坊格式",
                "一种测试框架",
                "一种部署工具",
            ],
            answer: 1,
            rationale: "EventStorming 官网定义为 'a flexible workshop format for collaborative exploration of complex business domains'。",
        },
        {
            id: "w2-2-q6",
            question: "InfoQ 文档强调 DDD 的核心理念是什么？",
            options: [
                "实现是软件项目最复杂的方面",
                "软件服务的现实世界领域才是最复杂的，领域理解比实现更重要",
                "技术选型是最关键的",
                "团队管理是核心",
            ],
            answer: 1,
            rationale: "InfoQ 文档指出 'The most complicated aspect of large software projects is not the implementation, it is the real world domain that the software serves'。",
        },
        {
            id: "w2-2-q7",
            question: "通用域（Generic Subdomain）的典型处理方式是什么？",
            options: [
                "投入最多资源开发",
                "使用现成的解决方案或外包",
                "忽略不处理",
                "总是自己开发",
            ],
            answer: 1,
            rationale: "Vaadin 指出通用域是 'Standard needs (like identity management); candidates for off-the-shelf tools'。",
        },
        {
            id: "w2-2-q8",
            question: "子域（Subdomain）和限界上下文（Bounded Context）的关系是什么？",
            options: [
                "它们是完全相同的概念",
                "子域是问题空间，限界上下文是解决方案空间，可以多对多映射",
                "一个子域只能有一个限界上下文",
                "限界上下文包含多个子域",
            ],
            answer: 1,
            rationale: "Vaadin 指出子域是 problem-space，限界上下文是 solution-space，'Multiple bounded contexts can exist within one subdomain and vice versa'。",
        },
        {
            id: "w2-2-q9",
            question: "EventStorming 如何帮助识别服务边界？",
            options: [
                "通过代码分析",
                "通过映射事件流发现不同利益相关者视角的分歧点",
                "通过数据库分析",
                "通过性能测试",
            ],
            answer: 1,
            rationale: "EventStorming 官网指出它帮助 'highlight architectural boundaries' 通过映射事件流发现 'where different stakeholders perspectives diverge'。",
        },
        {
            id: "w2-2-q10",
            question: "如果难以用通用语言解释某个概念，这说明什么？",
            options: [
                "需要使用更复杂的词汇",
                "领域模型可能有遗漏",
                "应该简化解释",
                "这个概念不重要",
            ],
            answer: 1,
            rationale: "Vaadin 指出：'When you struggle explaining concepts using this language, you are most likely missing something from the language and, thereby, from your domain model'。",
        },
        {
            id: "w2-2-q11",
            question: "在线商店的子域示例包括哪些？",
            options: [
                "JavaScript、CSS、HTML",
                "产品目录、库存管理、订单管理、配送管理",
                "数据库、缓存、消息队列",
                "开发、测试、部署",
            ],
            answer: 1,
            rationale: "microservices.io 举例在线商店的子域包括：product catalog、inventory management、order management、delivery management。",
        },
        {
            id: "w2-2-q12",
            question: "为什么 DDD 方法被认为是迭代的？",
            options: [
                "因为使用敏捷开发",
                "因为服务边界不是一次性决定的，随着领域理解演进而调整",
                "因为代码需要重构",
                "因为需要多次部署",
            ],
            answer: 1,
            rationale: "Microsoft 强调 'Domain-driven design is iterative'——服务边界随理解演进而调整，不是一次性完成的。",
        },
    ],
    "w2-3": [
        {
            id: "w2-3-q1",
            question: "Martin Fowler 如何定义限界上下文（Bounded Context）？",
            options: [
                "一种编程模式",
                "DDD 的核心模式，将大型系统模型划分为不同区域，每个维护自己的统一模型",
                "一种数据库设计",
                "一种 API 标准",
            ],
            answer: 1,
            rationale: "Fowler 定义 Bounded Context 为 DDD 的核心模式，'divides large system models into distinct sections, each maintaining its own unified model'。",
        },
        {
            id: "w2-3-q2",
            question: "为什么大型系统的 'total unification of the domain model' 不可行？",
            options: [
                "技术限制",
                "不同组织群体对同一概念使用不同词汇（多义词问题），完全统一不划算",
                "成本太高",
                "团队太小",
            ],
            answer: 1,
            rationale: "Fowler 指出 'total unification of the domain model for a large system will not be feasible or cost-effective'，因为多义词问题导致不同群体对同一术语有不同理解。",
        },
        {
            id: "w2-3-q3",
            question: "Fowler 用什么例子说明多义词问题？",
            options: [
                "银行中 'Account' 的多义性",
                "电力公司中 'meter' 意味着电网连接、客户连接或物理设备",
                "零售中 'Product' 的多义性",
                "医院中 'Patient' 的多义性",
            ],
            answer: 1,
            rationale: "Fowler 用电力公司的例子：'meter' 可能意味着电网连接、客户连接或物理设备——造成持续的组织混乱。",
        },
        {
            id: "w2-3-q4",
            question: "上下文映射（Context Map）的作用是什么？",
            options: [
                "绘制地理位置",
                "文档化边界、通信方法、模型翻译和保护机制",
                "映射代码依赖",
                "测试覆盖率报告",
            ],
            answer: 1,
            rationale: "Vaadin 指出 Context Map 'document boundaries, communication methods, model translations, and protection mechanisms between contexts'。",
        },
        {
            id: "w2-3-q5",
            question: "防腐层（Anti-Corruption Layer）的作用是什么？",
            options: [
                "防止安全攻击",
                "在上下文边界提供翻译机制，保护下游免受上游模型变更影响",
                "加密数据",
                "验证用户身份",
            ],
            answer: 1,
            rationale: "InfoQ 文档定义 ACL 为 'an explicit translation mechanism at context boundaries that protects a downstream context from upstream model changes'。",
        },
        {
            id: "w2-3-q6",
            question: "上游/下游（Upstream/Downstream）关系意味着什么？",
            options: [
                "网络流量方向",
                "上游上下文影响下游，反之可能不成立，反映依赖关系",
                "数据流方向",
                "团队汇报关系",
            ],
            answer: 1,
            rationale: "InfoQ 解释 'An upstream context influences downstream contexts, while the reverse may not be true'——反映依赖、调度或响应性因素。",
        },
        {
            id: "w2-3-q7",
            question: "Conformist 模式适用于什么场景？",
            options: [
                "团队紧密协作时",
                "下游接受上游 'as-is'，当上游没有动机支持下游需求时",
                "需要定制化时",
                "双方平等协作时",
            ],
            answer: 1,
            rationale: "InfoQ 指出 Conformist 是 'A downstream context accepts an upstream context as-is without negotiating changes'——当上游没有动机支持下游时使用。",
        },
        {
            id: "w2-3-q8",
            question: "七种上下文集成模式中，哪种表示'团队合作，接口共同演进'？",
            options: [
                "Conformist",
                "Partnership",
                "Separate Ways",
                "Anticorruption Layer",
            ],
            answer: 1,
            rationale: "Vaadin 列出 Partnership 为 'Teams cooperate; interfaces evolve together'。",
        },
        {
            id: "w2-3-q9",
            question: "根据 Fowler，限界上下文的边界主要由什么决定？",
            options: [
                "技术架构",
                "人类文化和语言变化",
                "数据库结构",
                "API 设计",
            ],
            answer: 1,
            rationale: "Fowler 指出边界 'are primarily drawn by human culture and language changes'——理解组织动态比技术边界更重要。",
        },
        {
            id: "w2-3-q10",
            question: "Shared Kernel 模式意味着什么？",
            options: [
                "共享代码库",
                "上下文共享公共模型子集，需要双方协商",
                "共享数据库",
                "共享服务器",
            ],
            answer: 1,
            rationale: "Vaadin 和 InfoQ 都指出 Shared Kernel 是 'Contexts share a common model subset'，需要双方协商。",
        },
        {
            id: "w2-3-q11",
            question: "'Separate Ways' 模式意味着什么？",
            options: [
                "团队分开工作",
                "不进行集成，各自独立演进",
                "使用不同技术",
                "在不同时区工作",
            ],
            answer: 1,
            rationale: "Vaadin 列出 Separate Ways 为 'No integration; independent evolution'——双方决定不进行集成。",
        },
        {
            id: "w2-3-q12",
            question: "限界上下文可以存在于单个应用内吗？",
            options: [
                "不可以，必须是独立服务",
                "可以，例如内存模型与关系数据库模型",
                "只能在分布式系统中",
                "只能在微服务中",
            ],
            answer: 1,
            rationale: "Fowler 指出 'Contexts can exist within a single application (e.g., in-memory vs. relational database models)'——不仅是服务边界。",
        },
    ],
    "w2-4": [
        {
            id: "w2-4-q1",
            question: "Self-contained Service 模式要解决什么问题？",
            options: [
                "数据存储问题",
                "同步请求中协作服务不可用导致整个操作失败的问题",
                "代码复用问题",
                "团队协作问题",
            ],
            answer: 1,
            rationale: "microservices.io 指出问题是：'synchronous request/response communication reduces availability because if any collaborating service is unavailable, the entire operation fails'。",
        },
        {
            id: "w2-4-q2",
            question: "实现 Self-contained Service 的两种方法是什么？",
            options: [
                "使用缓存和数据库",
                "合并功能到服务内，或使用 CQRS/Saga 异步模式",
                "增加服务器和负载均衡",
                "使用微前端和微后端",
            ],
            answer: 1,
            rationale: "microservices.io 列出两种方法：'Merge functionality' 或 'Use CQRS to maintain data replicas and Saga pattern for asynchronous data consistency'。",
        },
        {
            id: "w2-4-q3",
            question: "Service per Team 模式的核心原则是什么？",
            options: [
                "一个服务由多个团队共享",
                "每个服务由一个团队拥有，该团队对变更负全责",
                "团队可以随意修改任何服务",
                "服务没有明确的所有者",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Each service is owned by a team, which has sole responsibility for making changes'。",
        },
        {
            id: "w2-4-q4",
            question: "Team Topologies 定义的四种团队类型是什么？",
            options: [
                "开发、测试、运维、安全",
                "Stream-aligned、Platform、Enabling、Complicated Subsystem",
                "前端、后端、数据库、DevOps",
                "产品、设计、工程、质量",
            ],
            answer: 1,
            rationale: "Team Topologies 定义四种类型：Stream-aligned（流对齐）、Platform（平台）、Enabling（赋能）、Complicated Subsystem（复杂子系统）。",
        },
        {
            id: "w2-4-q5",
            question: "Stream-aligned 团队的特点是什么？",
            options: [
                "只负责开发，不负责运维",
                "端到端拥有价值流结果，实践 'You Built It, You Run It'",
                "只处理技术问题",
                "只做短期项目",
            ],
            answer: 1,
            rationale: "Team Topologies 指出 Stream-aligned 团队 'own the outcomes end-to-end with no handoffs'，实践 'You Built It, You Run It'。",
        },
        {
            id: "w2-4-q6",
            question: "三种团队交互模式是什么？",
            options: [
                "会议、邮件、即时通讯",
                "Collaboration、X-as-a-Service、Facilitation",
                "同步、异步、混合",
                "正式、非正式、紧急",
            ],
            answer: 1,
            rationale: "Team Topologies 定义三种交互模式：Collaboration（紧密协作）、X-as-a-Service（服务提供）、Facilitation（辅导指导）。",
        },
        {
            id: "w2-4-q7",
            question: "什么是 'Thinnest Viable Platform'？",
            options: [
                "最小的技术平台",
                "平台团队只提供刚好足够的能力，避免臃肿减慢其他团队",
                "最便宜的平台",
                "最快的平台",
            ],
            answer: 1,
            rationale: "Team Topologies 强调有效平台遵循 'Thinnest Viable Platform' 方法，'providing just enough capability without unnecessary complexity'。",
        },
        {
            id: "w2-4-q8",
            question: "Self-contained Service 模式的主要缺点是什么？",
            options: [
                "性能太差",
                "CQRS/Saga 增加运维复杂性，API 不直观（需轮询），代码库变大",
                "安全性问题",
                "无法扩展",
            ],
            answer: 1,
            rationale: "microservices.io 列出缺点：'Increased operational complexity with CQRS and Saga'、'Less intuitive APIs (clients must poll)'、'Larger service codebases'。",
        },
        {
            id: "w2-4-q9",
            question: "Conway's Law 与 Service per Team 模式有什么关系？",
            options: [
                "没有关系",
                "组织结构映射系统架构，松耦合团队构建松耦合系统",
                "Conway's Law 已过时",
                "只适用于大公司",
            ],
            answer: 1,
            rationale: "microservices.io 指出该模式反映 Conway's Law：'organizational structure mirrors system architecture—enabling loosely coupled teams to build loosely coupled systems'。",
        },
        {
            id: "w2-4-q10",
            question: "典型的服务团队规模是多少人？",
            options: [
                "1-2 人",
                "5-9 人",
                "20-30 人",
                "100+ 人",
            ],
            answer: 1,
            rationale: "microservices.io 指出团队是 'small, cross-functional units (typically 5-9 people)'。",
        },
        {
            id: "w2-4-q11",
            question: "Enabling 团队的职责是什么？",
            options: [
                "开发核心功能",
                "提供临时技能建设支持，帮助其他团队克服障碍",
                "管理基础设施",
                "制定公司政策",
            ],
            answer: 1,
            rationale: "Team Topologies 定义 Enabling 团队 'Provide temporary skill-building support to other teams, helping them overcome obstacles and identify capability gaps'。",
        },
        {
            id: "w2-4-q12",
            question: "X-as-a-Service 交互模式的特点是什么？",
            options: [
                "高带宽、高成本的紧密协作",
                "一方提供、另一方消费，交互最少，边界清晰",
                "临时的辅导指导",
                "无边界的自由协作",
            ],
            answer: 1,
            rationale: "Team Topologies 描述 X-as-a-Service 为 'One team provides, another consumes with minimal interaction (clear boundaries, low cost)'。",
        },
    ],
}
