import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week6Guides: Record<string, LessonGuide> = {
    "w6-1": {
        lessonId: "w6-1",
        background: [
            "【定义】Fowler：CQRS 是 'Command Query Responsibility Segregation'——将更新和读取信息的模型分离的架构模式。",
            "【核心思想】传统做法用同一模型处理所有交互，CQRS 将其拆分为命令模型（写）和查询模型（读），分别优化各自需求。",
            "【微服务场景】microservices.io：当采用数据库隔离策略后，跨多个服务的查询变得困难，CQRS 通过创建专用读取数据库解决这个问题。",
            "【实现方式】创建专用读取数据库（通常为 NoSQL），针对查询需求优化结构，通过订阅领域事件自动同步数据。",
            "【事件溯源必需】在事件溯源系统中，CQRS 成为必需模式，因为从事件流重建状态通常复杂且低效。",
        ],
        keyDifficulties: [
            "【谨慎使用】Fowler 警告：'you should be very cautious about using CQRS'——大多数信息系统并不适合此模式。",
            "【有限适用】应仅在特定的有界上下文（Bounded Context）中使用，而非整个系统。",
            "【复杂性增加】microservices.io：系统复杂性增加，可能出现代码重复。",
            "【最终一致性】存在复制延迟，数据最终一致性问题——查询视图可能落后于命令端。",
            "【适用场景】Fowler：主要受益于复杂领域（分离模型简化设计）和高性能应用（读写操作差异大时独立扩展）。",
        ],
        handsOnPath: [
            "识别读写差异：分析系统中读操作和写操作的特点和负载差异。",
            "定义命令模型：设计优化写入的领域模型和数据结构。",
            "定义查询模型：设计优化读取的视图和数据结构。",
            "实现事件发布：命令端在数据变更时发布领域事件。",
            "实现视图同步：查询端订阅事件并更新物化视图。",
            "处理最终一致性：设计用户体验以适应读取延迟。",
        ],
        selfCheck: [
            "CQRS 的定义是什么？它与传统架构有何不同？",
            "为什么 Fowler 说应该谨慎使用 CQRS？",
            "CQRS 主要适用于哪些场景？",
            "CQRS 与事件溯源的关系是什么？",
            "CQRS 的主要优势和劣势是什么？",
            "如何处理 CQRS 带来的最终一致性问题？",
        ],
        extensions: [
            "研究 CQRS 在金融系统中的应用案例。",
            "探索 Axon Framework 的 CQRS 实现。",
            "学习如何使用 Redis 或 Elasticsearch 作为读取存储。",
            "了解 CQRS 与 GraphQL 的结合使用。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/cqrs.html",
            "https://martinfowler.com/bliki/CQRS.html",
        ],
    },
    "w6-2": {
        lessonId: "w6-2",
        background: [
            "【定义】Fowler：'Capture all changes to an application state as a sequence of events'——将所有状态变更记录为事件序列。",
            "【核心思想】microservices.io：'Event sourcing persists the state of a business entity as a sequence of state-changing events'——通过重放事件重建实体状态。",
            "【完整历史】与传统只存储当前状态不同，Event Sourcing 维护所有变更的持久日志，支持完整重建、时间查询和事件重放。",
            "【关键能力】Complete Rebuild（完整重建）、Temporal Query（时间查询：重建任意历史时刻状态）、Event Replay（事件重放：纠正错误）。",
            "【Event Store】microservices.io：服务将事件保存到 Event Store——一个同时作为存储和消息代理的专用数据库。",
        ],
        keyDifficulties: [
            "【学习曲线】microservices.io：'Learning curve as event sourcing represents unfamiliar programming paradigms'——不熟悉的编程范式。",
            "【查询复杂】从事件重建状态通常复杂且低效，'necessitating handling of eventually consistent data'——需要 CQRS。",
            "【外部系统】Fowler：外部系统交互使 Event Sourcing 复杂化——网关必须区分真正处理和重放，避免不必要的外部通知。",
            "【事件版本】事件结构可能随时间演进，需要处理事件版本兼容性。",
            "【存储增长】事件日志会持续增长，需要考虑快照策略和存储管理。",
        ],
        handsOnPath: [
            "定义领域事件：识别业务实体的状态变更事件，如 OrderCreated、OrderShipped。",
            "设计事件结构：定义事件的属性，包括聚合 ID、事件类型、时间戳、负载。",
            "实现事件存储：选择事件存储方案（EventStore、Kafka、自建）。",
            "实现状态重建：通过重放事件序列重建实体当前状态。",
            "实现快照：定期保存状态快照，加速重建过程。",
            "处理外部系统：区分处理和重放，避免副作用。",
        ],
        selfCheck: [
            "Event Sourcing 的定义是什么？它与传统数据存储有何不同？",
            "Event Sourcing 的三个关键能力是什么？",
            "什么是 Event Store？它的作用是什么？",
            "为什么 Event Sourcing 通常需要与 CQRS 配合使用？",
            "外部系统交互在 Event Sourcing 中有什么挑战？",
            "如何处理事件日志的增长问题？",
        ],
        extensions: [
            "研究 EventStore 数据库的架构和使用。",
            "探索 Event Sourcing 在审计和合规中的应用。",
            "学习事件版本升级和事件迁移策略。",
            "了解 Event Sourcing 与 DDD 聚合的关系。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/event-sourcing.html",
            "https://martinfowler.com/eaaDev/EventSourcing.html",
        ],
    },
    "w6-3": {
        lessonId: "w6-3",
        background: [
            "【问题】microservices.io：微服务需要在更新数据库和发送消息时保持一致性，但 2PC 不适用，不应将服务耦合到多个系统。",
            "【解决方案】'First, write the message/event to a database OUTBOX table as part of the transaction that updates business objects, and then publish it to a message broker'。",
            "【Dual Write 问题】Debezium：Outbox 模式解决 'dual write' 问题——'by only modifying a single resource - the source service's own database - it avoids any potential inconsistencies'。",
            "【四个参与者】发送者（发送消息的服务）、数据库（存储业务实体和消息）、消息出站表（存储待发送消息）、消息中继（读取出站表并发送到消息代理）。",
            "【关键优势】避免使用 2PC，保证消息只在数据库事务成功时发送，维持消息发送顺序。",
        ],
        keyDifficulties: [
            "【幂等消费】microservices.io：消息中继可能重复发送消息，'consumers should be idempotent'——追踪已处理的消息 ID。",
            "【中继实现】消息中继有两种实现：Polling Publisher（轮询发布者）和 Transaction Log Tailing（事务日志追踪）。",
            "【Outbox 表设计】Debezium：Outbox 表包含 id（UUID 用于去重）、aggregatetype、aggregateid、type、payload（JSON 事件数据）。",
            "【事件路由】使用自定义转换（SMT）根据聚合类型将事件路由到适当的 Kafka topic。",
            "【立即删除】Debezium：事件写入后立即删除（两个操作都记录在日志中），CDC 捕获 INSERT 事件。",
        ],
        handsOnPath: [
            "设计 Outbox 表：定义表结构，包含事件 ID、聚合类型、聚合 ID、事件类型、负载。",
            "修改业务逻辑：在同一事务中更新业务表和写入 Outbox 表。",
            "实现消息中继：选择 Polling Publisher 或 Transaction Log Tailing。",
            "配置消息路由：设置事件到 topic 的路由规则。",
            "实现幂等消费：消费者追踪已处理的消息 ID。",
            "监控出站表：确保消息及时发送，没有积压。",
        ],
        selfCheck: [
            "Transactional Outbox 模式解决什么问题？",
            "什么是 Dual Write 问题？Outbox 如何解决它？",
            "Outbox 模式的四个参与者是什么？",
            "为什么消费者需要是幂等的？",
            "消息中继有哪两种实现方式？",
            "Outbox 表应该包含哪些字段？",
        ],
        extensions: [
            "研究 Debezium Outbox SMT 的配置和使用。",
            "探索 Kafka Connect 在 Outbox 模式中的应用。",
            "学习如何监控和告警 Outbox 表的积压。",
            "了解 Outbox 模式与 Saga 的结合使用。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/transactional-outbox.html",
            "https://debezium.io/blog/2019/02/19/reliable-microservices-data-exchange-with-the-outbox-pattern/",
        ],
    },
    "w6-4": {
        lessonId: "w6-4",
        background: [
            "【定义】microservices.io：'Tail the database transaction log and publish each message/event inserted into the outbox to the message broker'——追踪数据库事务日志并发布消息。",
            "【CDC 定义】Change Data Capture 是 '识别和捕获数据库中数据变更，并实时传递到下游系统的过程'。",
            "【数据库特定】实现机制因数据库而异：MySQL 使用 binlog、PostgreSQL 使用 WAL（Write-Ahead Logging）、AWS DynamoDB 使用 table streams。",
            "【Log-Based CDC】最高效的 CDC 实现方式：读取事务日志，对源系统影响最小，无需修改应用程序。",
            "【关键优势】消除 2PC 需求，确保消息发布的准确性，最小化对源数据库的影响。",
        ],
        keyDifficulties: [
            "【实现复杂】microservices.io：实现复杂度包括数据库特定要求和防止重复消息发布的挑战。",
            "【采用度】该模式相对不常见，但采用正在增加——Debezium 等工具降低了门槛。",
            "【对比 Polling】Transaction Log Tailing 比 Polling Publisher 更高效，但实现更复杂。",
            "【其他 CDC 方法】Trigger-Based（触发器，影响性能）、Timestamp/Query-Based（时间戳查询，侵入性）。",
            "【Debezium 架构】Debezium 提供多种数据库连接器，捕获事务日志变更并流式传输到 Kafka。",
        ],
        handsOnPath: [
            "评估数据库支持：确认数据库的事务日志访问方式（binlog、WAL 等）。",
            "配置 Debezium：安装和配置 Debezium 连接器连接到源数据库。",
            "设置 Kafka Connect：配置 Kafka Connect 运行 Debezium 连接器。",
            "定义捕获规则：配置要捕获的表和事件类型。",
            "处理 Schema 演进：配置 Schema Registry 处理表结构变更。",
            "监控和告警：监控 CDC 延迟和错误。",
        ],
        selfCheck: [
            "Transaction Log Tailing 模式的定义是什么？",
            "CDC（Change Data Capture）是什么？有哪些实现方法？",
            "Log-Based CDC 相比其他方法有什么优势？",
            "不同数据库使用什么机制实现事务日志访问？",
            "Debezium 在 CDC 中扮演什么角色？",
            "Transaction Log Tailing 与 Polling Publisher 的对比？",
        ],
        extensions: [
            "深入学习 Debezium 的架构和各数据库连接器。",
            "研究 Kafka Connect 的高可用配置。",
            "探索 CDC 在数据湖和数据仓库同步中的应用。",
            "了解 CDC 在数据库迁移中的使用。",
        ],
        sourceUrls: [
            "https://microservices.io/patterns/data/transaction-log-tailing.html",
            "https://debezium.io/documentation/reference/stable/tutorial.html",
        ],
    },
}

export const week6Quizzes: Record<string, QuizQuestion[]> = {
    "w6-1": [
        {
            id: "w6-1-q1",
            question: "CQRS 的全称是什么？",
            options: [
                "Command Query Request Segregation",
                "Command Query Responsibility Segregation",
                "Common Query Response System",
                "Central Query Resource Service",
            ],
            answer: 1,
            rationale: "Fowler 定义：CQRS stands for 'Command Query Responsibility Segregation'。",
        },
        {
            id: "w6-1-q2",
            question: "CQRS 的核心思想是什么？",
            options: [
                "合并读写模型",
                "将更新（命令）和读取（查询）的模型分离",
                "只使用读取模型",
                "只使用写入模型",
            ],
            answer: 1,
            rationale: "Fowler 描述 CQRS 的核心是采用不同的概念模型处理数据修改（命令）和数据查询（查询）两种操作。",
        },
        {
            id: "w6-1-q3",
            question: "Martin Fowler 对使用 CQRS 的建议是什么？",
            options: [
                "所有系统都应该使用",
                "应该非常谨慎地使用，大多数系统不适合",
                "只用于小型系统",
                "必须与所有模式一起使用",
            ],
            answer: 1,
            rationale: "Fowler 警告：'you should be very cautious about using CQRS'，大多数信息系统并不适合此模式。",
        },
        {
            id: "w6-1-q4",
            question: "CQRS 主要适用于哪些场景？",
            options: [
                "所有 CRUD 应用",
                "复杂领域和读写操作差异大的高性能应用",
                "只有小型应用",
                "只有批处理系统",
            ],
            answer: 1,
            rationale: "Fowler 指出主要受益场景：复杂领域（分离模型简化设计）和高性能应用（读写差异大时独立扩展）。",
        },
        {
            id: "w6-1-q5",
            question: "为什么在事件溯源系统中 CQRS 成为必需？",
            options: [
                "事件溯源不支持查询",
                "从事件流重建状态通常复杂且低效，需要专门的查询视图",
                "事件溯源只支持写入",
                "法规要求",
            ],
            answer: 1,
            rationale: "microservices.io 指出：在事件溯源架构中，数据难以直接查询，CQRS 成为必需模式。",
        },
        {
            id: "w6-1-q6",
            question: "CQRS 的主要劣势有哪些？",
            options: [
                "性能下降",
                "系统复杂性增加、代码重复、复制延迟导致最终一致性",
                "成本降低",
                "安全性降低",
            ],
            answer: 1,
            rationale: "microservices.io 列出劣势：系统复杂性增加、可能出现代码重复、存在复制延迟和最终一致性问题。",
        },
        {
            id: "w6-1-q7",
            question: "CQRS 查询端通常使用什么类型的数据库？",
            options: [
                "只能用关系数据库",
                "通常使用 NoSQL 数据库，针对查询需求优化",
                "只能用内存数据库",
                "不需要数据库",
            ],
            answer: 1,
            rationale: "microservices.io 描述：创建专用读取数据库（通常为 NoSQL），针对特定查询需求优化。",
        },
        {
            id: "w6-1-q8",
            question: "CQRS 查询视图如何保持更新？",
            options: [
                "手动同步",
                "通过订阅领域事件自动同步",
                "定期全量刷新",
                "不需要更新",
            ],
            answer: 1,
            rationale: "microservices.io 描述：通过订阅服务发布的领域事件来保持数据更新。",
        },
        {
            id: "w6-1-q9",
            question: "CQRS 应该在系统的什么范围内使用？",
            options: [
                "整个系统",
                "特定的有界上下文（Bounded Context）",
                "所有微服务",
                "只在前端",
            ],
            answer: 1,
            rationale: "Fowler 强调：应仅在特定的有界上下文中使用，而非整个系统。",
        },
        {
            id: "w6-1-q10",
            question: "CQRS 的替代方案是什么？",
            options: [
                "没有替代方案",
                "API Composition 模式",
                "只能用 CQRS",
                "直接跨数据库查询",
            ],
            answer: 1,
            rationale: "microservices.io 列出 API Composition 模式作为 CQRS 的替代方案。",
        },
        {
            id: "w6-1-q11",
            question: "CQRS 如何支持独立扩展？",
            options: [
                "不支持扩展",
                "命令端和查询端可以独立扩展，应用不同的优化策略",
                "只能同时扩展",
                "只能扩展查询端",
            ],
            answer: 1,
            rationale: "Fowler 指出当读写操作差异大时，CQRS 允许独立扩展，并能对两侧应用不同的优化策略。",
        },
        {
            id: "w6-1-q12",
            question: "CQRS 与哪些模式相关？",
            options: [
                "只有数据库模式",
                "Database per Service、API Composition、Event Sourcing、Domain Event",
                "只有网络模式",
                "只有安全模式",
            ],
            answer: 1,
            rationale: "microservices.io 列出相关模式：Database per Service、API Composition、Event Sourcing、Domain Event。",
        },
    ],
    "w6-2": [
        {
            id: "w6-2-q1",
            question: "Event Sourcing 的核心定义是什么？",
            options: [
                "存储当前状态",
                "将所有状态变更记录为事件序列",
                "删除历史数据",
                "只存储最新事件",
            ],
            answer: 1,
            rationale: "Fowler 定义：'Capture all changes to an application state as a sequence of events'。",
        },
        {
            id: "w6-2-q2",
            question: "Event Sourcing 如何重建实体状态？",
            options: [
                "从快照恢复",
                "通过重放事件序列",
                "从备份恢复",
                "手动输入",
            ],
            answer: 1,
            rationale: "microservices.io 描述：'persists the state as a sequence of state-changing events'——通过重放事件重建状态。",
        },
        {
            id: "w6-2-q3",
            question: "Event Sourcing 的三个关键能力是什么？",
            options: [
                "创建、更新、删除",
                "Complete Rebuild、Temporal Query、Event Replay",
                "读取、写入、删除",
                "同步、异步、批量",
            ],
            answer: 1,
            rationale: "Fowler 列出关键能力：Complete Rebuild（完整重建）、Temporal Query（时间查询）、Event Replay（事件重放）。",
        },
        {
            id: "w6-2-q4",
            question: "什么是 Event Store？",
            options: [
                "普通数据库",
                "同时作为存储和消息代理的专用数据库",
                "缓存系统",
                "文件系统",
            ],
            answer: 1,
            rationale: "microservices.io 描述：Event Store 是 '一个同时作为存储和消息代理的专用数据库'。",
        },
        {
            id: "w6-2-q5",
            question: "为什么 Event Sourcing 需要与 CQRS 配合？",
            options: [
                "法规要求",
                "从事件重建状态通常复杂且低效，需要专门的查询视图",
                "性能原因",
                "安全原因",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'reconstructing business entity state from events is typically complex and inefficient'。",
        },
        {
            id: "w6-2-q6",
            question: "Event Sourcing 的主要学习挑战是什么？",
            options: [
                "语法复杂",
                "不熟悉的编程范式",
                "硬件要求高",
                "文档少",
            ],
            answer: 1,
            rationale: "microservices.io 指出：'Learning curve as event sourcing represents unfamiliar programming paradigms'。",
        },
        {
            id: "w6-2-q7",
            question: "Temporal Query 能力是什么？",
            options: [
                "查询时间戳",
                "通过重放事件重建任意历史时刻的状态",
                "查询未来状态",
                "删除历史查询",
            ],
            answer: 1,
            rationale: "Fowler 描述：'Determine application state at any historical point by replaying events up to that moment'。",
        },
        {
            id: "w6-2-q8",
            question: "外部系统交互在 Event Sourcing 中有什么挑战？",
            options: [
                "没有挑战",
                "必须区分真正处理和重放，避免不必要的外部通知",
                "外部系统更快",
                "外部系统更稳定",
            ],
            answer: 1,
            rationale: "Fowler 指出：'Gateways must distinguish real processing from replay to prevent unwanted external notifications'。",
        },
        {
            id: "w6-2-q9",
            question: "Event Sourcing 适合哪些使用场景？",
            options: [
                "简单 CRUD 应用",
                "审计追踪、调试、事件驱动架构、会计系统",
                "静态网站",
                "批量数据处理",
            ],
            answer: 1,
            rationale: "Fowler 列出适用场景：审计追踪、调试、事件驱动架构、会计系统等。",
        },
        {
            id: "w6-2-q10",
            question: "如何处理事件日志的增长问题？",
            options: [
                "删除旧事件",
                "使用快照策略，定期保存状态快照",
                "不需要处理",
                "压缩事件",
            ],
            answer: 1,
            rationale: "需要考虑快照策略和存储管理，定期保存状态快照以加速重建过程。",
        },
        {
            id: "w6-2-q11",
            question: "Event Sourcing 如何处理事件反转？",
            options: [
                "删除事件",
                "差异事件易反转，绝对值事件需在处理时存储先前值",
                "不支持反转",
                "手动修改",
            ],
            answer: 1,
            rationale: "Fowler 描述：差异事件（如 'add $10'）易反转，绝对值事件需存储先前值以实现准确反转。",
        },
        {
            id: "w6-2-q12",
            question: "Event Sourcing 的主要优势有哪些？",
            options: [
                "只有性能优势",
                "可靠事件发布、完整审计追踪、时间查询、松耦合",
                "只有安全优势",
                "只有成本优势",
            ],
            answer: 1,
            rationale: "microservices.io 列出优势：可靠事件发布、完整审计追踪、时间查询、减少阻抗不匹配、松耦合。",
        },
    ],
    "w6-3": [
        {
            id: "w6-3-q1",
            question: "Transactional Outbox 模式解决什么问题？",
            options: [
                "数据库性能",
                "数据库更新和消息发送的原子性问题",
                "网络延迟",
                "安全问题",
            ],
            answer: 1,
            rationale: "microservices.io 指出该模式解决微服务中数据库更新和消息发送的一致性问题。",
        },
        {
            id: "w6-3-q2",
            question: "什么是 Dual Write 问题？",
            options: [
                "写两次数据",
                "同时修改数据库和发送消息可能导致不一致",
                "写入太慢",
                "写入失败",
            ],
            answer: 1,
            rationale: "Debezium 描述 Dual Write 问题：同时修改多个资源可能导致不一致，Outbox 模式通过只修改单一资源解决。",
        },
        {
            id: "w6-3-q3",
            question: "Outbox 模式的核心思想是什么？",
            options: [
                "直接发送消息",
                "先将消息写入数据库 Outbox 表（与业务数据同一事务），然后发布到消息代理",
                "使用 2PC",
                "不发送消息",
            ],
            answer: 1,
            rationale: "microservices.io 描述：'First, write the message/event to a database OUTBOX table as part of the transaction'。",
        },
        {
            id: "w6-3-q4",
            question: "Outbox 模式的四个参与者是什么？",
            options: [
                "客户端、服务器、数据库、缓存",
                "发送者、数据库、消息出站表、消息中继",
                "生产者、消费者、队列、主题",
                "读者、写者、存储、网络",
            ],
            answer: 1,
            rationale: "microservices.io 列出四个参与者：发送者、数据库、消息出站表、消息中继。",
        },
        {
            id: "w6-3-q5",
            question: "为什么消费者需要是幂等的？",
            options: [
                "提高性能",
                "消息中继可能重复发送消息",
                "简化代码",
                "减少存储",
            ],
            answer: 1,
            rationale: "microservices.io 指出：消息中继可能重复发送消息，'consumers should be idempotent'。",
        },
        {
            id: "w6-3-q6",
            question: "消息中继有哪两种实现方式？",
            options: [
                "同步和异步",
                "Polling Publisher 和 Transaction Log Tailing",
                "推送和拉取",
                "批量和流式",
            ],
            answer: 1,
            rationale: "消息中继可以通过 Polling Publisher（轮询发布者）或 Transaction Log Tailing（事务日志追踪）实现。",
        },
        {
            id: "w6-3-q7",
            question: "Debezium Outbox 表应该包含哪些关键字段？",
            options: [
                "只有 id 和 data",
                "id（UUID）、aggregatetype、aggregateid、type、payload",
                "只有消息内容",
                "只有时间戳",
            ],
            answer: 1,
            rationale: "Debezium 描述 Outbox 表包含：id（UUID 用于去重）、aggregatetype、aggregateid、type、payload（JSON）。",
        },
        {
            id: "w6-3-q8",
            question: "Outbox 模式如何避免 2PC？",
            options: [
                "使用分布式事务",
                "只修改单一资源（本地数据库），将消息写入同一事务的 Outbox 表",
                "不使用事务",
                "使用缓存",
            ],
            answer: 1,
            rationale: "Outbox 模式通过只修改单一资源避免 2PC，消息作为本地事务的一部分写入 Outbox 表。",
        },
        {
            id: "w6-3-q9",
            question: "Debezium 在 Outbox 模式中如何处理写入后的事件？",
            options: [
                "保留所有事件",
                "事件写入后立即删除，CDC 捕获 INSERT 事件",
                "定期清理",
                "移动到归档表",
            ],
            answer: 1,
            rationale: "Debezium 描述：事件写入后立即删除（两个操作都记录在日志中），CDC 捕获 INSERT 事件并传播。",
        },
        {
            id: "w6-3-q10",
            question: "Outbox 模式的关键优势有哪些？",
            options: [
                "只有性能优势",
                "避免 2PC、保证消息只在事务成功时发送、维持消息顺序",
                "只有成本优势",
                "只有简化开发",
            ],
            answer: 1,
            rationale: "microservices.io 列出优势：避免使用 2PC，保证消息只在数据库事务成功时发送，维持消息发送顺序。",
        },
        {
            id: "w6-3-q11",
            question: "SMT（Single Message Transforms）在 Outbox 中的作用是什么？",
            options: [
                "加密消息",
                "根据聚合类型将事件路由到适当的 Kafka topic",
                "压缩消息",
                "验证消息",
            ],
            answer: 1,
            rationale: "Debezium 描述使用自定义 SMT 根据聚合类型将事件路由到适当的 Kafka topic。",
        },
        {
            id: "w6-3-q12",
            question: "Outbox 模式与哪些模式相关？",
            options: [
                "只有数据库模式",
                "Saga、Domain Event、Event Sourcing",
                "只有网络模式",
                "只有安全模式",
            ],
            answer: 1,
            rationale: "microservices.io 指出 Outbox 模式与 Saga、Domain Event、Event Sourcing 等模式相关联。",
        },
    ],
    "w6-4": [
        {
            id: "w6-4-q1",
            question: "Transaction Log Tailing 模式的定义是什么？",
            options: [
                "轮询数据库",
                "追踪数据库事务日志并发布消息到消息代理",
                "直接读取表",
                "使用触发器",
            ],
            answer: 1,
            rationale: "microservices.io 定义：'Tail the database transaction log and publish each message/event inserted into the outbox to the message broker'。",
        },
        {
            id: "w6-4-q2",
            question: "CDC（Change Data Capture）是什么？",
            options: [
                "数据库备份",
                "识别和捕获数据库中数据变更，并实时传递到下游系统的过程",
                "数据加密",
                "数据压缩",
            ],
            answer: 1,
            rationale: "CDC 是识别和捕获数据库中数据变更，并实时传递到下游系统的过程。",
        },
        {
            id: "w6-4-q3",
            question: "MySQL 使用什么机制实现事务日志访问？",
            options: [
                "WAL",
                "binlog",
                "table streams",
                "redo log",
            ],
            answer: 1,
            rationale: "microservices.io 指出 MySQL 使用 binlog 实现事务日志访问。",
        },
        {
            id: "w6-4-q4",
            question: "PostgreSQL 使用什么机制实现事务日志访问？",
            options: [
                "binlog",
                "WAL（Write-Ahead Logging）",
                "table streams",
                "redo log",
            ],
            answer: 1,
            rationale: "microservices.io 指出 PostgreSQL 使用 WAL（Write-Ahead Logging）实现事务日志访问。",
        },
        {
            id: "w6-4-q5",
            question: "Log-Based CDC 相比其他方法有什么优势？",
            options: [
                "实现简单",
                "对源系统影响最小，无需修改应用程序",
                "成本最低",
                "速度最快",
            ],
            answer: 1,
            rationale: "Log-Based CDC 是最高效的实现方式：读取事务日志，对源系统影响最小，无需修改应用程序。",
        },
        {
            id: "w6-4-q6",
            question: "Trigger-Based CDC 的缺点是什么？",
            options: [
                "实现复杂",
                "影响数据库性能，每次更新需要多次写入",
                "不支持删除",
                "不支持更新",
            ],
            answer: 1,
            rationale: "Trigger-Based CDC 减少数据库性能，因为每次更新、插入或删除都需要多次写入。",
        },
        {
            id: "w6-4-q7",
            question: "Debezium 在 CDC 中扮演什么角色？",
            options: [
                "数据库",
                "提供多种数据库连接器，捕获事务日志变更并流式传输到 Kafka",
                "消息队列",
                "缓存",
            ],
            answer: 1,
            rationale: "Debezium 提供多种数据库连接器，捕获事务日志变更并流式传输到 Kafka。",
        },
        {
            id: "w6-4-q8",
            question: "Transaction Log Tailing 与 Polling Publisher 相比如何？",
            options: [
                "实现更简单",
                "更高效但实现更复杂",
                "性能更差",
                "不支持高可用",
            ],
            answer: 1,
            rationale: "Transaction Log Tailing 比 Polling Publisher 更高效，但实现更复杂。",
        },
        {
            id: "w6-4-q9",
            question: "Transaction Log Tailing 的关键优势是什么？",
            options: [
                "实现简单",
                "消除 2PC 需求，确保消息发布的准确性",
                "成本最低",
                "不需要配置",
            ],
            answer: 1,
            rationale: "microservices.io 指出关键优势：消除 2PC 需求，确保消息发布的准确性。",
        },
        {
            id: "w6-4-q10",
            question: "AWS DynamoDB 使用什么机制实现 CDC？",
            options: [
                "binlog",
                "table streams",
                "WAL",
                "triggers",
            ],
            answer: 1,
            rationale: "microservices.io 指出 AWS DynamoDB 使用 table streams 实现 CDC。",
        },
        {
            id: "w6-4-q11",
            question: "Transaction Log Tailing 的实现挑战有哪些？",
            options: [
                "没有挑战",
                "数据库特定要求和防止重复消息发布",
                "只有性能挑战",
                "只有成本挑战",
            ],
            answer: 1,
            rationale: "microservices.io 指出实现复杂度包括数据库特定要求和防止重复消息发布的挑战。",
        },
        {
            id: "w6-4-q12",
            question: "CDC 在哪些行业有典型应用？",
            options: [
                "只有金融业",
                "电商（库存追踪）、金融（账户活动）、医疗（患者记录）",
                "只有医疗业",
                "只有零售业",
            ],
            answer: 1,
            rationale: "CDC 在多个行业有应用：电商追踪库存变更，金融监控账户活动，医疗维护患者记录。",
        },
    ],
}
