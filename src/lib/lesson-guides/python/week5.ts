import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week5Guides: Record<string, LessonGuide> = {
    "py-w5-1": {
        lessonId: "py-w5-1",
        background: [
            "【字典定义】官方文档：Dictionaries are indexed by keys, which can be any immutable type。字典是键值对映射，键必须是不可变类型（字符串、数字、只包含不可变元素的元组）。",
            "【创建方式】字典可以用 {} 创建：tel = {'jack': 4098}，用 dict() 构造：dict([('a', 1)])，用关键字参数：dict(a=1, b=2)，用字典推导式：{x: x**2 for x in range(5)}。",
            "【基本操作】存储：d[key] = value，访问：d[key]（不存在抛 KeyError），删除：del d[key]，检查键存在：key in d。Python 3.7+ 字典保持插入顺序。",
            "【视图对象】keys()、values()、items() 返回视图对象，动态反映字典变化。遍历字典：for k, v in d.items()。",
            "【get 方法】d.get(key) 安全获取值，键不存在返回 None（或指定默认值），不会抛出 KeyError。",
        ],
        keyDifficulties: [
            "【KeyError 处理】直接访问 d[key] 键不存在会抛 KeyError。使用 get() 返回 None，或 setdefault() 设置默认值，或 in 检查键存在。",
            "【视图对象特性】keys()、values()、items() 返回视图而非列表，修改字典会反映到视图。Python 2 中返回列表，Python 3 中是视图对象。",
            "【键的要求】字典键必须可哈希（不可变）。列表不能作为键，但元组可以（如果元组元素都可哈希）。",
            "【字典比较】字典比较只支持 == 和 !=，不支持 < > 比较。两个字典相等当且仅当它们有相同的键值对。",
        ],
        handsOnPath: [
            "1. 创建字典：tel = {'jack': 4098, 'sape': 4139}",
            "2. 访问和修改：print(tel['jack']); tel['guido'] = 4127",
            "3. 使用 get：print(tel.get('irv', 'Not found'))",
            "4. 遍历字典：for k, v in tel.items(): print(k, v)",
            "5. 检查键存在：if 'jack' in tel: print('Found')",
            "6. 字典推导式：squares = {x: x**2 for x in range(5)}",
        ],
        selfCheck: [
            "访问不存在的键会发生什么？",
            "get() 和直接访问 [] 有什么区别？",
            "keys()、values()、items() 返回什么类型？",
            "列表为什么不能作为字典键？",
            "如何安全地删除一个可能不存在的键？",
            "Python 3.7+ 字典有什么保证？",
        ],
        extensions: [
            "学习 collections.OrderedDict 显式有序字典",
            "了解 collections.Counter 计数器字典",
            "探索 types.MappingProxyType 只读字典视图",
            "学习 ChainMap 链式字典查找",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/datastructures.html#dictionaries",
            "https://docs.python.org/3/library/stdtypes.html#mapping-types-dict",
            "https://docs.python.org/3/library/stdtypes.html#dict",
        ],
    },
    "py-w5-2": {
        lessonId: "py-w5-2",
        background: [
            "【字典推导式】语法：{k: v for k, v in iterable}。示例：{x: x**2 for x in (2, 4, 6)} 生成 {2: 4, 4: 16, 6: 36}。支持条件过滤。",
            "【合并运算符】PEP 584 引入 | 和 |= 运算符（Python 3.9+）。d | e 创建新字典合并两个字典，d |= e 就地更新。右侧值优先。",
            "【update 方法】d.update(e) 用 e 的键值对更新 d，等价于 d |= e。可接受字典或键值对可迭代对象。",
            "【setdefault 方法】d.setdefault(key, default) 如果键存在返回值，不存在则设置默认值并返回。比先检查再设置更简洁。",
            "【defaultdict】collections.defaultdict 自动为缺失键创建默认值。defaultdict(list) 访问不存在的键自动创建空列表。",
        ],
        keyDifficulties: [
            "【合并非交换性】d | e 与 e | d 不同：键冲突时右侧值覆盖左侧。这与 update() 行为一致：'last-seen wins'。",
            "【|= 灵活性】d |= e 的 e 可以是任何 Mapping 或键值对可迭代对象，而 d | e 要求两边都是字典。",
            "【defaultdict 陷阱】访问不存在的键会自动创建条目，即使只是读取。这可能导致意外的字典增长。get() 不会触发默认值创建。",
            "【setdefault vs defaultdict】setdefault 每次调用都要提供默认值；defaultdict 在创建时指定工厂函数，更高效。",
        ],
        handsOnPath: [
            "1. 字典推导式：squares = {x: x**2 for x in range(5)}",
            "2. 带条件推导式：evens = {x: x**2 for x in range(10) if x % 2 == 0}",
            "3. 合并字典：merged = {'a': 1} | {'b': 2}",
            "4. 使用 update：d = {'a': 1}; d.update({'b': 2})",
            "5. 使用 setdefault：d.setdefault('c', []).append(1)",
            "6. 使用 defaultdict：from collections import defaultdict; d = defaultdict(list)",
        ],
        selfCheck: [
            "字典推导式的语法是什么？",
            "d | e 中键冲突时哪个值保留？",
            "update() 和 | 运算符有什么区别？",
            "setdefault() 的作用是什么？",
            "defaultdict 什么时候会创建新条目？",
            "Python 3.9+ 引入了什么字典运算符？",
        ],
        extensions: [
            "学习 dict.fromkeys() 创建相同值的字典",
            "了解 functools.reduce 合并多个字典",
            "探索 operator.or_ 函数式合并",
            "学习 collections.UserDict 自定义字典类",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/datastructures.html#dictionaries",
            "https://peps.python.org/pep-0584/",
            "https://docs.python.org/3/library/collections.html#collections.defaultdict",
        ],
    },
    "py-w5-3": {
        lessonId: "py-w5-3",
        background: [
            "【集合定义】集合是无序不重复元素的集合。用 set() 或 {元素} 创建，空集合必须用 set()（{} 是空字典）。",
            "【集合运算】支持数学集合运算：& 交集、| 并集、- 差集、^ 对称差集。也有对应方法：intersection()、union()、difference()、symmetric_difference()。",
            "【集合方法】add(x) 添加元素、remove(x) 删除（不存在抛 KeyError）、discard(x) 删除（不存在不报错）、pop() 删除并返回任意元素。",
            "【frozenset】不可变集合，可以作为字典键或另一个集合的元素。支持所有非修改操作。frozenset([1, 2, 3]) 创建。",
            "【集合推导式】语法：{expr for item in iterable}。示例：{x**2 for x in range(10)} 创建平方数集合。",
        ],
        keyDifficulties: [
            "【空集合陷阱】{} 创建空字典而非空集合。空集合必须用 set()。这是常见错误来源。",
            "【集合元素要求】集合元素必须可哈希（不可变）。列表、字典、普通集合不能作为元素，但 frozenset 可以。",
            "【运算符 vs 方法】运算符 & | - ^ 要求两边都是集合；方法接受任何可迭代对象。s & [1,2] 报错，s.intersection([1,2]) 可以。",
            "【remove vs discard】remove(x) 元素不存在抛 KeyError，discard(x) 静默忽略。选择取决于是否需要知道元素存在。",
        ],
        handsOnPath: [
            "1. 创建集合：s = {1, 2, 3} 或 s = set([1, 2, 2, 3])",
            "2. 集合运算：a = {1,2,3}; b = {2,3,4}; print(a & b, a | b, a - b)",
            "3. 添加删除：s.add(4); s.remove(1); s.discard(10)",
            "4. 检查成员：2 in s",
            "5. 去重：unique = set([1, 2, 2, 3, 3, 3])",
            "6. frozenset：fs = frozenset([1, 2, 3])",
        ],
        selfCheck: [
            "如何创建空集合？为什么不能用 {}？",
            "集合的 & | - ^ 运算分别是什么？",
            "remove() 和 discard() 的区别是什么？",
            "为什么列表不能作为集合元素？",
            "frozenset 和 set 的区别是什么？",
            "如何用集合对列表去重？",
        ],
        extensions: [
            "学习 issubset() 和 issuperset() 判断子集关系",
            "了解 isdisjoint() 判断是否无交集",
            "探索集合在算法中的应用（如快速成员检测）",
            "学习 collections.abc.Set 抽象基类",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset",
            "https://docs.python.org/3/tutorial/datastructures.html#sets",
            "https://docs.python.org/3/library/stdtypes.html#frozenset",
        ],
    },
    "py-w5-4": {
        lessonId: "py-w5-4",
        background: [
            "【可哈希定义】官方文档：An object is hashable if it has a hash value which never changes during its lifetime。可哈希对象需要 __hash__() 方法和 __eq__() 方法，且相等的对象必须有相同哈希值。",
            "【哈希用途】可哈希性使对象可以作为字典键和集合成员，因为这些数据结构内部使用哈希值定位元素。",
            "【内置类型】大多数不可变内置对象是可哈希的；可变容器（list、dict、set）不可哈希；不可变容器（tuple、frozenset）只有元素都可哈希时才可哈希。",
            "【自定义类型】用户定义类默认可哈希，对象互不相等，哈希值基于 id()。定义 __eq__() 但不定义 __hash__() 会使类不可哈希。",
            "【__hash__ 规则】相等的对象必须有相同哈希值。如果类定义可变对象且实现了 __eq__()，不应实现 __hash__()，因为哈希值改变会导致哈希表出错。",
        ],
        keyDifficulties: [
            "【__hash__ 与 __eq__】定义 __eq__() 但不定义 __hash__() 会使 __hash__ 隐式设为 None，对象变为不可哈希。这是 Python 的安全机制。",
            "【可变对象不可哈希】可变对象（list、dict、set）不可哈希，因为它们的内容可能改变，导致哈希值不稳定。",
            "【元组的条件可哈希】元组只有在所有元素都可哈希时才可哈希。(1, 2, [3]) 不可哈希因为包含列表。",
            "【哈希冲突】不同对象可以有相同哈希值（哈希冲突），但相等的对象必须有相同哈希值。",
        ],
        handsOnPath: [
            "1. 测试可哈希性：hash(1); hash('str'); hash((1, 2))",
            "2. 不可哈希对象：hash([1, 2])  # TypeError",
            "3. 条件可哈希：hash((1, 2, 3)) vs hash((1, [2]))",
            "4. 字典键测试：{(1, 2): 'tuple ok'} vs {[1, 2]: 'list fail'}",
            "5. 自定义类哈希：class Point: def __hash__(self): return hash((self.x, self.y))",
            "6. 检查可哈希：from collections.abc import Hashable; isinstance(obj, Hashable)",
        ],
        selfCheck: [
            "什么是可哈希对象？",
            "为什么列表不能作为字典键？",
            "元组什么时候是可哈希的？",
            "定义 __eq__() 对 __hash__() 有什么影响？",
            "相等的对象必须满足什么哈希条件？",
            "如何检查一个对象是否可哈希？",
        ],
        extensions: [
            "学习 functools.hash 和 __hash__ 的关系",
            "了解 Python 的哈希表实现原理",
            "探索 sys.hash_info 获取哈希配置",
            "学习 dataclass 的 frozen=True 使实例可哈希",
        ],
        sourceUrls: [
            "https://docs.python.org/3/reference/datamodel.html#object.__hash__",
            "https://docs.python.org/3/glossary.html#term-hashable",
            "https://docs.python.org/3/reference/datamodel.html#objects-values-and-types",
        ],
    },
}

export const week5Quizzes: Record<string, QuizQuestion[]> = {
    "py-w5-1": [
        {
            id: "py-w5-1-q1",
            question: "字典键必须满足什么条件？",
            options: [
                "必须是字符串",
                "必须是整数",
                "必须是不可变类型（可哈希）",
                "可以是任意类型",
            ],
            answer: 2,
            rationale: "文档说明：Keys can be any immutable type。列表等可变类型不能作为键。",
        },
        {
            id: "py-w5-1-q2",
            question: "d.get('key') 与 d['key'] 的区别是什么？",
            options: [
                "没有区别",
                "get() 键不存在返回 None，[] 抛出 KeyError",
                "get() 更快",
                "[] 返回 None",
            ],
            answer: 1,
            rationale: "get() 方法安全获取值，键不存在返回 None（或指定默认值），不会抛出 KeyError。",
        },
        {
            id: "py-w5-1-q3",
            question: "dict.keys() 返回什么类型？",
            options: [
                "列表",
                "元组",
                "视图对象",
                "生成器",
            ],
            answer: 2,
            rationale: "Python 3 中 keys()、values()、items() 返回视图对象，动态反映字典变化。",
        },
        {
            id: "py-w5-1-q4",
            question: "如何检查键是否在字典中？",
            options: [
                "dict.has_key('key')",
                "'key' in dict",
                "dict.contains('key')",
                "dict.exists('key')",
            ],
            answer: 1,
            rationale: "使用 in 运算符检查键是否存在：'key' in d 返回 True 或 False。",
        },
        {
            id: "py-w5-1-q5",
            question: "{x: x**2 for x in range(3)} 的结果是？",
            options: [
                "{0: 0, 1: 1, 2: 4}",
                "{1: 1, 2: 4, 3: 9}",
                "[0, 1, 4]",
                "{0, 1, 4}",
            ],
            answer: 0,
            rationale: "字典推导式 {x: x**2 for x in range(3)} 生成 {0: 0, 1: 1, 2: 4}。",
        },
        {
            id: "py-w5-1-q6",
            question: "Python 3.7+ 字典有什么保证？",
            options: [
                "键按字母排序",
                "保持插入顺序",
                "值按大小排序",
                "自动去重",
            ],
            answer: 1,
            rationale: "Python 3.7+ 字典保证保持插入顺序，这是语言规范的一部分。",
        },
        {
            id: "py-w5-1-q7",
            question: "删除字典中的键值对使用什么？",
            options: [
                "dict.remove('key')",
                "del dict['key']",
                "dict.delete('key')",
                "dict.pop() 无参数",
            ],
            answer: 1,
            rationale: "使用 del dict['key'] 删除键值对。也可以用 pop('key') 删除并返回值。",
        },
        {
            id: "py-w5-1-q8",
            question: "以下哪个可以作为字典键？",
            options: [
                "[1, 2, 3]",
                "{'a': 1}",
                "(1, 2, 3)",
                "{1, 2, 3}",
            ],
            answer: 2,
            rationale: "元组是不可变的可哈希类型，可以作为键。列表、字典、集合是可变的不能作为键。",
        },
        {
            id: "py-w5-1-q9",
            question: "dict(a=1, b=2) 等价于什么？",
            options: [
                "{'a': 1, 'b': 2}",
                "{a: 1, b: 2}",
                "[(a, 1), (b, 2)]",
                "错误语法",
            ],
            answer: 0,
            rationale: "dict() 支持关键字参数，dict(a=1, b=2) 创建 {'a': 1, 'b': 2}。",
        },
        {
            id: "py-w5-1-q10",
            question: "如何同时遍历字典的键和值？",
            options: [
                "for k, v in dict",
                "for k, v in dict.items()",
                "for k, v in dict.pairs()",
                "for k, v in dict.values()",
            ],
            answer: 1,
            rationale: "使用 for k, v in dict.items() 同时获取键和值进行遍历。",
        },
        {
            id: "py-w5-1-q11",
            question: "字典支持哪些比较操作？",
            options: [
                "== != < > <= >=",
                "只支持 == 和 !=",
                "不支持任何比较",
                "只支持 ==",
            ],
            answer: 1,
            rationale: "字典只支持 == 和 != 比较，不支持 < > 等大小比较。",
        },
        {
            id: "py-w5-1-q12",
            question: "如何创建空字典？",
            options: [
                "只能用 {}",
                "只能用 dict()",
                "{} 或 dict()",
                "set()",
            ],
            answer: 2,
            rationale: "{} 和 dict() 都可以创建空字典。注意 {} 是空字典不是空集合。",
        },
    ],
    "py-w5-2": [
        {
            id: "py-w5-2-q1",
            question: "d | e 运算符在 Python 哪个版本引入？",
            options: [
                "Python 3.5",
                "Python 3.7",
                "Python 3.9",
                "Python 3.10",
            ],
            answer: 2,
            rationale: "PEP 584 在 Python 3.9 引入字典合并运算符 | 和更新运算符 |=。",
        },
        {
            id: "py-w5-2-q2",
            question: "{'a': 1} | {'a': 2} 的结果是什么？",
            options: [
                "{'a': 1}",
                "{'a': 2}",
                "{'a': 1, 'a': 2}",
                "KeyError",
            ],
            answer: 1,
            rationale: "字典合并时右侧值优先（last-seen wins），所以 'a' 的值是 2。",
        },
        {
            id: "py-w5-2-q3",
            question: "d |= e 与 d.update(e) 有什么区别？",
            options: [
                "完全相同",
                "|= 创建新字典，update 就地修改",
                "功能相同，都就地修改",
                "update 创建新字典",
            ],
            answer: 2,
            rationale: "d |= e 和 d.update(e) 功能相同，都就地修改 d。|= 是 Python 3.9+ 的新语法。",
        },
        {
            id: "py-w5-2-q4",
            question: "defaultdict(list) 访问不存在的键会怎样？",
            options: [
                "抛出 KeyError",
                "返回 None",
                "自动创建空列表并返回",
                "返回 0",
            ],
            answer: 2,
            rationale: "defaultdict 访问不存在的键时调用工厂函数创建默认值，list() 返回空列表。",
        },
        {
            id: "py-w5-2-q5",
            question: "setdefault(key, default) 的作用是什么？",
            options: [
                "总是设置键的值为 default",
                "键不存在时设置默认值并返回，存在时返回现有值",
                "删除键并返回默认值",
                "检查键是否存在",
            ],
            answer: 1,
            rationale: "setdefault() 键存在返回现有值，不存在则设置默认值并返回。避免了先检查再设置。",
        },
        {
            id: "py-w5-2-q6",
            question: "d | e 和 e | d 的关系是？",
            options: [
                "总是相等",
                "结果可能不同（键冲突时）",
                "d | e 更快",
                "e | d 总是空字典",
            ],
            answer: 1,
            rationale: "字典合并是非交换的，键冲突时右侧值覆盖左侧，所以 d | e 可能不等于 e | d。",
        },
        {
            id: "py-w5-2-q7",
            question: "defaultdict 的 get() 方法会创建新条目吗？",
            options: [
                "会",
                "不会，只有 __getitem__ 会",
                "取决于默认值类型",
                "会，但返回 None",
            ],
            answer: 1,
            rationale: "文档说明：__missing__() is only called by __getitem__()。get() 不会触发默认值创建。",
        },
        {
            id: "py-w5-2-q8",
            question: "以下哪个是有效的字典推导式？",
            options: [
                "[k: v for k, v in items]",
                "{k: v for k, v in items}",
                "(k: v for k, v in items)",
                "{k, v for k, v in items}",
            ],
            answer: 1,
            rationale: "字典推导式使用花括号和冒号：{k: v for k, v in items}。",
        },
        {
            id: "py-w5-2-q9",
            question: "d |= [('a', 1)] 是否合法？",
            options: [
                "不合法，必须是字典",
                "合法，|= 接受键值对可迭代对象",
                "只在 Python 3.10+ 合法",
                "会抛出 TypeError",
            ],
            answer: 1,
            rationale: "PEP 584 说明：|= 接受任何 Mapping 或键值对可迭代对象，而 | 要求两边都是字典。",
        },
        {
            id: "py-w5-2-q10",
            question: "defaultdict(int) 的默认值是什么？",
            options: [
                "None",
                "0",
                "空字符串",
                "空列表",
            ],
            answer: 1,
            rationale: "int() 不带参数返回 0，所以 defaultdict(int) 的默认值是 0，常用于计数。",
        },
        {
            id: "py-w5-2-q11",
            question: "{x: x*2 for x in range(3) if x > 0} 的结果是？",
            options: [
                "{0: 0, 1: 2, 2: 4}",
                "{1: 2, 2: 4}",
                "{1: 1, 2: 2}",
                "{0: 0}",
            ],
            answer: 1,
            rationale: "if 条件过滤掉 x=0，只保留 x=1 和 x=2，结果是 {1: 2, 2: 4}。",
        },
        {
            id: "py-w5-2-q12",
            question: "合并多个字典的推荐方式是什么（Python 3.9+）？",
            options: [
                "dict.update() 循环",
                "使用 | 运算符链式合并",
                "使用 ChainMap",
                "使用 **解包",
            ],
            answer: 1,
            rationale: "Python 3.9+ 推荐使用 | 运算符：d1 | d2 | d3，语法简洁直观。",
        },
    ],
    "py-w5-3": [
        {
            id: "py-w5-3-q1",
            question: "如何创建空集合？",
            options: [
                "{}",
                "set()",
                "[]",
                "{}空集合{}",
            ],
            answer: 1,
            rationale: "{} 创建空字典而非空集合，空集合必须用 set() 创建。",
        },
        {
            id: "py-w5-3-q2",
            question: "{1, 2, 3} & {2, 3, 4} 的结果是？",
            options: [
                "{1, 2, 3, 4}",
                "{2, 3}",
                "{1, 4}",
                "{1}",
            ],
            answer: 1,
            rationale: "& 是交集运算，返回两个集合的共同元素 {2, 3}。",
        },
        {
            id: "py-w5-3-q3",
            question: "remove(x) 和 discard(x) 的区别是什么？",
            options: [
                "没有区别",
                "remove 元素不存在抛 KeyError，discard 静默忽略",
                "discard 元素不存在抛 KeyError",
                "remove 返回被删除的元素",
            ],
            answer: 1,
            rationale: "remove(x) 元素不存在抛 KeyError，discard(x) 静默忽略不报错。",
        },
        {
            id: "py-w5-3-q4",
            question: "以下哪个可以作为集合元素？",
            options: [
                "[1, 2]",
                "{'a': 1}",
                "(1, 2)",
                "{1, 2}",
            ],
            answer: 2,
            rationale: "集合元素必须可哈希，元组是不可变的可以作为元素，列表、字典、集合不行。",
        },
        {
            id: "py-w5-3-q5",
            question: "{1, 2} | {3, 4} 的结果是？",
            options: [
                "{1, 2, 3, 4}",
                "{1, 2}",
                "{3, 4}",
                "{}",
            ],
            answer: 0,
            rationale: "| 是并集运算，返回两个集合的所有元素 {1, 2, 3, 4}。",
        },
        {
            id: "py-w5-3-q6",
            question: "{1, 2, 3} - {2, 3, 4} 的结果是？",
            options: [
                "{1, 4}",
                "{1}",
                "{4}",
                "{2, 3}",
            ],
            answer: 1,
            rationale: "- 是差集运算，返回在第一个集合但不在第二个集合的元素 {1}。",
        },
        {
            id: "py-w5-3-q7",
            question: "frozenset 与 set 的主要区别是什么？",
            options: [
                "frozenset 更快",
                "frozenset 是不可变的",
                "frozenset 只能存储数字",
                "frozenset 有序",
            ],
            answer: 1,
            rationale: "frozenset 是不可变集合，可以作为字典键或另一个集合的元素。",
        },
        {
            id: "py-w5-3-q8",
            question: "集合推导式的语法是什么？",
            options: [
                "[x for x in iterable]",
                "{x for x in iterable}",
                "(x for x in iterable)",
                "set(x for x in iterable)",
            ],
            answer: 1,
            rationale: "集合推导式使用花括号但没有冒号：{x for x in iterable}。",
        },
        {
            id: "py-w5-3-q9",
            question: "{1, 2, 3} ^ {2, 3, 4} 的结果是？",
            options: [
                "{2, 3}",
                "{1, 4}",
                "{1, 2, 3, 4}",
                "{}",
            ],
            answer: 1,
            rationale: "^ 是对称差集运算，返回只在一个集合中的元素 {1, 4}。",
        },
        {
            id: "py-w5-3-q10",
            question: "s.intersection([1, 2, 3]) 是否合法？",
            options: [
                "不合法，必须是集合",
                "合法，方法接受任何可迭代对象",
                "只在 Python 3.9+ 合法",
                "返回 None",
            ],
            answer: 1,
            rationale: "集合方法接受任何可迭代对象，而运算符 & 要求两边都是集合。",
        },
        {
            id: "py-w5-3-q11",
            question: "set([1, 2, 2, 3, 3, 3]) 的结果是？",
            options: [
                "[1, 2, 3]",
                "{1, 2, 2, 3, 3, 3}",
                "{1, 2, 3}",
                "TypeError",
            ],
            answer: 2,
            rationale: "集合自动去重，结果是 {1, 2, 3}。",
        },
        {
            id: "py-w5-3-q12",
            question: "pop() 方法从集合中删除什么元素？",
            options: [
                "第一个元素",
                "最后一个元素",
                "任意一个元素",
                "指定的元素",
            ],
            answer: 2,
            rationale: "集合是无序的，pop() 删除并返回任意一个元素，不能指定。",
        },
    ],
    "py-w5-4": [
        {
            id: "py-w5-4-q1",
            question: "可哈希对象需要实现哪些方法？",
            options: [
                "只需要 __hash__()",
                "__hash__() 和 __eq__()",
                "只需要 __eq__()",
                "__hash__() 和 __cmp__()",
            ],
            answer: 1,
            rationale: "官方文档：可哈希对象需要 __hash__() 方法和 __eq__() 方法。",
        },
        {
            id: "py-w5-4-q2",
            question: "相等的对象必须满足什么哈希条件？",
            options: [
                "可以有不同的哈希值",
                "必须有相同的哈希值",
                "不需要实现 __hash__",
                "哈希值必须不同",
            ],
            answer: 1,
            rationale: "文档规定：Objects which compare equal must have the same hash value。",
        },
        {
            id: "py-w5-4-q3",
            question: "定义 __eq__() 但不定义 __hash__() 会怎样？",
            options: [
                "使用默认哈希",
                "__hash__ 被隐式设为 None，对象不可哈希",
                "抛出错误",
                "自动生成哈希函数",
            ],
            answer: 1,
            rationale: "文档说明：A class that overrides __eq__() and does not define __hash__() will have its __hash__() implicitly set to None。",
        },
        {
            id: "py-w5-4-q4",
            question: "以下哪个类型不可哈希？",
            options: [
                "int",
                "str",
                "list",
                "tuple",
            ],
            answer: 2,
            rationale: "可变容器（list、dict、set）不可哈希，因为内容可能改变。",
        },
        {
            id: "py-w5-4-q5",
            question: "(1, 2, [3]) 是否可哈希？",
            options: [
                "可哈希，因为是元组",
                "不可哈希，因为包含列表",
                "取决于 Python 版本",
                "可哈希，但哈希值不稳定",
            ],
            answer: 1,
            rationale: "元组只有元素都可哈希时才可哈希，包含列表的元组不可哈希。",
        },
        {
            id: "py-w5-4-q6",
            question: "用户定义类默认是否可哈希？",
            options: [
                "不可哈希",
                "可哈希，哈希值基于 id()",
                "取决于是否定义 __eq__",
                "需要显式定义 __hash__",
            ],
            answer: 1,
            rationale: "文档说明：用户定义类默认可哈希，对象互不相等，哈希值基于 id()。",
        },
        {
            id: "py-w5-4-q7",
            question: "为什么可变对象不应该实现 __hash__()？",
            options: [
                "性能问题",
                "对象内容改变会导致哈希值改变，破坏哈希表",
                "语法限制",
                "内存问题",
            ],
            answer: 1,
            rationale: "文档说明：如果可变对象的哈希值改变，会被放在错误的哈希桶中，导致查找失败。",
        },
        {
            id: "py-w5-4-q8",
            question: "如何检查对象是否可哈希？",
            options: [
                "type(obj) == hashable",
                "isinstance(obj, collections.abc.Hashable)",
                "obj.hashable()",
                "hash(obj) != None",
            ],
            answer: 1,
            rationale: "使用 isinstance(obj, collections.abc.Hashable) 检查对象是否可哈希。",
        },
        {
            id: "py-w5-4-q9",
            question: "hash() 函数在 64 位系统上返回值的大小是？",
            options: [
                "4 字节",
                "8 字节",
                "16 字节",
                "无限大",
            ],
            answer: 1,
            rationale: "文档说明：hash() 返回值在 64 位系统上通常是 8 字节（Py_ssize_t 大小）。",
        },
        {
            id: "py-w5-4-q10",
            question: "frozenset 为什么可以作为字典键？",
            options: [
                "因为它更小",
                "因为它是不可变的，所以可哈希",
                "因为它是内置类型",
                "Python 特殊处理",
            ],
            answer: 1,
            rationale: "frozenset 是不可变集合，内容不会改变，所以可以计算稳定的哈希值。",
        },
        {
            id: "py-w5-4-q11",
            question: "不同对象可以有相同的哈希值吗？",
            options: [
                "不可以",
                "可以，这叫哈希冲突",
                "只有相等的对象才能有相同哈希值",
                "取决于对象类型",
            ],
            answer: 1,
            rationale: "不同对象可以有相同哈希值（哈希冲突），但相等的对象必须有相同哈希值。",
        },
        {
            id: "py-w5-4-q12",
            question: "自定义 __hash__ 时推荐的做法是什么？",
            options: [
                "返回 id(self)",
                "返回对象大小",
                "将参与比较的属性打包成元组并哈希",
                "返回随机数",
            ],
            answer: 2,
            rationale: "文档推荐：mix together the hash values of the components by packing them into a tuple and hashing the tuple。",
        },
    ],
}
