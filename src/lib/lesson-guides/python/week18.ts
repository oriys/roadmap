import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week18Guides: Record<string, LessonGuide> = {
    "py-w18-1": {
        lessonId: "py-w18-1",
        background: [
            "【GIL 全局解释器锁】CPython 的 GIL 限制同一时刻只有一个线程执行 Python 字节码。这使得多线程无法利用多核进行 CPU 密集型计算。",
            "【线程适用场景】线程适合 I/O 密集型任务（文件操作、网络请求），因为等待 I/O 时会释放 GIL，其他线程可以执行。",
            "【Thread 类】threading.Thread(target=func, args=(), kwargs={}) 创建线程。start() 启动线程，join() 等待线程完成。",
            "【线程方法】is_alive() 检查线程是否运行；daemon 属性设置守护线程（必须在 start() 前设置）。",
            "【守护线程】daemon=True 的线程在主线程结束时自动终止，不会阻止程序退出。但不会执行清理操作。",
        ],
        keyDifficulties: [
            "【GIL 影响】GIL 限制了 CPU 密集型任务的多线程性能。对于计算密集型任务应使用 multiprocessing。",
            "【线程安全】多个线程同时访问共享数据可能导致竞态条件。必须使用同步原语保护共享资源。",
            "【join 阻塞】join(timeout=None) 会阻塞直到线程结束。不传 timeout 会无限等待。",
            "【线程异常】线程中的异常不会传播到主线程。需要在线程内部捕获处理或使用 threading.excepthook。",
        ],
        handsOnPath: [
            "1. 创建线程：import threading; t = threading.Thread(target=func, args=(1,))",
            "2. 启动和等待：t.start(); t.join()",
            "3. 守护线程：t.daemon = True; t.start()",
            "4. 检查状态：print(t.is_alive(), t.name, t.ident)",
            "5. 多线程执行：threads = [Thread(target=f) for _ in range(5)]; [t.start() for t in threads]",
            "6. 线程本地数据：local_data = threading.local(); local_data.x = 1",
        ],
        selfCheck: [
            "GIL 对多线程有什么影响？",
            "线程适合什么类型的任务？",
            "如何创建和启动线程？",
            "守护线程和普通线程有什么区别？",
            "join() 方法的作用是什么？",
            "threading.local() 的用途是什么？",
        ],
        extensions: [
            "学习 threading.excepthook 处理线程异常",
            "了解线程池 ThreadPoolExecutor",
            "探索 Python 3.12+ 的 per-interpreter GIL",
            "学习 asyncio 协程替代方案",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/threading.html",
            "https://docs.python.org/3/glossary.html#term-global-interpreter-lock",
            "https://docs.python.org/3/library/threading.html#thread-objects",
        ],
    },
    "py-w18-2": {
        lessonId: "py-w18-2",
        background: [
            "【Lock 互斥锁】threading.Lock() 创建锁。acquire() 获取锁，release() 释放锁。推荐使用 with 语句自动管理。",
            "【RLock 可重入锁】RLock 允许同一线程多次获取锁，但必须释放相同次数。用于递归调用场景。",
            "【Event 事件】threading.Event() 用于线程间信号传递。set() 设置标志，wait() 阻塞等待，clear() 清除标志。",
            "【Condition 条件变量】用于复杂的生产者-消费者模式。wait() 等待条件，notify()/notify_all() 通知等待线程。",
            "【Semaphore 信号量】控制同时访问资源的线程数量。BoundedSemaphore 防止 release 过多。",
        ],
        keyDifficulties: [
            "【死锁风险】多个锁的获取顺序不一致可能导致死锁。应始终按固定顺序获取锁。",
            "【with 语句优势】使用 with lock: 确保即使发生异常也能释放锁，避免死锁。",
            "【Condition 陷阱】Condition.wait() 会释放关联的锁，唤醒后重新获取。wait_for(predicate) 更安全。",
            "【Queue 线程安全】queue.Queue 是线程安全的，内置了锁机制，无需额外同步。",
        ],
        handsOnPath: [
            "1. 使用锁：lock = threading.Lock(); with lock: shared_resource += 1",
            "2. Event 信号：event = threading.Event(); event.wait(); event.set()",
            "3. Condition：cv = threading.Condition(); cv.wait_for(lambda: ready)",
            "4. Semaphore：sem = threading.Semaphore(5); with sem: access_resource()",
            "5. 线程安全队列：from queue import Queue; q = Queue(); q.put(item); q.get()",
            "6. 任务追踪：q.task_done(); q.join()  # 等待所有任务完成",
        ],
        selfCheck: [
            "Lock 和 RLock 有什么区别？",
            "如何使用 Event 进行线程间信号传递？",
            "Condition 变量的 wait() 方法会做什么？",
            "Semaphore 的作用是什么？",
            "为什么推荐使用 with 语句管理锁？",
            "queue.Queue 为什么是线程安全的？",
        ],
        extensions: [
            "学习 Barrier 同步多个线程",
            "了解 Timer 延迟执行",
            "探索 threading.local 线程本地存储",
            "学习读写锁模式",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/threading.html#lock-objects",
            "https://docs.python.org/3/library/threading.html#event-objects",
            "https://docs.python.org/3/library/queue.html",
        ],
    },
    "py-w18-3": {
        lessonId: "py-w18-3",
        background: [
            "【multiprocessing 模块】使用独立进程绕过 GIL，实现真正的并行计算。API 类似 threading。",
            "【Process 类】Process(target=func, args=()) 创建进程。start()、join()、terminate() 控制进程生命周期。",
            "【进程池 Pool】Pool(processes=4) 管理工作进程池。map()、apply_async() 分发任务。",
            "【进程间通信】Queue 多生产者多消费者队列；Pipe 两进程间双向通信；Manager 管理共享对象。",
            "【共享内存】Value 和 Array 在进程间共享简单数据类型。Manager 支持共享 dict、list 等复杂类型。",
        ],
        keyDifficulties: [
            "【if __name__ == '__main__'】Windows 上必须在此保护下创建进程，否则会无限递归。",
            "【pickle 序列化】进程间传递的对象必须可 pickle 序列化。lambda 和嵌套函数通常不可序列化。",
            "【启动方法】spawn（慢但安全）、fork（快但可能不安全）、forkserver。不同平台默认值不同。",
            "【进程开销】创建进程比线程开销大，适合计算密集型任务或需要隔离的场景。",
        ],
        handsOnPath: [
            "1. 创建进程：from multiprocessing import Process; p = Process(target=f, args=(x,))",
            "2. 进程池：with Pool(4) as p: results = p.map(func, data)",
            "3. Queue 通信：q = Queue(); q.put(data); result = q.get()",
            "4. Pipe 通信：parent_conn, child_conn = Pipe()",
            "5. 共享值：num = Value('d', 0.0); arr = Array('i', [1,2,3])",
            "6. Manager：with Manager() as m: d = m.dict(); l = m.list()",
        ],
        selfCheck: [
            "multiprocessing 相比 threading 有什么优势？",
            "为什么需要 if __name__ == '__main__'？",
            "Queue 和 Pipe 的区别是什么？",
            "如何使用 Pool 并行处理数据？",
            "Value 和 Array 的作用是什么？",
            "进程启动方法有哪些？",
        ],
        extensions: [
            "学习 shared_memory 高性能共享内存",
            "了解 Manager 的网络支持",
            "探索进程池的 starmap 方法",
            "学习 ProcessPoolExecutor 高级接口",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/multiprocessing.html",
            "https://docs.python.org/3/library/multiprocessing.html#the-process-class",
            "https://docs.python.org/3/library/multiprocessing.html#using-a-pool-of-workers",
        ],
    },
    "py-w18-4": {
        lessonId: "py-w18-4",
        background: [
            "【concurrent.futures 模块】提供高级接口统一管理线程池和进程池。简化了并发编程的复杂性。",
            "【ThreadPoolExecutor】管理线程池，适合 I/O 密集型任务。submit() 提交单个任务，map() 批量处理。",
            "【ProcessPoolExecutor】管理进程池，适合 CPU 密集型任务。绕过 GIL 实现真正的并行。",
            "【Future 对象】表示异步操作的结果。result() 获取返回值，exception() 获取异常，done() 检查完成状态。",
            "【上下文管理】使用 with executor: 确保正确关闭线程池或进程池，等待所有任务完成。",
        ],
        keyDifficulties: [
            "【submit vs map】submit() 返回 Future 可以异步获取结果；map() 按顺序返回结果，更简单。",
            "【as_completed】concurrent.futures.as_completed(futures) 按完成顺序迭代 Future，而非提交顺序。",
            "【异常处理】Future.result() 会重新抛出任务中的异常。Future.exception() 返回异常对象。",
            "【max_workers 默认值】ThreadPoolExecutor 默认 min(32, cpu_count + 4)；ProcessPoolExecutor 默认 cpu_count。",
        ],
        handsOnPath: [
            "1. 线程池：with ThreadPoolExecutor(max_workers=5) as executor:",
            "2. 提交任务：future = executor.submit(func, arg); result = future.result()",
            "3. 批量处理：results = list(executor.map(func, items))",
            "4. as_completed：for f in as_completed(futures): print(f.result())",
            "5. 进程池：with ProcessPoolExecutor() as executor: executor.map(cpu_task, data)",
            "6. 回调函数：future.add_done_callback(on_complete)",
        ],
        selfCheck: [
            "ThreadPoolExecutor 和 ProcessPoolExecutor 的区别是什么？",
            "submit() 和 map() 有什么区别？",
            "Future 对象有哪些常用方法？",
            "as_completed() 的作用是什么？",
            "如何处理 Future 中的异常？",
            "max_workers 的默认值是多少？",
        ],
        extensions: [
            "学习 wait() 函数的不同返回模式",
            "了解 Python 3.14 的 InterpreterPoolExecutor",
            "探索 Future 的 cancel() 方法",
            "学习结合 asyncio 的用法",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/concurrent.futures.html",
            "https://docs.python.org/3/library/concurrent.futures.html#executor-objects",
            "https://docs.python.org/3/library/concurrent.futures.html#future-objects",
        ],
    },
}

export const week18Quizzes: Record<string, QuizQuestion[]> = {
    "py-w18-1": [
        {
            id: "py-w18-1-q1",
            question: "GIL（全局解释器锁）的作用是什么？",
            options: [
                "加速多线程执行",
                "限制同一时刻只有一个线程执行 Python 字节码",
                "管理内存分配",
                "处理异常",
            ],
            answer: 1,
            rationale: "文档说明：GIL 限制 CPython 同一时刻只有一个线程执行字节码。",
        },
        {
            id: "py-w18-1-q2",
            question: "多线程最适合什么类型的任务？",
            options: [
                "CPU 密集型计算",
                "I/O 密集型任务",
                "内存密集型操作",
                "图形渲染",
            ],
            answer: 1,
            rationale: "文档说明：线程适合 I/O 密集型任务，因为等待 I/O 时会释放 GIL。",
        },
        {
            id: "py-w18-1-q3",
            question: "如何启动一个线程？",
            options: [
                "t.run()",
                "t.start()",
                "t.execute()",
                "t.begin()",
            ],
            answer: 1,
            rationale: "文档说明：调用 start() 方法启动线程，开始执行 target 函数。",
        },
        {
            id: "py-w18-1-q4",
            question: "join() 方法的作用是什么？",
            options: [
                "合并两个线程",
                "阻塞直到线程完成",
                "启动线程",
                "终止线程",
            ],
            answer: 1,
            rationale: "文档说明：join(timeout=None) 阻塞调用线程直到目标线程终止。",
        },
        {
            id: "py-w18-1-q5",
            question: "守护线程（daemon thread）有什么特点？",
            options: [
                "优先级更高",
                "主线程结束时自动终止，不阻止程序退出",
                "不受 GIL 影响",
                "可以修改全局变量",
            ],
            answer: 1,
            rationale: "文档说明：daemon=True 的线程在主线程结束时自动终止。",
        },
        {
            id: "py-w18-1-q6",
            question: "daemon 属性必须在什么时候设置？",
            options: [
                "线程运行后",
                "start() 调用前",
                "join() 调用后",
                "任何时候都可以",
            ],
            answer: 1,
            rationale: "文档说明：daemon 属性必须在 start() 调用前设置。",
        },
        {
            id: "py-w18-1-q7",
            question: "is_alive() 方法返回什么？",
            options: [
                "线程 ID",
                "线程是否正在运行的布尔值",
                "线程名称",
                "线程状态字符串",
            ],
            answer: 1,
            rationale: "文档说明：is_alive() 返回线程是否正在运行（True/False）。",
        },
        {
            id: "py-w18-1-q8",
            question: "threading.local() 的用途是什么？",
            options: [
                "创建本地锁",
                "创建线程本地数据（每个线程独立的存储）",
                "本地化时区",
                "本地文件操作",
            ],
            answer: 1,
            rationale: "文档说明：threading.local() 创建线程本地存储，每个线程看到独立的数据。",
        },
        {
            id: "py-w18-1-q9",
            question: "如何向线程传递参数？",
            options: [
                "Thread(target=func(arg))",
                "Thread(target=func, args=(arg,))",
                "Thread(func, arg)",
                "Thread.set_args(arg)",
            ],
            answer: 1,
            rationale: "文档说明：使用 args 元组和 kwargs 字典传递参数。",
        },
        {
            id: "py-w18-1-q10",
            question: "线程中的异常会怎样处理？",
            options: [
                "自动传播到主线程",
                "不会传播到主线程，需要在线程内捕获",
                "导致整个程序崩溃",
                "被自动忽略",
            ],
            answer: 1,
            rationale: "文档说明：线程中的异常不会传播到主线程，需要在线程内部处理。",
        },
        {
            id: "py-w18-1-q11",
            question: "对于 CPU 密集型任务，应该使用什么替代多线程？",
            options: [
                "更多线程",
                "multiprocessing 多进程",
                "更快的 CPU",
                "异步 IO",
            ],
            answer: 1,
            rationale: "文档建议：CPU 密集型任务应使用 multiprocessing 绕过 GIL。",
        },
        {
            id: "py-w18-1-q12",
            question: "Thread 对象的 ident 属性表示什么？",
            options: [
                "线程名称",
                "线程标识符（整数）",
                "线程优先级",
                "线程组",
            ],
            answer: 1,
            rationale: "文档说明：ident 是线程的整数标识符，线程启动后可用。",
        },
    ],
    "py-w18-2": [
        {
            id: "py-w18-2-q1",
            question: "Lock 和 RLock 的主要区别是什么？",
            options: [
                "RLock 更快",
                "RLock 允许同一线程多次获取",
                "Lock 支持超时",
                "没有区别",
            ],
            answer: 1,
            rationale: "文档说明：RLock 是可重入锁，同一线程可以多次 acquire。",
        },
        {
            id: "py-w18-2-q2",
            question: "为什么推荐使用 with lock: 而不是 lock.acquire()/release()？",
            options: [
                "性能更好",
                "即使发生异常也能确保释放锁",
                "语法更简洁",
                "支持超时",
            ],
            answer: 1,
            rationale: "文档推荐：with 语句确保即使发生异常也能正确释放锁。",
        },
        {
            id: "py-w18-2-q3",
            question: "Event.wait() 的作用是什么？",
            options: [
                "设置事件标志",
                "阻塞直到事件被 set()",
                "清除事件标志",
                "检查事件状态",
            ],
            answer: 1,
            rationale: "文档说明：wait() 阻塞直到内部标志被 set() 设置为 True。",
        },
        {
            id: "py-w18-2-q4",
            question: "Semaphore 的作用是什么？",
            options: [
                "信号传递",
                "控制同时访问资源的线程数量",
                "优先级调度",
                "消息队列",
            ],
            answer: 1,
            rationale: "文档说明：Semaphore 限制可以同时访问共享资源的线程数量。",
        },
        {
            id: "py-w18-2-q5",
            question: "Condition.wait() 会做什么？",
            options: [
                "只是等待",
                "释放关联的锁并等待通知，被唤醒后重新获取锁",
                "永久阻塞",
                "立即返回",
            ],
            answer: 1,
            rationale: "文档说明：wait() 释放底层锁，阻塞等待通知，唤醒后重新获取锁。",
        },
        {
            id: "py-w18-2-q6",
            question: "queue.Queue 是否需要额外的锁来保护？",
            options: [
                "是，必须使用锁",
                "否，Queue 内部已经是线程安全的",
                "取决于操作类型",
                "只有 put 需要",
            ],
            answer: 1,
            rationale: "文档说明：Queue 使用内部锁实现线程安全，无需额外同步。",
        },
        {
            id: "py-w18-2-q7",
            question: "BoundedSemaphore 和 Semaphore 的区别是什么？",
            options: [
                "BoundedSemaphore 更快",
                "BoundedSemaphore 防止 release 超过初始值",
                "Semaphore 有上限",
                "没有区别",
            ],
            answer: 1,
            rationale: "文档说明：BoundedSemaphore 检查 release 不超过 acquire 次数。",
        },
        {
            id: "py-w18-2-q8",
            question: "q.task_done() 的作用是什么？",
            options: [
                "从队列获取任务",
                "表示先前获取的任务已完成处理",
                "清空队列",
                "关闭队列",
            ],
            answer: 1,
            rationale: "文档说明：task_done() 通知队列一个任务已完成，配合 join() 使用。",
        },
        {
            id: "py-w18-2-q9",
            question: "什么情况下可能发生死锁？",
            options: [
                "使用太多线程",
                "多个锁的获取顺序不一致",
                "使用 with 语句",
                "使用 Queue",
            ],
            answer: 1,
            rationale: "文档警告：多个锁的获取顺序不一致可能导致死锁。",
        },
        {
            id: "py-w18-2-q10",
            question: "Condition.notify_all() 的作用是什么？",
            options: [
                "通知一个等待线程",
                "通知所有等待线程",
                "清除条件",
                "设置条件",
            ],
            answer: 1,
            rationale: "文档说明：notify_all() 唤醒所有等待该条件的线程。",
        },
        {
            id: "py-w18-2-q11",
            question: "LifoQueue 的取出顺序是什么？",
            options: [
                "先进先出",
                "后进先出",
                "优先级顺序",
                "随机顺序",
            ],
            answer: 1,
            rationale: "文档说明：LifoQueue 是后进先出（栈）结构。",
        },
        {
            id: "py-w18-2-q12",
            question: "q.join() 什么时候返回？",
            options: [
                "立即返回",
                "所有放入队列的项都已处理（task_done）后",
                "队列为空时",
                "超时后",
            ],
            answer: 1,
            rationale: "文档说明：join() 阻塞直到所有项的 task_done() 都被调用。",
        },
    ],
    "py-w18-3": [
        {
            id: "py-w18-3-q1",
            question: "multiprocessing 相比 threading 的主要优势是什么？",
            options: [
                "更简单的 API",
                "绕过 GIL，实现真正的并行计算",
                "内存使用更少",
                "启动更快",
            ],
            answer: 1,
            rationale: "文档说明：multiprocessing 使用独立进程绕过 GIL，可以利用多核。",
        },
        {
            id: "py-w18-3-q2",
            question: "为什么 Windows 上必须使用 if __name__ == '__main__'？",
            options: [
                "语法要求",
                "防止 spawn 启动方式导致的无限递归",
                "性能优化",
                "不是必须的",
            ],
            answer: 1,
            rationale: "文档说明：spawn 方式会重新导入模块，必须保护入口代码。",
        },
        {
            id: "py-w18-3-q3",
            question: "进程间通信应该使用什么？",
            options: [
                "全局变量",
                "Queue 或 Pipe",
                "共享文件",
                "socket",
            ],
            answer: 1,
            rationale: "文档说明：Queue 和 Pipe 是进程间通信的推荐方式。",
        },
        {
            id: "py-w18-3-q4",
            question: "Pool.map() 的作用是什么？",
            options: [
                "创建进程映射",
                "并行地将函数应用到可迭代对象的每个元素",
                "映射内存地址",
                "创建共享字典",
            ],
            answer: 1,
            rationale: "文档说明：map(func, iterable) 并行执行，返回结果列表。",
        },
        {
            id: "py-w18-3-q5",
            question: "Value 和 Array 的用途是什么？",
            options: [
                "存储函数",
                "在进程间共享简单数据类型",
                "创建数据库",
                "网络通信",
            ],
            answer: 1,
            rationale: "文档说明：Value 和 Array 在进程间共享简单数据（数值、数组）。",
        },
        {
            id: "py-w18-3-q6",
            question: "Manager 相比 Value/Array 有什么优势？",
            options: [
                "性能更好",
                "支持更复杂的数据类型（dict、list）",
                "更简单的 API",
                "不需要锁",
            ],
            answer: 1,
            rationale: "文档说明：Manager 支持共享 dict、list 等复杂数据类型。",
        },
        {
            id: "py-w18-3-q7",
            question: "进程的启动方法 spawn 有什么特点？",
            options: [
                "最快",
                "启动新的 Python 解释器，较慢但安全",
                "复制父进程",
                "只在 Linux 可用",
            ],
            answer: 1,
            rationale: "文档说明：spawn 启动新的解释器，较慢但线程安全，是 Windows 默认。",
        },
        {
            id: "py-w18-3-q8",
            question: "传递给 Process 的参数必须满足什么条件？",
            options: [
                "必须是字符串",
                "必须可 pickle 序列化",
                "必须是数字",
                "没有限制",
            ],
            answer: 1,
            rationale: "文档说明：进程间传递的对象必须可以用 pickle 序列化。",
        },
        {
            id: "py-w18-3-q9",
            question: "Queue 和 Pipe 的主要区别是什么？",
            options: [
                "Pipe 更快",
                "Queue 支持多生产者多消费者，Pipe 用于两进程间",
                "Queue 不能传递对象",
                "没有区别",
            ],
            answer: 1,
            rationale: "文档说明：Queue 用于多进程，Pipe 用于两个进程间的双向通信。",
        },
        {
            id: "py-w18-3-q10",
            question: "p.terminate() 的作用是什么？",
            options: [
                "等待进程完成",
                "立即终止进程",
                "暂停进程",
                "重启进程",
            ],
            answer: 1,
            rationale: "文档说明：terminate() 发送 SIGTERM 信号终止进程。",
        },
        {
            id: "py-w18-3-q11",
            question: "进程池使用完毕后应该如何处理？",
            options: [
                "不需要处理",
                "调用 close() 和 join()，或使用 with 语句",
                "调用 terminate()",
                "调用 destroy()",
            ],
            answer: 1,
            rationale: "文档说明：使用 with Pool() as p: 或 close() + join() 正确关闭池。",
        },
        {
            id: "py-w18-3-q12",
            question: "apply_async() 和 map() 的区别是什么？",
            options: [
                "apply_async 更快",
                "apply_async 异步执行单个任务并返回 AsyncResult，map 同步批量处理",
                "没有区别",
                "map 只能处理列表",
            ],
            answer: 1,
            rationale: "文档说明：apply_async 异步提交单个任务，map 同步批量执行。",
        },
    ],
    "py-w18-4": [
        {
            id: "py-w18-4-q1",
            question: "ThreadPoolExecutor 适合什么类型的任务？",
            options: [
                "CPU 密集型",
                "I/O 密集型",
                "内存密集型",
                "图形处理",
            ],
            answer: 1,
            rationale: "文档说明：ThreadPoolExecutor 使用线程池，适合 I/O 密集型任务。",
        },
        {
            id: "py-w18-4-q2",
            question: "executor.submit() 返回什么？",
            options: [
                "结果值",
                "Future 对象",
                "线程对象",
                "None",
            ],
            answer: 1,
            rationale: "文档说明：submit() 返回 Future 对象，表示异步操作的结果。",
        },
        {
            id: "py-w18-4-q3",
            question: "Future.result() 的作用是什么？",
            options: [
                "检查是否完成",
                "获取任务的返回值（会阻塞直到完成）",
                "取消任务",
                "添加回调",
            ],
            answer: 1,
            rationale: "文档说明：result(timeout=None) 返回调用的结果，必要时阻塞等待。",
        },
        {
            id: "py-w18-4-q4",
            question: "as_completed() 的作用是什么？",
            options: [
                "等待所有完成",
                "按完成顺序返回 Future 迭代器",
                "按提交顺序返回",
                "取消未完成的任务",
            ],
            answer: 1,
            rationale: "文档说明：as_completed(fs) 返回按完成顺序的 Future 迭代器。",
        },
        {
            id: "py-w18-4-q5",
            question: "ProcessPoolExecutor 相比 ThreadPoolExecutor 有什么优势？",
            options: [
                "更简单",
                "可以绕过 GIL 实现真正的并行",
                "内存使用更少",
                "启动更快",
            ],
            answer: 1,
            rationale: "文档说明：ProcessPoolExecutor 使用进程，可以利用多核进行并行计算。",
        },
        {
            id: "py-w18-4-q6",
            question: "submit() 和 map() 的主要区别是什么？",
            options: [
                "submit 更快",
                "submit 返回 Future 可异步处理，map 按顺序返回结果",
                "map 只能单线程",
                "没有区别",
            ],
            answer: 1,
            rationale: "文档说明：submit 返回 Future，map 类似内置 map 但并行执行。",
        },
        {
            id: "py-w18-4-q7",
            question: "Future.done() 返回什么？",
            options: [
                "结果值",
                "任务是否已完成的布尔值",
                "完成时间",
                "异常信息",
            ],
            answer: 1,
            rationale: "文档说明：done() 返回 True 如果调用已完成或被取消。",
        },
        {
            id: "py-w18-4-q8",
            question: "如何为 Future 添加完成回调？",
            options: [
                "future.callback = func",
                "future.add_done_callback(func)",
                "future.on_complete(func)",
                "future.then(func)",
            ],
            answer: 1,
            rationale: "文档说明：add_done_callback(fn) 在 Future 完成时调用 fn。",
        },
        {
            id: "py-w18-4-q9",
            question: "ThreadPoolExecutor 的默认 max_workers 是多少？",
            options: [
                "1",
                "CPU 核心数",
                "min(32, cpu_count + 4)",
                "无限制",
            ],
            answer: 2,
            rationale: "文档说明：Python 3.13+ 默认 min(32, (cpu_count or 1) + 4)。",
        },
        {
            id: "py-w18-4-q10",
            question: "使用 with executor: 有什么好处？",
            options: [
                "性能更好",
                "确保正确关闭执行器并等待任务完成",
                "支持更多任务",
                "避免死锁",
            ],
            answer: 1,
            rationale: "文档推荐：with 语句确保 executor 正确关闭。",
        },
        {
            id: "py-w18-4-q11",
            question: "Future.exception() 的作用是什么？",
            options: [
                "抛出异常",
                "返回任务引发的异常对象",
                "忽略异常",
                "记录异常",
            ],
            answer: 1,
            rationale: "文档说明：exception() 返回任务引发的异常，没有则返回 None。",
        },
        {
            id: "py-w18-4-q12",
            question: "wait() 函数的 return_when 参数有哪些选项？",
            options: [
                "只有 ALL_COMPLETED",
                "FIRST_COMPLETED、FIRST_EXCEPTION、ALL_COMPLETED",
                "TIMEOUT 和 COMPLETED",
                "START 和 END",
            ],
            answer: 1,
            rationale: "文档说明：return_when 可以是 FIRST_COMPLETED、FIRST_EXCEPTION 或 ALL_COMPLETED。",
        },
    ],
}
