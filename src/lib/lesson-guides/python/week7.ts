import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week7Guides: Record<string, LessonGuide> = {
    "py-w7-1": {
        lessonId: "py-w7-1",
        background: [
            "【类定义语法】class ClassName: 定义类。类定义执行时创建类对象，在当前作用域绑定类名到类对象。所有类默认继承 object。",
            "【类对象】类对象支持两种操作：属性引用 MyClass.attribute 和实例化 MyClass()。类对象是可调用的，调用返回新实例。",
            "【实例对象】实例支持数据属性（实例变量）和方法。数据属性无需声明，首次赋值时创建。方法是绑定到实例的函数。",
            "【self 参数】self 是方法的第一个参数，代表实例本身。调用 x.f() 等价于 ClassName.f(x)，实例自动作为第一个参数传递。",
            "【命名空间】类定义创建新的命名空间，类体中的赋值创建类属性。当类定义结束，命名空间成为类的属性字典。",
        ],
        keyDifficulties: [
            "【类体执行时机】类体在定义时立即执行，不是在实例化时。类体中的代码在类创建过程中运行，可以包含任意语句。",
            "【属性查找顺序】访问属性时先查找实例属性，再查找类属性。实例属性会遮蔽同名的类属性。",
            "【方法绑定】x.f 返回方法对象（绑定方法），MyClass.f 返回函数对象。绑定方法记住了实例，调用时自动传入 self。",
            "【类作为对象】类本身也是对象，可以赋值给变量、作为参数传递、动态创建。这是 Python 元编程的基础。",
        ],
        handsOnPath: [
            "1. 定义简单类：class Dog: species = 'canine'",
            "2. 创建实例：d = Dog(); print(d.species)",
            "3. 添加方法：class Dog: def bark(self): return 'woof'",
            "4. 检查类型：print(type(d)); print(isinstance(d, Dog))",
            "5. 方法绑定：m = d.bark; print(m()); print(Dog.bark(d))",
            "6. 类作为对象：C = Dog; x = C(); print(type(x))",
        ],
        selfCheck: [
            "class 定义执行时发生了什么？",
            "类对象支持哪两种操作？",
            "self 参数的作用是什么？",
            "x.f() 和 ClassName.f(x) 有什么关系？",
            "实例属性和类属性的查找顺序是什么？",
            "方法对象和函数对象有什么区别？",
        ],
        extensions: [
            "学习 type() 动态创建类",
            "了解 __class__ 属性访问实例的类",
            "探索 vars() 和 __dict__ 查看属性",
            "学习 hasattr()、getattr()、setattr() 动态属性操作",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/classes.html",
            "https://docs.python.org/3/reference/compound_stmts.html#class-definitions",
            "https://docs.python.org/3/tutorial/classes.html#class-objects",
        ],
    },
    "py-w7-2": {
        lessonId: "py-w7-2",
        background: [
            "【__init__ 方法】__init__ 在实例创建后自动调用，用于初始化实例。参数来自类调用：x = MyClass(arg1, arg2) 调用 __init__(self, arg1, arg2)。",
            "【__init__ 返回值】__init__ 必须返回 None，返回其他值会抛出 TypeError。__init__ 是初始化方法，不是构造方法。",
            "【实例属性】使用 self.attr = value 在 __init__ 中设置实例属性。实例属性存储在 instance.__dict__ 字典中。",
            "【__new__ 与 __init__】__new__ 创建实例，__init__ 初始化实例。__new__ 返回实例后，__init__ 自动调用。通常只需定义 __init__。",
            "【继承中的 __init__】派生类的 __init__ 必须显式调用基类的 __init__：super().__init__(args)。Python 不会自动调用父类初始化。",
        ],
        keyDifficulties: [
            "【__init__ vs 构造函数】__init__ 是初始化器而非构造器，实例在调用 __init__ 前已由 __new__ 创建。__init__ 只负责设置属性。",
            "【忘记 self】在 __init__ 中忘记使用 self.attr = value 会创建局部变量而非实例属性，这是常见错误。",
            "【__dict__ 理解】实例属性存储在 __dict__ 字典中。可以直接操作：obj.__dict__['attr'] = value，但不推荐。",
            "【super().__init__() 必要性】不调用 super().__init__() 会导致父类属性未初始化，可能引发 AttributeError。",
        ],
        handsOnPath: [
            "1. 定义 __init__：class Person: def __init__(self, name): self.name = name",
            "2. 创建实例：p = Person('Alice'); print(p.name)",
            "3. 查看 __dict__：print(p.__dict__)",
            "4. 多个属性：class Point: def __init__(self, x, y): self.x = x; self.y = y",
            "5. 继承中调用：class Student(Person): def __init__(self, name, grade): super().__init__(name); self.grade = grade",
            "6. 测试返回值：class Bad: def __init__(self): return 1  # TypeError",
        ],
        selfCheck: [
            "__init__ 方法什么时候被调用？",
            "__init__ 可以返回什么值？",
            "如何在 __init__ 中设置实例属性？",
            "__new__ 和 __init__ 的区别是什么？",
            "继承时为什么要调用 super().__init__()？",
            "实例属性存储在哪里？",
        ],
        extensions: [
            "学习 __new__ 方法实现单例模式",
            "了解 __del__ 析构方法",
            "探索 dataclasses 自动生成 __init__",
            "学习 attrs 库简化类定义",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/classes.html#instance-objects",
            "https://docs.python.org/3/reference/datamodel.html#object.__init__",
            "https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables",
        ],
    },
    "py-w7-3": {
        lessonId: "py-w7-3",
        background: [
            "【类属性】在类体中直接定义的变量是类属性，所有实例共享。访问方式：ClassName.attr 或 instance.attr。",
            "【实例方法】第一个参数是 self 的方法是实例方法。调用时实例自动作为第一个参数传递：obj.method() 等价于 Class.method(obj)。",
            "【类属性 vs 实例属性】类属性定义在类体中，实例属性在 __init__ 或方法中通过 self.attr 创建。实例属性会遮蔽同名类属性。",
            "【可变类属性陷阱】使用可变对象（列表、字典）作为类属性会被所有实例共享。应在 __init__ 中创建可变实例属性。",
            "【方法对象】方法对象是绑定到实例的函数。可以保存方法引用：m = obj.method，稍后调用 m() 仍然知道实例是 obj。",
        ],
        keyDifficulties: [
            "【类属性修改】通过实例修改类属性会创建同名实例属性，而非修改类属性。只有通过类名才能修改类属性。",
            "【可变类属性问题】class Dog: tricks = [] 导致所有实例共享同一个列表。正确做法是在 __init__ 中创建 self.tricks = []。",
            "【属性查找链】访问 obj.attr 时：先查 obj.__dict__，再查 type(obj).__dict__，再查基类链。第一个找到的被使用。",
            "【函数 vs 方法】Class.method 是函数，obj.method 是绑定方法。绑定方法调用时自动传入 self。",
        ],
        handsOnPath: [
            "1. 类属性：class Dog: kind = 'canine'; d = Dog(); print(d.kind)",
            "2. 修改类属性：Dog.kind = 'animal'; print(d.kind)",
            "3. 实例属性遮蔽：d.kind = 'pet'; print(d.kind); print(Dog.kind)",
            "4. 可变类属性陷阱：class Bad: items = []; def add(self, x): self.items.append(x)",
            "5. 正确做法：class Good: def __init__(self): self.items = []",
            "6. 方法引用：m = d.bark; print(m); m()",
        ],
        selfCheck: [
            "类属性和实例属性的定义位置有什么不同？",
            "为什么不应该用可变对象作为类属性？",
            "通过实例修改类属性会发生什么？",
            "属性查找的顺序是什么？",
            "方法对象保存了什么信息？",
            "如何正确修改类属性？",
        ],
        extensions: [
            "学习 __slots__ 限制实例属性",
            "了解描述符协议实现属性访问控制",
            "探索 property 装饰器创建计算属性",
            "学习 __getattr__ 和 __setattr__ 自定义属性访问",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/classes.html#class-and-instance-variables",
            "https://docs.python.org/3/tutorial/classes.html#method-objects",
            "https://docs.python.org/3/reference/compound_stmts.html#class-definitions",
        ],
    },
    "py-w7-4": {
        lessonId: "py-w7-4",
        background: [
            "【@staticmethod】静态方法不接收隐式第一个参数（无 self 或 cls）。定义不需要访问实例或类状态的工具函数。",
            "【@classmethod】类方法第一个参数是 cls，指向类本身。可以访问和修改类属性，常用于工厂方法模式。",
            "【调用方式】静态方法和类方法都可以通过类或实例调用：Class.method() 或 instance.method()。",
            "【工厂方法】classmethod 常用于实现工厂方法，提供多种创建实例的方式。例如 Date.from_string('2024-01-01')。",
            "【继承行为】classmethod 在派生类上调用时，cls 参数是派生类而非基类。这使得工厂方法可以正确创建派生类实例。",
        ],
        keyDifficulties: [
            "【三种方法对比】实例方法接收 self（实例），类方法接收 cls（类），静态方法不接收隐式参数。选择取决于是否需要访问实例或类。",
            "【staticmethod 使用场景】当方法与类相关但不需要访问实例或类状态时使用。相当于放在类命名空间中的普通函数。",
            "【classmethod 继承优势】classmethod 创建实例时使用 cls()，在子类中调用会创建子类实例，而非硬编码的基类实例。",
            "【装饰器顺序】@staticmethod 和 @classmethod 应该放在方法定义的最内层（紧贴 def）。与其他装饰器组合时注意顺序。",
        ],
        handsOnPath: [
            "1. 静态方法：class Math: @staticmethod def add(a, b): return a + b",
            "2. 调用静态方法：Math.add(1, 2); m = Math(); m.add(1, 2)",
            "3. 类方法：class Person: count = 0; @classmethod def get_count(cls): return cls.count",
            "4. 工厂方法：class Date: @classmethod def from_string(cls, s): parts = s.split('-'); return cls(*map(int, parts))",
            "5. 继承中的类方法：class SubDate(Date): pass; d = SubDate.from_string('2024-1-1'); print(type(d))",
            "6. 三种方法对比：class Demo: def instance(self): pass; @classmethod def clsm(cls): pass; @staticmethod def static(): pass",
        ],
        selfCheck: [
            "@staticmethod 和 @classmethod 的区别是什么？",
            "静态方法适合什么场景？",
            "类方法的第一个参数是什么？",
            "工厂方法模式如何用 classmethod 实现？",
            "类方法在继承中有什么优势？",
            "三种方法分别什么时候使用？",
        ],
        extensions: [
            "学习 @property 创建只读属性",
            "了解 @abstractmethod 定义抽象方法",
            "探索描述符实现 staticmethod 和 classmethod",
            "学习 functools.singledispatchmethod 实现方法重载",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/functions.html#staticmethod",
            "https://docs.python.org/3/library/functions.html#classmethod",
            "https://docs.python.org/3/howto/descriptor.html#static-methods-and-class-methods",
        ],
    },
}

export const week7Quizzes: Record<string, QuizQuestion[]> = {
    "py-w7-1": [
        {
            id: "py-w7-1-q1",
            question: "Python 中所有类默认继承自哪个类？",
            options: [
                "None",
                "object",
                "type",
                "base",
            ],
            answer: 1,
            rationale: "文档说明：所有类默认继承 object，class Foo: pass 等价于 class Foo(object): pass。",
        },
        {
            id: "py-w7-1-q2",
            question: "类对象支持哪两种操作？",
            options: [
                "继承和实例化",
                "属性引用和实例化",
                "方法调用和属性修改",
                "导入和导出",
            ],
            answer: 1,
            rationale: "文档说明：类对象支持属性引用 MyClass.attribute 和实例化 MyClass()。",
        },
        {
            id: "py-w7-1-q3",
            question: "调用 x.f() 等价于什么？",
            options: [
                "f(x)",
                "ClassName.f(x)",
                "x.f",
                "f.x()",
            ],
            answer: 1,
            rationale: "文档说明：x.f() 等价于 ClassName.f(x)，实例自动作为第一个参数传递。",
        },
        {
            id: "py-w7-1-q4",
            question: "类体中的代码什么时候执行？",
            options: [
                "导入模块时",
                "创建实例时",
                "类定义时",
                "调用方法时",
            ],
            answer: 2,
            rationale: "文档说明：类体在定义时立即执行，不是在实例化时。",
        },
        {
            id: "py-w7-1-q5",
            question: "self 参数代表什么？",
            options: [
                "类本身",
                "实例本身",
                "父类",
                "模块",
            ],
            answer: 1,
            rationale: "文档说明：self 是方法的第一个参数，代表实例本身。",
        },
        {
            id: "py-w7-1-q6",
            question: "访问属性时的查找顺序是什么？",
            options: [
                "先类属性，后实例属性",
                "先实例属性，后类属性",
                "只查找实例属性",
                "只查找类属性",
            ],
            answer: 1,
            rationale: "文档说明：访问属性时先查找实例属性，再查找类属性。实例属性会遮蔽同名类属性。",
        },
        {
            id: "py-w7-1-q7",
            question: "x.f 和 ClassName.f 的区别是什么？",
            options: [
                "没有区别",
                "x.f 是方法对象，ClassName.f 是函数对象",
                "x.f 是函数对象，ClassName.f 是方法对象",
                "都是方法对象",
            ],
            answer: 1,
            rationale: "文档说明：x.f 返回方法对象（绑定方法），ClassName.f 返回函数对象。",
        },
        {
            id: "py-w7-1-q8",
            question: "以下哪个是正确的类定义？",
            options: [
                "class MyClass {}",
                "class MyClass:",
                "def class MyClass:",
                "class MyClass()",
            ],
            answer: 1,
            rationale: "Python 类定义语法：class ClassName: 后跟类体。使用冒号而非花括号或括号。",
        },
        {
            id: "py-w7-1-q9",
            question: "类定义结束后，类的命名空间变成什么？",
            options: [
                "被删除",
                "类的属性字典",
                "全局命名空间",
                "实例属性",
            ],
            answer: 1,
            rationale: "文档说明：当类定义结束，命名空间成为类的属性字典。",
        },
        {
            id: "py-w7-1-q10",
            question: "绑定方法保存了什么信息？",
            options: [
                "只有函数",
                "只有实例",
                "函数和实例",
                "类和参数",
            ],
            answer: 2,
            rationale: "文档说明：绑定方法记住了实例，调用时自动传入 self。它包含函数和绑定的实例。",
        },
        {
            id: "py-w7-1-q11",
            question: "可以把类赋值给变量吗？",
            options: [
                "不可以",
                "可以，因为类也是对象",
                "只有内置类可以",
                "只有自定义类可以",
            ],
            answer: 1,
            rationale: "文档说明：类本身也是对象，可以赋值给变量、作为参数传递、动态创建。",
        },
        {
            id: "py-w7-1-q12",
            question: "isinstance(obj, ClassName) 检查什么？",
            options: [
                "obj 是否等于 ClassName",
                "obj 是否是 ClassName 的实例",
                "obj 是否有 ClassName 属性",
                "obj 的类型名是否是 ClassName",
            ],
            answer: 1,
            rationale: "isinstance 检查对象是否是指定类或其子类的实例。",
        },
    ],
    "py-w7-2": [
        {
            id: "py-w7-2-q1",
            question: "__init__ 方法什么时候被调用？",
            options: [
                "导入类时",
                "定义类时",
                "实例创建后",
                "实例销毁时",
            ],
            answer: 2,
            rationale: "文档说明：__init__ 在实例创建后自动调用，用于初始化实例。",
        },
        {
            id: "py-w7-2-q2",
            question: "__init__ 方法必须返回什么？",
            options: [
                "self",
                "True",
                "None",
                "实例",
            ],
            answer: 2,
            rationale: "文档说明：__init__ 必须返回 None，返回其他值会抛出 TypeError。",
        },
        {
            id: "py-w7-2-q3",
            question: "实例属性存储在哪里？",
            options: [
                "类的 __dict__",
                "实例的 __dict__",
                "全局命名空间",
                "模块的 __dict__",
            ],
            answer: 1,
            rationale: "文档说明：实例属性存储在 instance.__dict__ 字典中。",
        },
        {
            id: "py-w7-2-q4",
            question: "__new__ 和 __init__ 的调用顺序是什么？",
            options: [
                "同时调用",
                "__init__ 先，__new__ 后",
                "__new__ 先，__init__ 后",
                "只调用 __init__",
            ],
            answer: 2,
            rationale: "文档说明：__new__ 创建实例，__init__ 初始化实例。__new__ 返回实例后 __init__ 自动调用。",
        },
        {
            id: "py-w7-2-q5",
            question: "派生类的 __init__ 需要做什么？",
            options: [
                "什么都不需要",
                "显式调用基类的 __init__",
                "自动调用基类 __init__",
                "不能有 __init__",
            ],
            answer: 1,
            rationale: "文档说明：派生类的 __init__ 必须显式调用基类的 __init__：super().__init__(args)。",
        },
        {
            id: "py-w7-2-q6",
            question: "在 __init__ 中忘记 self.attr = value 会怎样？",
            options: [
                "自动创建实例属性",
                "创建局部变量而非实例属性",
                "抛出错误",
                "创建类属性",
            ],
            answer: 1,
            rationale: "在 __init__ 中忘记 self 会创建局部变量而非实例属性，这是常见错误。",
        },
        {
            id: "py-w7-2-q7",
            question: "x = MyClass(1, 2) 调用的是哪个方法？",
            options: [
                "__init__(1, 2)",
                "__init__(self, 1, 2)",
                "__new__(1, 2)",
                "__call__(1, 2)",
            ],
            answer: 1,
            rationale: "MyClass(1, 2) 调用 __init__(self, 1, 2)，self 是新创建的实例。",
        },
        {
            id: "py-w7-2-q8",
            question: "__init__ 是构造函数吗？",
            options: [
                "是，它创建实例",
                "否，它只初始化实例",
                "是，它分配内存",
                "否，Python 没有构造函数",
            ],
            answer: 1,
            rationale: "文档说明：__init__ 是初始化器而非构造器，实例在调用 __init__ 前已由 __new__ 创建。",
        },
        {
            id: "py-w7-2-q9",
            question: "以下哪个是正确的 __init__ 定义？",
            options: [
                "def __init__(): pass",
                "def __init__(self): pass",
                "def init(self): pass",
                "def __init__(cls): pass",
            ],
            answer: 1,
            rationale: "__init__ 必须以 self 作为第一个参数，表示正在初始化的实例。",
        },
        {
            id: "py-w7-2-q10",
            question: "如果 __init__ 返回 1 会怎样？",
            options: [
                "返回 1",
                "忽略返回值",
                "抛出 TypeError",
                "返回 None",
            ],
            answer: 2,
            rationale: "文档说明：__init__ 返回非 None 值会抛出 TypeError。",
        },
        {
            id: "py-w7-2-q11",
            question: "如何调用父类的 __init__？",
            options: [
                "parent.__init__()",
                "super().__init__()",
                "self.parent.__init__()",
                "base.__init__()",
            ],
            answer: 1,
            rationale: "文档推荐使用 super().__init__() 调用父类的初始化方法。",
        },
        {
            id: "py-w7-2-q12",
            question: "__new__ 方法的作用是什么？",
            options: [
                "初始化实例",
                "创建实例",
                "删除实例",
                "修改实例",
            ],
            answer: 1,
            rationale: "文档说明：__new__ 创建实例，__init__ 初始化实例。",
        },
    ],
    "py-w7-3": [
        {
            id: "py-w7-3-q1",
            question: "类属性定义在哪里？",
            options: [
                "__init__ 方法中",
                "类体中直接定义",
                "实例方法中",
                "模块级别",
            ],
            answer: 1,
            rationale: "文档说明：在类体中直接定义的变量是类属性，所有实例共享。",
        },
        {
            id: "py-w7-3-q2",
            question: "使用可变对象（如列表）作为类属性有什么问题？",
            options: [
                "没有问题",
                "所有实例共享同一个对象",
                "每个实例有独立副本",
                "无法创建",
            ],
            answer: 1,
            rationale: "文档警告：使用可变对象作为类属性会被所有实例共享，导致意外修改。",
        },
        {
            id: "py-w7-3-q3",
            question: "通过实例修改类属性会发生什么？",
            options: [
                "修改类属性",
                "创建同名实例属性",
                "抛出错误",
                "什么都不发生",
            ],
            answer: 1,
            rationale: "文档说明：通过实例修改类属性会创建同名实例属性，而非修改类属性。",
        },
        {
            id: "py-w7-3-q4",
            question: "实例方法的第一个参数是什么？",
            options: [
                "cls",
                "self",
                "this",
                "instance",
            ],
            answer: 1,
            rationale: "文档说明：实例方法第一个参数是 self，代表调用该方法的实例。",
        },
        {
            id: "py-w7-3-q5",
            question: "如何正确修改类属性？",
            options: [
                "instance.attr = value",
                "self.attr = value",
                "ClassName.attr = value",
                "以上都可以",
            ],
            answer: 2,
            rationale: "只有通过类名才能修改类属性，通过实例修改会创建实例属性。",
        },
        {
            id: "py-w7-3-q6",
            question: "属性查找链的顺序是什么？",
            options: [
                "类 -> 实例 -> 基类",
                "实例 -> 类 -> 基类",
                "基类 -> 类 -> 实例",
                "只查找实例",
            ],
            answer: 1,
            rationale: "文档说明：先查 obj.__dict__，再查 type(obj).__dict__，再查基类链。",
        },
        {
            id: "py-w7-3-q7",
            question: "方法对象和函数对象的区别是什么？",
            options: [
                "没有区别",
                "方法对象绑定了实例",
                "函数对象绑定了实例",
                "方法对象不能调用",
            ],
            answer: 1,
            rationale: "文档说明：方法对象是绑定到实例的函数，调用时自动传入 self。",
        },
        {
            id: "py-w7-3-q8",
            question: "class Dog: tricks = [] 有什么问题？",
            options: [
                "语法错误",
                "所有 Dog 实例共享同一个 tricks 列表",
                "无法添加元素",
                "没有问题",
            ],
            answer: 1,
            rationale: "文档示例：tricks = [] 是类属性，所有实例共享，一个实例修改会影响所有实例。",
        },
        {
            id: "py-w7-3-q9",
            question: "保存方法引用 m = obj.method 后，m() 调用时 self 是什么？",
            options: [
                "None",
                "obj",
                "需要手动传入",
                "类本身",
            ],
            answer: 1,
            rationale: "文档说明：方法对象记住了实例，m() 调用时 self 仍然是 obj。",
        },
        {
            id: "py-w7-3-q10",
            question: "如何解决可变类属性共享问题？",
            options: [
                "使用 @classmethod",
                "在 __init__ 中创建实例属性",
                "使用 @staticmethod",
                "使用 global 关键字",
            ],
            answer: 1,
            rationale: "文档推荐：在 __init__ 中创建可变实例属性 self.tricks = []，每个实例有独立副本。",
        },
        {
            id: "py-w7-3-q11",
            question: "类属性可以通过哪些方式访问？",
            options: [
                "只能通过类名",
                "只能通过实例",
                "通过类名或实例都可以",
                "只能通过 self",
            ],
            answer: 2,
            rationale: "文档说明：访问方式包括 ClassName.attr 和 instance.attr。",
        },
        {
            id: "py-w7-3-q12",
            question: "当实例属性和类属性同名时，访问哪个？",
            options: [
                "类属性",
                "实例属性",
                "抛出错误",
                "随机选择",
            ],
            answer: 1,
            rationale: "文档说明：实例属性会遮蔽同名类属性，先找到的是实例属性。",
        },
    ],
    "py-w7-4": [
        {
            id: "py-w7-4-q1",
            question: "@staticmethod 定义的方法接收什么隐式参数？",
            options: [
                "self",
                "cls",
                "不接收隐式参数",
                "args",
            ],
            answer: 2,
            rationale: "文档说明：静态方法不接收隐式第一个参数（无 self 或 cls）。",
        },
        {
            id: "py-w7-4-q2",
            question: "@classmethod 的第一个参数是什么？",
            options: [
                "self（实例）",
                "cls（类）",
                "无参数",
                "args",
            ],
            answer: 1,
            rationale: "文档说明：类方法第一个参数是 cls，指向类本身。",
        },
        {
            id: "py-w7-4-q3",
            question: "静态方法可以访问什么？",
            options: [
                "实例属性",
                "类属性",
                "都不能直接访问",
                "只能访问全局变量",
            ],
            answer: 2,
            rationale: "文档说明：静态方法不接收 self 或 cls，不能直接访问实例或类状态。",
        },
        {
            id: "py-w7-4-q4",
            question: "类方法常用于什么设计模式？",
            options: [
                "单例模式",
                "工厂方法模式",
                "观察者模式",
                "装饰器模式",
            ],
            answer: 1,
            rationale: "文档说明：classmethod 常用于实现工厂方法，提供多种创建实例的方式。",
        },
        {
            id: "py-w7-4-q5",
            question: "静态方法和类方法可以如何调用？",
            options: [
                "只能通过类调用",
                "只能通过实例调用",
                "通过类或实例都可以",
                "只能在类内部调用",
            ],
            answer: 2,
            rationale: "文档说明：静态方法和类方法都可以通过 Class.method() 或 instance.method() 调用。",
        },
        {
            id: "py-w7-4-q6",
            question: "在派生类上调用类方法时，cls 是什么？",
            options: [
                "基类",
                "派生类",
                "object",
                "None",
            ],
            answer: 1,
            rationale: "文档说明：classmethod 在派生类上调用时，cls 参数是派生类而非基类。",
        },
        {
            id: "py-w7-4-q7",
            question: "什么时候应该使用 @staticmethod？",
            options: [
                "需要访问实例属性时",
                "需要访问类属性时",
                "不需要访问实例或类状态时",
                "创建工厂方法时",
            ],
            answer: 2,
            rationale: "文档说明：当方法与类相关但不需要访问实例或类状态时使用 staticmethod。",
        },
        {
            id: "py-w7-4-q8",
            question: "工厂方法 Date.from_string('2024-01-01') 返回什么？",
            options: [
                "字符串",
                "Date 类的实例",
                "None",
                "字典",
            ],
            answer: 1,
            rationale: "文档示例：工厂方法使用 cls() 创建并返回类的实例。",
        },
        {
            id: "py-w7-4-q9",
            question: "类方法相比实例方法的优势是什么？",
            options: [
                "更快",
                "可以在子类中正确创建子类实例",
                "使用更少内存",
                "没有优势",
            ],
            answer: 1,
            rationale: "文档说明：classmethod 创建实例时使用 cls()，在子类中会创建子类实例。",
        },
        {
            id: "py-w7-4-q10",
            question: "以下哪个是正确的静态方法定义？",
            options: [
                "@staticmethod def f(self): pass",
                "@staticmethod def f(): pass",
                "def staticmethod f(): pass",
                "@static def f(): pass",
            ],
            answer: 1,
            rationale: "静态方法使用 @staticmethod 装饰器，不需要 self 参数。",
        },
        {
            id: "py-w7-4-q11",
            question: "三种方法类型中，哪个可以访问实例属性？",
            options: [
                "只有实例方法",
                "只有类方法",
                "实例方法和类方法",
                "三种都可以",
            ],
            answer: 0,
            rationale: "只有实例方法有 self 参数，可以直接访问实例属性。",
        },
        {
            id: "py-w7-4-q12",
            question: "@classmethod 装饰器应该放在什么位置？",
            options: [
                "方法定义之后",
                "方法定义之前，紧贴 def",
                "类定义之前",
                "任意位置",
            ],
            answer: 1,
            rationale: "@classmethod 装饰器应该放在方法定义的最内层，紧贴 def。",
        },
    ],
}
