import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week19Guides: Record<string, LessonGuide> = {
    "py-w19-1": {
        lessonId: "py-w19-1",
        background: [
            "【协程函数】使用 async def 声明的函数是协程函数。调用协程函数返回协程对象，不会立即执行。",
            "【await 表达式】await 暂停协程执行，等待可等待对象（协程、Task、Future）完成并返回结果。",
            "【可等待对象】三种类型：协程对象、Task（通过 create_task 创建）、Future（低级异步操作结果）。",
            "【asyncio.run()】运行主协程的高级 API，自动创建事件循环、运行协程、关闭循环。推荐使用。",
            "【协程必须运行】协程对象必须被 await 或通过 asyncio.run() 执行，否则只是创建对象不执行代码。",
        ],
        keyDifficulties: [
            "【协程 vs 函数】调用协程函数不执行代码，只返回协程对象。必须 await 或调度执行。",
            "【await 只在 async 中】await 只能在 async def 函数内使用，否则语法错误。",
            "【阻塞 vs 非阻塞】await asyncio.sleep() 非阻塞让出控制权；time.sleep() 阻塞整个线程。",
            "【协程不可重用】协程对象只能被 await 一次，再次 await 会抛出 RuntimeError。",
        ],
        handsOnPath: [
            "1. 定义协程：async def hello(): await asyncio.sleep(1); return 'Hello'",
            "2. 运行协程：asyncio.run(hello())",
            "3. await 调用：result = await hello()",
            "4. 协程对象：coro = hello(); print(type(coro))  # <class 'coroutine'>",
            "5. 非阻塞睡眠：await asyncio.sleep(1)  # 让出控制权",
            "6. 返回值：result = await some_coro()",
        ],
        selfCheck: [
            "async def 定义的函数调用后返回什么？",
            "await 表达式的作用是什么？",
            "哪些对象是可等待的？",
            "asyncio.run() 做了什么？",
            "为什么不能用 time.sleep() 代替 asyncio.sleep()？",
            "协程对象可以被 await 多次吗？",
        ],
        extensions: [
            "学习 async for 异步迭代",
            "了解 async with 异步上下文管理",
            "探索 asyncio.to_thread 在协程中运行阻塞代码",
            "学习 async generators 异步生成器",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/asyncio-task.html#coroutines",
            "https://docs.python.org/3/library/asyncio.html",
            "https://docs.python.org/3/reference/expressions.html#await-expression",
        ],
    },
    "py-w19-2": {
        lessonId: "py-w19-2",
        background: [
            "【事件循环】asyncio 的核心，负责调度和执行协程、处理 I/O 事件、运行回调。",
            "【asyncio.run()】高级 API，自动管理事件循环生命周期。推荐用于应用程序入口。",
            "【create_task()】将协程包装为 Task 并立即调度执行。Task 是 Future 的子类。",
            "【asyncio.gather()】并发执行多个协程/任务，返回结果列表（按传入顺序）。",
            "【TaskGroup】Python 3.11+ 推荐的结构化并发方式，自动处理异常和取消。",
        ],
        keyDifficulties: [
            "【create_task 引用】必须保持对 Task 的引用，否则可能被垃圾回收导致任务丢失。",
            "【gather vs TaskGroup】gather 简单灵活；TaskGroup 更安全，异常时自动取消其他任务。",
            "【并发 vs 顺序】多个 await 是顺序执行；create_task 或 gather 才是并发执行。",
            "【get_running_loop】在协程中获取当前循环，比 get_event_loop 更可靠。",
        ],
        handsOnPath: [
            "1. 创建任务：task = asyncio.create_task(coro())",
            "2. 并发执行：results = await asyncio.gather(coro1(), coro2())",
            "3. TaskGroup：async with asyncio.TaskGroup() as tg: tg.create_task(coro())",
            "4. 获取循环：loop = asyncio.get_running_loop()",
            "5. 低级 API：loop.run_until_complete(coro())",
            "6. 保持引用：tasks.add(task); task.add_done_callback(tasks.discard)",
        ],
        selfCheck: [
            "事件循环的作用是什么？",
            "create_task() 和直接 await 有什么区别？",
            "gather() 返回的结果顺序是什么？",
            "为什么要保持对 Task 的引用？",
            "TaskGroup 相比 gather 有什么优势？",
            "如何在协程中获取当前事件循环？",
        ],
        extensions: [
            "学习 asyncio.wait 的不同返回模式",
            "了解 asyncio.shield 保护任务不被取消",
            "探索 asyncio.timeout 上下文管理器",
            "学习任务取消和异常处理",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/asyncio-eventloop.html",
            "https://docs.python.org/3/library/asyncio-task.html#creating-tasks",
            "https://docs.python.org/3/library/asyncio-task.html#asyncio.gather",
        ],
    },
    "py-w19-3": {
        lessonId: "py-w19-3",
        background: [
            "【异步流】asyncio 提供 StreamReader 和 StreamWriter 进行异步网络 I/O。",
            "【open_connection】asyncio.open_connection(host, port) 建立 TCP 连接，返回 reader 和 writer。",
            "【start_server】asyncio.start_server(callback, host, port) 创建 TCP 服务器。",
            "【aiohttp】流行的异步 HTTP 客户端/服务器库，支持 WebSocket、会话管理。",
            "【aiofiles】异步文件操作库，提供与同步文件 API 类似的异步接口。",
        ],
        keyDifficulties: [
            "【流式读写】reader.read(n) 读取最多 n 字节；readline() 读取一行；drain() 确保写入完成。",
            "【资源清理】使用 writer.close() 和 await writer.wait_closed() 正确关闭连接。",
            "【HTTP vs TCP】aiohttp 处理 HTTP 协议细节，asyncio streams 是更低级的 TCP 接口。",
            "【文件异步限制】标准库文件 I/O 本质是阻塞的，aiofiles 使用线程池实现异步。",
        ],
        handsOnPath: [
            "1. TCP 客户端：reader, writer = await asyncio.open_connection('host', 8888)",
            "2. 发送数据：writer.write(b'Hello'); await writer.drain()",
            "3. 接收数据：data = await reader.read(100)",
            "4. 关闭连接：writer.close(); await writer.wait_closed()",
            "5. aiohttp：async with aiohttp.ClientSession() as session: await session.get(url)",
            "6. 服务器：server = await asyncio.start_server(handle_client, 'localhost', 8888)",
        ],
        selfCheck: [
            "open_connection 返回什么？",
            "drain() 的作用是什么？",
            "如何正确关闭 StreamWriter？",
            "aiohttp 和 requests 的主要区别是什么？",
            "为什么需要 aiofiles 进行异步文件操作？",
            "如何创建异步 TCP 服务器？",
        ],
        extensions: [
            "学习 asyncio.start_unix_server Unix 套接字",
            "了解 WebSocket 异步通信",
            "探索 asyncio.subprocess 异步子进程",
            "学习 uvloop 高性能事件循环",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/asyncio-stream.html",
            "https://docs.python.org/3/library/asyncio-protocol.html",
            "https://docs.aiohttp.org/",
        ],
    },
    "py-w19-4": {
        lessonId: "py-w19-4",
        background: [
            "【asyncio.Lock】异步互斥锁，使用 async with lock: 确保协程独占访问共享资源。",
            "【asyncio.Event】事件对象，set() 设置事件，wait() 等待事件，clear() 清除事件。",
            "【asyncio.Semaphore】信号量，控制同时访问资源的协程数量。BoundedSemaphore 防止过度释放。",
            "【asyncio.Condition】条件变量，结合锁和事件，支持 wait()、notify()、notify_all()。",
            "【asyncio.Queue】异步队列，put() 和 get() 是协程方法，支持 join() 等待任务完成。",
        ],
        keyDifficulties: [
            "【非线程安全】asyncio 同步原语仅用于协程间同步，不能跨线程使用。",
            "【无超时参数】同步原语方法不接受 timeout，需用 asyncio.wait_for() 包装实现超时。",
            "【async with 推荐】使用 async with lock: 确保正确释放锁，即使发生异常。",
            "【Barrier】Python 3.11+ 新增，阻塞直到指定数量的任务到达同步点。",
        ],
        handsOnPath: [
            "1. 异步锁：async with asyncio.Lock(): await access_shared_resource()",
            "2. 事件：event = asyncio.Event(); await event.wait(); event.set()",
            "3. 信号量：async with asyncio.Semaphore(5): await limited_resource()",
            "4. 条件变量：async with cond: await cond.wait(); cond.notify()",
            "5. 异步队列：q = asyncio.Queue(); await q.put(item); item = await q.get()",
            "6. 超时控制：await asyncio.wait_for(lock.acquire(), timeout=5.0)",
        ],
        selfCheck: [
            "asyncio.Lock 和 threading.Lock 有什么区别？",
            "Event 的 wait()、set()、clear() 分别做什么？",
            "Semaphore 如何限制并发数？",
            "为什么推荐使用 async with 管理锁？",
            "如何为异步操作添加超时？",
            "asyncio.Queue 和 queue.Queue 有什么区别？",
        ],
        extensions: [
            "学习 asyncio.Barrier 多任务同步",
            "了解 PriorityQueue 和 LifoQueue",
            "探索 asyncio.timeout 上下文管理器",
            "学习协程取消和清理",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/asyncio-sync.html",
            "https://docs.python.org/3/library/asyncio-sync.html#asyncio.Lock",
            "https://docs.python.org/3/library/asyncio-queue.html",
        ],
    },
}

export const week19Quizzes: Record<string, QuizQuestion[]> = {
    "py-w19-1": [
        {
            id: "py-w19-1-q1",
            question: "async def 定义的函数调用后返回什么？",
            options: [
                "执行结果",
                "协程对象",
                "None",
                "Future 对象",
            ],
            answer: 1,
            rationale: "文档说明：调用协程函数返回协程对象，不会立即执行代码。",
        },
        {
            id: "py-w19-1-q2",
            question: "await 表达式可以在哪里使用？",
            options: [
                "任何函数中",
                "只能在 async def 函数中",
                "只在类方法中",
                "在模块顶层",
            ],
            answer: 1,
            rationale: "文档说明：await 只能在 async def 函数内使用。",
        },
        {
            id: "py-w19-1-q3",
            question: "以下哪个不是可等待对象？",
            options: [
                "协程对象",
                "Task",
                "Future",
                "普通函数",
            ],
            answer: 3,
            rationale: "文档说明：三种可等待对象：协程、Task、Future。普通函数不是。",
        },
        {
            id: "py-w19-1-q4",
            question: "asyncio.run() 的作用是什么？",
            options: [
                "创建协程",
                "运行主协程，自动管理事件循环",
                "暂停协程",
                "取消任务",
            ],
            answer: 1,
            rationale: "文档说明：asyncio.run() 是运行协程的高级 API，自动创建和关闭事件循环。",
        },
        {
            id: "py-w19-1-q5",
            question: "为什么不应该在协程中使用 time.sleep()？",
            options: [
                "会抛出异常",
                "会阻塞整个事件循环",
                "语法错误",
                "性能问题",
            ],
            answer: 1,
            rationale: "time.sleep() 是阻塞调用，会阻塞整个事件循环。应使用 asyncio.sleep()。",
        },
        {
            id: "py-w19-1-q6",
            question: "协程对象可以被 await 多少次？",
            options: [
                "无限次",
                "只能一次",
                "两次",
                "取决于返回值",
            ],
            answer: 1,
            rationale: "文档说明：协程对象只能被 await 一次，再次 await 会抛出 RuntimeError。",
        },
        {
            id: "py-w19-1-q7",
            question: "asyncio.sleep(1) 的作用是什么？",
            options: [
                "阻塞线程 1 秒",
                "非阻塞暂停，让出事件循环控制权 1 秒",
                "创建延迟任务",
                "取消其他任务",
            ],
            answer: 1,
            rationale: "文档说明：asyncio.sleep() 非阻塞暂停协程，让出控制权给事件循环。",
        },
        {
            id: "py-w19-1-q8",
            question: "如何执行一个协程？",
            options: [
                "直接调用 coro()",
                "使用 asyncio.run(coro()) 或 await",
                "使用 exec(coro())",
                "使用 start(coro())",
            ],
            answer: 1,
            rationale: "文档说明：协程必须通过 asyncio.run() 或 await 执行。",
        },
        {
            id: "py-w19-1-q9",
            question: "async def 函数和普通函数的主要区别是什么？",
            options: [
                "async 函数更快",
                "async 函数返回协程对象，可被暂停和恢复",
                "async 函数不能有参数",
                "async 函数不能返回值",
            ],
            answer: 1,
            rationale: "async def 定义的协程函数返回协程对象，支持暂停和恢复执行。",
        },
        {
            id: "py-w19-1-q10",
            question: "以下代码会输出什么？async def foo(): return 42; print(foo())",
            options: [
                "42",
                "<coroutine object foo at 0x...>",
                "None",
                "语法错误",
            ],
            answer: 1,
            rationale: "调用协程函数只返回协程对象，不执行代码。需要 await 或 run 执行。",
        },
        {
            id: "py-w19-1-q11",
            question: "如何获取协程的返回值？",
            options: [
                "coro().result()",
                "await coro() 或 asyncio.run(coro())",
                "coro().get()",
                "result(coro())",
            ],
            answer: 1,
            rationale: "文档说明：使用 await 或 asyncio.run() 执行协程并获取返回值。",
        },
        {
            id: "py-w19-1-q12",
            question: "async with 语句用于什么？",
            options: [
                "定义协程",
                "异步上下文管理器",
                "创建任务",
                "取消协程",
            ],
            answer: 1,
            rationale: "async with 用于异步上下文管理器，如异步锁、异步文件操作。",
        },
    ],
    "py-w19-2": [
        {
            id: "py-w19-2-q1",
            question: "asyncio.create_task() 的作用是什么？",
            options: [
                "创建协程",
                "将协程包装为 Task 并立即调度执行",
                "暂停任务",
                "取消任务",
            ],
            answer: 1,
            rationale: "文档说明：create_task() 将协程包装为 Task 并立即调度到事件循环。",
        },
        {
            id: "py-w19-2-q2",
            question: "asyncio.gather() 返回的结果顺序是什么？",
            options: [
                "完成顺序",
                "传入参数的顺序",
                "随机顺序",
                "按运行时间排序",
            ],
            answer: 1,
            rationale: "文档说明：gather() 返回的结果列表按传入协程的顺序排列。",
        },
        {
            id: "py-w19-2-q3",
            question: "为什么要保持对 create_task() 返回的 Task 的引用？",
            options: [
                "提高性能",
                "防止任务被垃圾回收导致丢失",
                "方便调试",
                "语法要求",
            ],
            answer: 1,
            rationale: "文档警告：没有引用的 Task 可能被垃圾回收，导致任务静默丢失。",
        },
        {
            id: "py-w19-2-q4",
            question: "TaskGroup 相比 gather 的优势是什么？",
            options: [
                "更快",
                "异常时自动取消其他任务，更安全",
                "更简单",
                "支持更多任务",
            ],
            answer: 1,
            rationale: "文档说明：TaskGroup 实现结构化并发，异常时自动取消组内其他任务。",
        },
        {
            id: "py-w19-2-q5",
            question: "如何在协程中获取当前事件循环？",
            options: [
                "asyncio.get_loop()",
                "asyncio.get_running_loop()",
                "asyncio.current_loop()",
                "asyncio.loop()",
            ],
            answer: 1,
            rationale: "文档说明：get_running_loop() 返回当前运行的事件循环。",
        },
        {
            id: "py-w19-2-q6",
            question: "以下代码的执行时间大约是多少？await coro1(); await coro2() 各需 1 秒",
            options: [
                "1 秒",
                "2 秒",
                "0 秒",
                "不确定",
            ],
            answer: 1,
            rationale: "多个 await 是顺序执行，1+1=2 秒。并发需使用 gather 或 create_task。",
        },
        {
            id: "py-w19-2-q7",
            question: "gather(coro1(), coro2()) 各需 1 秒，总执行时间大约是多少？",
            options: [
                "2 秒",
                "1 秒",
                "0.5 秒",
                "4 秒",
            ],
            answer: 1,
            rationale: "gather 并发执行协程，最长任务决定总时间，约 1 秒。",
        },
        {
            id: "py-w19-2-q8",
            question: "loop.run_until_complete(future) 的作用是什么？",
            options: [
                "创建循环",
                "运行直到 future 完成",
                "立即完成",
                "取消 future",
            ],
            answer: 1,
            rationale: "文档说明：run_until_complete() 运行事件循环直到 future 完成。",
        },
        {
            id: "py-w19-2-q9",
            question: "Task 是什么的子类？",
            options: [
                "协程",
                "Future",
                "Event",
                "Thread",
            ],
            answer: 1,
            rationale: "文档说明：Task 是 Future 的子类，用于调度协程执行。",
        },
        {
            id: "py-w19-2-q10",
            question: "asyncio.run() 可以在已运行的事件循环中调用吗？",
            options: [
                "可以",
                "不可以，会抛出 RuntimeError",
                "取决于参数",
                "会自动嵌套",
            ],
            answer: 1,
            rationale: "文档说明：asyncio.run() 不能在已运行的事件循环中调用。",
        },
        {
            id: "py-w19-2-q11",
            question: "gather(return_exceptions=True) 的效果是什么？",
            options: [
                "忽略异常",
                "异常作为结果返回而非抛出",
                "重试失败的任务",
                "取消所有任务",
            ],
            answer: 1,
            rationale: "文档说明：return_exceptions=True 时，异常作为结果返回而非传播。",
        },
        {
            id: "py-w19-2-q12",
            question: "TaskGroup 使用什么语法？",
            options: [
                "with TaskGroup()",
                "async with asyncio.TaskGroup() as tg:",
                "TaskGroup.start()",
                "await TaskGroup()",
            ],
            answer: 1,
            rationale: "文档说明：TaskGroup 使用 async with 语句作为异步上下文管理器。",
        },
    ],
    "py-w19-3": [
        {
            id: "py-w19-3-q1",
            question: "asyncio.open_connection() 返回什么？",
            options: [
                "socket 对象",
                "(StreamReader, StreamWriter) 元组",
                "连接对象",
                "Future",
            ],
            answer: 1,
            rationale: "文档说明：open_connection 返回 (reader, writer) 元组。",
        },
        {
            id: "py-w19-3-q2",
            question: "writer.drain() 的作用是什么？",
            options: [
                "清空缓冲区",
                "等待写入缓冲区被消费",
                "关闭连接",
                "重置流",
            ],
            answer: 1,
            rationale: "文档说明：drain() 等待写入缓冲区被底层传输消费。",
        },
        {
            id: "py-w19-3-q3",
            question: "如何正确关闭 StreamWriter？",
            options: [
                "writer.close()",
                "writer.close(); await writer.wait_closed()",
                "del writer",
                "writer.shutdown()",
            ],
            answer: 1,
            rationale: "文档推荐：调用 close() 后 await wait_closed() 确保完全关闭。",
        },
        {
            id: "py-w19-3-q4",
            question: "aiohttp 是什么？",
            options: [
                "标准库模块",
                "异步 HTTP 客户端/服务器库",
                "同步 HTTP 库",
                "文件操作库",
            ],
            answer: 1,
            rationale: "aiohttp 是流行的第三方异步 HTTP 客户端和服务器库。",
        },
        {
            id: "py-w19-3-q5",
            question: "reader.readline() 读取什么？",
            options: [
                "固定字节数",
                "一行数据（直到换行符）",
                "整个文件",
                "一个字符",
            ],
            answer: 1,
            rationale: "文档说明：readline() 读取一行数据，直到遇到换行符。",
        },
        {
            id: "py-w19-3-q6",
            question: "asyncio.start_server() 用于什么？",
            options: [
                "启动 HTTP 服务器",
                "创建 TCP 服务器",
                "启动 WebSocket",
                "创建 UDP 服务器",
            ],
            answer: 1,
            rationale: "文档说明：start_server 创建 TCP 服务器。",
        },
        {
            id: "py-w19-3-q7",
            question: "为什么需要 aiofiles 进行文件操作？",
            options: [
                "标准库不支持文件操作",
                "标准文件 I/O 是阻塞的，aiofiles 提供异步接口",
                "aiofiles 更快",
                "语法更简单",
            ],
            answer: 1,
            rationale: "标准库文件 I/O 是阻塞的，aiofiles 使用线程池实现异步接口。",
        },
        {
            id: "py-w19-3-q8",
            question: "reader.read(100) 最多读取多少字节？",
            options: [
                "恰好 100 字节",
                "最多 100 字节",
                "至少 100 字节",
                "取决于缓冲区",
            ],
            answer: 1,
            rationale: "文档说明：read(n) 读取最多 n 字节，可能返回更少。",
        },
        {
            id: "py-w19-3-q9",
            question: "aiohttp.ClientSession 应该如何使用？",
            options: [
                "每次请求创建新实例",
                "使用 async with 作为上下文管理器",
                "作为全局变量",
                "使用 with 语句",
            ],
            answer: 1,
            rationale: "aiohttp 推荐使用 async with ClientSession() as session: 管理会话。",
        },
        {
            id: "py-w19-3-q10",
            question: "writer.write() 是协程吗？",
            options: [
                "是",
                "不是，它是普通方法（但需要 await drain()）",
                "取决于参数",
                "取决于平台",
            ],
            answer: 1,
            rationale: "write() 是普通方法，不是协程。需要 await drain() 确保写入完成。",
        },
        {
            id: "py-w19-3-q11",
            question: "如何读取直到 EOF？",
            options: [
                "reader.read()",
                "await reader.read() 不传参数",
                "reader.readall()",
                "reader.read(-1)",
            ],
            answer: 1,
            rationale: "文档说明：read() 不传参数（或传 -1）读取直到 EOF。",
        },
        {
            id: "py-w19-3-q12",
            question: "asyncio streams 和 aiohttp 的主要区别是什么？",
            options: [
                "性能不同",
                "streams 是低级 TCP，aiohttp 处理 HTTP 协议",
                "streams 只能做服务器",
                "aiohttp 只能做客户端",
            ],
            answer: 1,
            rationale: "asyncio streams 是低级 TCP 接口，aiohttp 封装了 HTTP 协议细节。",
        },
    ],
    "py-w19-4": [
        {
            id: "py-w19-4-q1",
            question: "asyncio.Lock 和 threading.Lock 的主要区别是什么？",
            options: [
                "性能不同",
                "asyncio.Lock 用于协程，threading.Lock 用于线程",
                "没有区别",
                "asyncio.Lock 更快",
            ],
            answer: 1,
            rationale: "文档说明：asyncio 同步原语仅用于协程间同步，不能跨线程使用。",
        },
        {
            id: "py-w19-4-q2",
            question: "asyncio.Event.wait() 会阻塞到什么时候？",
            options: [
                "超时",
                "直到 set() 被调用",
                "立即返回",
                "1 秒后",
            ],
            answer: 1,
            rationale: "文档说明：wait() 阻塞直到事件被 set() 设置。",
        },
        {
            id: "py-w19-4-q3",
            question: "Semaphore(5) 允许多少个协程同时访问资源？",
            options: [
                "1 个",
                "5 个",
                "无限制",
                "取决于资源",
            ],
            answer: 1,
            rationale: "文档说明：Semaphore 初始值决定同时访问的最大数量。",
        },
        {
            id: "py-w19-4-q4",
            question: "如何为 asyncio.Lock.acquire() 添加超时？",
            options: [
                "lock.acquire(timeout=5)",
                "await asyncio.wait_for(lock.acquire(), timeout=5)",
                "lock.set_timeout(5)",
                "不支持超时",
            ],
            answer: 1,
            rationale: "文档说明：同步原语不接受 timeout 参数，需用 wait_for() 包装。",
        },
        {
            id: "py-w19-4-q5",
            question: "BoundedSemaphore 和 Semaphore 的区别是什么？",
            options: [
                "BoundedSemaphore 更快",
                "BoundedSemaphore 防止 release 超过初始值",
                "没有区别",
                "Semaphore 有上限",
            ],
            answer: 1,
            rationale: "文档说明：BoundedSemaphore 在 release 超过初始值时抛出 ValueError。",
        },
        {
            id: "py-w19-4-q6",
            question: "asyncio.Queue.put() 是什么类型的方法？",
            options: [
                "普通方法",
                "协程方法",
                "类方法",
                "静态方法",
            ],
            answer: 1,
            rationale: "文档说明：asyncio.Queue 的 put() 和 get() 都是协程方法。",
        },
        {
            id: "py-w19-4-q7",
            question: "Condition.notify() 做什么？",
            options: [
                "通知所有等待者",
                "唤醒一个等待的协程",
                "清除条件",
                "设置条件",
            ],
            answer: 1,
            rationale: "文档说明：notify(n=1) 唤醒 n 个等待的协程，默认 1 个。",
        },
        {
            id: "py-w19-4-q8",
            question: "推荐使用什么语法管理 asyncio.Lock？",
            options: [
                "lock.acquire(); lock.release()",
                "async with lock:",
                "with lock:",
                "try: lock.get()",
            ],
            answer: 1,
            rationale: "文档推荐：使用 async with 确保正确释放锁。",
        },
        {
            id: "py-w19-4-q9",
            question: "asyncio.Barrier 的作用是什么？",
            options: [
                "阻止任务执行",
                "阻塞直到指定数量的任务到达同步点",
                "取消任务",
                "优先级调度",
            ],
            answer: 1,
            rationale: "文档说明：Barrier 阻塞直到指定数量的任务都调用 wait()。",
        },
        {
            id: "py-w19-4-q10",
            question: "asyncio 同步原语可以跨线程使用吗？",
            options: [
                "可以",
                "不可以，仅用于协程间同步",
                "只有 Lock 可以",
                "只有 Event 可以",
            ],
            answer: 1,
            rationale: "文档警告：asyncio 同步原语非线程安全，仅用于协程。",
        },
        {
            id: "py-w19-4-q11",
            question: "Event.clear() 的作用是什么？",
            options: [
                "删除事件",
                "重置事件标志为未设置状态",
                "清空等待者",
                "取消事件",
            ],
            answer: 1,
            rationale: "文档说明：clear() 将内部标志重置为 False。",
        },
        {
            id: "py-w19-4-q12",
            question: "asyncio.Queue 支持 join() 方法吗？",
            options: [
                "不支持",
                "支持，等待所有任务完成",
                "只有 JoinableQueue 支持",
                "取决于版本",
            ],
            answer: 1,
            rationale: "文档说明：asyncio.Queue 支持 join()，等待所有项被处理（配合 task_done）。",
        },
    ],
}
