import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week8Guides: Record<string, LessonGuide> = {
    "py-w8-1": {
        lessonId: "py-w8-1",
        background: [
            "【继承语法】class DerivedClass(BaseClass): 定义派生类。基类名必须在派生类定义的作用域中可访问。可以是来自其他模块的类：class D(modname.Base)。",
            "【属性查找顺序】访问派生类属性时：先在派生类中查找，未找到则在基类中查找，递归搜索基类的基类链。",
            "【方法重写】派生类可以重写基类的方法。Python 中所有方法都是虚拟的，方法调用在运行时根据实际对象类型确定。",
            "【调用基类方法】重写方法时可以调用基类实现：BaseClassName.methodname(self, arguments) 或使用 super().methodname()。",
            "【isinstance 和 issubclass】isinstance(obj, ClassName) 检查实例类型；issubclass(A, B) 检查类继承关系。两者都支持元组参数。",
        ],
        keyDifficulties: [
            "【虚拟方法】Python 中所有方法都是虚拟的，不需要像 C++ 那样声明 virtual。派生类方法总是可以覆盖基类方法。",
            "【动态绑定】方法调用在运行时根据对象的实际类型解析，而非声明类型。这是多态的基础。",
            "【super() 的作用】super() 返回代理对象，自动按 MRO 调用下一个类的方法，比直接调用 BaseClass.method() 更灵活。",
            "【继承 vs 组合】继承表示 is-a 关系，组合表示 has-a 关系。过度使用继承会导致类层次复杂，应优先考虑组合。",
        ],
        handsOnPath: [
            "1. 定义基类：class Animal: def speak(self): return 'sound'",
            "2. 定义派生类：class Dog(Animal): def speak(self): return 'woof'",
            "3. 测试多态：animals = [Animal(), Dog()]; [a.speak() for a in animals]",
            "4. 调用基类方法：class Cat(Animal): def speak(self): return super().speak() + ' meow'",
            "5. 使用 isinstance：print(isinstance(Dog(), Animal))",
            "6. 使用 issubclass：print(issubclass(Dog, Animal))",
        ],
        selfCheck: [
            "派生类如何定义？",
            "属性查找的顺序是什么？",
            "如何在重写方法中调用基类的实现？",
            "Python 中的方法为什么都是虚拟的？",
            "isinstance 和 type() 检查有什么区别？",
            "什么时候应该使用继承，什么时候使用组合？",
        ],
        extensions: [
            "学习 __init_subclass__ 钩子自定义子类创建",
            "了解 __subclasses__() 获取所有子类",
            "探索 __bases__ 和 __mro__ 属性",
            "学习抽象基类强制子类实现方法",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/classes.html#inheritance",
            "https://docs.python.org/3/reference/datamodel.html#customizing-class-creation",
            "https://docs.python.org/3/library/functions.html#isinstance",
        ],
    },
    "py-w8-2": {
        lessonId: "py-w8-2",
        background: [
            "【super() 函数】super() 返回代理对象，用于委派方法调用到父类或同级类。零参形式 super() 仅在类方法内有效，编译器自动填充参数。",
            "【MRO 定义】Method Resolution Order（方法解析顺序）是查找基类成员时的搜索顺序。Python 使用 C3 线性化算法计算 MRO。",
            "【查看 MRO】使用 ClassName.__mro__ 属性或 ClassName.mro() 方法查看方法解析顺序。",
            "【super() 搜索机制】super(type, obj) 从 type 之后的类开始按 MRO 搜索。例如 MRO 为 D→B→C→A，super(B, obj) 搜索 C→A。",
            "【协作式多继承】super() 支持协作式多继承，每个类调用 super() 确保 MRO 中所有类的方法都被调用。",
        ],
        keyDifficulties: [
            "【super() vs 直接调用】super().method() 按 MRO 调用，支持多继承；BaseClass.method(self) 固定调用指定类，不灵活。",
            "【MRO 算法】C3 线性化保证：每个类在其父类之前、左边的父类在右边之前、每个父类只出现一次。",
            "【菱形继承问题】多继承导致同一基类被多条路径继承。super() 和 MRO 确保共同基类的方法只被调用一次。",
            "【协作调用顺序】在多继承中，所有类都应使用 super() 调用以确保协作链不断裂。",
        ],
        handsOnPath: [
            "1. 单继承 super：class Child(Parent): def __init__(self): super().__init__()",
            "2. 查看 MRO：class D(B, C): pass; print(D.__mro__)",
            "3. 菱形继承：class A: pass; class B(A): pass; class C(A): pass; class D(B, C): pass",
            "4. 验证 MRO：print(D.mro())",
            "5. 协作调用：class B(A): def method(self): print('B'); super().method()",
            "6. 完整链调用：d = D(); d.method()  # 观察调用顺序",
        ],
        selfCheck: [
            "super() 返回什么类型的对象？",
            "MRO 是什么？如何查看？",
            "C3 线性化算法有什么保证？",
            "菱形继承中 super() 如何工作？",
            "为什么推荐使用 super() 而非直接调用基类？",
            "零参 super() 在哪里有效？",
        ],
        extensions: [
            "学习 Raymond Hettinger 的 'super() considered super'",
            "了解 __class__ 单元在 super() 中的作用",
            "探索 super() 与属性和描述符的交互",
            "学习多继承设计模式（Mixin）",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/functions.html#super",
            "https://docs.python.org/3/glossary.html#term-method-resolution-order",
            "https://docs.python.org/3/tutorial/classes.html#multiple-inheritance",
        ],
    },
    "py-w8-3": {
        lessonId: "py-w8-3",
        background: [
            "【多继承语法】class D(Base1, Base2, Base3): 定义多继承。基类从左到右列出，左边的优先级更高。",
            "【菱形继承】所有多继承都会产生菱形关系，因为所有类都继承自 object。Python 的 MRO 算法正确处理这种情况。",
            "【Mixin 模式】Mixin 是提供可选功能的小型类，不独立使用。设计原则：Mixin 放在左边，主要基类放在右边。",
            "【C3 线性化】Python 使用 C3 线性化算法计算 MRO，保证单调性和一致性。无法线性化的继承结构会抛出 TypeError。",
            "【协作方法】多继承中所有类都应使用 super() 调用方法，确保 MRO 链上的所有类都被正确调用。",
        ],
        keyDifficulties: [
            "【MRO 计算规则】C3 规则：子类在父类之前、左边基类在右边基类之前、每个类只出现一次。违反会导致 TypeError。",
            "【Mixin 设计原则】Mixin 应该：单一功能、不独立实例化、命名以 Mixin 结尾、方法应调用 super()。",
            "【方法查找顺序】查找方法时严格按 MRO 顺序，第一个找到的方法被使用。可通过 __mro__ 查看完整顺序。",
            "【多继承陷阱】避免深层多继承层次、避免有状态的 Mixin、注意 __init__ 参数传递问题。",
        ],
        handsOnPath: [
            "1. 定义 Mixin：class LogMixin: def log(self, msg): print(f'Log: {msg}')",
            "2. 使用 Mixin：class MyClass(LogMixin, BaseClass): pass",
            "3. 无效 MRO：class A(X, Y): pass; class B(Y, X): pass; class C(A, B): pass  # TypeError",
            "4. 查看复杂 MRO：class D(B, C): pass; print(D.__mro__)",
            "5. Mixin 调用链：class M: def save(self): super().save(); print('M saved')",
            "6. 完整示例：class Product(LogMixin, Serializable, Model): pass",
        ],
        selfCheck: [
            "多继承的语法是什么？",
            "什么是 Mixin？有什么设计原则？",
            "C3 线性化有什么保证？",
            "什么情况下会无法计算 MRO？",
            "为什么所有多继承都有菱形关系？",
            "Mixin 应该放在继承列表的什么位置？",
        ],
        extensions: [
            "学习 Django 中的 Mixin 模式应用",
            "了解 Python 2.3 MRO 文档详细算法",
            "探索 __init_subclass__ 替代 Mixin",
            "学习协议（Protocol）作为 Mixin 的替代",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/classes.html#multiple-inheritance",
            "https://www.python.org/download/releases/2.3/mro/",
            "https://docs.python.org/3/howto/descriptor.html",
        ],
    },
    "py-w8-4": {
        lessonId: "py-w8-4",
        background: [
            "【鸭子类型】'If it looks like a duck and quacks like a duck, it must be a duck。' 关注对象的行为（方法和属性）而非类型。",
            "【动态多态】Python 多态不需要继承关系，只要对象有相同的方法即可。这比静态类型语言更灵活。",
            "【EAFP 原则】'Easier to Ask for Forgiveness than Permission'：先调用方法，用 try-except 处理异常，而非先检查类型。",
            "【抽象基类】abc 模块提供抽象基类支持。继承 ABC 并用 @abstractmethod 标记抽象方法，子类必须实现才能实例化。",
            "【虚拟子类】ABC.register(cls) 将类注册为虚拟子类，isinstance 检查返回 True，但不真正继承 ABC 的方法。",
        ],
        keyDifficulties: [
            "【避免类型检查】鸭子类型避免使用 type() 或 isinstance() 检查。如需检查，使用 hasattr() 或直接调用让它失败。",
            "【抽象方法规则】有 @abstractmethod 的类不能直接实例化。子类必须实现所有抽象方法才能实例化。",
            "【__subclasshook__】自定义 isinstance 和 issubclass 的行为，基于接口而非继承判断子类关系。",
            "【协议 vs ABC】Python 3.8+ 的 Protocol 提供结构化子类型，比 ABC 更符合鸭子类型精神。",
        ],
        handsOnPath: [
            "1. 鸭子类型：def process(obj): obj.read()  # 任何有 read() 的对象都可以",
            "2. EAFP 风格：try: obj.method() except AttributeError: pass",
            "3. hasattr 检查：if hasattr(obj, 'method'): obj.method()",
            "4. 定义 ABC：from abc import ABC, abstractmethod; class Base(ABC): @abstractmethod def m(self): pass",
            "5. 实现 ABC：class Impl(Base): def m(self): return 'impl'",
            "6. 虚拟子类：Base.register(ExistingClass)",
        ],
        selfCheck: [
            "什么是鸭子类型？核心原则是什么？",
            "EAFP 是什么意思？与 LBYL 有什么区别？",
            "如何定义抽象基类和抽象方法？",
            "抽象类可以直接实例化吗？",
            "虚拟子类是什么？有什么用途？",
            "Protocol 和 ABC 有什么区别？",
        ],
        extensions: [
            "学习 collections.abc 中的抽象基类",
            "了解 typing.Protocol 结构化子类型",
            "探索 __subclasshook__ 自定义类型检查",
            "学习 PEP 544 Protocol 类",
        ],
        sourceUrls: [
            "https://docs.python.org/3/glossary.html#term-duck-typing",
            "https://docs.python.org/3/library/abc.html",
            "https://docs.python.org/3/library/abc.html#abc.ABC",
        ],
    },
}

export const week8Quizzes: Record<string, QuizQuestion[]> = {
    "py-w8-1": [
        {
            id: "py-w8-1-q1",
            question: "Python 中定义派生类的语法是什么？",
            options: [
                "class Child extends Parent:",
                "class Child(Parent):",
                "class Child inherits Parent:",
                "class Child : Parent:",
            ],
            answer: 1,
            rationale: "Python 使用 class Child(Parent): 语法定义派生类，基类放在括号中。",
        },
        {
            id: "py-w8-1-q2",
            question: "Python 中的方法是否需要声明为 virtual？",
            options: [
                "需要，否则不能重写",
                "不需要，所有方法默认都是虚拟的",
                "只有特殊方法需要",
                "取决于基类定义",
            ],
            answer: 1,
            rationale: "文档说明：Python 中所有方法都是虚拟的，派生类可以覆盖任何基类方法。",
        },
        {
            id: "py-w8-1-q3",
            question: "属性查找顺序是什么？",
            options: [
                "基类 → 派生类",
                "派生类 → 基类 → 基类的基类",
                "只查找派生类",
                "随机顺序",
            ],
            answer: 1,
            rationale: "文档说明：先在派生类中查找，未找到则在基类中查找，递归搜索基类链。",
        },
        {
            id: "py-w8-1-q4",
            question: "如何在重写方法中调用基类的实现？",
            options: [
                "parent.method()",
                "base.method()",
                "super().method()",
                "this.super.method()",
            ],
            answer: 2,
            rationale: "使用 super().method() 调用基类方法，或 BaseClass.method(self)。",
        },
        {
            id: "py-w8-1-q5",
            question: "isinstance(True, int) 返回什么？",
            options: [
                "False",
                "True",
                "TypeError",
                "None",
            ],
            answer: 1,
            rationale: "bool 是 int 的子类，所以 isinstance(True, int) 返回 True。",
        },
        {
            id: "py-w8-1-q6",
            question: "issubclass(bool, int) 返回什么？",
            options: [
                "False",
                "True",
                "TypeError",
                "None",
            ],
            answer: 1,
            rationale: "bool 是 int 的子类，issubclass(bool, int) 返回 True。",
        },
        {
            id: "py-w8-1-q7",
            question: "继承表示什么关系？",
            options: [
                "has-a 关系",
                "is-a 关系",
                "uses-a 关系",
                "contains 关系",
            ],
            answer: 1,
            rationale: "继承表示 is-a 关系（Dog is-a Animal），组合表示 has-a 关系。",
        },
        {
            id: "py-w8-1-q8",
            question: "动态绑定意味着什么？",
            options: [
                "编译时确定调用哪个方法",
                "运行时根据实际对象类型确定调用哪个方法",
                "方法不能被重写",
                "只有基类方法可以调用",
            ],
            answer: 1,
            rationale: "动态绑定指方法调用在运行时根据对象的实际类型解析，这是多态的基础。",
        },
        {
            id: "py-w8-1-q9",
            question: "以下哪个是正确的多态示例？",
            options: [
                "只能调用基类定义的方法",
                "相同方法名在不同类中有不同实现",
                "方法只能接受固定类型参数",
                "子类不能有新方法",
            ],
            answer: 1,
            rationale: "多态指相同方法名在不同类中有不同实现，根据对象类型调用相应版本。",
        },
        {
            id: "py-w8-1-q10",
            question: "isinstance(obj, (A, B, C)) 检查什么？",
            options: [
                "obj 必须同时是 A、B、C 的实例",
                "obj 是 A、B、C 中任意一个的实例",
                "语法错误",
                "总是返回 False",
            ],
            answer: 1,
            rationale: "isinstance 支持元组参数，检查对象是否是元组中任意类的实例。",
        },
        {
            id: "py-w8-1-q11",
            question: "派生类可以继承哪些内容？",
            options: [
                "只有方法",
                "只有属性",
                "方法和属性",
                "只有公有成员",
            ],
            answer: 2,
            rationale: "派生类继承基类的所有属性和方法（包括特殊方法）。",
        },
        {
            id: "py-w8-1-q12",
            question: "什么时候应该优先使用组合而非继承？",
            options: [
                "永远使用继承",
                "当关系是 has-a 而非 is-a 时",
                "只在多继承时",
                "从不使用组合",
            ],
            answer: 1,
            rationale: "当关系是 has-a（拥有）而非 is-a（是一种）时，应优先使用组合。",
        },
    ],
    "py-w8-2": [
        {
            id: "py-w8-2-q1",
            question: "super() 返回什么？",
            options: [
                "父类本身",
                "父类的实例",
                "代理对象",
                "None",
            ],
            answer: 2,
            rationale: "文档说明：super() 返回代理对象，用于委派方法调用到父类或同级类。",
        },
        {
            id: "py-w8-2-q2",
            question: "MRO 是什么的缩写？",
            options: [
                "Method Return Order",
                "Method Resolution Order",
                "Multiple Reference Object",
                "Module Resolution Order",
            ],
            answer: 1,
            rationale: "MRO 是 Method Resolution Order（方法解析顺序）的缩写。",
        },
        {
            id: "py-w8-2-q3",
            question: "如何查看类的 MRO？",
            options: [
                "ClassName.order()",
                "ClassName.__mro__ 或 ClassName.mro()",
                "ClassName.resolution()",
                "mro(ClassName)",
            ],
            answer: 1,
            rationale: "使用 ClassName.__mro__ 属性或 ClassName.mro() 方法查看 MRO。",
        },
        {
            id: "py-w8-2-q4",
            question: "Python 使用什么算法计算 MRO？",
            options: [
                "深度优先搜索",
                "广度优先搜索",
                "C3 线性化",
                "随机算法",
            ],
            answer: 2,
            rationale: "文档说明：Python 使用 C3 线性化算法计算 MRO。",
        },
        {
            id: "py-w8-2-q5",
            question: "零参 super() 在哪里有效？",
            options: [
                "任何地方",
                "只在类方法内",
                "只在模块级别",
                "只在 __init__ 中",
            ],
            answer: 1,
            rationale: "文档说明：零参形式 super() 仅在类方法内有效，编译器自动填充参数。",
        },
        {
            id: "py-w8-2-q6",
            question: "class D(B, C) 的 MRO 开头是什么？",
            options: [
                "B, C, D",
                "D, B, C",
                "C, B, D",
                "object, D, B, C",
            ],
            answer: 1,
            rationale: "MRO 总是以当前类开头，然后按 C3 算法排列基类，最后是 object。",
        },
        {
            id: "py-w8-2-q7",
            question: "super(B, obj) 从哪里开始搜索？",
            options: [
                "从 B 开始",
                "从 B 之后的类开始",
                "从 object 开始",
                "从 obj 的类开始",
            ],
            answer: 1,
            rationale: "文档说明：super(type, obj) 从 type 之后的类开始按 MRO 搜索。",
        },
        {
            id: "py-w8-2-q8",
            question: "菱形继承中 super() 确保什么？",
            options: [
                "基类方法被调用多次",
                "基类方法只被调用一次",
                "基类方法不被调用",
                "抛出错误",
            ],
            answer: 1,
            rationale: "MRO 和 super() 确保共同基类的方法只被调用一次，解决菱形继承问题。",
        },
        {
            id: "py-w8-2-q9",
            question: "C3 线性化保证什么？",
            options: [
                "随机顺序",
                "子类在父类之前、保持左右顺序、每个类只出现一次",
                "父类在子类之前",
                "只有一种可能的顺序",
            ],
            answer: 1,
            rationale: "C3 保证：子类在父类之前、左边基类在右边之前、每个类只出现一次。",
        },
        {
            id: "py-w8-2-q10",
            question: "为什么推荐使用 super() 而非 BaseClass.method(self)？",
            options: [
                "super() 更快",
                "super() 支持多继承的协作调用",
                "BaseClass.method 已弃用",
                "没有区别",
            ],
            answer: 1,
            rationale: "super() 按 MRO 调用，支持多继承协作；直接调用固定类，不够灵活。",
        },
        {
            id: "py-w8-2-q11",
            question: "协作式多继承要求什么？",
            options: [
                "只有一个类使用 super()",
                "所有类都应使用 super() 调用",
                "不使用 super()",
                "只在 __init__ 中使用 super()",
            ],
            answer: 1,
            rationale: "协作式多继承要求所有类都使用 super() 调用方法，确保 MRO 链完整。",
        },
        {
            id: "py-w8-2-q12",
            question: "MRO 的最后一个类总是什么？",
            options: [
                "当前类",
                "第一个基类",
                "object",
                "None",
            ],
            answer: 2,
            rationale: "所有类都继承自 object，所以 MRO 的最后一个类总是 object。",
        },
    ],
    "py-w8-3": [
        {
            id: "py-w8-3-q1",
            question: "多继承的语法是什么？",
            options: [
                "class D extends B, C:",
                "class D(B, C):",
                "class D(B) + C:",
                "class D: B, C",
            ],
            answer: 1,
            rationale: "Python 多继承语法：class D(Base1, Base2, Base3):，基类用逗号分隔。",
        },
        {
            id: "py-w8-3-q2",
            question: "多继承中基类的优先级顺序是什么？",
            options: [
                "右边优先",
                "左边优先",
                "按字母顺序",
                "随机",
            ],
            answer: 1,
            rationale: "文档说明：基类从左到右列出，左边的优先级更高。",
        },
        {
            id: "py-w8-3-q3",
            question: "什么是 Mixin？",
            options: [
                "主要基类",
                "提供可选功能的小型类",
                "抽象基类",
                "元类",
            ],
            answer: 1,
            rationale: "Mixin 是提供可选功能的小型类，不独立使用，用于增强其他类。",
        },
        {
            id: "py-w8-3-q4",
            question: "Mixin 应该放在继承列表的什么位置？",
            options: [
                "最右边",
                "最左边",
                "中间",
                "任意位置",
            ],
            answer: 1,
            rationale: "设计原则：Mixin 放在左边，主要基类放在右边。",
        },
        {
            id: "py-w8-3-q5",
            question: "为什么所有多继承都有菱形关系？",
            options: [
                "不一定有",
                "因为所有类都继承自 object",
                "Python 强制要求",
                "只有三层以上才有",
            ],
            answer: 1,
            rationale: "文档说明：所有类都继承自 object，任何多继承都会产生至少一条到 object 的路径。",
        },
        {
            id: "py-w8-3-q6",
            question: "无法计算 MRO 时会发生什么？",
            options: [
                "返回空列表",
                "抛出 TypeError",
                "使用默认顺序",
                "忽略冲突",
            ],
            answer: 1,
            rationale: "无法线性化的继承结构会抛出 TypeError。",
        },
        {
            id: "py-w8-3-q7",
            question: "Mixin 类应该有什么特点？",
            options: [
                "复杂的状态管理",
                "单一功能、不独立实例化",
                "很多基类",
                "不使用 super()",
            ],
            answer: 1,
            rationale: "Mixin 设计原则：单一功能、不独立实例化、方法应调用 super()。",
        },
        {
            id: "py-w8-3-q8",
            question: "以下哪个是好的 Mixin 命名？",
            options: [
                "Loggable",
                "LogMixin",
                "LogClass",
                "Logger",
            ],
            answer: 1,
            rationale: "Mixin 命名约定：以 Mixin 结尾，如 LogMixin、SerializerMixin。",
        },
        {
            id: "py-w8-3-q9",
            question: "在多继承中方法查找的顺序是什么？",
            options: [
                "按定义顺序",
                "严格按 MRO 顺序",
                "随机",
                "按方法名",
            ],
            answer: 1,
            rationale: "查找方法时严格按 MRO 顺序，第一个找到的方法被使用。",
        },
        {
            id: "py-w8-3-q10",
            question: "多继承的常见陷阱是什么？",
            options: [
                "太少基类",
                "__init__ 参数传递问题",
                "方法太少",
                "没有陷阱",
            ],
            answer: 1,
            rationale: "多继承陷阱包括：深层层次、有状态 Mixin、__init__ 参数传递问题。",
        },
        {
            id: "py-w8-3-q11",
            question: "class C(A, B) 和 class C(B, A) 的区别是什么？",
            options: [
                "没有区别",
                "MRO 不同，方法查找顺序不同",
                "只有性能区别",
                "会抛出错误",
            ],
            answer: 1,
            rationale: "基类顺序决定 MRO，不同顺序导致方法查找顺序不同。",
        },
        {
            id: "py-w8-3-q12",
            question: "Mixin 类通常应该如何调用方法？",
            options: [
                "不调用其他方法",
                "使用 super() 调用以保持协作链",
                "直接调用基类",
                "只调用自己的方法",
            ],
            answer: 1,
            rationale: "Mixin 方法应调用 super() 以确保多继承中的协作链不断裂。",
        },
    ],
    "py-w8-4": [
        {
            id: "py-w8-4-q1",
            question: "鸭子类型的核心原则是什么？",
            options: [
                "严格类型检查",
                "关注行为而非类型",
                "必须继承同一基类",
                "使用 isinstance 检查",
            ],
            answer: 1,
            rationale: "鸭子类型：'If it looks like a duck and quacks like a duck, it must be a duck。'",
        },
        {
            id: "py-w8-4-q2",
            question: "EAFP 是什么意思？",
            options: [
                "先检查后执行",
                "先执行后处理异常",
                "不处理异常",
                "总是检查类型",
            ],
            answer: 1,
            rationale: "EAFP：Easier to Ask for Forgiveness than Permission，先调用再用 try-except 处理。",
        },
        {
            id: "py-w8-4-q3",
            question: "如何定义抽象基类？",
            options: [
                "class MyABC: pass",
                "class MyABC(ABC): pass",
                "abstract class MyABC:",
                "interface MyABC:",
            ],
            answer: 1,
            rationale: "继承 ABC 类定义抽象基类：from abc import ABC; class MyABC(ABC): pass。",
        },
        {
            id: "py-w8-4-q4",
            question: "@abstractmethod 标记的方法有什么特点？",
            options: [
                "可以有实现，子类必须重写",
                "不能有实现",
                "子类可以不实现",
                "只能在普通类中使用",
            ],
            answer: 0,
            rationale: "抽象方法可以有实现，但子类必须重写所有抽象方法才能实例化。",
        },
        {
            id: "py-w8-4-q5",
            question: "抽象类可以直接实例化吗？",
            options: [
                "可以",
                "不可以，会抛出 TypeError",
                "取决于有多少抽象方法",
                "可以，但会警告",
            ],
            answer: 1,
            rationale: "有 @abstractmethod 的类不能直接实例化，会抛出 TypeError。",
        },
        {
            id: "py-w8-4-q6",
            question: "鸭子类型建议避免什么？",
            options: [
                "使用方法",
                "使用 type() 或 isinstance() 检查",
                "使用异常处理",
                "使用 hasattr()",
            ],
            answer: 1,
            rationale: "鸭子类型避免使用 type() 或 isinstance() 检查，关注行为而非类型。",
        },
        {
            id: "py-w8-4-q7",
            question: "ABC.register(cls) 的作用是什么？",
            options: [
                "让 cls 继承 ABC",
                "将 cls 注册为虚拟子类",
                "删除 cls",
                "检查 cls 类型",
            ],
            answer: 1,
            rationale: "register() 将类注册为虚拟子类，isinstance 返回 True 但不继承方法。",
        },
        {
            id: "py-w8-4-q8",
            question: "虚拟子类会出现在 MRO 中吗？",
            options: [
                "会",
                "不会",
                "取决于注册顺序",
                "只出现在末尾",
            ],
            answer: 1,
            rationale: "文档说明：虚拟子类不会出现在 MRO 中，无法调用注册 ABC 的方法实现。",
        },
        {
            id: "py-w8-4-q9",
            question: "Python 多态需要继承关系吗？",
            options: [
                "必须继承",
                "不需要，只要有相同方法即可",
                "必须是同一类型",
                "必须注册为虚拟子类",
            ],
            answer: 1,
            rationale: "Python 多态不需要继承关系，只要对象有相同的方法即可（鸭子类型）。",
        },
        {
            id: "py-w8-4-q10",
            question: "hasattr(obj, 'method') 的作用是什么？",
            options: [
                "调用 method",
                "检查 obj 是否有 method 属性",
                "删除 method",
                "创建 method",
            ],
            answer: 1,
            rationale: "hasattr() 检查对象是否有指定属性，是鸭子类型的中间方案。",
        },
        {
            id: "py-w8-4-q11",
            question: "__subclasshook__ 的作用是什么？",
            options: [
                "创建子类",
                "自定义 isinstance 和 issubclass 的行为",
                "删除子类",
                "列出所有子类",
            ],
            answer: 1,
            rationale: "__subclasshook__ 自定义子类检查，基于接口而非继承判断关系。",
        },
        {
            id: "py-w8-4-q12",
            question: "Protocol 和 ABC 的主要区别是什么？",
            options: [
                "没有区别",
                "Protocol 基于结构化子类型，不需要显式继承",
                "ABC 更灵活",
                "Protocol 必须继承",
            ],
            answer: 1,
            rationale: "Protocol 提供结构化子类型，基于对象的方法/属性而非继承关系判断类型。",
        },
    ],
}
