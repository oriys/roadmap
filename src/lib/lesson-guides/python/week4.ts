import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week4Guides: Record<string, LessonGuide> = {
    "py-w4-1": {
        lessonId: "py-w4-1",
        background: [
            "【列表定义】官方文档：Lists are mutable sequences, typically used to store collections of homogeneous items。列表用方括号创建：squares = [1, 4, 9, 16, 25]，可以包含不同类型的元素。",
            "【列表方法】列表提供丰富的方法：append(x) 在末尾添加元素、extend(iterable) 扩展列表、insert(i, x) 在指定位置插入、remove(x) 删除第一个匹配元素、pop([i]) 删除并返回元素。",
            "【就地修改】文档强调：Methods like insert, remove, sort modify the list in-place and return None。这些方法不返回新列表，而是直接修改原列表。",
            "【列表构造】创建列表的方式：[] 空列表、[a, b, c] 字面量、list() 从可迭代对象构造、[x for x in iterable] 列表推导式。",
            "【引用语义】列表赋值是引用而非拷贝：a = b = [1, 2, 3] 后 a 和 b 指向同一列表。使用 copy() 或切片 [:] 创建浅拷贝。",
        ],
        keyDifficulties: [
            "【append vs extend】append(x) 将 x 作为单个元素添加，extend(iterable) 将可迭代对象的所有元素添加。append([1,2]) 添加一个列表元素，extend([1,2]) 添加两个整数。",
            "【remove vs pop】remove(x) 删除第一个值等于 x 的元素，找不到抛出 ValueError；pop([i]) 删除指定索引的元素并返回，默认删除最后一个。",
            "【sort vs sorted】list.sort() 就地排序返回 None；sorted(list) 返回新排序列表不修改原列表。sort 只能用于列表，sorted 可用于任何可迭代对象。",
            "【浅拷贝陷阱】copy() 和 [:] 创建浅拷贝，嵌套列表中的内部列表仍是引用。深拷贝需要 copy.deepcopy()。",
        ],
        handsOnPath: [
            "1. 创建列表：numbers = [1, 2, 3, 4, 5]",
            "2. 使用 append 和 extend：numbers.append(6); numbers.extend([7, 8])",
            "3. 使用 insert：numbers.insert(0, 0)",
            "4. 使用 pop 和 remove：last = numbers.pop(); numbers.remove(1)",
            "5. 测试 sort 返回值：result = numbers.sort(); print(result)  # None",
            "6. 验证浅拷贝：a = [[1, 2], [3, 4]]; b = a.copy(); b[0].append(5); print(a)",
        ],
        selfCheck: [
            "append 和 extend 的区别是什么？",
            "为什么 list.sort() 返回 None？",
            "如何安全地获取列表的最后一个元素并删除它？",
            "copy() 创建的是深拷贝还是浅拷贝？",
            "如何检查一个元素是否在列表中？",
            "clear() 和 del list[:] 有什么区别？",
        ],
        extensions: [
            "学习 collections.deque 用于高效的双端队列操作",
            "了解 bisect 模块维护有序列表",
            "探索 array 模块存储同类型数据",
            "学习 heapq 模块实现优先队列",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/introduction.html#lists",
            "https://docs.python.org/3/tutorial/datastructures.html#more-on-lists",
            "https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range",
        ],
    },
    "py-w4-2": {
        lessonId: "py-w4-2",
        background: [
            "【列表推导式起源】PEP 202 于 2000 年引入列表推导式，作为 map()、filter() 和嵌套循环的更优雅替代。语法：[expression for item in iterable]。",
            "【基本语法】官方文档示例：squares = [x**2 for x in range(10)] 等价于 squares = list(map(lambda x: x**2, range(10)))，但更简洁易读。",
            "【条件过滤】支持 if 子句过滤：[x for x in range(20) if x % 2 == 0] 生成偶数列表。if 子句放在 for 后面。",
            "【嵌套推导式】可以包含多个 for 子句：[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y] 等价于嵌套 for 循环，外层 for 在左边。",
            "【元组语法】在推导式中创建元组需要括号：[(x, y) for x in range(3) for y in range(3)]，不加括号 [x, y for ...] 是语法错误。",
        ],
        keyDifficulties: [
            "【for 顺序】多个 for 子句的顺序与嵌套循环相同：[... for x in xs for y in ys] 等价于外层 for x，内层 for y。最右边的索引变化最快。",
            "【if 位置】条件 if 可以放在 for 后面过滤，也可以在表达式中使用三元运算符：[x if x > 0 else 0 for x in list]。",
            "【可读性权衡】复杂的嵌套推导式可能难以理解，超过两层嵌套时应考虑使用普通循环。PEP 8 建议保持推导式简洁。",
            "【生成器表达式】将 [] 改为 () 得到生成器表达式：(x**2 for x in range(10))，惰性求值，更节省内存。",
        ],
        handsOnPath: [
            "1. 基本推导式：squares = [x**2 for x in range(10)]",
            "2. 带条件过滤：evens = [x for x in range(20) if x % 2 == 0]",
            "3. 嵌套推导式：pairs = [(x, y) for x in range(3) for y in range(3)]",
            "4. 条件表达式：signs = ['pos' if x > 0 else 'neg' for x in [-1, 0, 1]]",
            "5. 扁平化嵌套列表：flat = [x for row in matrix for x in row]",
            "6. 对比生成器：gen = (x**2 for x in range(10)); print(sum(gen))",
        ],
        selfCheck: [
            "列表推导式 [x for x in range(10) if x % 2 == 0] 生成什么？",
            "多个 for 子句的执行顺序是什么？",
            "推导式中的 if 和三元运算符 if 有什么区别？",
            "什么时候应该使用生成器表达式而非列表推导式？",
            "如何用推导式创建字典或集合？",
            "推导式中可以调用函数吗？",
        ],
        extensions: [
            "学习字典推导式 {k: v for k, v in pairs}",
            "了解集合推导式 {x for x in iterable}",
            "探索生成器表达式的惰性求值特性",
            "学习 map、filter、reduce 函数式编程工具",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions",
            "https://docs.python.org/3/tutorial/datastructures.html#nested-list-comprehensions",
            "https://peps.python.org/pep-0202/",
        ],
    },
    "py-w4-3": {
        lessonId: "py-w4-3",
        background: [
            "【切片语法】序列支持切片操作：s[i:j:k] 获取从索引 i 到 j（不含）步长为 k 的元素。省略时 i 默认 0，j 默认 len(s)，k 默认 1。",
            "【负数索引】负数索引从末尾计数：s[-1] 是最后一个元素，s[-2] 是倒数第二个。s[-3:] 获取最后三个元素。",
            "【切片返回新对象】文档说明：All slice operations return a new list containing the requested elements。原序列不变，切片是浅拷贝。",
            "【切片赋值】列表支持切片赋值修改多个元素：a[2:5] = ['C', 'D', 'E']。可以用不同长度的序列替换，甚至用空列表删除。",
            "【slice 对象】内置 slice(start, stop, step) 创建切片对象，可重复使用：s = slice(1, 5, 2); a[s] 等价于 a[1:5:2]。",
        ],
        keyDifficulties: [
            "【边界理解】切片 s[i:j] 包含索引 i 不包含 j，便于计算长度 j-i 和拼接 s[:i] + s[i:] == s。超出边界的切片不会报错。",
            "【步长为负】步长为负时从右向左取：s[::-1] 反转序列。s[5:2:-1] 从索引 5 到 3（不含 2）。",
            "【切片赋值规则】扩展切片（带步长）赋值时，右侧长度必须匹配：a[::2] = [1, 2, 3] 需要替换的位置数与右侧元素数相同。",
            "【浅拷贝语义】a[:] 创建浅拷贝，但嵌套对象仍是引用。修改嵌套列表会影响原列表和拷贝。",
        ],
        handsOnPath: [
            "1. 基本切片：a = [0, 1, 2, 3, 4, 5]; print(a[2:5])",
            "2. 负数索引：print(a[-3:])  # 最后三个",
            "3. 步长切片：print(a[::2])  # 偶数位置",
            "4. 反转列表：print(a[::-1])",
            "5. 切片赋值：a[2:4] = ['x', 'y', 'z']; print(a)",
            "6. 删除元素：a[1:3] = []; print(a)",
        ],
        selfCheck: [
            "s[2:5] 包含哪些索引位置的元素？",
            "s[::-1] 的作用是什么？",
            "切片超出范围会报错吗？",
            "a[:] 和 a 有什么区别？",
            "如何用切片删除列表中间的元素？",
            "扩展切片赋值有什么限制？",
        ],
        extensions: [
            "学习 itertools.islice 用于迭代器切片",
            "了解 numpy 数组的高级切片功能",
            "探索 memoryview 对象的零拷贝切片",
            "学习自定义类的 __getitem__ 实现切片",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/stdtypes.html#common-sequence-operations",
            "https://docs.python.org/3/library/functions.html#slice",
            "https://docs.python.org/3/tutorial/introduction.html#lists",
        ],
    },
    "py-w4-4": {
        lessonId: "py-w4-4",
        background: [
            "【元组定义】官方文档：Tuples are immutable sequences, typically used to store collections of heterogeneous data。元组用圆括号创建，逗号是关键：(1,) 是元组，(1) 是整数。",
            "【元组特点】元组是不可变的，创建后不能修改。可以作为字典键（如果元素都可哈希）。支持所有序列操作但不支持修改操作。",
            "【解包赋值】Python 支持序列解包：a, b, c = [1, 2, 3]。元组解包最常用：x, y = (1, 2)。交换变量：a, b = b, a。",
            "【扩展解包】PEP 3132 引入星号表达式：first, *rest = [1, 2, 3, 4] 得到 first=1, rest=[2, 3, 4]。星号变量得到列表。",
            "【函数返回】函数返回多个值实际是返回元组：return x, y 返回 (x, y)。调用时可以解包：a, b = func()。",
        ],
        keyDifficulties: [
            "【单元素元组】创建单元素元组必须加逗号：(1,) 是元组，(1) 只是带括号的整数。这是常见错误来源。",
            "【解包数量匹配】普通解包时左右数量必须匹配，否则抛出 ValueError。使用 * 可以捕获剩余元素解决不匹配问题。",
            "【星号位置】每个赋值目标中最多一个星号表达式。星号可以在任意位置：*a, b, c = range(5) 或 a, *b, c = range(5)。",
            "【不可变但可变内容】元组本身不可变，但元组中的可变对象（如列表）可以修改：t = ([1, 2], 3); t[0].append(4) 是合法的。",
        ],
        handsOnPath: [
            "1. 创建元组：t = (1, 2, 3) 或 t = 1, 2, 3",
            "2. 单元素元组：single = (1,)  # 注意逗号",
            "3. 解包赋值：a, b, c = (1, 2, 3)",
            "4. 交换变量：a, b = b, a",
            "5. 扩展解包：first, *rest = [1, 2, 3, 4, 5]",
            "6. 中间解包：a, *middle, z = [1, 2, 3, 4, 5]",
        ],
        selfCheck: [
            "如何创建单元素元组？",
            "元组和列表的主要区别是什么？",
            "a, b = b, a 是如何实现变量交换的？",
            "星号表达式 *rest 得到的是什么类型？",
            "为什么元组可以作为字典的键而列表不行？",
            "元组中包含列表时，列表可以修改吗？",
        ],
        extensions: [
            "学习 collections.namedtuple 创建具名元组",
            "了解 typing.NamedTuple 用于类型注解",
            "探索 dataclasses 模块作为元组的替代",
            "学习 struct 模块处理 C 结构体数据",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences",
            "https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences",
            "https://peps.python.org/pep-3132/",
        ],
    },
}

export const week4Quizzes: Record<string, QuizQuestion[]> = {
    "py-w4-1": [
        {
            id: "py-w4-1-q1",
            question: "list.append(x) 和 list.extend(iterable) 的区别是什么？",
            options: [
                "append 添加多个元素，extend 添加单个元素",
                "append 将 x 作为单个元素添加，extend 将可迭代对象的所有元素添加",
                "两者功能相同",
                "append 修改原列表，extend 返回新列表",
            ],
            answer: 1,
            rationale: "文档说明：append(x) adds x as a single element; extend(iterable) appends all items from the iterable。",
        },
        {
            id: "py-w4-1-q2",
            question: "list.sort() 方法的返回值是什么？",
            options: [
                "排序后的新列表",
                "True 或 False",
                "None",
                "原列表的引用",
            ],
            answer: 2,
            rationale: "文档强调：Methods like insert, remove, sort modify the list in-place and return None。",
        },
        {
            id: "py-w4-1-q3",
            question: "list.remove(x) 找不到元素 x 时会怎样？",
            options: [
                "返回 None",
                "返回 -1",
                "抛出 ValueError",
                "静默忽略",
            ],
            answer: 2,
            rationale: "文档说明：remove(x) removes the first item equal to x. Raises ValueError if not found。",
        },
        {
            id: "py-w4-1-q4",
            question: "如何创建列表的浅拷贝？",
            options: [
                "b = a",
                "b = a.copy() 或 b = a[:]",
                "b = list(a)",
                "以上都正确",
            ],
            answer: 1,
            rationale: "b = a 只是创建引用，指向同一列表。copy() 和 [:] 创建浅拷贝，list(a) 也创建拷贝但通常用 copy()。",
        },
        {
            id: "py-w4-1-q5",
            question: "list.pop() 不带参数时删除哪个元素？",
            options: [
                "第一个元素",
                "最后一个元素",
                "随机元素",
                "抛出错误",
            ],
            answer: 1,
            rationale: "文档说明：pop([i]) removes and returns the item at index i. If no index is specified, removes and returns the last item。",
        },
        {
            id: "py-w4-1-q6",
            question: "以下哪个方法会返回一个值（而非 None）？",
            options: [
                "list.append(x)",
                "list.sort()",
                "list.pop()",
                "list.reverse()",
            ],
            answer: 2,
            rationale: "文档说明：pop() 是唯一返回值的方法，其他修改方法都返回 None。",
        },
        {
            id: "py-w4-1-q7",
            question: "list.insert(0, x) 的作用是什么？",
            options: [
                "在列表末尾添加 x",
                "在列表开头插入 x",
                "替换第一个元素为 x",
                "删除第一个元素",
            ],
            answer: 1,
            rationale: "文档说明：insert(i, x) inserts an item at a given position. insert(0, x) inserts at the front。",
        },
        {
            id: "py-w4-1-q8",
            question: "a = b = [1, 2, 3] 后修改 a.append(4)，b 会怎样？",
            options: [
                "b 不变，仍是 [1, 2, 3]",
                "b 也变成 [1, 2, 3, 4]",
                "抛出错误",
                "b 变成 None",
            ],
            answer: 1,
            rationale: "列表赋值是引用，a 和 b 指向同一个列表对象，修改一个会影响另一个。",
        },
        {
            id: "py-w4-1-q9",
            question: "list.count(x) 方法的作用是什么？",
            options: [
                "统计列表长度",
                "返回 x 在列表中出现的次数",
                "返回 x 的索引",
                "判断 x 是否在列表中",
            ],
            answer: 1,
            rationale: "文档说明：count(x) returns the number of times x appears in the list。",
        },
        {
            id: "py-w4-1-q10",
            question: "sort(reverse=True) 的作用是什么？",
            options: [
                "反转列表",
                "降序排序",
                "升序排序",
                "原地反转后排序",
            ],
            answer: 1,
            rationale: "文档示例：sort(reverse=True) 按降序排序列表。",
        },
        {
            id: "py-w4-1-q11",
            question: "list.clear() 等价于什么操作？",
            options: [
                "list = []",
                "del list",
                "del list[:]",
                "list.remove()",
            ],
            answer: 2,
            rationale: "文档说明：clear() removes all items from the list. Equivalent to del a[:]。",
        },
        {
            id: "py-w4-1-q12",
            question: "如何检查元素是否在列表中？",
            options: [
                "list.contains(x)",
                "list.has(x)",
                "x in list",
                "list.find(x) >= 0",
            ],
            answer: 2,
            rationale: "使用 in 运算符检查成员关系：x in list 返回 True 或 False。",
        },
    ],
    "py-w4-2": [
        {
            id: "py-w4-2-q1",
            question: "[x**2 for x in range(5)] 的结果是什么？",
            options: [
                "[1, 4, 9, 16, 25]",
                "[0, 1, 4, 9, 16]",
                "[0, 2, 4, 6, 8]",
                "[1, 2, 3, 4, 5]",
            ],
            answer: 1,
            rationale: "range(5) 生成 0-4，对每个数求平方得到 [0, 1, 4, 9, 16]。",
        },
        {
            id: "py-w4-2-q2",
            question: "[x for x in range(10) if x % 2 == 0] 生成什么？",
            options: [
                "[1, 3, 5, 7, 9]",
                "[0, 2, 4, 6, 8]",
                "[2, 4, 6, 8, 10]",
                "[0, 1, 2, 3, 4]",
            ],
            answer: 1,
            rationale: "if 子句过滤出偶数，结果是 [0, 2, 4, 6, 8]。",
        },
        {
            id: "py-w4-2-q3",
            question: "列表推导式中多个 for 的执行顺序是什么？",
            options: [
                "从右到左，右边的变化最快",
                "从左到右，右边的变化最快",
                "随机顺序",
                "同时执行",
            ],
            answer: 1,
            rationale: "PEP 202 规定：多个 for 子句从左到右嵌套，rightmost index varies fastest（最右边的索引变化最快）。",
        },
        {
            id: "py-w4-2-q4",
            question: "[(x, y) for x in [1,2] for y in [3,4]] 等价于什么循环结构？",
            options: [
                "for y in [3,4]: for x in [1,2]:",
                "for x in [1,2]: for y in [3,4]:",
                "同时遍历两个列表",
                "zip([1,2], [3,4])",
            ],
            answer: 1,
            rationale: "左边的 for 是外层循环，右边的是内层循环，等价于嵌套 for x: for y:。",
        },
        {
            id: "py-w4-2-q5",
            question: "在推导式中创建元组需要注意什么？",
            options: [
                "不需要括号",
                "需要显式括号：[(x, y) for ...]",
                "使用花括号",
                "使用 tuple(x, y)",
            ],
            answer: 1,
            rationale: "PEP 202 规定：元组需要显式括号 [(x, y) for ...] 而非 [x, y for ...]。",
        },
        {
            id: "py-w4-2-q6",
            question: "(x**2 for x in range(10)) 创建什么对象？",
            options: [
                "列表",
                "元组",
                "生成器",
                "集合",
            ],
            answer: 2,
            rationale: "圆括号创建生成器表达式，惰性求值，不立即生成所有元素。",
        },
        {
            id: "py-w4-2-q7",
            question: "[x if x > 0 else 0 for x in [-1, 0, 1]] 的结果是？",
            options: [
                "[-1, 0, 1]",
                "[0, 0, 1]",
                "[1]",
                "[0, 1]",
            ],
            answer: 1,
            rationale: "条件表达式在推导式表达式部分，负数变 0，结果是 [0, 0, 1]。",
        },
        {
            id: "py-w4-2-q8",
            question: "如何用推导式创建字典？",
            options: [
                "[k: v for k, v in pairs]",
                "{k: v for k, v in pairs}",
                "dict([k, v] for k, v in pairs)",
                "{{k, v} for k, v in pairs}",
            ],
            answer: 1,
            rationale: "字典推导式使用花括号和冒号：{k: v for k, v in pairs}。",
        },
        {
            id: "py-w4-2-q9",
            question: "以下哪个不是有效的推导式？",
            options: [
                "[x for x in range(10)]",
                "{x for x in range(10)}",
                "{k: v for k, v in items}",
                "(x for x in range(10))",
            ],
            answer: 3,
            rationale: "选项 D 是生成器表达式，不是推导式。列表用 []，集合用 {}，字典用 {k:v}。",
        },
        {
            id: "py-w4-2-q10",
            question: "[x for row in matrix for x in row] 的作用是什么？",
            options: [
                "转置矩阵",
                "扁平化嵌套列表",
                "复制矩阵",
                "计算矩阵和",
            ],
            answer: 1,
            rationale: "双重 for 循环遍历每行的每个元素，将嵌套列表扁平化为一维列表。",
        },
        {
            id: "py-w4-2-q11",
            question: "列表推导式 PEP 202 是在哪个 Python 版本引入的？",
            options: [
                "Python 1.5",
                "Python 2.0",
                "Python 2.7",
                "Python 3.0",
            ],
            answer: 1,
            rationale: "PEP 202 于 2000 年引入，随 Python 2.0 发布。",
        },
        {
            id: "py-w4-2-q12",
            question: "什么时候应该使用普通循环而非列表推导式？",
            options: [
                "创建简单列表时",
                "需要过滤元素时",
                "逻辑复杂、嵌套过深时",
                "任何时候都应该用推导式",
            ],
            answer: 2,
            rationale: "PEP 8 建议保持推导式简洁，复杂逻辑应使用普通循环以提高可读性。",
        },
    ],
    "py-w4-3": [
        {
            id: "py-w4-3-q1",
            question: "s[2:5] 包含哪些索引位置的元素？",
            options: [
                "索引 2, 3, 4, 5",
                "索引 2, 3, 4",
                "索引 3, 4, 5",
                "索引 2, 3",
            ],
            answer: 1,
            rationale: "切片 s[i:j] 包含索引 i 到 j-1，即 s[2:5] 包含索引 2, 3, 4。",
        },
        {
            id: "py-w4-3-q2",
            question: "s[-1] 表示什么？",
            options: [
                "第一个元素",
                "最后一个元素",
                "倒数第二个元素",
                "IndexError",
            ],
            answer: 1,
            rationale: "负数索引从末尾计数，-1 是最后一个元素，-2 是倒数第二个。",
        },
        {
            id: "py-w4-3-q3",
            question: "s[::-1] 的作用是什么？",
            options: [
                "返回空列表",
                "返回原列表",
                "返回反转的列表",
                "抛出错误",
            ],
            answer: 2,
            rationale: "步长为 -1 时从右向左取元素，s[::-1] 反转整个序列。",
        },
        {
            id: "py-w4-3-q4",
            question: "切片 s[10:100] 在长度为 5 的列表上会怎样？",
            options: [
                "抛出 IndexError",
                "返回空列表",
                "返回 s[10:5]",
                "返回整个列表",
            ],
            answer: 1,
            rationale: "切片超出范围不会报错，而是优雅地返回可用元素。起始位置超出长度时返回空列表。",
        },
        {
            id: "py-w4-3-q5",
            question: "a[:] 和 a 有什么区别？",
            options: [
                "完全相同",
                "a[:] 是浅拷贝，a 是引用",
                "a[:] 是深拷贝，a 是引用",
                "a[:] 返回元组",
            ],
            answer: 1,
            rationale: "文档说明：All slice operations return a new list containing the requested elements。a[:] 创建浅拷贝。",
        },
        {
            id: "py-w4-3-q6",
            question: "切片赋值 a[2:4] = [] 的作用是什么？",
            options: [
                "在位置 2-3 插入空列表",
                "删除索引 2 和 3 的元素",
                "抛出错误",
                "清空整个列表",
            ],
            answer: 1,
            rationale: "用空列表替换切片会删除对应元素，a[2:4] = [] 删除索引 2 和 3 的元素。",
        },
        {
            id: "py-w4-3-q7",
            question: "s[::2] 的作用是什么？",
            options: [
                "取前两个元素",
                "取每隔一个元素（偶数索引）",
                "取后两个元素",
                "取所有元素的两倍",
            ],
            answer: 1,
            rationale: "步长为 2 时每隔一个元素取一个，s[::2] 取索引 0, 2, 4... 的元素。",
        },
        {
            id: "py-w4-3-q8",
            question: "slice(1, 5, 2) 对象的属性是什么？",
            options: [
                "start=0, stop=5, step=2",
                "start=1, stop=5, step=2",
                "start=1, stop=4, step=2",
                "start=1, stop=5, step=1",
            ],
            answer: 1,
            rationale: "slice(start, stop, step) 创建切片对象，属性值与参数相同：start=1, stop=5, step=2。",
        },
        {
            id: "py-w4-3-q9",
            question: "扩展切片赋值 a[::2] = [1, 2, 3] 有什么要求？",
            options: [
                "右侧可以是任意长度",
                "右侧长度必须匹配被替换的位置数",
                "只能赋值相同类型",
                "不支持扩展切片赋值",
            ],
            answer: 1,
            rationale: "扩展切片（带步长）赋值时，右侧序列的长度必须与被替换位置的数量相等。",
        },
        {
            id: "py-w4-3-q10",
            question: "s[5:2:-1] 取哪些索引的元素？",
            options: [
                "索引 2, 3, 4, 5",
                "索引 5, 4, 3",
                "索引 3, 4, 5",
                "空序列",
            ],
            answer: 1,
            rationale: "步长为负时从大索引到小索引，s[5:2:-1] 取索引 5, 4, 3（不含 2）。",
        },
        {
            id: "py-w4-3-q11",
            question: "如何获取列表的最后三个元素？",
            options: [
                "s[3:]",
                "s[-3:]",
                "s[:-3]",
                "s[:3]",
            ],
            answer: 1,
            rationale: "s[-3:] 从倒数第三个元素开始到末尾，获取最后三个元素。",
        },
        {
            id: "py-w4-3-q12",
            question: "Python 3.12 中 slice 对象有什么新特性？",
            options: [
                "支持负数步长",
                "可以作为字典键（可哈希）",
                "支持浮点数索引",
                "自动类型转换",
            ],
            answer: 1,
            rationale: "文档说明：Changed in version 3.12: Slice objects are now hashable（前提是 start, stop, step 都可哈希）。",
        },
    ],
    "py-w4-4": [
        {
            id: "py-w4-4-q1",
            question: "如何创建单元素元组？",
            options: [
                "(1)",
                "(1,)",
                "tuple(1)",
                "[1]",
            ],
            answer: 1,
            rationale: "文档说明：单元素元组需要逗号：(a,)。(1) 只是带括号的整数，不是元组。",
        },
        {
            id: "py-w4-4-q2",
            question: "元组和列表的主要区别是什么？",
            options: [
                "元组更快",
                "元组是不可变的",
                "元组只能存储数字",
                "元组不能嵌套",
            ],
            answer: 1,
            rationale: "文档定义：Tuples are immutable sequences。这是元组与列表的核心区别。",
        },
        {
            id: "py-w4-4-q3",
            question: "a, b = b, a 实现什么功能？",
            options: [
                "创建两个新变量",
                "交换 a 和 b 的值",
                "复制 b 到 a",
                "删除 a 和 b",
            ],
            answer: 1,
            rationale: "这是 Python 的多重赋值语法，右侧先打包成元组 (b, a)，再解包赋值给左侧，实现变量交换。",
        },
        {
            id: "py-w4-4-q4",
            question: "first, *rest = [1, 2, 3, 4] 后 rest 是什么？",
            options: [
                "(2, 3, 4)",
                "[2, 3, 4]",
                "2, 3, 4",
                "{2, 3, 4}",
            ],
            answer: 1,
            rationale: "PEP 3132 规定：星号变量总是得到列表，即使原序列是元组。",
        },
        {
            id: "py-w4-4-q5",
            question: "为什么元组可以作为字典键而列表不行？",
            options: [
                "元组更小",
                "元组是不可变的，可哈希",
                "列表太长",
                "Python 限制",
            ],
            answer: 1,
            rationale: "字典键必须是可哈希的。元组不可变所以可哈希（如果元素都可哈希），列表可变所以不可哈希。",
        },
        {
            id: "py-w4-4-q6",
            question: "每个赋值目标中最多可以有几个星号表达式？",
            options: [
                "无限制",
                "最多一个",
                "最多两个",
                "不允许星号表达式",
            ],
            answer: 1,
            rationale: "PEP 3132 规定：A tuple (or list) on the left side of a simple assignment may contain at most one starred expression。",
        },
        {
            id: "py-w4-4-q7",
            question: "t = ([1, 2], 3); t[0].append(4) 会怎样？",
            options: [
                "抛出 TypeError",
                "成功，t 变成 ([1, 2, 4], 3)",
                "创建新元组",
                "t[0] 变成 None",
            ],
            answer: 1,
            rationale: "元组本身不可变，但其中的可变对象（列表）可以修改。t[0] 是列表，可以 append。",
        },
        {
            id: "py-w4-4-q8",
            question: "*a, = range(5) 是什么意思？",
            options: [
                "语法错误",
                "a = [0, 1, 2, 3, 4]",
                "a = (0, 1, 2, 3, 4)",
                "a = range(5)",
            ],
            answer: 1,
            rationale: "PEP 3132 示例：*a, = range(5) 是有效的，逗号创建单元素元组目标，a 得到整个 range 转换为列表。",
        },
        {
            id: "py-w4-4-q9",
            question: "函数 return x, y 实际返回什么？",
            options: [
                "两个独立的值",
                "一个包含 x 和 y 的元组",
                "一个列表",
                "一个字典",
            ],
            answer: 1,
            rationale: "return x, y 等价于 return (x, y)，返回一个元组。逗号创建元组，括号是可选的。",
        },
        {
            id: "py-w4-4-q10",
            question: "a, b, c = [1, 2] 会怎样？",
            options: [
                "c = None",
                "c = 0",
                "抛出 ValueError",
                "只赋值 a 和 b",
            ],
            answer: 2,
            rationale: "解包时左右数量必须匹配，否则抛出 ValueError: not enough values to unpack。",
        },
        {
            id: "py-w4-4-q11",
            question: "PEP 3132 是在哪个 Python 版本引入的？",
            options: [
                "Python 2.7",
                "Python 3.0",
                "Python 3.5",
                "Python 3.8",
            ],
            answer: 1,
            rationale: "PEP 3132 Extended Iterable Unpacking 随 Python 3.0 发布。",
        },
        {
            id: "py-w4-4-q12",
            question: "a, *b, c = range(5) 后各变量的值是什么？",
            options: [
                "a=0, b=[1,2,3], c=4",
                "a=0, b=(1,2,3), c=4",
                "a=[0], b=[1,2,3], c=[4]",
                "抛出错误",
            ],
            answer: 0,
            rationale: "a 得到第一个元素 0，c 得到最后一个元素 4，*b 捕获中间元素作为列表 [1, 2, 3]。",
        },
    ],
}
