import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week2Guides: Record<string, LessonGuide> = {
    "py-w2-1": {
        lessonId: "py-w2-1",
        background: [
            "【对象三要素】Python 数据模型定义：'Every piece of data in Python is represented by objects'。每个对象有三个属性：identity（通过 id() 获取，CPython 中是内存地址）、type（通过 type() 获取，决定支持的操作）、value（可能是可变或不可变的）。",
            "【可变与不可变】不可变对象（int、str、tuple）的值创建后不能改变；可变对象（list、dict、set）可以修改。关键区别：'Immutability applies to the object itself, not nested references'——元组包含列表时，列表的内容可以改变。",
            "【命名约定】PEP 8 规定：类名使用 CapWords（驼峰），函数和变量使用 lowercase_with_underscores（蛇形），常量使用 ALL_CAPS。避免使用单字母 l、O、I 作为变量名（容易与 1 和 0 混淆）。",
            "【类型层次】Python 类型层次：None、数值类型（int、float、complex、bool）、序列类型（str、tuple、list、bytes）、集合类型（set、frozenset）、映射类型（dict）。bool 是 int 的子类，True 和 False 分别等于 1 和 0。",
            "【引用语义】Python 变量是对象的引用而非容器：'a = b' 让 a 和 b 指向同一对象。使用 is 测试对象身份（同一对象），使用 == 测试值相等。",
        ],
        keyDifficulties: [
            "【身份 vs 相等】初学者常混淆 is 和 ==：'is' tests object identity; '==' tests value equality。对于小整数和字符串，Python 可能复用对象，导致 'a is b' 意外为 True，但这是实现细节，不应依赖。",
            "【可变默认参数陷阱】在函数定义中使用可变对象作为默认参数是常见错误，因为默认值只创建一次，会在调用间共享。应使用 None 作为默认值，在函数内部创建新对象。",
            "【浅拷贝 vs 深拷贝】列表切片 list[:] 和 copy() 创建浅拷贝，只复制顶层引用。嵌套可变对象需要 copy.deepcopy() 进行深拷贝。",
            "【命名空间理解】PEP 8 强调：'Code is read much more often than it is written'。一致的命名比严格遵守指南更重要，但在项目内应保持风格统一。",
        ],
        handsOnPath: [
            "1. 打开 Python 交互模式，创建变量 x = 42，使用 type(x) 和 id(x) 查看类型和标识",
            "2. 创建 a = [1, 2, 3] 和 b = a，修改 a.append(4)，观察 b 的变化",
            "3. 创建 c = a[:] 浅拷贝，修改 c.append(5)，观察 a 是否改变",
            "4. 测试身份：x = 256; y = 256; print(x is y)，再测试 x = 257; y = 257; print(x is y)",
            "5. 创建包含列表的元组 t = ([1, 2], 3)，尝试 t[0].append(4)，观察结果",
            "6. 编写符合 PEP 8 的代码：变量用 snake_case，类用 CamelCase，常量用 ALL_CAPS",
        ],
        selfCheck: [
            "type() 和 id() 分别返回对象的什么属性？",
            "为什么说 Python 变量是引用而非容器？",
            "可变对象和不可变对象的核心区别是什么？",
            "is 和 == 的区别是什么？什么时候应该用 is？",
            "PEP 8 对函数名和类名的命名约定分别是什么？",
            "为什么不应该使用可变对象作为函数的默认参数？",
        ],
        extensions: [
            "学习 copy 模块的 copy() 和 deepcopy() 函数",
            "了解 Python 的引用计数和垃圾回收机制",
            "探索 __slots__ 优化内存使用",
            "阅读 PEP 8 完整版了解更多代码风格建议",
        ],
        sourceUrls: [
            "https://docs.python.org/3/reference/datamodel.html",
            "https://peps.python.org/pep-0008/",
            "https://docs.python.org/3/library/stdtypes.html",
        ],
    },
    "py-w2-2": {
        lessonId: "py-w2-2",
        background: [
            "【整数无限精度】Python 整数具有'unlimited precision'，不像 C/Java 有 32 位或 64 位限制。可以计算任意大的数，如 2**1000。这是 Python 动态类型的体现。",
            "【数值运算符】基本运算：+ 加、- 减、* 乘、/ 除（总是返回浮点数）、// 整除（向负无穷方向舍入）、% 取模、** 幂。注意 (-1) // 2 = -1 而非 0。",
            "【浮点数精度】float 使用 C 的 double 实现，有精度限制。1.1 + 2.2 可能得到 3.3000000000000003 而非精确的 3.3。金融计算应使用 decimal.Decimal。",
            "【Decimal 优势】decimal 模块提供精确十进制运算：'Decimal(\"1.1\") + Decimal(\"2.2\")' 精确等于 Decimal(\"3.3\")。支持用户可调精度（默认 28 位）、8 种舍入模式、线程安全。",
            "【math 模块】math 模块提供数学函数：sqrt()、ceil()、floor()、trunc()、log()、exp()、sin()、cos() 等，以及常量 pi、e、tau、inf、nan。不支持复数，复数用 cmath。",
        ],
        keyDifficulties: [
            "【整除 vs 真除】/ 总是返回 float（即使能整除），// 返回整数（对 int 操作）或 float（对 float 操作）。// 向负无穷舍入：-7 // 2 = -4（不是 -3）。",
            "【浮点比较陷阱】不要用 == 比较浮点数，应使用 math.isclose(a, b) 或设置容差。0.1 + 0.2 == 0.3 返回 False！",
            "【round() 行为】Python 3 的 round() 使用'四舍五入到偶数'（银行家舍入）：round(2.5) = 2，round(3.5) = 4。这避免了统计偏差。",
            "【Decimal 创建方式】应使用字符串创建 Decimal：Decimal('0.1') 而非 Decimal(0.1)，后者会保留 float 的精度误差。",
        ],
        handsOnPath: [
            "1. 计算大整数：print(2 ** 1000)，观察 Python 处理任意大整数的能力",
            "2. 测试整除和取模：print(17 // 5, 17 % 5)，再测试负数 print(-17 // 5)",
            "3. 验证浮点精度问题：print(0.1 + 0.2)，对比 print(0.1 + 0.2 == 0.3)",
            "4. 使用 Decimal 精确计算：from decimal import Decimal; print(Decimal('0.1') + Decimal('0.2'))",
            "5. 测试 round() 的银行家舍入：print(round(2.5), round(3.5))",
            "6. 使用 math 函数：import math; print(math.sqrt(2), math.pi, math.ceil(3.2))",
        ],
        selfCheck: [
            "Python 整数有大小限制吗？",
            "/ 和 // 的区别是什么？-7 // 2 的结果是多少？",
            "为什么 0.1 + 0.2 不精确等于 0.3？",
            "什么时候应该使用 decimal.Decimal？",
            "round(2.5) 在 Python 3 中返回什么？为什么？",
            "math.isclose() 函数的作用是什么？",
        ],
        extensions: [
            "学习 fractions 模块进行分数运算",
            "了解 IEEE 754 浮点数标准",
            "探索 numpy 的数值计算能力",
            "学习 decimal 模块的 Context 配置精度和舍入模式",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/stdtypes.html#numeric-types-int-float-complex",
            "https://docs.python.org/3/library/decimal.html",
            "https://docs.python.org/3/library/math.html",
        ],
    },
    "py-w2-3": {
        lessonId: "py-w2-3",
        background: [
            "【字符串不可变】Python 字符串是不可变序列：'Python strings are immutable'。尝试 s[0] = 'x' 会抛出 TypeError。修改字符串需要创建新对象，如 'J' + word[1:]。",
            "【创建方式】字符串可用单引号 'spam' 或双引号 \"spam\"（效果相同）、三引号 '''...''' 或 \"\"\"...\"\"\" 创建多行字符串、原始字符串 r'C:\\path' 禁用转义。",
            "【索引和切片】正向索引从 0 开始，负向索引从 -1 开始（最后一个字符）。切片 s[start:end] 包含 start 不包含 end。切片超出范围会被优雅处理。",
            "【f-string 格式化】Python 3.6+ 推荐使用 f-string：f'Value: {x:.2f}' 嵌入表达式。支持格式说明符（.2f、10d）、转换标志（!r、!s、!a）、自文档化（{x=}）。",
            "【常用方法】字符串方法分类：查找替换（find、replace）、分割连接（split、join）、大小写转换（upper、lower、title）、去空白（strip）、检查类型（isalpha、isdigit）。",
        ],
        keyDifficulties: [
            "【切片边界】切片 s[i:j] 包含 i 不包含 j，便于计算长度（j-i）和拼接（s[:i] + s[i:] == s）。s[::2] 表示步长为 2，s[::-1] 反转字符串。",
            "【join vs + 连接】用 + 连接字符串在循环中效率低（每次创建新对象），应使用 ''.join(list) 一次性连接。这是性能优化的关键点。",
            "【格式化方式选择】三种格式化方式：f-string（推荐，最直观）、str.format()（兼容旧版本）、% 操作符（已过时）。f-string 在编译时解析，效率最高。",
            "【编码问题】Python 3 字符串是 Unicode（str），字节序列是 bytes。encode() 转为字节，decode() 转为字符串。处理文件 I/O 时要注意编码。",
        ],
        handsOnPath: [
            "1. 测试字符串不可变性：s = 'Python'; s[0] = 'J' 观察错误",
            "2. 练习切片：word = 'Python'; print(word[0:2], word[2:], word[-2:])",
            "3. 尝试反转字符串：print('hello'[::-1])",
            "4. 使用 f-string 格式化：x = 3.14159; print(f'Pi is approximately {x:.2f}')",
            "5. 测试字符串方法：s = '  Hello World  '; print(s.strip().lower().split())",
            "6. 使用 join 高效连接：words = ['Hello', 'World']; print(' '.join(words))",
        ],
        selfCheck: [
            "为什么 Python 字符串是不可变的？这有什么好处？",
            "s[2:5] 包含哪些索引位置的字符？",
            "如何反转一个字符串？",
            "f-string 相比 % 格式化有什么优势？",
            "split() 和 join() 是什么关系？",
            "strip()、lstrip()、rstrip() 的区别是什么？",
        ],
        extensions: [
            "学习正则表达式 re 模块进行复杂字符串匹配",
            "了解 Unicode 和字符编码（UTF-8、ASCII）",
            "探索 textwrap 模块格式化长文本",
            "学习 string 模块的模板字符串",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/stdtypes.html#string-methods",
            "https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals",
            "https://docs.python.org/3/tutorial/introduction.html#strings",
        ],
    },
    "py-w2-4": {
        lessonId: "py-w2-4",
        background: [
            "【bool 类型】bool 是 int 的子类，只有 True 和 False 两个值，分别等于 1 和 0。可以参与数值运算：True + True = 2。这是历史设计决定。",
            "【假值列表】文档明确列出被认为是假的对象：None 和 False、零值（0, 0.0, 0j, Decimal(0), Fraction(0,1)）、空序列和集合（'', (), [], {}, set(), range(0)）。",
            "【短路求值】and 和 or 是短路运算符：or 返回第一个真值或最后一个值；and 返回第一个假值或最后一个值。它们返回操作数本身而非布尔值。",
            "【None 语义】None 是唯一的 NoneType 对象，表示'无值'或'缺失'。函数无显式返回时返回 None。检查 None 应使用 is None 而非 == None。",
            "【比较运算符】8 种比较运算优先级相同：<, <=, >, >=, ==, !=, is, is not。支持链式比较：x < y <= z 等价于 x < y and y <= z（y 只求值一次）。",
        ],
        keyDifficulties: [
            "【is vs == 对 None】检查 None 必须用 is None，因为 == 可能被类重写。PEP 8 明确要求：'Comparisons to singletons like None should always be done with is or is not'。",
            "【短路求值陷阱】5 or 3 返回 5（不是 True），0 and 5 返回 0（不是 False）。理解返回值是操作数本身很重要，特别是在 x = a or b 这种模式中。",
            "【not 优先级】not 的优先级低于比较运算符：not a == b 解释为 not (a == b) 而非 (not a) == b。写 a == not b 是语法错误。",
            "【自定义真值】类可以通过 __bool__() 或 __len__() 定义真值。__bool__() 返回 False 或 __len__() 返回 0 时对象为假。",
        ],
        handsOnPath: [
            "1. 验证 bool 是 int 子类：print(isinstance(True, int), True + True)",
            "2. 测试假值：for x in [None, False, 0, '', [], {}]: print(f'{x!r} is {bool(x)}')",
            "3. 理解短路求值：print(5 or 3, 0 or 3, 5 and 3, 0 and 3)",
            "4. 比较 is 和 ==：a = None; print(a is None, a == None)",
            "5. 测试链式比较：x = 5; print(1 < x < 10, 1 < x and x < 10)",
            "6. 创建自定义类并定义 __bool__：class MyBool: def __bool__(self): return False",
        ],
        selfCheck: [
            "bool 类型和 int 类型有什么关系？",
            "哪些内置对象在布尔上下文中为假？",
            "5 or 3 返回什么？为什么？",
            "为什么应该用 is None 而不是 == None？",
            "链式比较 1 < x < 10 是如何工作的？",
            "如何让自定义类的实例在布尔上下文中为假？",
        ],
        extensions: [
            "学习 operator 模块的比较函数",
            "了解 functools.total_ordering 简化比较方法实现",
            "探索 any() 和 all() 函数与布尔运算的关系",
            "学习 Python 的三值比较协议（__eq__, __lt__ 等）",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not",
            "https://docs.python.org/3/library/stdtypes.html#truth-value-testing",
            "https://docs.python.org/3/library/stdtypes.html#comparisons",
        ],
    },
}

export const week2Quizzes: Record<string, QuizQuestion[]> = {
    "py-w2-1": [
        {
            id: "py-w2-1-q1",
            question: "Python 数据模型中，每个对象有哪三个属性？",
            options: [
                "name, value, type",
                "identity, type, value",
                "id, class, data",
                "reference, content, kind",
            ],
            answer: 1,
            rationale: "官方文档明确：Each object has three properties: identity, type, value。",
        },
        {
            id: "py-w2-1-q2",
            question: "关于可变和不可变对象，以下哪项是正确的？",
            options: [
                "元组是可变的",
                "列表是不可变的",
                "元组包含列表时，列表内容仍可修改",
                "字符串是可变的",
            ],
            answer: 2,
            rationale: "文档说明：'Immutability applies to the object itself, not nested references'——元组本身不可变，但其中的可变对象可以修改。",
        },
        {
            id: "py-w2-1-q3",
            question: "根据 PEP 8，函数名应该使用什么命名风格？",
            options: [
                "CamelCase",
                "lowercase_with_underscores",
                "ALL_CAPS",
                "mixedCase",
            ],
            answer: 1,
            rationale: "PEP 8 规定：Functions & Variables 使用 lowercase with underscores (snake_case)。",
        },
        {
            id: "py-w2-1-q4",
            question: "is 和 == 的区别是什么？",
            options: [
                "is 比较值，== 比较类型",
                "is 比较对象身份，== 比较值是否相等",
                "两者完全相同",
                "is 用于数字，== 用于字符串",
            ],
            answer: 1,
            rationale: "文档说明：'is' tests object identity; '==' tests value equality。",
        },
        {
            id: "py-w2-1-q5",
            question: "bool 类型在 Python 类型层次中的位置是？",
            options: [
                "bool 是独立类型",
                "bool 是 int 的子类",
                "bool 是 str 的子类",
                "bool 是 object 的直接子类",
            ],
            answer: 1,
            rationale: "文档明确：bool - subtype of int, values 0 and 1。",
        },
        {
            id: "py-w2-1-q6",
            question: "在 CPython 中，id() 函数返回的是什么？",
            options: [
                "对象的哈希值",
                "对象的内存地址",
                "对象的类型编号",
                "对象的引用计数",
            ],
            answer: 1,
            rationale: "文档说明：In CPython, this is the memory address。",
        },
        {
            id: "py-w2-1-q7",
            question: "PEP 8 建议避免使用哪些单字符作为变量名？",
            options: [
                "a, b, c",
                "x, y, z",
                "l, O, I",
                "m, n, p",
            ],
            answer: 2,
            rationale: "PEP 8：'Avoid: Single letters l, O, or I as variable names (confusing with 1 and 0)'。",
        },
        {
            id: "py-w2-1-q8",
            question: "关于 Python 字典，以下哪项是正确的？",
            options: [
                "字典是不可变的",
                "Python 3.7+ 字典保持插入顺序",
                "字典不能作为其他字典的值",
                "字典的键可以是列表",
            ],
            answer: 1,
            rationale: "文档说明：dict - finite indexed objects (insertion-ordered since 3.7)。",
        },
        {
            id: "py-w2-1-q9",
            question: "以下哪种类型可以作为字典的键？",
            options: [
                "list",
                "dict",
                "tuple",
                "set",
            ],
            answer: 2,
            rationale: "文档说明：Immutable types (int, str, tuple) 是可哈希的，可作为字典键。Mutable types 不能作为键。",
        },
        {
            id: "py-w2-1-q10",
            question: "PEP 8 中关于代码风格一致性的核心原则是什么？",
            options: [
                "必须严格遵守所有规则",
                "项目内一致性比遵守指南更重要",
                "每个文件可以有不同风格",
                "风格不重要，功能正确即可",
            ],
            answer: 1,
            rationale: "PEP 8：'Code is read much more often than it is written.' Consistency within your project matters more than strict adherence。",
        },
        {
            id: "py-w2-1-q11",
            question: "a = [1, 2, 3]; b = a 后，a 和 b 的关系是？",
            options: [
                "a 和 b 是完全独立的副本",
                "a 和 b 指向同一个对象",
                "b 是 a 的浅拷贝",
                "b 是 a 的深拷贝",
            ],
            answer: 1,
            rationale: "Python 变量是对象引用，赋值语句让两个变量指向同一对象，修改其中一个会影响另一个。",
        },
        {
            id: "py-w2-1-q12",
            question: "frozenset 与 set 的主要区别是？",
            options: [
                "frozenset 更快",
                "frozenset 是不可变的，可以作为字典键",
                "frozenset 只能包含数字",
                "frozenset 是有序的",
            ],
            answer: 1,
            rationale: "文档说明：frozenset - immutable, hashable。而 set 是可变的，不可哈希。",
        },
    ],
    "py-w2-2": [
        {
            id: "py-w2-2-q1",
            question: "Python 整数的精度是？",
            options: [
                "32 位",
                "64 位",
                "无限精度",
                "128 位",
            ],
            answer: 2,
            rationale: "文档明确：Python integers have 'unlimited precision'。",
        },
        {
            id: "py-w2-2-q2",
            question: "(-7) // 2 的结果是？",
            options: [
                "-3",
                "-4",
                "-3.5",
                "3",
            ],
            answer: 1,
            rationale: "文档说明：// 是整除，向负无穷方向舍入。-7 // 2 = -4（不是 -3）。",
        },
        {
            id: "py-w2-2-q3",
            question: "为什么 0.1 + 0.2 != 0.3？",
            options: [
                "Python 的 bug",
                "浮点数使用二进制表示，无法精确表示某些十进制小数",
                "需要导入 math 模块",
                "这是 Python 2 的问题，Python 3 已修复",
            ],
            answer: 1,
            rationale: "文档说明浮点数有精度限制：1.1 + 2.2 可能得到 3.3000000000000003。",
        },
        {
            id: "py-w2-2-q4",
            question: "创建精确的 Decimal 对象应该使用什么方式？",
            options: [
                "Decimal(0.1)",
                "Decimal('0.1')",
                "decimal(0.1)",
                "Decimal.from_float(0.1)",
            ],
            answer: 1,
            rationale: "文档推荐使用字符串创建：Decimal('0.1')，而非 Decimal(0.1) 后者会保留 float 的精度误差。",
        },
        {
            id: "py-w2-2-q5",
            question: "round(2.5) 在 Python 3 中返回什么？",
            options: [
                "2",
                "3",
                "2.5",
                "2.0",
            ],
            answer: 0,
            rationale: "Python 3 使用银行家舍入（四舍五入到偶数）：round(2.5) = 2，round(3.5) = 4。",
        },
        {
            id: "py-w2-2-q6",
            question: "以下哪个 math 函数用于向上取整？",
            options: [
                "math.floor()",
                "math.ceil()",
                "math.trunc()",
                "math.round()",
            ],
            answer: 1,
            rationale: "文档说明：ceil(x) 向上取整，floor(x) 向下取整，trunc(x) 截断小数部分。",
        },
        {
            id: "py-w2-2-q7",
            question: "7 / 2 的结果类型是？",
            options: [
                "int",
                "float",
                "Decimal",
                "取决于 Python 版本",
            ],
            answer: 1,
            rationale: "文档说明：/ 是真除法，总是返回 float（即使能整除）。",
        },
        {
            id: "py-w2-2-q8",
            question: "decimal 模块的默认精度是多少位？",
            options: [
                "10 位",
                "16 位",
                "28 位",
                "无限",
            ],
            answer: 2,
            rationale: "文档说明：用户可调精度（默认 28 位）。",
        },
        {
            id: "py-w2-2-q9",
            question: "math.sqrt(-1) 会发生什么？",
            options: [
                "返回 1j",
                "返回 NaN",
                "抛出 ValueError",
                "返回 None",
            ],
            answer: 2,
            rationale: "文档说明：math 模块不支持复数，对负数求平方根会抛出 ValueError。复数用 cmath。",
        },
        {
            id: "py-w2-2-q10",
            question: "以下哪个是 Python 浮点数精度问题的推荐解决方案？",
            options: [
                "使用 round() 函数",
                "使用 decimal.Decimal 进行精确计算",
                "使用更大的数值",
                "使用字符串存储数字",
            ],
            answer: 1,
            rationale: "文档强调 decimal 模块用于金融等需要精确十进制运算的场景。",
        },
        {
            id: "py-w2-2-q11",
            question: "int 类型的 bit_length() 方法返回什么？",
            options: [
                "整数的字节数",
                "表示整数所需的二进制位数",
                "整数中 1 的个数",
                "整数的符号",
            ],
            answer: 1,
            rationale: "文档说明：bit_length() 返回表示整数所需的二进制位数（不含符号和前导零）。",
        },
        {
            id: "py-w2-2-q12",
            question: "如何避免浮点数比较的精度问题？",
            options: [
                "使用 == 比较",
                "使用 math.isclose() 比较",
                "将浮点数转为字符串比较",
                "使用 round() 后再比较",
            ],
            answer: 1,
            rationale: "文档提供了 math.isclose(a, b) 函数用于判断两个数是否接近。",
        },
    ],
    "py-w2-3": [
        {
            id: "py-w2-3-q1",
            question: "Python 字符串是什么类型的对象？",
            options: [
                "可变序列",
                "不可变序列",
                "可变映射",
                "不可变映射",
            ],
            answer: 1,
            rationale: "文档明确：'Python strings are immutable'。",
        },
        {
            id: "py-w2-3-q2",
            question: "word = 'Python'; word[-1] 返回什么？",
            options: [
                "'P'",
                "'n'",
                "IndexError",
                "'Python'",
            ],
            answer: 1,
            rationale: "文档说明负索引从末尾开始：word[-1] 是最后一个字符 'n'。",
        },
        {
            id: "py-w2-3-q3",
            question: "如何反转字符串 'hello'？",
            options: [
                "hello.reverse()",
                "'hello'[::-1]",
                "reverse('hello')",
                "'hello'.flip()",
            ],
            answer: 1,
            rationale: "使用步长为 -1 的切片：s[::-1] 可以反转字符串。字符串没有 reverse() 方法。",
        },
        {
            id: "py-w2-3-q4",
            question: "f-string 中 {x:.2f} 的含义是？",
            options: [
                "x 转换为二进制",
                "x 格式化为保留 2 位小数的浮点数",
                "x 重复 2 次",
                "x 转换为十六进制",
            ],
            answer: 1,
            rationale: "文档说明 .2f 是格式说明符：浮点数保留 2 位小数。",
        },
        {
            id: "py-w2-3-q5",
            question: "' '.join(['a', 'b', 'c']) 的结果是？",
            options: [
                "['a', 'b', 'c']",
                "'a b c'",
                "'abc'",
                "' a b c '",
            ],
            answer: 1,
            rationale: "文档示例：', '.join(['spam', 'spam', 'spam']) 返回 'spam, spam, spam'。",
        },
        {
            id: "py-w2-3-q6",
            question: "以下哪个方法用于移除字符串前缀（Python 3.9+）？",
            options: [
                "strip()",
                "lstrip()",
                "removeprefix()",
                "cutprefix()",
            ],
            answer: 2,
            rationale: "文档说明 Python 3.9+ 新增 removeprefix() 和 removesuffix() 方法。",
        },
        {
            id: "py-w2-3-q7",
            question: "r'C:\\path' 中的 r 前缀表示什么？",
            options: [
                "正则表达式",
                "原始字符串，禁用转义",
                "只读字符串",
                "反转字符串",
            ],
            answer: 1,
            rationale: "文档说明使用 r 前缀创建原始字符串，避免转义处理。",
        },
        {
            id: "py-w2-3-q8",
            question: "切片 'Python'[2:5] 返回什么？",
            options: [
                "'Pyt'",
                "'tho'",
                "'thon'",
                "'yth'",
            ],
            answer: 1,
            rationale: "切片 [start:end] 包含 start 不包含 end，所以 [2:5] 返回索引 2,3,4 的字符 'tho'。",
        },
        {
            id: "py-w2-3-q9",
            question: "f-string 中 {x!r} 的作用是？",
            options: [
                "将 x 转为整数",
                "对 x 应用 repr()",
                "将 x 反转",
                "将 x 转为原始字符串",
            ],
            answer: 1,
            rationale: "文档说明 !r 转换标志应用 repr()，!s 应用 str()，!a 应用 ascii()。",
        },
        {
            id: "py-w2-3-q10",
            question: "'hello'.split() 返回什么？",
            options: [
                "['h', 'e', 'l', 'l', 'o']",
                "['hello']",
                "('hello',)",
                "'hello'",
            ],
            answer: 1,
            rationale: "split() 不带参数时按空白符分割，'hello' 没有空白符所以返回 ['hello']。",
        },
        {
            id: "py-w2-3-q11",
            question: "为什么在循环中用 + 连接字符串效率低？",
            options: [
                "Python 限制了 + 操作的次数",
                "字符串不可变，每次 + 都创建新对象",
                "+ 操作需要更多内存",
                "这是 Python 2 的问题",
            ],
            answer: 1,
            rationale: "因为字符串不可变，每次 + 都创建新字符串对象。应使用 ''.join(list) 一次性连接。",
        },
        {
            id: "py-w2-3-q12",
            question: "'  hello  '.strip() 返回什么？",
            options: [
                "'  hello  '",
                "'hello'",
                "'hello  '",
                "'  hello'",
            ],
            answer: 1,
            rationale: "文档示例：'   spacious   '.strip() 返回 'spacious'，strip() 移除首尾空白符。",
        },
    ],
    "py-w2-4": [
        {
            id: "py-w2-4-q1",
            question: "True + True 的结果是？",
            options: [
                "True",
                "2",
                "TypeError",
                "False",
            ],
            answer: 1,
            rationale: "bool 是 int 的子类，True 等于 1，所以 True + True = 2。",
        },
        {
            id: "py-w2-4-q2",
            question: "以下哪个值在布尔上下文中为假？",
            options: [
                "[0]",
                "' '",
                "[]",
                "(0,)",
            ],
            answer: 2,
            rationale: "文档列出假值包括空序列：'', (), [], {}, set(), range(0)。[0] 和 (0,) 不是空的。",
        },
        {
            id: "py-w2-4-q3",
            question: "5 or 3 返回什么？",
            options: [
                "True",
                "5",
                "3",
                "8",
            ],
            answer: 1,
            rationale: "文档说明 or 返回第一个真值或最后一个值。5 为真，所以返回 5。",
        },
        {
            id: "py-w2-4-q4",
            question: "检查变量是否为 None 应该使用什么？",
            options: [
                "x == None",
                "x is None",
                "x = None",
                "None(x)",
            ],
            answer: 1,
            rationale: "PEP 8 要求：'Comparisons to singletons like None should always be done with is or is not'。",
        },
        {
            id: "py-w2-4-q5",
            question: "0 and 5 返回什么？",
            options: [
                "False",
                "0",
                "5",
                "True",
            ],
            answer: 1,
            rationale: "文档说明 and 返回第一个假值或最后一个值。0 为假，所以返回 0。",
        },
        {
            id: "py-w2-4-q6",
            question: "1 < x < 10 等价于什么？",
            options: [
                "1 < x or x < 10",
                "1 < x and x < 10",
                "(1 < x) < 10",
                "1 < (x < 10)",
            ],
            answer: 1,
            rationale: "文档说明链式比较：x < y <= z 等价于 x < y and y <= z，且 y 只求值一次。",
        },
        {
            id: "py-w2-4-q7",
            question: "如何让自定义类的实例在布尔上下文中为假？",
            options: [
                "定义 __false__() 返回 True",
                "定义 __bool__() 返回 False",
                "继承 FalseClass",
                "设置 self.false = True",
            ],
            answer: 1,
            rationale: "文档说明：类可以定义 __bool__() 返回 False 或 __len__() 返回 0 使实例为假。",
        },
        {
            id: "py-w2-4-q8",
            question: "not a == b 被解释为什么？",
            options: [
                "(not a) == b",
                "not (a == b)",
                "语法错误",
                "a != b",
            ],
            answer: 1,
            rationale: "文档说明：not 优先级低于比较运算符，所以 not a == b 被解释为 not (a == b)。",
        },
        {
            id: "py-w2-4-q9",
            question: "Decimal(0) 在布尔上下文中是什么？",
            options: [
                "True",
                "False",
                "取决于精度设置",
                "会抛出异常",
            ],
            answer: 1,
            rationale: "文档列出假值包括零值：0, 0.0, 0j, Decimal(0), Fraction(0, 1)。",
        },
        {
            id: "py-w2-4-q10",
            question: "布尔运算符的优先级从低到高是？",
            options: [
                "not < and < or",
                "or < and < not",
                "and < or < not",
                "not < or < and",
            ],
            answer: 1,
            rationale: "文档明确：Boolean operations are ordered by ascending priority: or < and < not。",
        },
        {
            id: "py-w2-4-q11",
            question: "'' or 'default' 返回什么？",
            options: [
                "''",
                "'default'",
                "True",
                "False",
            ],
            answer: 1,
            rationale: "空字符串为假，or 返回第一个真值，所以返回 'default'。这是常用的默认值模式。",
        },
        {
            id: "py-w2-4-q12",
            question: "比较运算符 is 和 is not 可以被自定义类重写吗？",
            options: [
                "可以，通过 __is__() 方法",
                "不可以，它们的行为不能被自定义",
                "可以，通过 __eq__() 方法",
                "只有 is not 可以被重写",
            ],
            answer: 1,
            rationale: "文档说明：is 和 is not 比较对象身份，行为不能自定义 (cannot be customized)。",
        },
    ],
}
