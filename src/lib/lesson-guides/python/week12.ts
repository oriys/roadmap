import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week12Guides: Record<string, LessonGuide> = {
    "py-w12-1": {
        lessonId: "py-w12-1",
        background: [
            "【迭代器协议】迭代器对象必须支持两个方法：__iter__() 返回迭代器对象本身，__next__() 返回下一个元素或抛出 StopIteration。",
            "【可迭代 vs 迭代器】可迭代对象（Iterable）实现 __iter__() 返回迭代器；迭代器（Iterator）同时实现 __iter__() 和 __next__()。",
            "【for 循环机制】for 循环在后台调用 iter() 获取迭代器对象，然后重复调用 next() 获取下一个元素，捕获 StopIteration 终止循环。",
            "【StopIteration 规则】一旦迭代器的 __next__() 抛出 StopIteration，后续调用必须继续抛出该异常。不遵守此规则的实现被视为有问题。",
            "【容器迭代支持】容器对象的 __iter__() 返回迭代器对象，可以提供多个方法支持不同迭代方式（如树的广度优先和深度优先遍历）。",
        ],
        keyDifficulties: [
            "【__iter__ 返回 self】迭代器类的 __iter__() 通常返回 self，这样迭代器既是可迭代对象也是迭代器，允许在 for 和 in 语句中使用。",
            "【迭代器是一次性的】迭代器遍历完成后不能重置。要再次迭代，需要从可迭代对象重新获取新的迭代器。",
            "【iter() 和 next() 函数】内置函数 iter(obj) 调用 obj.__iter__()，next(it) 调用 it.__next__()。推荐使用内置函数而非直接调用方法。",
            "【设置 __iter__ 为 None】如果类将 __iter__ 设置为 None，表示该类不可迭代，调用 iter() 会抛出 TypeError。",
        ],
        handsOnPath: [
            "1. 实现迭代器：class Counter: def __init__(self, n): self.n = n; self.i = 0",
            "2. 添加 __iter__：def __iter__(self): return self",
            "3. 添加 __next__：def __next__(self): if self.i < self.n: self.i += 1; return self.i; raise StopIteration",
            "4. 使用迭代器：for i in Counter(3): print(i)  # 1, 2, 3",
            "5. 手动迭代：it = iter('abc'); print(next(it), next(it), next(it))  # a b c",
            "6. 捕获结束：try: next(it) except StopIteration: print('迭代结束')",
        ],
        selfCheck: [
            "迭代器协议包括哪两个方法？",
            "可迭代对象和迭代器有什么区别？",
            "for 循环的底层执行机制是什么？",
            "为什么迭代器的 __iter__() 通常返回 self？",
            "StopIteration 异常后能继续调用 __next__() 吗？",
            "如何将一个类标记为不可迭代？",
        ],
        extensions: [
            "学习 collections.abc.Iterator 抽象基类",
            "了解 __reversed__ 方法实现反向迭代",
            "探索 __length_hint__ 提供长度估计",
            "学习 itertools 模块的迭代工具",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/stdtypes.html#iterator-types",
            "https://docs.python.org/3/tutorial/classes.html#iterators",
            "https://docs.python.org/3/reference/datamodel.html#object.__iter__",
        ],
    },
    "py-w12-2": {
        lessonId: "py-w12-2",
        background: [
            "【生成器函数】包含 yield 语句的函数是生成器函数。调用生成器函数返回生成器对象，而不是立即执行函数体。",
            "【yield 语句】yield 返回值给调用者并暂停执行，保留所有局部状态（变量绑定、指令指针、内部栈）。下次调用时从暂停处恢复。",
            "【自动协议实现】生成器对象自动实现 __iter__() 和 __next__() 方法，无需手动定义完整的迭代器类。",
            "【惰性求值】生成器是惰性的，按需产出值而非一次性生成全部。函数终止时自动抛出 StopIteration。",
            "【状态保存】每次调用 next() 时，生成器从上次停止处恢复执行，记住所有数据值和最后执行的语句位置。",
        ],
        keyDifficulties: [
            "【send() 方法】generator.send(value) 恢复执行并发送值，该值成为当前 yield 表达式的结果。启动生成器必须用 send(None) 或 next()。",
            "【throw() 方法】generator.throw(exception) 在暂停处抛出异常。如果生成器捕获异常并 yield 了值，则返回该值。",
            "【close() 方法】generator.close() 在暂停处抛出 GeneratorExit。允许 finally 子句执行清理。生成器关闭后不应再 yield 值。",
            "【yield 表达式的值】yield expr 的整体表达式值是调用者通过 send() 发送的值。如果用 next() 恢复，值为 None。",
        ],
        handsOnPath: [
            "1. 定义生成器：def countdown(n): while n > 0: yield n; n -= 1",
            "2. 使用生成器：for i in countdown(3): print(i)  # 3, 2, 1",
            "3. 手动迭代：gen = countdown(3); print(next(gen))  # 3",
            "4. 双向通信：def echo(): while True: received = yield; print(f'Got: {received}')",
            "5. 使用 send：g = echo(); next(g); g.send('hello')  # Got: hello",
            "6. 关闭生成器：g.close()",
        ],
        selfCheck: [
            "什么样的函数是生成器函数？",
            "调用生成器函数返回什么？",
            "yield 语句的执行流程是怎样的？",
            "send() 方法如何实现双向通信？",
            "生成器终止时抛出什么异常？",
            "close() 方法的作用是什么？",
        ],
        extensions: [
            "学习 yield 在协程中的应用",
            "了解生成器的 gi_frame、gi_code 属性",
            "探索 inspect.isgeneratorfunction() 检测",
            "学习异步生成器 async def + yield",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/classes.html#generators",
            "https://docs.python.org/3/reference/expressions.html#yield-expressions",
            "https://docs.python.org/3/glossary.html#term-generator",
        ],
    },
    "py-w12-3": {
        lessonId: "py-w12-3",
        background: [
            "【生成器表达式】(expr for item in iterable) 使用圆括号而非方括号。返回生成器对象而非完整列表，按需生成元素。",
            "【内存效率】生成器表达式比列表推导式更节省内存：数据逐个生成并处理，不预先存储全部结果。",
            "【yield from 语法】yield from iterable 委托给子迭代器，直接传递值给调用者。支持 send()、throw()、close() 的自动转发。",
            "【yield from 返回值】子生成器使用 return value 时，该值成为 yield from 表达式的结果（通过 StopIteration.value 传递）。",
            "【重构支持】yield from 允许将包含 yield 的代码重构到单独的生成器函数中，不改变行为。",
        ],
        keyDifficulties: [
            "【生成器表达式 vs 列表推导】sum([x*x for x in range(10)]) 先创建列表再求和；sum(x*x for x in range(10)) 逐个生成值求和。",
            "【yield from 双向传递】send() 的值传递给子生成器的 yield；子生成器 yield 的值直接返回给调用者。",
            "【异常处理】非 GeneratorExit 异常传给子生成器的 throw()；GeneratorExit 触发子生成器的 close()。",
            "【作用域限制】Python 3.8+ 禁止在推导式和生成器表达式的隐式嵌套作用域中使用 yield 表达式。",
        ],
        handsOnPath: [
            "1. 生成器表达式：squares = (x*x for x in range(10))",
            "2. 立即消费：sum(x*x for x in range(10))  # 285",
            "3. yield from：def flatten(nested): for item in nested: yield from item",
            "4. 测试 flatten：list(flatten([[1,2], [3,4]]))  # [1, 2, 3, 4]",
            "5. 返回值：def sub(): yield 1; return 'done'",
            "6. 获取返回值：def main(): result = yield from sub(); print(result)  # done",
        ],
        selfCheck: [
            "生成器表达式和列表推导式的语法区别是什么？",
            "为什么生成器表达式更节省内存？",
            "yield from 的作用是什么？",
            "子生成器的 return 值如何传递？",
            "yield from 如何处理 send() 调用？",
            "什么情况下推导式中不能用 yield？",
        ],
        extensions: [
            "学习 PEP 380 yield from 的完整语义",
            "了解生成器表达式的求值时机",
            "探索 yield from 在协程模式中的应用",
            "学习异步生成器中的 async for",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/classes.html#generator-expressions",
            "https://docs.python.org/3/reference/expressions.html#yield-expressions",
            "https://peps.python.org/pep-0380/",
        ],
    },
    "py-w12-4": {
        lessonId: "py-w12-4",
        background: [
            "【itertools 概述】itertools 模块提供快速、内存高效的迭代器构建块，用于构建专门的迭代工具和实现迭代器代数。",
            "【无限迭代器】count(start, step) 无限计数；cycle(iterable) 无限循环；repeat(obj, times) 重复对象。",
            "【终止迭代器】chain() 连接多个迭代器；islice() 切片迭代器；takewhile()/dropwhile() 条件过滤。",
            "【组合迭代器】product() 笛卡尔积；permutations() 排列；combinations() 组合；combinations_with_replacement() 可重复组合。",
            "【分组工具】groupby(iterable, key) 按键分组（需预排序）；compress(data, selectors) 按选择器过滤数据。",
        ],
        keyDifficulties: [
            "【groupby 需要预排序】groupby 只对连续相同键的元素分组。要按键分组所有元素，必须先排序：groupby(sorted(data, key=func), func)。",
            "【tee 注意事项】tee(it, n) 将迭代器分成 n 个独立迭代器，但消耗大量内存保存中间值。如果迭代器很长，考虑使用 list。",
            "【islice 不支持负索引】islice(it, start, stop, step) 类似切片但不支持负数。要反向迭代需要先转为序列。",
            "【accumulate 默认求和】accumulate(it) 默认累积加法；可传入函数如 accumulate(it, operator.mul) 累积乘法。",
        ],
        handsOnPath: [
            "1. 无限计数：from itertools import count; list(islice(count(10, 2), 5))  # [10, 12, 14, 16, 18]",
            "2. 循环迭代：from itertools import cycle; list(islice(cycle('AB'), 5))  # ['A', 'B', 'A', 'B', 'A']",
            "3. 连接迭代：from itertools import chain; list(chain('ABC', 'DEF'))  # ['A', 'B', 'C', 'D', 'E', 'F']",
            "4. 排列组合：from itertools import permutations, combinations",
            "5. permutations：list(permutations('ABC', 2))  # [('A','B'), ('A','C'), ('B','A'), ...]",
            "6. combinations：list(combinations('ABCD', 2))  # [('A','B'), ('A','C'), ('A','D'), ('B','C'), ...]",
        ],
        selfCheck: [
            "itertools 模块的设计目标是什么？",
            "count、cycle、repeat 分别有什么作用？",
            "chain 和 chain.from_iterable 有什么区别？",
            "使用 groupby 前为什么要先排序？",
            "permutations 和 combinations 的区别是什么？",
            "tee 有什么使用注意事项？",
        ],
        extensions: [
            "学习 itertools.recipes 中的常用模式",
            "了解 more-itertools 第三方库",
            "探索 functools.reduce 配合 itertools",
            "学习 operator 模块简化迭代操作",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/itertools.html",
            "https://docs.python.org/3/library/itertools.html#itertools-recipes",
            "https://docs.python.org/3/library/functools.html",
        ],
    },
}

export const week12Quizzes: Record<string, QuizQuestion[]> = {
    "py-w12-1": [
        {
            id: "py-w12-1-q1",
            question: "迭代器协议包括哪两个方法？",
            options: [
                "__iter__ 和 __getitem__",
                "__iter__ 和 __next__",
                "__next__ 和 __len__",
                "__iter__ 和 __contains__",
            ],
            answer: 1,
            rationale: "文档说明：迭代器必须支持 __iter__() 返回自身和 __next__() 返回下一个元素。",
        },
        {
            id: "py-w12-1-q2",
            question: "__next__() 在没有更多元素时应该做什么？",
            options: [
                "返回 None",
                "返回空字符串",
                "抛出 StopIteration 异常",
                "抛出 IndexError 异常",
            ],
            answer: 2,
            rationale: "文档说明：当没有更多项时，__next__() 必须抛出 StopIteration 异常。",
        },
        {
            id: "py-w12-1-q3",
            question: "可迭代对象和迭代器的区别是什么？",
            options: [
                "没有区别",
                "可迭代对象只实现 __iter__，迭代器实现 __iter__ 和 __next__",
                "迭代器只实现 __iter__",
                "可迭代对象实现 __next__",
            ],
            answer: 1,
            rationale: "可迭代对象实现 __iter__() 返回迭代器；迭代器同时实现 __iter__() 和 __next__()。",
        },
        {
            id: "py-w12-1-q4",
            question: "for 循环的底层执行机制是什么？",
            options: [
                "直接访问索引",
                "调用 iter() 获取迭代器，然后重复调用 next()",
                "使用 while 循环和计数器",
                "调用 __getitem__ 方法",
            ],
            answer: 1,
            rationale: "文档说明：for 循环调用 iter() 获取迭代器，重复调用 next()，捕获 StopIteration 终止。",
        },
        {
            id: "py-w12-1-q5",
            question: "迭代器的 __iter__() 通常返回什么？",
            options: [
                "新的迭代器对象",
                "self（自身）",
                "None",
                "被迭代的容器",
            ],
            answer: 1,
            rationale: "文档说明：迭代器的 __iter__() 返回迭代器对象本身，允许在 for 和 in 语句中使用。",
        },
        {
            id: "py-w12-1-q6",
            question: "StopIteration 异常抛出后，再次调用 __next__() 会怎样？",
            options: [
                "返回 None",
                "重新开始迭代",
                "必须继续抛出 StopIteration",
                "抛出 RuntimeError",
            ],
            answer: 2,
            rationale: "文档规则：一旦抛出 StopIteration，后续调用必须继续抛出该异常。",
        },
        {
            id: "py-w12-1-q7",
            question: "如果类将 __iter__ 设置为 None，调用 iter() 会怎样？",
            options: [
                "返回 None",
                "返回空迭代器",
                "抛出 TypeError",
                "抛出 AttributeError",
            ],
            answer: 2,
            rationale: "文档说明：将 __iter__ 设置为 None 表示类不可迭代，调用 iter() 会抛出 TypeError。",
        },
        {
            id: "py-w12-1-q8",
            question: "内置函数 next(it) 做什么？",
            options: [
                "返回迭代器对象",
                "调用 it.__next__()",
                "调用 it.__iter__()",
                "跳过一个元素",
            ],
            answer: 1,
            rationale: "next(it) 调用 it.__next__() 返回下一个元素。推荐使用内置函数而非直接调用方法。",
        },
        {
            id: "py-w12-1-q9",
            question: "迭代器可以重置吗？",
            options: [
                "可以，调用 reset() 方法",
                "可以，调用 __iter__()",
                "不可以，迭代器是一次性的",
                "取决于实现",
            ],
            answer: 2,
            rationale: "迭代器遍历完成后不能重置。要再次迭代，需要从可迭代对象重新获取新的迭代器。",
        },
        {
            id: "py-w12-1-q10",
            question: "以下哪个是正确的迭代器类定义？",
            options: [
                "class It: def __iter__(self): return self",
                "class It: def __next__(self): return 1",
                "class It: def __iter__(self): return self; def __next__(self): raise StopIteration",
                "class It: def __getitem__(self, i): return i",
            ],
            answer: 2,
            rationale: "迭代器类必须同时实现 __iter__() 返回 self 和 __next__() 返回值或抛出 StopIteration。",
        },
        {
            id: "py-w12-1-q11",
            question: "容器对象如何支持迭代？",
            options: [
                "实现 __contains__ 方法",
                "实现 __iter__ 方法返回迭代器对象",
                "实现 __len__ 方法",
                "继承 list 类",
            ],
            answer: 1,
            rationale: "文档说明：容器对象需要定义 __iter__() 返回一个支持迭代器协议的迭代器对象。",
        },
        {
            id: "py-w12-1-q12",
            question: "iter('abc') 返回什么？",
            options: [
                "字符串 'abc'",
                "列表 ['a', 'b', 'c']",
                "字符串迭代器对象",
                "元组 ('a', 'b', 'c')",
            ],
            answer: 2,
            rationale: "iter() 函数返回迭代器对象。对于字符串，返回字符串迭代器，可逐字符迭代。",
        },
    ],
    "py-w12-2": [
        {
            id: "py-w12-2-q1",
            question: "什么样的函数是生成器函数？",
            options: [
                "返回列表的函数",
                "包含 yield 语句的函数",
                "使用 return 的函数",
                "定义了 __iter__ 的函数",
            ],
            answer: 1,
            rationale: "文档说明：包含 yield 语句的函数是生成器函数。",
        },
        {
            id: "py-w12-2-q2",
            question: "调用生成器函数返回什么？",
            options: [
                "函数的返回值",
                "None",
                "生成器对象",
                "迭代器类",
            ],
            answer: 2,
            rationale: "文档说明：调用生成器函数返回生成器对象，而不是立即执行函数体。",
        },
        {
            id: "py-w12-2-q3",
            question: "yield 语句执行后发生什么？",
            options: [
                "函数立即终止",
                "返回值并暂停，保留所有局部状态",
                "清除所有局部变量",
                "抛出异常",
            ],
            answer: 1,
            rationale: "文档说明：yield 返回值给调用者并暂停执行，保留所有局部状态。",
        },
        {
            id: "py-w12-2-q4",
            question: "generator.send(value) 的 value 成为什么？",
            options: [
                "函数的参数",
                "当前 yield 表达式的结果",
                "下一个 yield 的值",
                "返回值",
            ],
            answer: 1,
            rationale: "文档说明：send(value) 恢复执行，value 成为当前 yield 表达式的结果。",
        },
        {
            id: "py-w12-2-q5",
            question: "启动生成器时 send() 的参数应该是什么？",
            options: [
                "任意值",
                "必须是 None",
                "空字符串",
                "0",
            ],
            answer: 1,
            rationale: "文档说明：启动生成器必须用 send(None) 或 next()，因为还没有 yield 表达式接收值。",
        },
        {
            id: "py-w12-2-q6",
            question: "生成器函数终止时抛出什么异常？",
            options: [
                "GeneratorExit",
                "StopIteration",
                "RuntimeError",
                "不抛出异常",
            ],
            answer: 1,
            rationale: "文档说明：生成器函数终止时自动抛出 StopIteration 异常。",
        },
        {
            id: "py-w12-2-q7",
            question: "generator.close() 的作用是什么？",
            options: [
                "重置生成器",
                "在暂停处抛出 GeneratorExit",
                "返回最后的值",
                "删除生成器",
            ],
            answer: 1,
            rationale: "文档说明：close() 在暂停处抛出 GeneratorExit，允许 finally 子句执行清理。",
        },
        {
            id: "py-w12-2-q8",
            question: "generator.throw(exception) 做什么？",
            options: [
                "忽略异常",
                "在暂停处抛出异常",
                "记录异常",
                "返回异常",
            ],
            answer: 1,
            rationale: "文档说明：throw(exception) 在生成器暂停处抛出异常。",
        },
        {
            id: "py-w12-2-q9",
            question: "生成器相比类迭代器的优势是什么？",
            options: [
                "运行更快",
                "自动实现迭代器协议，代码更简洁",
                "支持更多类型",
                "可以被继承",
            ],
            answer: 1,
            rationale: "文档说明：生成器自动创建 __iter__() 和 __next__() 方法，无需手动实现迭代器类。",
        },
        {
            id: "py-w12-2-q10",
            question: "用 next() 恢复生成器时，yield 表达式的值是什么？",
            options: [
                "上一个 yield 的值",
                "None",
                "0",
                "空字符串",
            ],
            answer: 1,
            rationale: "文档说明：如果用 next() 恢复而不是 send()，当前 yield 表达式的值为 None。",
        },
        {
            id: "py-w12-2-q11",
            question: "生成器的惰性求值意味着什么？",
            options: [
                "执行很慢",
                "按需产出值而非一次性生成全部",
                "不能处理大数据",
                "只能使用一次",
            ],
            answer: 1,
            rationale: "文档说明：生成器是惰性的，按需产出值，适合处理大数据或无限序列。",
        },
        {
            id: "py-w12-2-q12",
            question: "生成器关闭后尝试 yield 值会怎样？",
            options: [
                "正常 yield",
                "返回 None",
                "抛出 RuntimeError",
                "被忽略",
            ],
            answer: 2,
            rationale: "文档说明：生成器关闭后不应再 yield 值，否则会抛出 RuntimeError。",
        },
    ],
    "py-w12-3": [
        {
            id: "py-w12-3-q1",
            question: "生成器表达式和列表推导式的语法区别是什么？",
            options: [
                "使用不同的关键字",
                "生成器表达式用圆括号，列表推导式用方括号",
                "没有区别",
                "生成器表达式用花括号",
            ],
            answer: 1,
            rationale: "文档说明：生成器表达式使用圆括号 (expr for x in it)，列表推导式用方括号 [expr for x in it]。",
        },
        {
            id: "py-w12-3-q2",
            question: "为什么生成器表达式比列表推导式更节省内存？",
            options: [
                "使用压缩算法",
                "数据逐个生成，不预先存储全部结果",
                "只存储引用",
                "使用特殊数据结构",
            ],
            answer: 1,
            rationale: "文档说明：生成器表达式按需生成元素，不预先存储全部结果，因此更节省内存。",
        },
        {
            id: "py-w12-3-q3",
            question: "yield from iterable 的作用是什么？",
            options: [
                "导入 iterable",
                "委托给子迭代器，直接传递值给调用者",
                "复制 iterable",
                "反向迭代",
            ],
            answer: 1,
            rationale: "文档说明：yield from 委托给子迭代器，直接将值传递给调用者。",
        },
        {
            id: "py-w12-3-q4",
            question: "子生成器的 return value 如何传递？",
            options: [
                "被忽略",
                "成为 yield from 表达式的结果",
                "抛出异常",
                "传给下一个生成器",
            ],
            answer: 1,
            rationale: "文档说明：子生成器的 return value 通过 StopIteration.value 成为 yield from 表达式的结果。",
        },
        {
            id: "py-w12-3-q5",
            question: "sum(x*x for x in range(10)) 中的表达式是什么类型？",
            options: [
                "列表推导式",
                "生成器表达式",
                "集合推导式",
                "字典推导式",
            ],
            answer: 1,
            rationale: "当生成器表达式是函数唯一参数时，可以省略外层括号，这里是生成器表达式。",
        },
        {
            id: "py-w12-3-q6",
            question: "yield from 如何处理 send() 调用？",
            options: [
                "忽略 send",
                "将值传递给子生成器的 yield",
                "抛出异常",
                "累积发送的值",
            ],
            answer: 1,
            rationale: "文档说明：yield from 支持 send() 的自动转发，将值传递给子生成器。",
        },
        {
            id: "py-w12-3-q7",
            question: "yield from 如何处理 GeneratorExit？",
            options: [
                "忽略",
                "触发子生成器的 close() 方法",
                "抛给调用者",
                "转换为 StopIteration",
            ],
            answer: 1,
            rationale: "文档说明：GeneratorExit 触发子生成器的 close() 方法。",
        },
        {
            id: "py-w12-3-q8",
            question: "以下哪个是正确的生成器表达式？",
            options: [
                "[x*2 for x in range(5)]",
                "(x*2 for x in range(5))",
                "{x*2 for x in range(5)}",
                "x*2 for x in range(5)",
            ],
            answer: 1,
            rationale: "生成器表达式使用圆括号。方括号是列表推导式，花括号是集合推导式。",
        },
        {
            id: "py-w12-3-q9",
            question: "Python 3.8+ 对推导式中的 yield 有什么限制？",
            options: [
                "完全禁止",
                "禁止在推导式的隐式嵌套作用域中使用",
                "只允许在列表推导式中",
                "没有限制",
            ],
            answer: 1,
            rationale: "文档说明：Python 3.8+ 禁止在推导式和生成器表达式的隐式嵌套作用域中使用 yield。",
        },
        {
            id: "py-w12-3-q10",
            question: "def flatten(nested): 如何用 yield from 实现？",
            options: [
                "for item in nested: yield item",
                "for sublist in nested: yield from sublist",
                "yield nested",
                "return nested",
            ],
            answer: 1,
            rationale: "yield from sublist 委托给子列表，将其元素直接传递给调用者。",
        },
        {
            id: "py-w12-3-q11",
            question: "PEP 380 引入 yield from 的主要目的是什么？",
            options: [
                "提高性能",
                "支持重构包含 yield 的代码到单独函数",
                "简化语法",
                "支持异步编程",
            ],
            answer: 1,
            rationale: "PEP 380 的动机是允许将包含 yield 的代码重构到单独的生成器函数中，不改变行为。",
        },
        {
            id: "py-w12-3-q12",
            question: "生成器表达式的求值时机是什么？",
            options: [
                "定义时立即求值",
                "调用 next() 或迭代时按需求值",
                "函数返回时求值",
                "赋值时求值",
            ],
            answer: 1,
            rationale: "生成器表达式是惰性的，只有在调用 next() 或迭代时才按需计算值。",
        },
    ],
    "py-w12-4": [
        {
            id: "py-w12-4-q1",
            question: "itertools 模块的设计目标是什么？",
            options: [
                "提供数学函数",
                "提供快速、内存高效的迭代器构建块",
                "提供文件操作",
                "提供网络功能",
            ],
            answer: 1,
            rationale: "文档说明：itertools 提供快速、内存高效的迭代器构建块，用于构建迭代工具。",
        },
        {
            id: "py-w12-4-q2",
            question: "itertools.count(10, 2) 生成什么序列？",
            options: [
                "10, 11, 12, ...",
                "10, 12, 14, 16, ...",
                "2, 4, 6, 8, 10",
                "10, 8, 6, 4, ...",
            ],
            answer: 1,
            rationale: "文档说明：count(start, step) 生成无限序列：start, start+step, start+2*step, ...。",
        },
        {
            id: "py-w12-4-q3",
            question: "itertools.cycle('AB') 做什么？",
            options: [
                "返回 ['A', 'B']",
                "无限循环返回 A, B, A, B, ...",
                "返回 'AB' 两次",
                "反转字符串",
            ],
            answer: 1,
            rationale: "文档说明：cycle(iterable) 循环迭代，无限重复：A B A B A B ...。",
        },
        {
            id: "py-w12-4-q4",
            question: "itertools.chain('ABC', 'DEF') 返回什么？",
            options: [
                "[['ABC'], ['DEF']]",
                "A B C D E F",
                "'ABCDEF'",
                "[('A', 'D'), ('B', 'E'), ('C', 'F')]",
            ],
            answer: 1,
            rationale: "文档说明：chain() 依次连接多个可迭代对象，返回 A B C D E F。",
        },
        {
            id: "py-w12-4-q5",
            question: "使用 groupby 前为什么要先排序？",
            options: [
                "提高性能",
                "groupby 只对连续相同键的元素分组",
                "避免内存溢出",
                "排序是 groupby 的内部要求",
            ],
            answer: 1,
            rationale: "文档说明：groupby 只对连续相同键的元素分组，要按键分组所有元素必须先排序。",
        },
        {
            id: "py-w12-4-q6",
            question: "permutations('ABC', 2) 和 combinations('ABC', 2) 的区别是什么？",
            options: [
                "没有区别",
                "permutations 考虑顺序，combinations 不考虑顺序",
                "combinations 考虑顺序，permutations 不考虑顺序",
                "combinations 允许重复",
            ],
            answer: 1,
            rationale: "permutations 返回排列（AB, BA 是不同的），combinations 返回组合（只有 AB）。",
        },
        {
            id: "py-w12-4-q7",
            question: "itertools.islice(it, 2, 5) 做什么？",
            options: [
                "返回前 2 个元素",
                "返回索引 2 到 4 的元素",
                "跳过 5 个元素",
                "返回 5 个元素",
            ],
            answer: 1,
            rationale: "文档说明：islice(it, start, stop) 返回从 start 到 stop-1 的元素，类似列表切片。",
        },
        {
            id: "py-w12-4-q8",
            question: "itertools.tee(it, 3) 返回什么？",
            options: [
                "一个迭代器",
                "三个独立的迭代器",
                "迭代器的三个副本",
                "三元组",
            ],
            answer: 1,
            rationale: "文档说明：tee(it, n) 将一个迭代器分成 n 个独立迭代器。",
        },
        {
            id: "py-w12-4-q9",
            question: "itertools.repeat(10, 3) 返回什么？",
            options: [
                "30",
                "10 10 10",
                "[10, 10, 10]",
                "无限个 10",
            ],
            answer: 1,
            rationale: "文档说明：repeat(obj, times) 重复返回同一对象指定次数，返回 10 10 10。",
        },
        {
            id: "py-w12-4-q10",
            question: "itertools.product('AB', repeat=2) 生成什么？",
            options: [
                "AA AB BA BB",
                "AB AB",
                "A B A B",
                "AA BB",
            ],
            answer: 0,
            rationale: "文档说明：product 返回笛卡尔积，repeat=2 等价于 product('AB', 'AB')。",
        },
        {
            id: "py-w12-4-q11",
            question: "itertools.takewhile(lambda x: x<5, [1,4,6,3]) 返回什么？",
            options: [
                "1 4",
                "1 4 3",
                "6",
                "1 4 6 3",
            ],
            answer: 0,
            rationale: "文档说明：takewhile 当谓词为真时返回元素，遇到 6 时停止，返回 1 4。",
        },
        {
            id: "py-w12-4-q12",
            question: "itertools.accumulate([1,2,3,4]) 返回什么？",
            options: [
                "10",
                "1 3 6 10",
                "1 2 3 4",
                "4 3 2 1",
            ],
            answer: 1,
            rationale: "文档说明：accumulate 默认累积加法，返回 1, 1+2=3, 3+3=6, 6+4=10。",
        },
    ],
}
