import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week14Guides: Record<string, LessonGuide> = {
    "py-w14-1": {
        lessonId: "py-w14-1",
        background: [
            "【描述符定义】描述符是定义了 __get__、__set__ 或 __delete__ 方法的对象。当作为类属性时，描述符控制对该属性的访问。",
            "【描述符协议】__get__(self, obj, type=None) 获取属性；__set__(self, obj, value) 设置属性；__delete__(self, obj) 删除属性。",
            "【数据描述符 vs 非数据描述符】数据描述符同时定义 __get__ 和 __set__；非数据描述符只定义 __get__。两者在属性查找优先级上不同。",
            "【查找优先级】数据描述符 > 实例字典 > 非数据描述符 > __getattr__。这个优先级决定了属性访问的行为。",
            "【内置描述符】property、classmethod、staticmethod 都是描述符的实现。理解描述符有助于理解这些内置工具的工作原理。",
        ],
        keyDifficulties: [
            "【实例字典覆盖】非数据描述符可被实例字典覆盖；数据描述符不能被覆盖。要创建只读描述符，需定义 __set__ 抛出 AttributeError。",
            "【obj 参数含义】__get__(self, obj, type) 中，obj 是实例（类访问时为 None），type 是所属类。需要区分实例访问和类访问。",
            "【__set_name__ 钩子】Python 3.6+ 支持 __set_name__(self, owner, name)，在类创建时被调用，让描述符知道自己的属性名。",
            "【描述符触发条件】描述符只有作为类属性时才生效。直接赋值给实例属性不会触发描述符协议。",
        ],
        handsOnPath: [
            "1. 简单描述符：class Desc: def __get__(self, obj, type=None): return 'value'",
            "2. 作为类属性：class C: attr = Desc(); c = C(); print(c.attr)",
            "3. 数据描述符：class Data: def __get__(...): ...; def __set__(...): ...",
            "4. 验证器示例：class Validator: def __set__(self, obj, value): if value < 0: raise ValueError",
            "5. 使用 __set_name__：def __set_name__(self, owner, name): self.name = name",
            "6. 模拟 property：实现带 getter/setter 的描述符",
        ],
        selfCheck: [
            "描述符协议包括哪些方法？",
            "数据描述符和非数据描述符的区别是什么？",
            "属性查找的优先级顺序是什么？",
            "__set_name__ 什么时候被调用？",
            "如何创建只读描述符？",
            "为什么 property 是描述符？",
        ],
        extensions: [
            "学习 functools.cached_property 的描述符实现",
            "了解 Django ORM 的字段描述符",
            "探索 SQLAlchemy 的 Column 描述符",
            "学习 attrs 库的属性验证描述符",
        ],
        sourceUrls: [
            "https://docs.python.org/3/howto/descriptor.html",
            "https://docs.python.org/3/reference/datamodel.html#descriptors",
            "https://docs.python.org/3/reference/datamodel.html#invoking-descriptors",
        ],
    },
    "py-w14-2": {
        lessonId: "py-w14-2",
        background: [
            "【元类定义】元类是类的类。类是元类的实例。默认元类是 type。class Foo: pass 等价于 Foo = type('Foo', (), {})。",
            "【type() 三参数】type(name, bases, dict) 动态创建类：name 是类名字符串，bases 是基类元组，dict 是类属性字典。",
            "【metaclass 关键字】class Foo(metaclass=Meta): 指定元类。元类控制类的创建过程。",
            "【元类方法】__new__(mcs, name, bases, namespace) 创建类对象；__init__(cls, name, bases, namespace) 初始化类对象。",
            "【__prepare__ 方法】__prepare__(mcs, name, bases) 返回用于类定义的命名空间（默认是普通 dict）。可返回 OrderedDict 等特殊字典。",
        ],
        keyDifficulties: [
            "【元类 vs 类装饰器】元类在类定义时介入，可以控制类创建；装饰器在类创建后应用。元类会被继承，装饰器不会。",
            "【__new__ vs __init__】__new__ 创建并返回类对象，__init__ 初始化类对象。__new__ 必须返回类对象。",
            "【元类继承】子类自动继承父类的元类。如果有多个元类，必须是其中一个的子类，否则报错。",
            "【应用场景】元类用于：自动注册类、强制接口实现、自动添加方法、ORM 映射、单例模式等。",
        ],
        handsOnPath: [
            "1. 使用 type 创建类：Foo = type('Foo', (), {'x': 1})",
            "2. 简单元类：class Meta(type): def __new__(mcs, name, bases, ns): ...",
            "3. 使用元类：class Foo(metaclass=Meta): pass",
            "4. __prepare__ 示例：def __prepare__(mcs, name, bases): return OrderedDict()",
            "5. 自动注册：在 __init__ 中将类添加到注册表",
            "6. 验证元类继承：检查 type(Foo) 返回的元类",
        ],
        selfCheck: [
            "什么是元类？",
            "type() 三参数形式的作用是什么？",
            "如何指定类的元类？",
            "__new__ 和 __init__ 在元类中的区别是什么？",
            "__prepare__ 方法用于什么？",
            "元类和类装饰器有什么区别？",
        ],
        extensions: [
            "学习 abc.ABCMeta 抽象基类元类",
            "了解 enum.EnumMeta 枚举元类",
            "探索 Django Model 的元类实现",
            "学习 typing 模块的泛型元类",
        ],
        sourceUrls: [
            "https://docs.python.org/3/reference/datamodel.html#metaclasses",
            "https://docs.python.org/3/library/functions.html#type",
            "https://docs.python.org/3/reference/datamodel.html#customizing-class-creation",
        ],
    },
    "py-w14-3": {
        lessonId: "py-w14-3",
        background: [
            "【__init_subclass__ 目的】PEP 487 引入的钩子方法，允许父类在子类创建时自定义子类，无需使用元类。",
            "【方法签名】def __init_subclass__(cls, **kwargs): super().__init_subclass__(**kwargs)。cls 是新创建的子类，kwargs 是类定义中的关键字参数。",
            "【类关键字参数】class Child(Parent, param=value): 中的 param=value 会传递给 __init_subclass__。",
            "【调用时机】子类定义完成后自动调用。直接定义 __init_subclass__ 的类本身不会被调用，只有其子类会触发。",
            "【替代元类】对于简单的类定制需求，__init_subclass__ 比元类更简单。避免了元类冲突问题。",
        ],
        keyDifficulties: [
            "【必须调用 super()】__init_subclass__ 中必须调用 super().__init_subclass__(**kwargs)，确保多继承正确工作。",
            "【参数处理】使用的关键字参数应从 kwargs 中移除，未使用的参数传递给 super()。否则会抛出 TypeError。",
            "【与元类对比】__init_subclass__ 只能在子类创建后处理；元类可以在创建过程中介入。功能较弱但更简单。",
            "【__set_name__ 配合】PEP 487 同时引入 __set_name__，在类创建时通知描述符其属性名。两者常配合使用。",
        ],
        handsOnPath: [
            "1. 基本用法：class Base: def __init_subclass__(cls, **kwargs): print(f'{cls.__name__} created')",
            "2. 创建子类：class Child(Base): pass  # 打印 'Child created'",
            "3. 接收参数：def __init_subclass__(cls, required=False, **kwargs): cls.required = required",
            "4. 传递参数：class Child(Base, required=True): pass",
            "5. 注册模式：registry = []; def __init_subclass__(cls): registry.append(cls)",
            "6. 调用 super：def __init_subclass__(cls, **kwargs): super().__init_subclass__(**kwargs)",
        ],
        selfCheck: [
            "__init_subclass__ 什么时候被调用？",
            "cls 参数代表什么？",
            "如何传递参数给 __init_subclass__？",
            "为什么必须调用 super().__init_subclass__？",
            "__init_subclass__ 相比元类有什么优势？",
            "__set_name__ 和 __init_subclass__ 的关系是什么？",
        ],
        extensions: [
            "学习 PEP 487 的完整设计",
            "了解 dataclasses 如何使用 __init_subclass__",
            "探索 typing.Protocol 的子类钩子",
            "学习 pydantic 的模型注册机制",
        ],
        sourceUrls: [
            "https://peps.python.org/pep-0487/",
            "https://docs.python.org/3/reference/datamodel.html#customizing-class-creation",
            "https://docs.python.org/3/reference/datamodel.html#object.__init_subclass__",
        ],
    },
    "py-w14-4": {
        lessonId: "py-w14-4",
        background: [
            "【dataclasses 模块】PEP 557 引入，自动生成 __init__、__repr__、__eq__ 等方法。减少样板代码，提高可读性。",
            "【@dataclass 装饰器】@dataclass 装饰器检查类的类型注解，自动生成方法。字段通过类型注解定义：x: int。",
            "【field() 函数】field(default=..., default_factory=..., repr=..., compare=...) 自定义字段行为。default_factory 用于可变默认值。",
            "【参数选项】@dataclass(frozen=True) 冻结实例；order=True 生成比较方法；slots=True 使用 __slots__ 节省内存。",
            "【__post_init__ 方法】在自动生成的 __init__ 之后调用，用于执行额外的初始化逻辑或字段验证。",
        ],
        keyDifficulties: [
            "【可变默认值陷阱】不能直接使用 list 作为默认值：x: list = []。必须使用 field(default_factory=list)。",
            "【继承问题】子类字段不能有默认值而父类字段没有，会导致参数顺序错误。使用 field(kw_only=True) 解决。",
            "【frozen 与 __hash__】frozen=True 的 dataclass 自动可哈希（如果所有字段可哈希）。非 frozen 默认不可哈希。",
            "【InitVar 类型】InitVar[T] 声明仅用于 __init__ 的参数，不存储为实例属性。在 __post_init__ 中接收。",
        ],
        handsOnPath: [
            "1. 基本 dataclass：@dataclass class Point: x: int; y: int",
            "2. 使用：p = Point(1, 2); print(p)  # Point(x=1, y=2)",
            "3. 可变默认值：items: list = field(default_factory=list)",
            "4. 冻结实例：@dataclass(frozen=True) class Frozen: x: int",
            "5. __post_init__：def __post_init__(self): self.total = self.x + self.y",
            "6. InitVar：from dataclasses import InitVar; scale: InitVar[int] = 1",
        ],
        selfCheck: [
            "@dataclass 自动生成哪些方法？",
            "如何为列表字段设置默认值？",
            "frozen=True 有什么效果？",
            "__post_init__ 什么时候调用？",
            "InitVar 的用途是什么？",
            "field() 函数有哪些重要参数？",
        ],
        extensions: [
            "学习 attrs 库的高级功能",
            "了解 pydantic 的数据验证",
            "探索 dataclasses 与 typing 的集成",
            "学习 Python 3.10+ 的 slots=True 优化",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/dataclasses.html",
            "https://peps.python.org/pep-0557/",
            "https://docs.python.org/3/library/dataclasses.html#module-contents",
        ],
    },
}

export const week14Quizzes: Record<string, QuizQuestion[]> = {
    "py-w14-1": [
        {
            id: "py-w14-1-q1",
            question: "描述符协议包括哪些方法？",
            options: [
                "__get__、__set__、__call__",
                "__get__、__set__、__delete__",
                "__init__、__get__、__set__",
                "__enter__、__exit__、__get__",
            ],
            answer: 1,
            rationale: "文档说明：描述符定义 __get__、__set__ 或 __delete__ 方法来控制属性访问。",
        },
        {
            id: "py-w14-1-q2",
            question: "数据描述符和非数据描述符的区别是什么？",
            options: [
                "数据描述符只定义 __get__",
                "数据描述符同时定义 __get__ 和 __set__（或 __delete__）",
                "非数据描述符定义 __set__",
                "没有区别",
            ],
            answer: 1,
            rationale: "文档说明：数据描述符同时定义 __get__ 和 __set__；非数据描述符只定义 __get__。",
        },
        {
            id: "py-w14-1-q3",
            question: "属性查找的正确优先级顺序是什么？",
            options: [
                "实例字典 > 数据描述符 > 非数据描述符",
                "数据描述符 > 实例字典 > 非数据描述符",
                "非数据描述符 > 实例字典 > 数据描述符",
                "实例字典 > 非数据描述符 > 数据描述符",
            ],
            answer: 1,
            rationale: "文档说明：优先级是数据描述符 > 实例字典 > 非数据描述符 > __getattr__。",
        },
        {
            id: "py-w14-1-q4",
            question: "__get__(self, obj, type) 中，当通过类访问时 obj 是什么？",
            options: [
                "类对象",
                "None",
                "实例对象",
                "type 对象",
            ],
            answer: 1,
            rationale: "文档说明：通过类访问时 obj 是 None，通过实例访问时 obj 是实例。",
        },
        {
            id: "py-w14-1-q5",
            question: "__set_name__ 方法什么时候被调用？",
            options: [
                "属性被设置时",
                "类创建时",
                "实例创建时",
                "模块导入时",
            ],
            answer: 1,
            rationale: "文档说明：__set_name__(self, owner, name) 在类创建时被调用，让描述符知道属性名。",
        },
        {
            id: "py-w14-1-q6",
            question: "如何创建只读描述符？",
            options: [
                "只定义 __get__",
                "定义 __get__ 和 __set__，__set__ 抛出 AttributeError",
                "设置 readonly=True",
                "使用 @readonly 装饰器",
            ],
            answer: 1,
            rationale: "文档说明：只读数据描述符需定义 __set__ 抛出 AttributeError，否则实例字典会覆盖。",
        },
        {
            id: "py-w14-1-q7",
            question: "以下哪个是内置描述符？",
            options: [
                "list",
                "dict",
                "property",
                "tuple",
            ],
            answer: 2,
            rationale: "文档说明：property、classmethod、staticmethod 都是描述符的实现。",
        },
        {
            id: "py-w14-1-q8",
            question: "描述符只有在什么情况下才生效？",
            options: [
                "作为实例属性时",
                "作为类属性时",
                "作为模块变量时",
                "作为函数参数时",
            ],
            answer: 1,
            rationale: "文档说明：描述符只有作为类属性时才生效，赋值给实例属性不会触发描述符协议。",
        },
        {
            id: "py-w14-1-q9",
            question: "非数据描述符可以被什么覆盖？",
            options: [
                "类属性",
                "实例字典",
                "元类属性",
                "不能被覆盖",
            ],
            answer: 1,
            rationale: "文档说明：非数据描述符可被实例字典覆盖；数据描述符优先级高于实例字典。",
        },
        {
            id: "py-w14-1-q10",
            question: "staticmethod 是什么类型的描述符？",
            options: [
                "数据描述符",
                "非数据描述符",
                "不是描述符",
                "混合描述符",
            ],
            answer: 1,
            rationale: "文档说明：staticmethod 只定义 __get__，是非数据描述符。",
        },
        {
            id: "py-w14-1-q11",
            question: "__delete__ 方法的作用是什么？",
            options: [
                "删除描述符本身",
                "控制 del obj.attr 的行为",
                "删除类定义",
                "清理内存",
            ],
            answer: 1,
            rationale: "文档说明：__delete__(self, obj) 控制删除属性时的行为（del obj.attr）。",
        },
        {
            id: "py-w14-1-q12",
            question: "描述符的主要用途是什么？",
            options: [
                "提高性能",
                "实现属性访问控制、验证和计算属性",
                "简化代码语法",
                "支持多线程",
            ],
            answer: 1,
            rationale: "文档说明：描述符用于实现属性访问控制、自动验证、延迟计算等高级功能。",
        },
    ],
    "py-w14-2": [
        {
            id: "py-w14-2-q1",
            question: "什么是元类？",
            options: [
                "抽象基类",
                "类的类",
                "父类",
                "接口定义",
            ],
            answer: 1,
            rationale: "文档说明：元类是类的类，类是元类的实例。默认元类是 type。",
        },
        {
            id: "py-w14-2-q2",
            question: "type(name, bases, dict) 的作用是什么？",
            options: [
                "检查对象类型",
                "动态创建类",
                "创建实例",
                "复制类",
            ],
            answer: 1,
            rationale: "文档说明：type(name, bases, dict) 是动态创建类的方式，等价于 class 语句。",
        },
        {
            id: "py-w14-2-q3",
            question: "如何指定类的元类？",
            options: [
                "class Foo(Meta):",
                "class Foo(metaclass=Meta):",
                "@Meta class Foo:",
                "Foo.__metaclass__ = Meta",
            ],
            answer: 1,
            rationale: "文档说明：使用 class Foo(metaclass=Meta): 指定元类。",
        },
        {
            id: "py-w14-2-q4",
            question: "元类的 __new__ 方法返回什么？",
            options: [
                "实例对象",
                "类对象",
                "None",
                "元类本身",
            ],
            answer: 1,
            rationale: "文档说明：元类的 __new__ 创建并返回类对象。",
        },
        {
            id: "py-w14-2-q5",
            question: "__prepare__ 方法的作用是什么？",
            options: [
                "准备实例",
                "返回用于类定义的命名空间",
                "准备元类",
                "初始化类属性",
            ],
            answer: 1,
            rationale: "文档说明：__prepare__ 返回用于类定义的命名空间对象（默认是普通 dict）。",
        },
        {
            id: "py-w14-2-q6",
            question: "元类和类装饰器的主要区别是什么？",
            options: [
                "性能不同",
                "元类在创建时介入且会被继承，装饰器在创建后应用",
                "没有区别",
                "元类更简单",
            ],
            answer: 1,
            rationale: "文档说明：元类在类定义时介入且会被继承；装饰器在类创建后应用，不会被继承。",
        },
        {
            id: "py-w14-2-q7",
            question: "默认的元类是什么？",
            options: [
                "object",
                "type",
                "Meta",
                "class",
            ],
            answer: 1,
            rationale: "文档说明：默认元类是 type，所有类都是 type 的实例。",
        },
        {
            id: "py-w14-2-q8",
            question: "Foo = type('Foo', (), {'x': 1}) 创建了什么？",
            options: [
                "Foo 实例",
                "名为 Foo 的类，有属性 x=1",
                "元类",
                "函数",
            ],
            answer: 1,
            rationale: "文档示例：type(name, bases, dict) 创建类，这里创建了有属性 x=1 的 Foo 类。",
        },
        {
            id: "py-w14-2-q9",
            question: "如果子类继承多个有不同元类的父类会怎样？",
            options: [
                "使用第一个父类的元类",
                "必须有一个元类是其他元类的子类，否则报错",
                "自动合并元类",
                "使用 type 作为元类",
            ],
            answer: 1,
            rationale: "文档说明：多个元类必须有一个是其他的子类，否则会抛出 TypeError。",
        },
        {
            id: "py-w14-2-q10",
            question: "元类的 __init__ 接收什么参数？",
            options: [
                "(self, *args)",
                "(cls, name, bases, namespace)",
                "(mcs, name, bases)",
                "(self, name)",
            ],
            answer: 1,
            rationale: "文档说明：__init__(cls, name, bases, namespace) 初始化已创建的类对象。",
        },
        {
            id: "py-w14-2-q11",
            question: "以下哪个是元类的典型应用场景？",
            options: [
                "数据压缩",
                "自动注册类、ORM 映射",
                "文件操作",
                "网络通信",
            ],
            answer: 1,
            rationale: "文档说明：元类用于自动注册类、强制接口、自动添加方法、ORM 映射等。",
        },
        {
            id: "py-w14-2-q12",
            question: "class Meta(type) 中继承 type 的目的是什么？",
            options: [
                "获得类型检查功能",
                "成为有效的元类",
                "提高性能",
                "支持继承",
            ],
            answer: 1,
            rationale: "元类必须继承自 type（或其子类），这样才能作为有效的元类使用。",
        },
    ],
    "py-w14-3": [
        {
            id: "py-w14-3-q1",
            question: "__init_subclass__ 什么时候被调用？",
            options: [
                "父类创建时",
                "子类定义完成后",
                "实例创建时",
                "模块导入时",
            ],
            answer: 1,
            rationale: "文档说明：__init_subclass__ 在子类定义完成后自动调用。",
        },
        {
            id: "py-w14-3-q2",
            question: "__init_subclass__(cls, **kwargs) 中 cls 是什么？",
            options: [
                "父类",
                "新创建的子类",
                "元类",
                "实例",
            ],
            answer: 1,
            rationale: "文档说明：cls 参数是新创建的子类，不是定义 __init_subclass__ 的类。",
        },
        {
            id: "py-w14-3-q3",
            question: "如何传递参数给 __init_subclass__？",
            options: [
                "通过装饰器",
                "通过类定义中的关键字参数",
                "通过 __init__",
                "无法传递参数",
            ],
            answer: 1,
            rationale: "文档说明：class Child(Parent, param=value): 中的关键字参数传递给 __init_subclass__。",
        },
        {
            id: "py-w14-3-q4",
            question: "为什么必须在 __init_subclass__ 中调用 super().__init_subclass__？",
            options: [
                "语法要求",
                "确保多继承正确工作",
                "提高性能",
                "不是必须的",
            ],
            answer: 1,
            rationale: "文档说明：必须调用 super().__init_subclass__(**kwargs) 确保多继承正确工作。",
        },
        {
            id: "py-w14-3-q5",
            question: "__init_subclass__ 相比元类有什么优势？",
            options: [
                "功能更强大",
                "更简单，避免元类冲突",
                "性能更好",
                "支持更多类型",
            ],
            answer: 1,
            rationale: "文档说明：对于简单的类定制，__init_subclass__ 比元类更简单，避免元类冲突问题。",
        },
        {
            id: "py-w14-3-q6",
            question: "定义 __init_subclass__ 的类本身会被调用吗？",
            options: [
                "会",
                "不会，只有其子类会触发",
                "取决于参数",
                "只有第一次会",
            ],
            answer: 1,
            rationale: "文档说明：直接定义 __init_subclass__ 的类本身不会被调用，只有其子类会触发。",
        },
        {
            id: "py-w14-3-q7",
            question: "PEP 487 除了 __init_subclass__ 还引入了什么？",
            options: [
                "__new__",
                "__set_name__",
                "__call__",
                "__getattr__",
            ],
            answer: 1,
            rationale: "PEP 487 同时引入 __init_subclass__ 和 __set_name__（用于描述符）。",
        },
        {
            id: "py-w14-3-q8",
            question: "未使用的关键字参数应该怎么处理？",
            options: [
                "忽略",
                "传递给 super().__init_subclass__",
                "抛出异常",
                "存储到类属性",
            ],
            answer: 1,
            rationale: "文档说明：未使用的参数应传递给 super()，否则会抛出 TypeError。",
        },
        {
            id: "py-w14-3-q9",
            question: "__init_subclass__ 的典型用途是什么？",
            options: [
                "创建实例",
                "自动注册子类、验证子类定义",
                "定义方法",
                "内存管理",
            ],
            answer: 1,
            rationale: "常见用途包括自动注册子类到注册表、验证子类是否满足要求等。",
        },
        {
            id: "py-w14-3-q10",
            question: "__init_subclass__ 可以修改子类吗？",
            options: [
                "不能",
                "可以，通过 cls 参数",
                "只能读取",
                "需要元类",
            ],
            answer: 1,
            rationale: "可以通过 cls 参数修改子类，如添加属性、注册到列表等。",
        },
        {
            id: "py-w14-3-q11",
            question: "__init_subclass__ 和元类的 __init__ 哪个先执行？",
            options: [
                "__init_subclass__ 先",
                "元类 __init__ 先",
                "同时执行",
                "不确定",
            ],
            answer: 0,
            rationale: "__init_subclass__ 在类完全创建后、元类 __init__ 中被调用。",
        },
        {
            id: "py-w14-3-q12",
            question: "class Child(Parent, required=True) 中 required 如何获取？",
            options: [
                "通过 Child.required",
                "在 __init_subclass__(cls, required, **kwargs) 中",
                "通过 kwargs['required']",
                "通过 self.required",
            ],
            answer: 1,
            rationale: "类关键字参数直接作为 __init_subclass__ 的参数传递。",
        },
    ],
    "py-w14-4": [
        {
            id: "py-w14-4-q1",
            question: "@dataclass 自动生成哪些方法？",
            options: [
                "只有 __init__",
                "__init__、__repr__、__eq__ 等",
                "所有魔术方法",
                "只有 __repr__",
            ],
            answer: 1,
            rationale: "文档说明：@dataclass 自动生成 __init__、__repr__、__eq__ 等特殊方法。",
        },
        {
            id: "py-w14-4-q2",
            question: "如何为列表字段设置默认值？",
            options: [
                "items: list = []",
                "items: list = field(default_factory=list)",
                "items = list()",
                "@default([]) items: list",
            ],
            answer: 1,
            rationale: "文档说明：可变默认值必须使用 field(default_factory=list)，不能直接赋值 []。",
        },
        {
            id: "py-w14-4-q3",
            question: "frozen=True 有什么效果？",
            options: [
                "提高性能",
                "冻结实例，禁止修改属性",
                "冻结类定义",
                "禁止继承",
            ],
            answer: 1,
            rationale: "文档说明：frozen=True 使实例不可变，尝试修改属性会抛出 FrozenInstanceError。",
        },
        {
            id: "py-w14-4-q4",
            question: "__post_init__ 什么时候调用？",
            options: [
                "__init__ 之前",
                "自动生成的 __init__ 之后",
                "类创建时",
                "从不调用",
            ],
            answer: 1,
            rationale: "文档说明：__post_init__ 在自动生成的 __init__ 之后调用，用于额外初始化。",
        },
        {
            id: "py-w14-4-q5",
            question: "InitVar[T] 的用途是什么？",
            options: [
                "初始化类变量",
                "声明仅用于 __init__ 的参数，不存储为属性",
                "初始化父类",
                "验证类型",
            ],
            answer: 1,
            rationale: "文档说明：InitVar[T] 声明只在 __init__ 中使用的参数，不会成为实例属性。",
        },
        {
            id: "py-w14-4-q6",
            question: "field() 的 compare 参数作用是什么？",
            options: [
                "比较性能",
                "控制字段是否参与 __eq__ 比较",
                "排序方式",
                "类型比较",
            ],
            answer: 1,
            rationale: "文档说明：compare=False 使字段不参与 __eq__ 和比较方法。",
        },
        {
            id: "py-w14-4-q7",
            question: "order=True 生成哪些方法？",
            options: [
                "只有 __lt__",
                "__lt__、__le__、__gt__、__ge__",
                "__eq__ 和 __ne__",
                "__cmp__",
            ],
            answer: 1,
            rationale: "文档说明：order=True 生成 __lt__、__le__、__gt__、__ge__ 比较方法。",
        },
        {
            id: "py-w14-4-q8",
            question: "直接使用 x: list = [] 作为 dataclass 字段会怎样？",
            options: [
                "正常工作",
                "抛出 ValueError",
                "所有实例共享同一个列表",
                "编译错误",
            ],
            answer: 1,
            rationale: "文档说明：dataclass 会检测可变默认值并抛出 ValueError，要求使用 default_factory。",
        },
        {
            id: "py-w14-4-q9",
            question: "slots=True 的作用是什么？",
            options: [
                "添加时间槽",
                "使用 __slots__ 节省内存",
                "定义插槽接口",
                "限制方法数量",
            ],
            answer: 1,
            rationale: "文档说明：slots=True 让 dataclass 使用 __slots__ 替代 __dict__，节省内存。",
        },
        {
            id: "py-w14-4-q10",
            question: "field(repr=False) 有什么效果？",
            options: [
                "禁用 repr 功能",
                "字段不出现在 __repr__ 输出中",
                "repr 返回 False",
                "隐藏字段",
            ],
            answer: 1,
            rationale: "文档说明：repr=False 使字段不出现在自动生成的 __repr__ 输出中。",
        },
        {
            id: "py-w14-4-q11",
            question: "PEP 557 引入 dataclasses 的主要目的是什么？",
            options: [
                "提高性能",
                "减少样板代码，自动生成常用方法",
                "支持类型检查",
                "替代元类",
            ],
            answer: 1,
            rationale: "PEP 557 的目的是减少定义数据类时的样板代码，自动生成常用方法。",
        },
        {
            id: "py-w14-4-q12",
            question: "kw_only=True 参数的作用是什么？",
            options: [
                "只允许关键字",
                "使字段必须通过关键字参数传递",
                "关键字优化",
                "禁用关键字",
            ],
            answer: 1,
            rationale: "文档说明：kw_only=True 使字段必须通过关键字参数传递，解决继承时的参数顺序问题。",
        },
    ],
}
