import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week11Guides: Record<string, LessonGuide> = {
    "py-w11-1": {
        lessonId: "py-w11-1",
        background: [
            "【try/except 语法】try 块包含可能出错的代码；except 块捕获并处理特定异常。可以有多个 except 块处理不同异常类型。",
            "【as 绑定异常】except ExceptionType as e 将异常对象绑定到变量 e，可以访问 e.args、e.__traceback__ 等属性。",
            "【else 块】else 块仅在 try 块没有抛出异常时执行。用于将非保护代码与 try 块分离，避免意外捕获其他异常。",
            "【finally 块】finally 块无论是否发生异常都会执行，用于资源清理。即使 try 块执行 return/break/continue，finally 也会在其前执行。",
            "【多异常捕获】except (TypeError, ValueError) 同时捕获多种异常；异常匹配按顺序检查，派生类应在基类之前。",
        ],
        keyDifficulties: [
            "【裸 except 风险】except: 不带异常类型会捕获所有异常（包括 KeyboardInterrupt），应避免使用。至少用 except Exception。",
            "【异常继承顺序】派生类异常必须在基类之前捕获，否则永远不会被匹配到。except Exception 会捕获其所有子类。",
            "【finally 与 return】如果 try 和 finally 都有 return，finally 的 return 会覆盖 try 的返回值。这是常见陷阱。",
            "【异常对象作用域】Python 3 中，except 块结束后异常对象会被删除。如果需要在块外使用，应赋值给其他变量。",
        ],
        handsOnPath: [
            "1. 基本异常处理：try: x = int(input()); except ValueError: print('Invalid')",
            "2. 绑定异常：try: ...; except Exception as e: print(e.args)",
            "3. 多异常：try: ...; except (TypeError, ValueError) as e: print(e)",
            "4. else 块：try: f = open('file'); except: ...; else: data = f.read()",
            "5. finally 清理：try: ...; finally: connection.close()",
            "6. 完整结构：try: ...; except: ...; else: ...; finally: ...",
        ],
        selfCheck: [
            "try/except/else/finally 的执行顺序是什么？",
            "为什么应避免使用裸 except？",
            "else 块什么时候执行？",
            "finally 块有什么保证？",
            "如何同时捕获多种异常类型？",
            "异常对象绑定后可以访问什么属性？",
        ],
        extensions: [
            "学习 ExceptionGroup 和 except* 处理多异常",
            "了解 traceback 模块格式化异常信息",
            "探索 sys.exc_info() 获取当前异常",
            "学习 warnings 模块发出警告",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/errors.html",
            "https://docs.python.org/3/reference/compound_stmts.html#the-try-statement",
            "https://docs.python.org/3/library/exceptions.html",
        ],
    },
    "py-w11-2": {
        lessonId: "py-w11-2",
        background: [
            "【异常层次】所有异常继承自 BaseException。用户异常应继承 Exception（非 BaseException），以避免被 except Exception 意外捕获。",
            "【BaseException 子类】BaseException 的直接子类：SystemExit、KeyboardInterrupt、GeneratorExit、Exception。只有 Exception 用于普通错误。",
            "【常见异常类型】ValueError（值错误）、TypeError（类型错误）、KeyError（键不存在）、IndexError（索引越界）、AttributeError（属性不存在）。",
            "【自定义异常】class MyError(Exception): pass。可以添加 __init__ 存储额外信息，添加 __str__ 自定义错误消息。",
            "【raise 语句】raise ExceptionType('message') 主动抛出异常。raise 不带参数重新抛出当前处理的异常。",
        ],
        keyDifficulties: [
            "【Exception vs BaseException】except Exception 不会捕获 SystemExit、KeyboardInterrupt。except BaseException 会捕获所有异常，通常不应使用。",
            "【异常上下文】__context__ 属性保存隐式异常链（在处理异常时抛出新异常）；__cause__ 保存显式原因（raise ... from）。",
            "【自定义异常设计】自定义异常应有意义的名称、清晰的文档、必要的属性。通常创建模块级异常基类，其他异常继承它。",
            "【继承多个异常】技术上可行但不推荐。如果需要，确保异常层次清晰且有意义。",
        ],
        handsOnPath: [
            "1. 自定义异常：class ValidationError(Exception): pass",
            "2. 带属性的异常：class APIError(Exception): def __init__(self, code, msg): self.code = code; super().__init__(msg)",
            "3. 主动抛出：raise ValueError('Invalid value')",
            "4. 重新抛出：try: ...; except: log_error(); raise",
            "5. 检查继承：print(issubclass(ValueError, Exception))",
            "6. 查看层次：print(ValueError.__mro__)",
        ],
        selfCheck: [
            "自定义异常应该继承什么类？",
            "BaseException 和 Exception 有什么区别？",
            "如何主动抛出异常？",
            "raise 不带参数的作用是什么？",
            "__context__ 和 __cause__ 的区别是什么？",
            "设计自定义异常有什么最佳实践？",
        ],
        extensions: [
            "学习 errno 模块的系统错误码",
            "了解 __notes__ 属性添加异常注释",
            "探索 OSError 子类的命名别名",
            "学习异常层次的设计模式",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/exceptions.html#exception-hierarchy",
            "https://docs.python.org/3/tutorial/errors.html#user-defined-exceptions",
            "https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement",
        ],
    },
    "py-w11-3": {
        lessonId: "py-w11-3",
        background: [
            "【with 语句】with expression as variable: 进入时调用 __enter__()，退出时调用 __exit__()。确保资源正确清理，即使发生异常。",
            "【上下文管理器协议】实现 __enter__(self) 和 __exit__(self, exc_type, exc_val, exc_tb) 方法。__enter__ 返回值绑定到 as 变量。",
            "【__exit__ 参数】如果有异常，参数是异常类型、值和追踪栈；没有异常则都是 None。返回 True 抑制异常，False 或 None 重新抛出。",
            "【多上下文管理器】with A() as a, B() as b: 等价于嵌套的 with 语句。退出时 B 先于 A 清理。",
            "【@contextmanager】contextlib.contextmanager 装饰器简化上下文管理器创建，用 yield 分隔进入和退出代码。",
        ],
        keyDifficulties: [
            "【异常抑制】__exit__ 返回 True 会抑制异常，程序继续执行。除非明确需要，否则应返回 False 让异常传播。",
            "【__enter__ 返回值】__enter__ 返回值是 as 后变量的值。常见模式是返回 self，但文件对象的 open() 返回文件对象本身。",
            "【@contextmanager 异常】在 @contextmanager 中，yield 周围的 try/except 可以捕获 with 块中的异常。不捕获则自动传播。",
            "【嵌套上下文退出顺序】多个上下文管理器按相反顺序退出。如果一个 __exit__ 抛出异常，后续的 __exit__ 仍会调用。",
        ],
        handsOnPath: [
            "1. 实现上下文管理器：class Timer: def __enter__(self): ...; def __exit__(self, *args): ...",
            "2. 使用 with：with Timer() as t: do_work()",
            "3. 多上下文：with open('a') as f1, open('b') as f2: ...",
            "4. @contextmanager：@contextmanager def tag(name): print(f'<{name}>'); yield; print(f'</{name}>')",
            "5. suppress：from contextlib import suppress; with suppress(FileNotFoundError): os.remove('file')",
            "6. closing：from contextlib import closing; with closing(urlopen(url)) as page: ...",
        ],
        selfCheck: [
            "with 语句调用了什么方法？",
            "__enter__ 的返回值有什么用？",
            "__exit__ 返回 True 有什么效果？",
            "@contextmanager 如何简化上下文管理器？",
            "多个上下文管理器的退出顺序是什么？",
            "contextlib.suppress 的作用是什么？",
        ],
        extensions: [
            "学习 contextlib.ExitStack 动态管理多个上下文",
            "了解异步上下文管理器 __aenter__/__aexit__",
            "探索 contextlib.nullcontext 占位符",
            "学习 contextlib.chdir 临时切换目录",
        ],
        sourceUrls: [
            "https://docs.python.org/3/reference/compound_stmts.html#the-with-statement",
            "https://docs.python.org/3/reference/datamodel.html#context-managers",
            "https://docs.python.org/3/library/contextlib.html",
        ],
    },
    "py-w11-4": {
        lessonId: "py-w11-4",
        background: [
            "【显式异常链】raise NewException from original_exception。新异常的 __cause__ 属性指向原因异常，追踪信息显示 'The above exception was the direct cause'。",
            "【隐式异常链】在 except 块中抛出新异常，自动设置 __context__ 属性。追踪信息显示 'During handling of the above exception'。",
            "【抑制上下文】raise NewException from None 抑制异常上下文显示。设置 __suppress_context__ = True。",
            "【裸 except 风险】except: 捕获所有异常包括系统异常，应该用 except Exception:。裸 except 让 Ctrl+C 无法中断程序。",
            "【logging 记录】import logging; logging.exception('Error occurred') 在 except 块中记录异常，包含完整追踪信息。",
        ],
        keyDifficulties: [
            "【何时用 from】显式转换异常类型时使用 from：将低级异常转换为高级领域异常，保留原因链。from None 用于隐藏实现细节。",
            "【异常链追溯】异常链帮助调试，显示错误的完整历史。__cause__ 是显式原因，__context__ 是隐式上下文，两者在追踪中显示不同。",
            "【最佳实践】捕获具体异常、记录后重新抛出、使用 from 保留上下文、在模块边界转换异常类型。",
            "【logging vs print】logging.exception() 自动包含追踪栈，支持日志级别和输出配置。比 print(e) 更专业。",
        ],
        handsOnPath: [
            "1. 显式链：try: ...; except ValueError as e: raise RuntimeError('Config error') from e",
            "2. 抑制上下文：raise RuntimeError('msg') from None",
            "3. 记录异常：import logging; try: ...; except: logging.exception('Failed')",
            "4. 重新抛出：try: ...; except: do_cleanup(); raise",
            "5. 检查链：try: ...; except Exception as e: print(e.__cause__, e.__context__)",
            "6. 自定义链：exc.__cause__ = original; raise exc",
        ],
        selfCheck: [
            "raise ... from e 的作用是什么？",
            "__cause__ 和 __context__ 有什么区别？",
            "from None 有什么作用？",
            "为什么要避免裸 except？",
            "logging.exception() 比 print(e) 好在哪？",
            "什么时候应该转换异常类型？",
        ],
        extensions: [
            "学习 logging 模块的配置和处理器",
            "了解 traceback.format_exception 格式化异常",
            "探索 sys.excepthook 全局异常处理",
            "学习 faulthandler 模块调试崩溃",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/errors.html#exception-chaining",
            "https://docs.python.org/3/library/logging.html",
            "https://docs.python.org/3/tutorial/errors.html#handling-exceptions",
        ],
    },
}

export const week11Quizzes: Record<string, QuizQuestion[]> = {
    "py-w11-1": [
        {
            id: "py-w11-1-q1",
            question: "try 语句中 else 块什么时候执行？",
            options: [
                "总是执行",
                "只有当 try 块没有抛出异常时",
                "只有当 except 块执行后",
                "只有当 finally 块执行后",
            ],
            answer: 1,
            rationale: "文档说明：else 块仅在 try 块没有抛出异常时执行，用于将非保护代码分离。",
        },
        {
            id: "py-w11-1-q2",
            question: "finally 块有什么保证？",
            options: [
                "只在没有异常时执行",
                "只在有异常时执行",
                "无论是否发生异常都会执行",
                "只在 else 块执行后执行",
            ],
            answer: 2,
            rationale: "文档说明：finally 块无论是否发生异常都会执行，即使 try 中有 return 也会先执行 finally。",
        },
        {
            id: "py-w11-1-q3",
            question: "如何将异常对象绑定到变量？",
            options: [
                "except ValueError, e:",
                "except ValueError as e:",
                "except e = ValueError:",
                "except (ValueError, e):",
            ],
            answer: 1,
            rationale: "文档语法：except ExceptionType as variable 将异常对象绑定到变量。",
        },
        {
            id: "py-w11-1-q4",
            question: "为什么应避免使用裸 except（except:）？",
            options: [
                "语法错误",
                "会捕获所有异常包括 KeyboardInterrupt",
                "性能问题",
                "不能重新抛出异常",
            ],
            answer: 1,
            rationale: "裸 except 捕获所有异常包括 KeyboardInterrupt 和 SystemExit，让程序无法正常中断。",
        },
        {
            id: "py-w11-1-q5",
            question: "如何同时捕获 TypeError 和 ValueError？",
            options: [
                "except TypeError, ValueError:",
                "except TypeError or ValueError:",
                "except (TypeError, ValueError):",
                "except [TypeError, ValueError]:",
            ],
            answer: 2,
            rationale: "文档语法：except (TypeError, ValueError) 使用元组同时捕获多种异常类型。",
        },
        {
            id: "py-w11-1-q6",
            question: "异常匹配按什么顺序检查？",
            options: [
                "随机顺序",
                "按定义顺序，从上到下",
                "按异常严重程度",
                "按异常名称字母顺序",
            ],
            answer: 1,
            rationale: "文档说明：except 块按定义顺序从上到下检查，第一个匹配的被执行。",
        },
        {
            id: "py-w11-1-q7",
            question: "如果 try 和 finally 都有 return，返回哪个？",
            options: [
                "try 的 return",
                "finally 的 return",
                "抛出异常",
                "返回 None",
            ],
            answer: 1,
            rationale: "文档说明：finally 的 return 会覆盖 try 的 return，这是常见陷阱。",
        },
        {
            id: "py-w11-1-q8",
            question: "except Exception as e 后，e.args 包含什么？",
            options: [
                "异常类型",
                "传递给异常构造函数的参数元组",
                "追踪栈",
                "错误代码",
            ],
            answer: 1,
            rationale: "文档示例：e.args 包含传递给异常构造函数的参数元组，如 ('spam', 'eggs')。",
        },
        {
            id: "py-w11-1-q9",
            question: "派生类异常应该放在基类异常的什么位置？",
            options: [
                "之后",
                "之前",
                "任意位置",
                "同一行",
            ],
            answer: 1,
            rationale: "文档说明：派生类异常必须在基类之前，否则会被基类的 except 块先捕获。",
        },
        {
            id: "py-w11-1-q10",
            question: "except Exception 会捕获 KeyboardInterrupt 吗？",
            options: [
                "会",
                "不会，KeyboardInterrupt 不继承 Exception",
                "只在 Windows 上会",
                "取决于 Python 版本",
            ],
            answer: 1,
            rationale: "KeyboardInterrupt 直接继承 BaseException 而非 Exception，所以不会被 except Exception 捕获。",
        },
        {
            id: "py-w11-1-q11",
            question: "try/except/else/finally 的执行顺序是什么？",
            options: [
                "try → except → else → finally",
                "try → (except 或 else) → finally",
                "try → else → except → finally",
                "try → finally → else → except",
            ],
            answer: 1,
            rationale: "文档说明：先执行 try，有异常执行 except，无异常执行 else，最后总是执行 finally。",
        },
        {
            id: "py-w11-1-q12",
            question: "在 except 块外能访问绑定的异常对象吗（Python 3）？",
            options: [
                "能，作用域是整个函数",
                "不能，except 块结束后会被删除",
                "只能在 finally 中访问",
                "取决于异常类型",
            ],
            answer: 1,
            rationale: "Python 3 中 except 块结束后异常对象会被删除，需要在块内赋值给其他变量才能在外部使用。",
        },
    ],
    "py-w11-2": [
        {
            id: "py-w11-2-q1",
            question: "自定义异常应该继承什么类？",
            options: [
                "BaseException",
                "Exception",
                "Error",
                "RuntimeError",
            ],
            answer: 1,
            rationale: "文档推荐：用户定义异常应继承 Exception，以便被 except Exception 捕获。",
        },
        {
            id: "py-w11-2-q2",
            question: "BaseException 和 Exception 有什么区别？",
            options: [
                "没有区别",
                "Exception 是 BaseException 的子类，排除了系统退出异常",
                "BaseException 是 Exception 的子类",
                "BaseException 只用于内部",
            ],
            answer: 1,
            rationale: "Exception 是 BaseException 的子类，但 SystemExit、KeyboardInterrupt 等直接继承 BaseException。",
        },
        {
            id: "py-w11-2-q3",
            question: "raise ValueError('message') 做了什么？",
            options: [
                "打印错误消息",
                "创建并抛出 ValueError 异常",
                "记录错误日志",
                "返回错误码",
            ],
            answer: 1,
            rationale: "文档说明：raise 语句创建并抛出指定类型的异常，参数传递给异常构造函数。",
        },
        {
            id: "py-w11-2-q4",
            question: "raise 不带参数有什么作用？",
            options: [
                "抛出 RuntimeError",
                "重新抛出当前处理的异常",
                "清除当前异常",
                "抛出 None",
            ],
            answer: 1,
            rationale: "文档说明：raise 不带参数重新抛出当前正在处理的活动异常。",
        },
        {
            id: "py-w11-2-q5",
            question: "__cause__ 和 __context__ 有什么区别？",
            options: [
                "没有区别",
                "__cause__ 是显式链（from），__context__ 是隐式链",
                "__context__ 是显式链（from），__cause__ 是隐式链",
                "__cause__ 用于警告",
            ],
            answer: 1,
            rationale: "文档说明：__cause__ 通过 raise ... from 显式设置，__context__ 在处理异常时自动设置。",
        },
        {
            id: "py-w11-2-q6",
            question: "ValueError 属于哪个异常类别？",
            options: [
                "ArithmeticError",
                "LookupError",
                "直接继承 Exception",
                "TypeError",
            ],
            answer: 2,
            rationale: "ValueError 直接继承 Exception，表示函数收到正确类型但值不合适的参数。",
        },
        {
            id: "py-w11-2-q7",
            question: "KeyError 和 IndexError 有什么共同点？",
            options: [
                "没有共同点",
                "都继承自 LookupError",
                "都继承自 TypeError",
                "都继承自 ValueError",
            ],
            answer: 1,
            rationale: "文档层次：KeyError 和 IndexError 都继承自 LookupError，表示查找失败。",
        },
        {
            id: "py-w11-2-q8",
            question: "如何检查一个异常类是否是另一个的子类？",
            options: [
                "TypeError.subclass(ValueError)",
                "issubclass(ValueError, Exception)",
                "ValueError.parent()",
                "isinstance(ValueError, Exception)",
            ],
            answer: 1,
            rationale: "使用 issubclass(A, B) 检查类 A 是否是类 B 的子类。",
        },
        {
            id: "py-w11-2-q9",
            question: "自定义异常添加属性的正确方式是什么？",
            options: [
                "直接赋值 e.code = 500",
                "在 __init__ 中设置属性并调用 super().__init__()",
                "使用 @property",
                "不能添加属性",
            ],
            answer: 1,
            rationale: "推荐在自定义异常的 __init__ 中设置属性，并调用父类的 __init__ 传递消息。",
        },
        {
            id: "py-w11-2-q10",
            question: "哪些异常不会被 except Exception 捕获？",
            options: [
                "ValueError, TypeError",
                "KeyboardInterrupt, SystemExit",
                "IndexError, KeyError",
                "RuntimeError, StopIteration",
            ],
            answer: 1,
            rationale: "KeyboardInterrupt 和 SystemExit 直接继承 BaseException，不会被 except Exception 捕获。",
        },
        {
            id: "py-w11-2-q11",
            question: "raise ValueError 和 raise ValueError() 有什么区别？",
            options: [
                "没有区别，类会被自动实例化",
                "前者是语法错误",
                "后者创建没有消息的异常",
                "前者性能更好",
            ],
            answer: 0,
            rationale: "文档说明：如果表达式是异常类，会被自动实例化（无参数），两者等价。",
        },
        {
            id: "py-w11-2-q12",
            question: "查看异常的方法解析顺序使用什么属性？",
            options: [
                "__bases__",
                "__mro__",
                "__parent__",
                "__super__",
            ],
            answer: 1,
            rationale: "使用 ExceptionClass.__mro__ 查看方法解析顺序，显示完整的继承链。",
        },
    ],
    "py-w11-3": [
        {
            id: "py-w11-3-q1",
            question: "with 语句进入时调用什么方法？",
            options: [
                "__init__",
                "__enter__",
                "__start__",
                "__begin__",
            ],
            answer: 1,
            rationale: "文档说明：with 语句进入时调用上下文管理器的 __enter__ 方法。",
        },
        {
            id: "py-w11-3-q2",
            question: "__exit__ 方法返回 True 有什么效果？",
            options: [
                "表示成功退出",
                "抑制异常，程序继续执行",
                "重新抛出异常",
                "打印错误消息",
            ],
            answer: 1,
            rationale: "文档说明：__exit__ 返回 True 会抑制异常，False 或 None 让异常继续传播。",
        },
        {
            id: "py-w11-3-q3",
            question: "__enter__ 方法的返回值有什么用？",
            options: [
                "没有用",
                "绑定到 as 后面的变量",
                "传递给 __exit__",
                "打印出来",
            ],
            answer: 1,
            rationale: "文档说明：__enter__ 的返回值绑定到 with ... as 后面的变量。",
        },
        {
            id: "py-w11-3-q4",
            question: "@contextmanager 装饰器要求什么？",
            options: [
                "返回类实例",
                "生成器必须 yield 恰好一次",
                "不能有 try/finally",
                "必须是异步函数",
            ],
            answer: 1,
            rationale: "文档说明：@contextmanager 要求函数是生成器，必须 yield 恰好一次。",
        },
        {
            id: "py-w11-3-q5",
            question: "with A() as a, B() as b: 的退出顺序是什么？",
            options: [
                "A 先退出，B 后退出",
                "B 先退出，A 后退出",
                "同时退出",
                "随机顺序",
            ],
            answer: 1,
            rationale: "文档说明：多个上下文管理器按相反顺序退出，相当于嵌套的 with 语句。",
        },
        {
            id: "py-w11-3-q6",
            question: "contextlib.suppress(FileNotFoundError) 的作用是什么？",
            options: [
                "抛出 FileNotFoundError",
                "抑制 FileNotFoundError，静默忽略",
                "记录 FileNotFoundError",
                "将 FileNotFoundError 转换为警告",
            ],
            answer: 1,
            rationale: "文档说明：suppress() 上下文管理器抑制指定的异常，静默继续执行。",
        },
        {
            id: "py-w11-3-q7",
            question: "__exit__ 在没有异常时接收什么参数？",
            options: [
                "空元组",
                "三个 None",
                "不接收参数",
                "True",
            ],
            answer: 1,
            rationale: "文档说明：没有异常时 __exit__ 接收 (None, None, None) 三个参数。",
        },
        {
            id: "py-w11-3-q8",
            question: "contextlib.closing(obj) 做什么？",
            options: [
                "关闭对象",
                "创建上下文管理器，退出时调用 obj.close()",
                "检查对象是否已关闭",
                "阻止对象被关闭",
            ],
            answer: 1,
            rationale: "文档说明：closing() 返回上下文管理器，退出时调用对象的 close() 方法。",
        },
        {
            id: "py-w11-3-q9",
            question: "@contextmanager 中的 yield 之前的代码相当于什么？",
            options: [
                "__exit__",
                "__enter__",
                "__init__",
                "finally",
            ],
            answer: 1,
            rationale: "yield 之前的代码相当于 __enter__，之后的代码相当于 __exit__。",
        },
        {
            id: "py-w11-3-q10",
            question: "with open('file') as f 中，f 是什么？",
            options: [
                "文件名",
                "__enter__ 的返回值（文件对象）",
                "open 函数本身",
                "布尔值",
            ],
            answer: 1,
            rationale: "as 后的变量是 __enter__ 的返回值，对于文件就是文件对象本身。",
        },
        {
            id: "py-w11-3-q11",
            question: "__exit__(self, exc_type, exc_val, exc_tb) 中 exc_tb 是什么？",
            options: [
                "异常类型",
                "异常值",
                "追踪栈对象",
                "错误消息",
            ],
            answer: 2,
            rationale: "文档说明：exc_type 是异常类型，exc_val 是异常值，exc_tb 是追踪栈对象。",
        },
        {
            id: "py-w11-3-q12",
            question: "如果 __enter__ 成功但 with 块抛出异常，__exit__ 会被调用吗？",
            options: [
                "不会",
                "会，这是 with 的保证",
                "取决于异常类型",
                "只有 finally 中才会",
            ],
            answer: 1,
            rationale: "文档说明：如果 __enter__ 成功，__exit__ 保证会被调用，无论是否发生异常。",
        },
    ],
    "py-w11-4": [
        {
            id: "py-w11-4-q1",
            question: "raise NewError from original_error 的作用是什么？",
            options: [
                "替换原错误",
                "创建显式异常链，设置 __cause__",
                "抑制原错误",
                "合并两个错误",
            ],
            answer: 1,
            rationale: "文档说明：from 子句创建显式异常链，新异常的 __cause__ 指向原异常。",
        },
        {
            id: "py-w11-4-q2",
            question: "raise Error from None 的作用是什么？",
            options: [
                "不抛出异常",
                "抑制异常上下文显示",
                "创建空异常",
                "抛出 NoneType 错误",
            ],
            answer: 1,
            rationale: "文档说明：from None 设置 __suppress_context__ = True，抑制自动显示异常上下文。",
        },
        {
            id: "py-w11-4-q3",
            question: "__context__ 什么时候自动设置？",
            options: [
                "使用 from 子句时",
                "在处理异常时抛出新异常",
                "总是设置",
                "从不自动设置",
            ],
            answer: 1,
            rationale: "文档说明：在 except 块中抛出新异常时，__context__ 自动设置为正在处理的异常。",
        },
        {
            id: "py-w11-4-q4",
            question: "logging.exception() 比 print(e) 好在哪？",
            options: [
                "更快",
                "自动包含追踪栈信息",
                "更短",
                "不需要导入",
            ],
            answer: 1,
            rationale: "logging.exception() 自动包含完整追踪栈信息，支持日志级别和输出配置。",
        },
        {
            id: "py-w11-4-q5",
            question: "什么时候应该使用 raise ... from e？",
            options: [
                "总是使用",
                "将低级异常转换为高级领域异常时",
                "只在调试时",
                "从不使用",
            ],
            answer: 1,
            rationale: "当需要将低级异常转换为更有意义的领域异常时，使用 from 保留原因链便于调试。",
        },
        {
            id: "py-w11-4-q6",
            question: "显式异常链在追踪信息中显示什么消息？",
            options: [
                "'During handling of the above exception'",
                "'The above exception was the direct cause'",
                "'Caused by'",
                "没有特殊消息",
            ],
            answer: 1,
            rationale: "文档示例：显式链（from）显示 'The above exception was the direct cause of the following exception'。",
        },
        {
            id: "py-w11-4-q7",
            question: "裸 except 为什么危险？",
            options: [
                "语法错误",
                "捕获所有异常包括 KeyboardInterrupt，让程序无法中断",
                "性能问题",
                "内存泄漏",
            ],
            answer: 1,
            rationale: "裸 except 捕获所有异常包括 KeyboardInterrupt，导致 Ctrl+C 无法中断程序。",
        },
        {
            id: "py-w11-4-q8",
            question: "在 except 块中如何重新抛出异常而不改变它？",
            options: [
                "raise Exception()",
                "raise",
                "throw",
                "reraise",
            ],
            answer: 1,
            rationale: "文档说明：raise 不带参数重新抛出当前正在处理的异常，保持原始追踪信息。",
        },
        {
            id: "py-w11-4-q9",
            question: "__suppress_context__ = True 有什么效果？",
            options: [
                "删除 __context__",
                "在追踪信息中不显示异常上下文",
                "抛出新异常",
                "打印警告",
            ],
            answer: 1,
            rationale: "文档说明：__suppress_context__ = True 抑制在追踪信息中显示 __context__ 的内容。",
        },
        {
            id: "py-w11-4-q10",
            question: "logging.exception() 应该在哪里调用？",
            options: [
                "任何地方",
                "在 except 块内",
                "在 finally 块内",
                "在函数开头",
            ],
            answer: 1,
            rationale: "logging.exception() 应该在 except 块内调用，它会自动获取当前异常信息。",
        },
        {
            id: "py-w11-4-q11",
            question: "如何在模块边界正确处理异常？",
            options: [
                "直接传播所有异常",
                "捕获低级异常，转换为模块定义的高级异常",
                "抑制所有异常",
                "只使用 print 打印",
            ],
            answer: 1,
            rationale: "最佳实践是在模块边界捕获低级异常，转换为模块定义的领域异常，使用 from 保留链。",
        },
        {
            id: "py-w11-4-q12",
            question: "隐式异常链在追踪信息中显示什么消息？",
            options: [
                "'The above exception was the direct cause'",
                "'During handling of the above exception, another exception occurred'",
                "'Caused by'",
                "没有消息",
            ],
            answer: 1,
            rationale: "隐式链（__context__）显示 'During handling of the above exception, another exception occurred'。",
        },
    ],
}
