import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week10Guides: Record<string, LessonGuide> = {
    "py-w10-1": {
        lessonId: "py-w10-1",
        background: [
            "【open() 函数】open(file, mode='r', encoding=None) 打开文件并返回文件对象。mode 参数指定打开模式：r 读取、w 写入（覆盖）、a 追加、b 二进制、+ 读写。",
            "【with 语句】使用 with open(...) as f 确保文件正确关闭，即使发生异常。这是处理文件的推荐方式，避免资源泄漏。",
            "【读取方法】f.read() 读取全部内容；f.read(size) 读取指定数量；f.readline() 读取一行；f.readlines() 返回所有行的列表。",
            "【写入方法】f.write(string) 写入字符串，返回写入的字符数。非字符串需要先转换为字符串。",
            "【编码参数】文本模式下推荐指定 encoding='utf-8'。默认编码取决于平台，可能导致跨平台问题。二进制模式不使用编码。",
        ],
        keyDifficulties: [
            "【文件模式组合】模式可以组合：'rb' 二进制读取、'w+' 读写（覆盖）、'a+' 读写（追加）。'x' 模式独占创建，文件已存在则失败。",
            "【换行符处理】文本模式下系统换行符自动转换。若需保持原样，使用 newline='' 参数。二进制模式不转换。",
            "【文件位置】f.tell() 返回当前位置；f.seek(offset, whence) 移动位置。文本模式只能 seek 到 tell() 返回的位置或文件开头。",
            "【缓冲区问题】写入数据可能在缓冲区中，不使用 with 可能导致数据未写入磁盘。f.flush() 强制刷新缓冲区。",
        ],
        handsOnPath: [
            "1. 读取文件：with open('file.txt', encoding='utf-8') as f: content = f.read()",
            "2. 写入文件：with open('out.txt', 'w', encoding='utf-8') as f: f.write('Hello')",
            "3. 逐行读取：for line in f: print(line, end='')",
            "4. 追加内容：with open('log.txt', 'a') as f: f.write('new line\\n')",
            "5. 二进制模式：with open('image.png', 'rb') as f: data = f.read()",
            "6. 读写模式：with open('data.txt', 'r+') as f: f.seek(0); f.write('new')",
        ],
        selfCheck: [
            "open() 的默认模式是什么？",
            "为什么推荐使用 with 语句处理文件？",
            "read() 和 readline() 有什么区别？",
            "如何指定文件编码？",
            "'w' 和 'a' 模式有什么区别？",
            "文本模式和二进制模式有什么区别？",
        ],
        extensions: [
            "学习 io 模块的 StringIO 和 BytesIO",
            "了解 mmap 模块内存映射文件",
            "探索 tempfile 模块创建临时文件",
            "学习 shutil 模块的高级文件操作",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files",
            "https://docs.python.org/3/library/functions.html#open",
            "https://docs.python.org/3/glossary.html#term-file-object",
        ],
    },
    "py-w10-2": {
        lessonId: "py-w10-2",
        background: [
            "【Path 类】pathlib.Path 是面向对象的路径处理类。Path('.') 创建当前目录路径，Path('/etc/hosts') 创建绝对路径。",
            "【路径拼接】使用 / 运算符拼接路径：p / 'subdir' / 'file.txt'。比 os.path.join() 更直观易读。",
            "【路径属性】p.name 文件名、p.stem 不含后缀的文件名、p.suffix 后缀、p.parent 父目录、p.parts 路径组成部分元组。",
            "【文件查询】p.exists() 是否存在、p.is_file() 是否为文件、p.is_dir() 是否为目录、p.stat() 获取文件状态。",
            "【Glob 模式】p.glob('*.py') 匹配当前目录的 .py 文件；p.rglob('*.py') 递归匹配所有子目录。支持 ** ? [] 等通配符。",
        ],
        keyDifficulties: [
            "【读写快捷方法】p.read_text(encoding='utf-8') 读取文本；p.write_text(content) 写入文本；p.read_bytes()/write_bytes() 处理二进制。",
            "【路径转换】p.resolve() 解析为绝对路径并消除 .. 和符号链接；p.absolute() 只转为绝对路径不解析；p.relative_to() 计算相对路径。",
            "【目录操作】p.mkdir(parents=True, exist_ok=True) 创建目录及父目录；p.iterdir() 迭代目录内容；p.rmdir() 删除空目录。",
            "【与 os.path 对比】os.path.dirname(p) → p.parent；os.path.join(a,b) → a / b；os.path.exists(p) → p.exists()。推荐新代码使用 pathlib。",
        ],
        handsOnPath: [
            "1. 创建路径：from pathlib import Path; p = Path('data') / 'file.txt'",
            "2. 检查存在：if p.exists(): print(p.read_text())",
            "3. 遍历目录：for item in Path('.').iterdir(): print(item)",
            "4. Glob 匹配：py_files = list(Path('.').glob('**/*.py'))",
            "5. 创建目录：Path('output/subdir').mkdir(parents=True, exist_ok=True)",
            "6. 路径属性：print(p.name, p.suffix, p.parent)",
        ],
        selfCheck: [
            "如何用 / 运算符拼接路径？",
            "p.glob() 和 p.rglob() 有什么区别？",
            "Path.cwd() 和 Path.home() 返回什么？",
            "如何读取文件内容而不用 open()？",
            "mkdir() 的 parents 和 exist_ok 参数作用是什么？",
            "pathlib 相比 os.path 有什么优势？",
        ],
        extensions: [
            "学习 PurePath 进行纯路径计算",
            "了解 Path.walk() 遍历目录树",
            "探索 Path.chmod() 修改文件权限",
            "学习 Path.symlink_to() 创建符号链接",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/pathlib.html",
            "https://docs.python.org/3/library/pathlib.html#basic-use",
            "https://docs.python.org/3/library/pathlib.html#correspondence-to-tools-in-the-os-module",
        ],
    },
    "py-w10-3": {
        lessonId: "py-w10-3",
        background: [
            "【JSON 编码】json.dumps(obj) 将 Python 对象序列化为 JSON 字符串；json.dump(obj, file) 写入文件。支持 dict、list、str、int、float、bool、None。",
            "【JSON 解码】json.loads(s) 将 JSON 字符串解析为 Python 对象；json.load(file) 从文件读取。JSON object 变 dict，array 变 list。",
            "【格式化输出】indent 参数缩进美化：json.dumps(obj, indent=4)。sort_keys=True 按键排序。separators 自定义分隔符。",
            "【类型映射】Python → JSON：dict→object、list/tuple→array、str→string、int/float→number、True/False→true/false、None→null。",
            "【自定义编码】default 参数指定无法序列化对象的处理函数。或继承 json.JSONEncoder 重写 default() 方法。",
        ],
        keyDifficulties: [
            "【ensure_ascii】默认 ensure_ascii=True 会转义非 ASCII 字符。设为 False 保留原字符：json.dumps({'中': '文'}, ensure_ascii=False)。",
            "【自定义解码】object_hook 参数为每个 dict 调用，可用于对象重建。parse_float 等参数可自定义数值解析（如用 Decimal）。",
            "【非标准类型】datetime、Decimal、自定义类等需要 default 函数处理。反序列化需要 object_hook 重建对象。",
            "【循环引用】json 不支持循环引用的数据结构，会抛出 ValueError。需要自行处理或使用其他序列化方案。",
        ],
        handsOnPath: [
            "1. 序列化：data = {'name': 'Alice', 'age': 30}; s = json.dumps(data)",
            "2. 反序列化：obj = json.loads('{\"a\": 1}')",
            "3. 文件操作：with open('data.json', 'w') as f: json.dump(data, f, indent=2)",
            "4. 美化输出：print(json.dumps(data, indent=4, sort_keys=True))",
            "5. 自定义编码：json.dumps({'time': dt}, default=str)",
            "6. 解码钩子：json.loads(s, object_hook=lambda d: MyClass(**d))",
        ],
        selfCheck: [
            "dumps() 和 dump() 有什么区别？",
            "如何美化 JSON 输出？",
            "Python tuple 序列化为 JSON 什么类型？",
            "如何处理 datetime 等非标准类型？",
            "ensure_ascii 参数的作用是什么？",
            "object_hook 参数用于什么？",
        ],
        extensions: [
            "学习 orjson 高性能 JSON 库",
            "了解 JSON Schema 数据验证",
            "探索 jsonlines 处理流式 JSON",
            "学习 pydantic 的 JSON 序列化",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/json.html",
            "https://docs.python.org/3/tutorial/inputoutput.html#saving-structured-data-with-json",
            "https://docs.python.org/3/library/json.html#json.JSONEncoder",
        ],
    },
    "py-w10-4": {
        lessonId: "py-w10-4",
        background: [
            "【pickle 模块】pickle 可以序列化任意 Python 对象。pickle.dump(obj, file) 写入文件；pickle.dumps(obj) 返回字节；load/loads 反序列化。",
            "【安全警告】pickle 不安全！恶意 pickle 数据可在反序列化时执行任意代码。绝不要加载不信任的 pickle 数据。",
            "【可序列化类型】支持：内置类型、顶层函数和类、类实例（如果 __getstate__ 返回可序列化对象）。不支持：lambda、局部函数、打开的文件对象。",
            "【csv 模块】csv.reader(file) 返回逐行迭代器，每行是字符串列表；csv.writer(file) 写入 CSV；DictReader/DictWriter 使用字典。",
            "【tomllib 模块】Python 3.11+ 内置 tomllib 解析 TOML 配置文件：tomllib.load(file) 返回字典。只支持读取，不支持写入。",
        ],
        keyDifficulties: [
            "【pickle 协议】不同协议版本有不同特性。pickle.HIGHEST_PROTOCOL 使用最新版本；protocol=0 生成可读 ASCII。默认协议版本随 Python 版本变化。",
            "【自定义序列化】__getstate__() 返回要序列化的状态；__setstate__(state) 恢复状态。用于排除不可序列化属性（如文件对象）。",
            "【csv newline】打开 CSV 文件应使用 newline=''，避免换行符处理问题。DictWriter 需要 fieldnames 参数，writeheader() 写入表头。",
            "【pickle vs json】pickle：任意 Python 对象、二进制、不安全。json：有限类型、文本、安全、跨语言。优先使用 json，特殊需求才用 pickle。",
        ],
        handsOnPath: [
            "1. pickle 序列化：with open('data.pkl', 'wb') as f: pickle.dump(obj, f)",
            "2. pickle 反序列化：with open('data.pkl', 'rb') as f: obj = pickle.load(f)",
            "3. csv 读取：with open('data.csv', newline='') as f: reader = csv.reader(f)",
            "4. csv 写入：writer = csv.writer(f); writer.writerow(['a', 'b', 'c'])",
            "5. DictReader：for row in csv.DictReader(f): print(row['name'])",
            "6. TOML 读取：import tomllib; with open('config.toml', 'rb') as f: config = tomllib.load(f)",
        ],
        selfCheck: [
            "pickle 有什么安全风险？",
            "哪些类型不能被 pickle？",
            "__getstate__ 和 __setstate__ 用于什么？",
            "csv 文件应该用什么 newline 参数打开？",
            "DictReader 和 reader 有什么区别？",
            "什么时候应该用 json 而不是 pickle？",
        ],
        extensions: [
            "学习 shelve 模块持久化字典",
            "了解 dill 库扩展 pickle 能力",
            "探索 msgpack 高效二进制格式",
            "学习 yaml 库处理 YAML 配置",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/pickle.html",
            "https://docs.python.org/3/library/csv.html",
            "https://docs.python.org/3/library/tomllib.html",
        ],
    },
}

export const week10Quizzes: Record<string, QuizQuestion[]> = {
    "py-w10-1": [
        {
            id: "py-w10-1-q1",
            question: "open() 函数的默认模式是什么？",
            options: [
                "'w'（写入模式）",
                "'r'（读取模式）",
                "'a'（追加模式）",
                "'rb'（二进制读取）",
            ],
            answer: 1,
            rationale: "文档说明：open(file, mode='r')，默认模式是 'r'（读取文本模式）。",
        },
        {
            id: "py-w10-1-q2",
            question: "为什么推荐使用 with 语句处理文件？",
            options: [
                "更快的读取速度",
                "自动关闭文件，即使发生异常",
                "支持更多编码",
                "可以同时打开多个文件",
            ],
            answer: 1,
            rationale: "文档强调：with 语句确保文件正确关闭，即使发生异常，避免资源泄漏。",
        },
        {
            id: "py-w10-1-q3",
            question: "f.read() 和 f.readline() 有什么区别？",
            options: [
                "没有区别",
                "read() 读取全部内容，readline() 读取一行",
                "read() 更快",
                "readline() 读取全部内容",
            ],
            answer: 1,
            rationale: "文档说明：f.read() 读取整个文件内容，f.readline() 读取单行（包含换行符）。",
        },
        {
            id: "py-w10-1-q4",
            question: "'w' 和 'a' 模式有什么区别？",
            options: [
                "'w' 追加，'a' 覆盖",
                "'w' 覆盖现有内容，'a' 在末尾追加",
                "没有区别",
                "'a' 只能写入 ASCII",
            ],
            answer: 1,
            rationale: "文档说明：'w' 打开文件写入会覆盖（truncate），'a' 打开文件在末尾追加。",
        },
        {
            id: "py-w10-1-q5",
            question: "如何正确指定文件编码？",
            options: [
                "open('file.txt', 'utf-8')",
                "open('file.txt', encoding='utf-8')",
                "open('file.txt').encoding('utf-8')",
                "无法指定编码",
            ],
            answer: 1,
            rationale: "文档示例：open('file.txt', encoding='utf-8') 使用 encoding 关键字参数。",
        },
        {
            id: "py-w10-1-q6",
            question: "文本模式和二进制模式有什么区别？",
            options: [
                "文本模式更快",
                "文本模式处理字符串并转换换行符，二进制模式处理字节不转换",
                "二进制模式不能写入",
                "没有区别",
            ],
            answer: 1,
            rationale: "文档说明：文本模式读写字符串并转换换行符；二进制模式读写字节，不做转换。",
        },
        {
            id: "py-w10-1-q7",
            question: "f.write() 返回什么？",
            options: [
                "None",
                "True 或 False",
                "写入的字符数",
                "文件对象",
            ],
            answer: 2,
            rationale: "文档说明：f.write(string) 写入字符串并返回写入的字符数。",
        },
        {
            id: "py-w10-1-q8",
            question: "'x' 模式的特点是什么？",
            options: [
                "扩展模式",
                "独占创建，文件已存在则失败",
                "十六进制模式",
                "只读模式",
            ],
            answer: 1,
            rationale: "文档说明：'x' 是独占创建模式，如果文件已存在会抛出异常。",
        },
        {
            id: "py-w10-1-q9",
            question: "到达文件末尾时，f.readline() 返回什么？",
            options: [
                "None",
                "抛出异常",
                "空字符串 ''",
                "False",
            ],
            answer: 2,
            rationale: "文档说明：到达文件末尾时，f.readline() 返回空字符串 ''。",
        },
        {
            id: "py-w10-1-q10",
            question: "如何高效逐行读取大文件？",
            options: [
                "f.readlines()",
                "for line in f:",
                "f.read().split('\\n')",
                "while f.readline():",
            ],
            answer: 1,
            rationale: "文档推荐：for line in f 是内存高效的逐行迭代方式，不会一次加载整个文件。",
        },
        {
            id: "py-w10-1-q11",
            question: "f.seek(0) 的作用是什么？",
            options: [
                "关闭文件",
                "移动到文件开头",
                "读取第一个字符",
                "删除文件内容",
            ],
            answer: 1,
            rationale: "文档说明：f.seek(offset) 移动文件位置，seek(0) 移动到文件开头。",
        },
        {
            id: "py-w10-1-q12",
            question: "不使用 with 语句可能导致什么问题？",
            options: [
                "文件打开失败",
                "数据可能未写入磁盘",
                "读取速度变慢",
                "编码错误",
            ],
            answer: 1,
            rationale: "文档警告：写入数据可能在缓冲区中，不使用 with 可能导致数据未写入磁盘就程序结束。",
        },
    ],
    "py-w10-2": [
        {
            id: "py-w10-2-q1",
            question: "pathlib 中如何拼接路径？",
            options: [
                "path.join('a', 'b')",
                "path + '/a/b'",
                "path / 'a' / 'b'",
                "path.concat('a', 'b')",
            ],
            answer: 2,
            rationale: "文档说明：使用 / 运算符拼接路径：p / 'subdir' / 'file.txt'。",
        },
        {
            id: "py-w10-2-q2",
            question: "p.glob('*.py') 和 p.rglob('*.py') 有什么区别？",
            options: [
                "没有区别",
                "glob 只匹配当前目录，rglob 递归匹配所有子目录",
                "rglob 更快",
                "glob 区分大小写，rglob 不区分",
            ],
            answer: 1,
            rationale: "文档说明：glob() 只匹配当前目录；rglob() 递归匹配所有子目录，等价于 glob('**/*.py')。",
        },
        {
            id: "py-w10-2-q3",
            question: "p.name 返回什么？",
            options: [
                "完整路径",
                "文件名（最后一个路径组件）",
                "目录名",
                "文件大小",
            ],
            answer: 1,
            rationale: "文档说明：p.name 返回路径的最后一个组件（文件名或目录名）。",
        },
        {
            id: "py-w10-2-q4",
            question: "如何创建目录及其所有父目录？",
            options: [
                "p.mkdir()",
                "p.mkdir(parents=True)",
                "p.makedirs()",
                "p.create_all()",
            ],
            answer: 1,
            rationale: "文档说明：p.mkdir(parents=True) 创建目录及所有不存在的父目录。",
        },
        {
            id: "py-w10-2-q5",
            question: "p.read_text() 的作用是什么？",
            options: [
                "打开文件进行读取",
                "直接读取并返回文件全部文本内容",
                "读取第一行",
                "检查文件是否可读",
            ],
            answer: 1,
            rationale: "文档说明：p.read_text() 是快捷方法，直接读取并返回文件的全部文本内容。",
        },
        {
            id: "py-w10-2-q6",
            question: "Path.cwd() 返回什么？",
            options: [
                "用户主目录",
                "当前工作目录",
                "系统根目录",
                "临时目录",
            ],
            answer: 1,
            rationale: "文档说明：Path.cwd() 返回当前工作目录的 Path 对象。",
        },
        {
            id: "py-w10-2-q7",
            question: "p.suffix 返回什么？",
            options: [
                "文件名",
                "文件扩展名（如 '.txt'）",
                "不含扩展名的文件名",
                "父目录",
            ],
            answer: 1,
            rationale: "文档说明：p.suffix 返回文件的扩展名，如 '.txt'、'.py'。",
        },
        {
            id: "py-w10-2-q8",
            question: "p.resolve() 的作用是什么？",
            options: [
                "删除文件",
                "解析为绝对路径并消除 .. 和符号链接",
                "检查路径是否存在",
                "重命名文件",
            ],
            answer: 1,
            rationale: "文档说明：p.resolve() 解析为绝对路径，消除 .. 和符号链接。",
        },
        {
            id: "py-w10-2-q9",
            question: "如何检查路径是否是文件？",
            options: [
                "p.isfile()",
                "p.is_file()",
                "p.file()",
                "isfile(p)",
            ],
            answer: 1,
            rationale: "文档说明：p.is_file() 检查路径是否指向一个普通文件。",
        },
        {
            id: "py-w10-2-q10",
            question: "p.iterdir() 返回什么？",
            options: [
                "文件列表",
                "目录内容的迭代器",
                "子目录数量",
                "文件名字符串",
            ],
            answer: 1,
            rationale: "文档说明：p.iterdir() 返回目录内容的迭代器，每个元素是 Path 对象。",
        },
        {
            id: "py-w10-2-q11",
            question: "p.stem 和 p.name 有什么区别？",
            options: [
                "没有区别",
                "stem 不含后缀，name 含后缀",
                "stem 含后缀，name 不含后缀",
                "stem 是父目录",
            ],
            answer: 1,
            rationale: "文档说明：p.stem 是不含后缀的文件名，p.name 是完整文件名（含后缀）。",
        },
        {
            id: "py-w10-2-q12",
            question: "Glob 模式中 ** 的含义是什么？",
            options: [
                "匹配两个字符",
                "匹配任意数量的目录层级",
                "匹配隐藏文件",
                "区分大小写",
            ],
            answer: 1,
            rationale: "文档说明：** 匹配任意数量的目录层级，用于递归搜索。",
        },
    ],
    "py-w10-3": [
        {
            id: "py-w10-3-q1",
            question: "json.dumps() 和 json.dump() 有什么区别？",
            options: [
                "没有区别",
                "dumps 返回字符串，dump 写入文件",
                "dump 返回字符串，dumps 写入文件",
                "dumps 更快",
            ],
            answer: 1,
            rationale: "文档说明：json.dumps() 返回 JSON 字符串，json.dump() 写入文件对象。",
        },
        {
            id: "py-w10-3-q2",
            question: "Python list 序列化为 JSON 什么类型？",
            options: [
                "object",
                "array",
                "string",
                "list",
            ],
            answer: 1,
            rationale: "文档类型映射：Python list 和 tuple 都序列化为 JSON array。",
        },
        {
            id: "py-w10-3-q3",
            question: "如何美化 JSON 输出？",
            options: [
                "json.dumps(obj, pretty=True)",
                "json.dumps(obj, indent=4)",
                "json.pretty(obj)",
                "json.format(obj)",
            ],
            answer: 1,
            rationale: "文档示例：json.dumps(obj, indent=4) 使用 indent 参数缩进美化输出。",
        },
        {
            id: "py-w10-3-q4",
            question: "ensure_ascii=False 的作用是什么？",
            options: [
                "禁用 ASCII 编码",
                "保留非 ASCII 字符不转义",
                "强制 ASCII 编码",
                "忽略编码错误",
            ],
            answer: 1,
            rationale: "文档说明：ensure_ascii=True（默认）会转义非 ASCII 字符；False 保留原字符。",
        },
        {
            id: "py-w10-3-q5",
            question: "如何处理 datetime 等无法直接序列化的类型？",
            options: [
                "无法处理",
                "使用 default 参数指定处理函数",
                "先转换为字符串再序列化",
                "使用 json.datetime()",
            ],
            answer: 1,
            rationale: "文档说明：使用 default 参数指定处理函数，如 json.dumps(obj, default=str)。",
        },
        {
            id: "py-w10-3-q6",
            question: "Python None 序列化为 JSON 什么？",
            options: [
                "null",
                "None",
                "\"None\"",
                "undefined",
            ],
            answer: 0,
            rationale: "文档类型映射：Python None 序列化为 JSON null。",
        },
        {
            id: "py-w10-3-q7",
            question: "object_hook 参数的作用是什么？",
            options: [
                "自定义编码",
                "为每个解码的 dict 调用，可用于对象重建",
                "验证 JSON 格式",
                "处理编码错误",
            ],
            answer: 1,
            rationale: "文档说明：object_hook 为每个解码的 dict 调用，可用于将 dict 转换为自定义对象。",
        },
        {
            id: "py-w10-3-q8",
            question: "Python tuple 序列化后再反序列化会变成什么？",
            options: [
                "tuple",
                "list",
                "dict",
                "抛出错误",
            ],
            answer: 1,
            rationale: "Python tuple 序列化为 JSON array，反序列化时变成 Python list，类型信息丢失。",
        },
        {
            id: "py-w10-3-q9",
            question: "sort_keys=True 的作用是什么？",
            options: [
                "按值排序",
                "按键字母顺序排序",
                "按插入顺序",
                "随机排序",
            ],
            answer: 1,
            rationale: "文档说明：sort_keys=True 按字典键的字母顺序排序输出。",
        },
        {
            id: "py-w10-3-q10",
            question: "JSON 解码时如何用 Decimal 代替 float？",
            options: [
                "json.loads(s, float=Decimal)",
                "json.loads(s, parse_float=Decimal)",
                "json.loads(s, type_float=Decimal)",
                "无法实现",
            ],
            answer: 1,
            rationale: "文档说明：parse_float 参数可自定义浮点数解析函数，如 parse_float=Decimal。",
        },
        {
            id: "py-w10-3-q11",
            question: "json 模块能处理循环引用吗？",
            options: [
                "能",
                "不能，会抛出 ValueError",
                "能，自动忽略",
                "能，转换为 null",
            ],
            answer: 1,
            rationale: "文档说明：json 不支持循环引用的数据结构，会抛出 ValueError。",
        },
        {
            id: "py-w10-3-q12",
            question: "如何继承 JSONEncoder 自定义编码？",
            options: [
                "重写 encode() 方法",
                "重写 default() 方法",
                "重写 serialize() 方法",
                "重写 __init__() 方法",
            ],
            answer: 1,
            rationale: "文档示例：继承 JSONEncoder 并重写 default() 方法处理自定义类型。",
        },
    ],
    "py-w10-4": [
        {
            id: "py-w10-4-q1",
            question: "pickle 的主要安全风险是什么？",
            options: [
                "数据可能损坏",
                "恶意数据可执行任意代码",
                "只支持小文件",
                "不支持加密",
            ],
            answer: 1,
            rationale: "文档警告：pickle 不安全，恶意 pickle 数据可在反序列化时执行任意代码。",
        },
        {
            id: "py-w10-4-q2",
            question: "以下哪个不能被 pickle？",
            options: [
                "dict",
                "顶层函数",
                "lambda 函数",
                "类实例",
            ],
            answer: 2,
            rationale: "文档说明：lambda 函数、局部函数、打开的文件对象等不能被 pickle。",
        },
        {
            id: "py-w10-4-q3",
            question: "__getstate__() 方法的作用是什么？",
            options: [
                "获取对象类型",
                "返回要序列化的状态，可排除不可序列化属性",
                "验证对象状态",
                "设置对象状态",
            ],
            answer: 1,
            rationale: "文档说明：__getstate__() 返回要序列化的状态，可用于排除不可序列化的属性如文件对象。",
        },
        {
            id: "py-w10-4-q4",
            question: "打开 CSV 文件应使用什么 newline 参数？",
            options: [
                "newline='\\n'",
                "newline=''",
                "newline=None",
                "不需要指定",
            ],
            answer: 1,
            rationale: "文档强调：打开 CSV 文件应使用 newline=''，避免换行符处理问题。",
        },
        {
            id: "py-w10-4-q5",
            question: "csv.DictReader 和 csv.reader 有什么区别？",
            options: [
                "没有区别",
                "DictReader 将每行解析为字典，reader 解析为列表",
                "DictReader 更快",
                "reader 支持更多格式",
            ],
            answer: 1,
            rationale: "文档说明：reader 返回字符串列表，DictReader 将每行映射为字典（键来自表头）。",
        },
        {
            id: "py-w10-4-q6",
            question: "pickle.HIGHEST_PROTOCOL 的作用是什么？",
            options: [
                "最安全的协议",
                "使用最新可用的协议版本",
                "最兼容的协议",
                "最小文件大小",
            ],
            answer: 1,
            rationale: "文档说明：pickle.HIGHEST_PROTOCOL 是当前 Python 版本支持的最新协议版本。",
        },
        {
            id: "py-w10-4-q7",
            question: "什么时候应该用 json 而不是 pickle？",
            options: [
                "需要序列化自定义类时",
                "需要跨语言或处理不信任数据时",
                "文件很大时",
                "需要保留类型信息时",
            ],
            answer: 1,
            rationale: "文档建议：json 是安全的跨语言格式，处理不信任数据时应使用 json 而非 pickle。",
        },
        {
            id: "py-w10-4-q8",
            question: "csv.DictWriter 需要什么必需参数？",
            options: [
                "只需要文件对象",
                "文件对象和 fieldnames",
                "只需要 fieldnames",
                "文件对象和 delimiter",
            ],
            answer: 1,
            rationale: "文档说明：DictWriter 需要文件对象和 fieldnames 参数来确定列的顺序。",
        },
        {
            id: "py-w10-4-q9",
            question: "tomllib 模块能写入 TOML 文件吗？",
            options: [
                "能",
                "不能，只支持读取",
                "只能追加",
                "只能更新",
            ],
            answer: 1,
            rationale: "文档说明：tomllib 只支持读取 TOML 文件，不支持写入。写入需要第三方库如 tomli-w。",
        },
        {
            id: "py-w10-4-q10",
            question: "__setstate__(state) 什么时候被调用？",
            options: [
                "序列化时",
                "反序列化时，用于恢复对象状态",
                "对象创建时",
                "对象销毁时",
            ],
            answer: 1,
            rationale: "文档说明：__setstate__(state) 在反序列化时被调用，用于从状态恢复对象。",
        },
        {
            id: "py-w10-4-q11",
            question: "csv.writer.writerow() 接受什么参数？",
            options: [
                "字符串",
                "字典",
                "可迭代对象（如列表）",
                "单个值",
            ],
            answer: 2,
            rationale: "文档说明：writerow(row) 接受可迭代对象，将其元素作为一行写入。",
        },
        {
            id: "py-w10-4-q12",
            question: "DictWriter.writeheader() 的作用是什么？",
            options: [
                "写入数据行",
                "写入 fieldnames 作为表头行",
                "验证表头",
                "读取表头",
            ],
            answer: 1,
            rationale: "文档说明：writeheader() 将 fieldnames 作为 CSV 文件的表头行写入。",
        },
    ],
}
