import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week6Guides: Record<string, LessonGuide> = {
    "py-w6-1": {
        lessonId: "py-w6-1",
        background: [
            "【函数定义语法】官方文档：使用 def 关键字定义函数，后跟函数名和圆括号内的参数列表。函数体从下一行开始，必须缩进。语法：def func_name(params): suite。",
            "【return 语句】return 语句返回函数的值。不含 return 的函数返回 None，执行到函数末尾也返回 None。return 可以返回任何 Python 对象。",
            "【docstring 文档字符串】函数体的第一条语句可以是字符串字面值，这就是函数的 docstring。约定：首行是简洁摘要，以句号结尾；多行 docstring 中第二行应为空行。",
            "【函数对象】Python 函数是一等公民：函数定义在当前作用域中将函数名与函数对象关联。函数可以赋值给变量、作为参数传递、作为返回值返回。",
            "【函数注解】Python 3 支持函数注解：def f(ham: str, eggs: str = 'eggs') -> str。注解存储在 __annotations__ 字典中，不影响运行时行为。",
        ],
        keyDifficulties: [
            "【函数体缩进】Python 使用缩进标识代码块，函数体必须缩进。混用 Tab 和空格会导致 IndentationError。建议使用 4 个空格缩进。",
            "【docstring 访问】docstring 可通过 function.__doc__ 属性访问。自动文档生成工具依赖 docstring，编写好的 docstring 是专业代码的标志。",
            "【None 返回值】没有 return 语句或 return 不带值都返回 None。这是 Python 的设计选择，任何函数都有返回值。",
            "【函数名称重绑定】函数名只是指向函数对象的引用，可以重新赋值：f = another_func。这允许动态替换函数行为。",
        ],
        handsOnPath: [
            "1. 定义简单函数：def greet(name): return f'Hello, {name}'",
            "2. 编写带 docstring 的函数：def add(a, b):\n    '''Return the sum of a and b.'''\n    return a + b",
            "3. 测试函数对象：print(add); f = add; print(f(1, 2))",
            "4. 查看 docstring：print(add.__doc__)",
            "5. 添加函数注解：def greet(name: str) -> str: return f'Hello, {name}'",
            "6. 查看注解：print(greet.__annotations__)",
        ],
        selfCheck: [
            "函数没有 return 语句返回什么？",
            "docstring 应该写在函数的什么位置？",
            "如何访问函数的 docstring？",
            "函数注解存储在哪个属性中？",
            "Python 中函数是一等公民是什么意思？",
            "如何检查一个对象是否是函数？",
        ],
        extensions: [
            "学习 inspect 模块获取函数签名和源码",
            "了解 functools.wraps 保留被装饰函数的元信息",
            "探索 typing 模块的类型提示",
            "学习 PEP 257 docstring 规范",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/controlflow.html#defining-functions",
            "https://docs.python.org/3/reference/compound_stmts.html#function-definitions",
            "https://docs.python.org/3/tutorial/controlflow.html#documentation-strings",
        ],
    },
    "py-w6-2": {
        lessonId: "py-w6-2",
        background: [
            "【默认参数值】默认值在函数定义时（而非调用时）求值，在定义所在的作用域中进行。语法：def func(a, b=10)。有默认值的参数必须在无默认值参数之后。",
            "【关键字参数】函数调用时可以使用 kwarg=value 形式。关键字参数必须在位置参数之后，关键字参数的顺序不重要。",
            "【*args 可变位置参数】*args 接收任意数量的位置参数，被包装成元组。通常放在参数列表最后，*args 之后的参数变为关键字专用。",
            "【**kwargs 可变关键字参数】**kwargs 接收任意数量的关键字参数，被包装成字典。关键字参数的顺序与调用时提供的顺序一致。",
            "【位置专用与关键字专用】/ 之前是位置专用参数（只能按位置传递），* 之后是关键字专用参数（只能按关键字传递）。完整语法：def f(pos_only, /, pos_or_kwd, *, kwd_only)。",
        ],
        keyDifficulties: [
            "【可变默认参数陷阱】默认值仅求值一次，可变对象（如列表）作为默认值会在调用间共享。解决方案：使用 None 作为默认值，在函数体内创建新对象。",
            "【参数顺序规则】完整参数顺序：位置专用参数、/、普通参数、*args、关键字专用参数、**kwargs。违反顺序会导致 SyntaxError。",
            "【解包参数】使用 * 解包列表/元组为位置参数：func(*args)；使用 ** 解包字典为关键字参数：func(**kwargs)。",
            "【位置专用参数应用】位置专用参数（/）用于：参数名无意义时、避免与 **kwargs 冲突、API 设计时隐藏内部参数名。",
        ],
        handsOnPath: [
            "1. 默认参数：def greet(name, greeting='Hello'): return f'{greeting}, {name}'",
            "2. 测试可变默认参数陷阱：def bad(L=[]): L.append(1); return L; print(bad(), bad())",
            "3. 修复陷阱：def good(L=None): L = L or []; L.append(1); return L",
            "4. 使用 *args：def sum_all(*args): return sum(args)",
            "5. 使用 **kwargs：def print_info(**kwargs): for k, v in kwargs.items(): print(f'{k}: {v}')",
            "6. 解包调用：args = [1, 2, 3]; print(sum_all(*args))",
        ],
        selfCheck: [
            "默认参数值在什么时候求值？",
            "为什么不应该使用可变对象作为默认参数？",
            "*args 和 **kwargs 分别包装成什么类型？",
            "/ 和 * 在参数列表中的作用是什么？",
            "如何将列表解包为函数的位置参数？",
            "关键字参数和位置参数的顺序规则是什么？",
        ],
        extensions: [
            "学习 functools.partial 固定部分参数",
            "了解 PEP 570 位置专用参数的设计动机",
            "探索 inspect.signature 获取函数签名",
            "学习 operator 模块的函数式工具",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/controlflow.html#default-argument-values",
            "https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments",
            "https://docs.python.org/3/tutorial/controlflow.html#arbitrary-argument-lists",
        ],
    },
    "py-w6-3": {
        lessonId: "py-w6-3",
        background: [
            "【LEGB 规则】Python 按 LEGB 顺序搜索名称：Local（局部）→ Enclosing（嵌套函数外层）→ Global（模块全局）→ Built-in（内置）。最先找到的绑定被使用。",
            "【命名空间】从名称到对象的映射，通常用字典实现。示例：内置名称、模块全局名称（module.__dict__）、函数局部名称。",
            "【global 语句】使列出的标识符被解释为全局变量。无 global 声明时，函数内赋值创建局部变量；使用 global 声明后，赋值修改全局变量。",
            "【nonlocal 语句】用于在嵌套函数中引用和修改外层函数的变量。如果多层嵌套中都有同名变量，使用最近的绑定。",
            "【闭包机制】内层函数可以捕获外层函数的变量，即使外层函数已返回。这使得函数可以'记住'创建时的环境。",
        ],
        keyDifficulties: [
            "【UnboundLocalError】函数内对变量赋值会使其成为局部变量。如果赋值前读取该变量，会抛出 UnboundLocalError。使用 global 或 nonlocal 可解决。",
            "【作用域静态确定】Python 在编译时确定变量作用域，而非运行时。函数内任何位置的赋值都使变量成为整个函数的局部变量。",
            "【global vs nonlocal】global 访问模块级全局变量；nonlocal 访问外层函数的局部变量。nonlocal 只能用于嵌套函数中。",
            "【闭包的后期绑定】闭包中的变量是后期绑定的，在闭包调用时查找。循环中创建闭包时要注意这个陷阱。",
        ],
        handsOnPath: [
            "1. 测试 LEGB：x = 'global'; def f(): x = 'local'; print(x); f(); print(x)",
            "2. 使用 global：x = 0; def inc(): global x; x += 1; inc(); print(x)",
            "3. 使用 nonlocal：def outer(): x = 1; def inner(): nonlocal x; x = 2; inner(); return x; print(outer())",
            "4. 闭包示例：def make_counter(): count = 0; def inc(): nonlocal count; count += 1; return count; return inc",
            "5. 测试闭包：counter = make_counter(); print(counter(), counter(), counter())",
            "6. 闭包陷阱：funcs = [lambda: i for i in range(3)]; print([f() for f in funcs])",
        ],
        selfCheck: [
            "LEGB 规则中四个字母分别代表什么？",
            "什么情况下会抛出 UnboundLocalError？",
            "global 和 nonlocal 的区别是什么？",
            "闭包是什么？有什么用途？",
            "为什么说 Python 变量作用域是静态确定的？",
            "如何在循环中正确创建闭包？",
        ],
        extensions: [
            "学习 PEP 3104 了解 nonlocal 的设计动机",
            "了解 __closure__ 属性访问闭包变量",
            "探索 locals() 和 globals() 函数",
            "学习装饰器如何利用闭包实现",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces",
            "https://docs.python.org/3/reference/simple_stmts.html#the-global-statement",
            "https://docs.python.org/3/reference/simple_stmts.html#the-nonlocal-statement",
        ],
    },
    "py-w6-4": {
        lessonId: "py-w6-4",
        background: [
            "【lambda 语法】lambda arguments: expression 创建匿名函数。lambda 只能包含一个表达式，表达式的结果自动作为返回值。",
            "【lambda 使用场景】lambda 适合简单操作：作为 sorted() 的 key 参数、作为回调函数、快速创建简单函数对象。复杂逻辑应使用 def。",
            "【map 函数】map(function, iterable) 对可迭代对象的每个元素应用函数，返回迭代器。支持多个可迭代对象：map(func, iter1, iter2)。",
            "【filter 函数】filter(function, iterable) 过滤出使 function 返回 True 的元素，返回迭代器。function 为 None 时移除所有假值。",
            "【函数式编程风格】map 和 filter 是函数式编程的基础工具，与 lambda 配合使用可以写出简洁的数据转换代码。但 Python 更推荐使用列表推导式。",
        ],
        keyDifficulties: [
            "【lambda 限制】lambda 只能包含一个表达式，不能包含语句（如 print、赋值、if 语句）。复杂逻辑必须使用 def 定义命名函数。",
            "【map/filter 返回迭代器】map() 和 filter() 返回迭代器而非列表，是惰性求值的。需要列表时使用 list() 转换。",
            "【列表推导式 vs map/filter】列表推导式 [x**2 for x in list] 比 list(map(lambda x: x**2, list)) 更 Pythonic。filter 也可用带 if 的推导式替代。",
            "【lambda 作用域】lambda 可以引用包含作用域中的变量（闭包），但要注意后期绑定问题。",
        ],
        handsOnPath: [
            "1. 基本 lambda：square = lambda x: x**2; print(square(5))",
            "2. 排序中使用：pairs = [(1, 'b'), (2, 'a')]; pairs.sort(key=lambda p: p[1])",
            "3. map 示例：list(map(lambda x: x**2, [1, 2, 3, 4]))",
            "4. filter 示例：list(filter(lambda x: x > 0, [-1, 0, 1, 2]))",
            "5. filter None：list(filter(None, [0, 1, '', 'hello', None]))",
            "6. 对比推导式：[x**2 for x in [1,2,3]] vs list(map(lambda x: x**2, [1,2,3]))",
        ],
        selfCheck: [
            "lambda 表达式可以包含几个表达式？",
            "map() 函数返回什么类型的对象？",
            "filter(None, iterable) 的作用是什么？",
            "lambda 和 def 定义的函数有什么区别？",
            "什么时候应该用列表推导式而非 map？",
            "如何用 filter 实现 [x for x in list if x > 0]？",
        ],
        extensions: [
            "学习 functools.reduce 实现归约操作",
            "了解 itertools.starmap 处理元组参数",
            "探索 operator 模块替代简单 lambda",
            "学习 toolz 库的函数式编程工具",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions",
            "https://docs.python.org/3/library/functions.html#map",
            "https://docs.python.org/3/library/functions.html#filter",
        ],
    },
}

export const week6Quizzes: Record<string, QuizQuestion[]> = {
    "py-w6-1": [
        {
            id: "py-w6-1-q1",
            question: "Python 中定义函数使用什么关键字？",
            options: [
                "function",
                "def",
                "func",
                "define",
            ],
            answer: 1,
            rationale: "Python 使用 def 关键字定义函数：def func_name(params): suite。",
        },
        {
            id: "py-w6-1-q2",
            question: "函数没有 return 语句时返回什么？",
            options: [
                "0",
                "空字符串",
                "None",
                "抛出错误",
            ],
            answer: 2,
            rationale: "文档说明：不含 return 的函数返回 None，执行到函数末尾也返回 None。",
        },
        {
            id: "py-w6-1-q3",
            question: "docstring 应该放在函数的什么位置？",
            options: [
                "函数定义之前",
                "函数体的第一条语句",
                "return 语句之后",
                "函数参数列表中",
            ],
            answer: 1,
            rationale: "文档说明：函数体的第一条语句可以是字符串字面值，这就是函数的 docstring。",
        },
        {
            id: "py-w6-1-q4",
            question: "如何访问函数的 docstring？",
            options: [
                "func.docstring",
                "func.__doc__",
                "func.doc()",
                "getdoc(func)",
            ],
            answer: 1,
            rationale: "文档示例：print(my_function.__doc__) 可以访问函数的 docstring。",
        },
        {
            id: "py-w6-1-q5",
            question: "关于 Python 函数，以下哪项是正确的？",
            options: [
                "函数不能赋值给变量",
                "函数是一等公民，可以赋值、传递、返回",
                "函数必须有返回值",
                "函数名不能重新绑定",
            ],
            answer: 1,
            rationale: "文档说明：函数定义在当前作用域中将函数名与函数对象关联，可以 f = fib 这样赋值。",
        },
        {
            id: "py-w6-1-q6",
            question: "函数注解存储在哪个属性中？",
            options: [
                "__annotations__",
                "__types__",
                "__hints__",
                "__params__",
            ],
            answer: 0,
            rationale: "文档示例：函数注解存储在 function.__annotations__ 字典中。",
        },
        {
            id: "py-w6-1-q7",
            question: "多行 docstring 的第二行应该是什么？",
            options: [
                "详细描述",
                "参数说明",
                "空行",
                "返回值说明",
            ],
            answer: 2,
            rationale: "文档规范：多行 docstring 中，第二行应为空行，用于视觉分隔。",
        },
        {
            id: "py-w6-1-q8",
            question: "def f(x: int) -> str: 中的 -> str 表示什么？",
            options: [
                "函数返回类型注解",
                "函数必须返回字符串",
                "参数类型",
                "语法错误",
            ],
            answer: 0,
            rationale: "文档说明：-> 后面是返回值类型注解，存储在 __annotations__ 中，不影响运行时。",
        },
        {
            id: "py-w6-1-q9",
            question: "以下哪种写法是正确的函数定义？",
            options: [
                "def func: pass",
                "def func() pass",
                "def func(): pass",
                "function func(): pass",
            ],
            answer: 2,
            rationale: "Python 函数定义语法：def func_name(params): suite，括号和冒号都是必需的。",
        },
        {
            id: "py-w6-1-q10",
            question: "装饰器的执行时机是什么？",
            options: [
                "函数调用时",
                "模块加载时",
                "函数定义时",
                "程序退出时",
            ],
            answer: 2,
            rationale: "文档说明：Decorator expressions are evaluated when the function is defined。",
        },
        {
            id: "py-w6-1-q11",
            question: "docstring 的首行应该如何编写？",
            options: [
                "详细描述所有参数",
                "简洁摘要，以句号结尾",
                "列出所有可能的返回值",
                "包含使用示例",
            ],
            answer: 1,
            rationale: "文档规范：首行应是简洁的摘要，以大写字母开头，以句号结尾。",
        },
        {
            id: "py-w6-1-q12",
            question: "return 不带值等价于什么？",
            options: [
                "return 0",
                "return ''",
                "return None",
                "不返回任何值",
            ],
            answer: 2,
            rationale: "文档说明：return 不带值等价于 return None。",
        },
    ],
    "py-w6-2": [
        {
            id: "py-w6-2-q1",
            question: "默认参数值在什么时候求值？",
            options: [
                "每次函数调用时",
                "函数定义时",
                "模块导入时",
                "程序启动时",
            ],
            answer: 1,
            rationale: "文档强调：默认值在函数定义时（而非调用时）求值，仅求值一次。",
        },
        {
            id: "py-w6-2-q2",
            question: "以下哪个是可变默认参数陷阱的正确修复？",
            options: [
                "def f(L=[]): L.append(1)",
                "def f(L=None): L = L or []; L.append(1)",
                "def f(L=list()): L.append(1)",
                "def f(L={}): L.append(1)",
            ],
            answer: 1,
            rationale: "文档推荐：使用 None 作为默认值，在函数体内创建新对象。",
        },
        {
            id: "py-w6-2-q3",
            question: "*args 参数被包装成什么类型？",
            options: [
                "列表",
                "字典",
                "元组",
                "集合",
            ],
            answer: 2,
            rationale: "文档说明：*args 接收任意数量的位置参数，被包装成元组。",
        },
        {
            id: "py-w6-2-q4",
            question: "**kwargs 参数被包装成什么类型？",
            options: [
                "列表",
                "字典",
                "元组",
                "集合",
            ],
            answer: 1,
            rationale: "文档说明：**kwargs 接收任意数量的关键字参数，被包装成字典。",
        },
        {
            id: "py-w6-2-q5",
            question: "def f(a, /, b, *, c): pass 中，参数 b 可以如何传递？",
            options: [
                "只能按位置传递",
                "只能按关键字传递",
                "可以按位置或关键字传递",
                "只能使用默认值",
            ],
            answer: 2,
            rationale: "/ 之后、* 之前的参数是普通参数，可以按位置或关键字传递。",
        },
        {
            id: "py-w6-2-q6",
            question: "def f(a, /, b, *, c): pass 中，参数 c 可以如何传递？",
            options: [
                "只能按位置传递",
                "只能按关键字传递",
                "可以按位置或关键字传递",
                "两种都不行",
            ],
            answer: 1,
            rationale: "文档说明：* 之后的参数是关键字专用参数，只能按关键字传递。",
        },
        {
            id: "py-w6-2-q7",
            question: "如何将列表 [1, 2, 3] 解包为函数的位置参数？",
            options: [
                "func([1, 2, 3])",
                "func(*[1, 2, 3])",
                "func(**[1, 2, 3])",
                "func(&[1, 2, 3])",
            ],
            answer: 1,
            rationale: "文档示例：使用 * 解包列表/元组为位置参数：list(range(*args))。",
        },
        {
            id: "py-w6-2-q8",
            question: "关键字参数必须放在什么位置？",
            options: [
                "位置参数之前",
                "位置参数之后",
                "可以任意位置",
                "必须放在最后",
            ],
            answer: 1,
            rationale: "文档说明：关键字参数必须在位置参数之后。",
        },
        {
            id: "py-w6-2-q9",
            question: "def f(a, b=[]): b.append(a) 调用两次 f(1) 和 f(2) 后 b 是什么？",
            options: [
                "[1] 和 [2]",
                "[1, 2] 和 [1, 2]",
                "[1] 和 [1, 2]",
                "抛出错误",
            ],
            answer: 2,
            rationale: "默认值只求值一次，可变对象在调用间共享。第一次 [1]，第二次 [1, 2]。",
        },
        {
            id: "py-w6-2-q10",
            question: "*args 之后的参数有什么特点？",
            options: [
                "成为位置专用参数",
                "成为关键字专用参数",
                "不能有默认值",
                "必须是 **kwargs",
            ],
            answer: 1,
            rationale: "文档说明：*args 之后的参数变为关键字专用参数。",
        },
        {
            id: "py-w6-2-q11",
            question: "以下哪个调用是正确的？def f(a, /, b): pass",
            options: [
                "f(a=1, b=2)",
                "f(1, b=2)",
                "f(b=2, 1)",
                "f(1, 2, 3)",
            ],
            answer: 1,
            rationale: "/ 之前的参数 a 是位置专用的，只能按位置传递。f(1, b=2) 是正确的。",
        },
        {
            id: "py-w6-2-q12",
            question: "参数列表的正确顺序是什么？",
            options: [
                "**kwargs, *args, 普通参数",
                "普通参数, *args, **kwargs",
                "*args, **kwargs, 普通参数",
                "**kwargs, 普通参数, *args",
            ],
            answer: 1,
            rationale: "文档说明：正确顺序是位置专用、/、普通参数、*args、关键字专用、**kwargs。",
        },
    ],
    "py-w6-3": [
        {
            id: "py-w6-3-q1",
            question: "LEGB 规则中的 E 代表什么？",
            options: [
                "External（外部）",
                "Enclosing（嵌套外层）",
                "Environment（环境）",
                "Execution（执行）",
            ],
            answer: 1,
            rationale: "LEGB: Local（局部）、Enclosing（嵌套函数外层）、Global（全局）、Built-in（内置）。",
        },
        {
            id: "py-w6-3-q2",
            question: "global 语句的作用是什么？",
            options: [
                "创建全局变量",
                "声明变量在全局作用域中",
                "导出变量到其他模块",
                "删除全局变量",
            ],
            answer: 1,
            rationale: "文档说明：global 语句使列出的标识符被解释为全局变量，允许对其赋值。",
        },
        {
            id: "py-w6-3-q3",
            question: "nonlocal 语句用于什么场景？",
            options: [
                "访问全局变量",
                "访问内置变量",
                "在嵌套函数中访问外层函数的变量",
                "创建新的命名空间",
            ],
            answer: 2,
            rationale: "文档说明：nonlocal 用于在嵌套函数中引用和修改外层函数（非全局）的变量。",
        },
        {
            id: "py-w6-3-q4",
            question: "以下代码输出什么？x = 'global'; def f(): x = 'local'; print(x); f()",
            options: [
                "global",
                "local",
                "抛出错误",
                "None",
            ],
            answer: 1,
            rationale: "函数内赋值创建局部变量，print(x) 输出局部变量 'local'。",
        },
        {
            id: "py-w6-3-q5",
            question: "什么情况下会抛出 UnboundLocalError？",
            options: [
                "访问不存在的全局变量",
                "函数内赋值前读取同名变量",
                "使用 nonlocal 声明不存在的变量",
                "在模块级别使用 global",
            ],
            answer: 1,
            rationale: "函数内对变量赋值会使其成为局部变量，如果赋值前读取该变量，抛出 UnboundLocalError。",
        },
        {
            id: "py-w6-3-q6",
            question: "Python 什么时候确定变量作用域？",
            options: [
                "运行时",
                "编译时",
                "导入时",
                "调用时",
            ],
            answer: 1,
            rationale: "文档说明：Python 在编译时确定变量作用域，而非运行时。这是静态作用域。",
        },
        {
            id: "py-w6-3-q7",
            question: "闭包是什么？",
            options: [
                "关闭的函数",
                "捕获外层变量的内层函数",
                "被删除的函数",
                "没有返回值的函数",
            ],
            answer: 1,
            rationale: "闭包是指内层函数捕获外层函数的变量，即使外层函数已返回，变量仍然可用。",
        },
        {
            id: "py-w6-3-q8",
            question: "nonlocal 语句可以用在什么地方？",
            options: [
                "任何函数中",
                "只能在嵌套函数中",
                "只能在模块级别",
                "只能在类中",
            ],
            answer: 1,
            rationale: "文档说明：nonlocal 只能用于嵌套函数中，用于访问外层函数的局部变量。",
        },
        {
            id: "py-w6-3-q9",
            question: "命名空间通常用什么数据结构实现？",
            options: [
                "列表",
                "元组",
                "字典",
                "集合",
            ],
            answer: 2,
            rationale: "文档说明：命名空间是从名称到对象的映射，通常用字典实现。",
        },
        {
            id: "py-w6-3-q10",
            question: "x = 1; def f(): global x; x = 2; f() 后 x 的值是？",
            options: [
                "1",
                "2",
                "抛出错误",
                "None",
            ],
            answer: 1,
            rationale: "使用 global 声明后，函数内的赋值修改全局变量，x 变为 2。",
        },
        {
            id: "py-w6-3-q11",
            question: "闭包变量的绑定时机是什么？",
            options: [
                "闭包定义时",
                "外层函数返回时",
                "闭包调用时",
                "模块加载时",
            ],
            answer: 2,
            rationale: "闭包中的变量是后期绑定的，在闭包调用时查找，而非定义时。",
        },
        {
            id: "py-w6-3-q12",
            question: "以下哪个是获取全局命名空间的方法？",
            options: [
                "namespace()",
                "globals()",
                "global_vars()",
                "get_global()",
            ],
            answer: 1,
            rationale: "Python 内置函数 globals() 返回当前全局命名空间的字典。",
        },
    ],
    "py-w6-4": [
        {
            id: "py-w6-4-q1",
            question: "lambda 表达式可以包含几个表达式？",
            options: [
                "任意多个",
                "只能一个",
                "最多三个",
                "至少两个",
            ],
            answer: 1,
            rationale: "文档说明：lambda 只能包含一个表达式，表达式的结果自动作为返回值。",
        },
        {
            id: "py-w6-4-q2",
            question: "lambda x, y: x + y 的返回值是什么？",
            options: [
                "None",
                "x + y 的结果",
                "需要显式 return",
                "抛出错误",
            ],
            answer: 1,
            rationale: "lambda 表达式的结果自动作为返回值，不需要（也不能）使用 return。",
        },
        {
            id: "py-w6-4-q3",
            question: "map(func, iterable) 返回什么类型？",
            options: [
                "列表",
                "元组",
                "迭代器",
                "生成器",
            ],
            answer: 2,
            rationale: "文档说明：map() 返回一个迭代器（iterator），是惰性求值的。",
        },
        {
            id: "py-w6-4-q4",
            question: "filter(None, iterable) 的作用是什么？",
            options: [
                "返回所有元素",
                "移除所有元素",
                "移除所有假值元素",
                "抛出错误",
            ],
            answer: 2,
            rationale: "文档说明：function 为 None 时，移除所有假值元素（False, None, 0, '', [] 等）。",
        },
        {
            id: "py-w6-4-q5",
            question: "以下哪个是 lambda 不能做的？",
            options: [
                "作为 sorted 的 key 参数",
                "包含 if-else 表达式",
                "包含多条语句",
                "引用外层变量",
            ],
            answer: 2,
            rationale: "文档说明：lambda 只能包含一个表达式，不能包含语句。",
        },
        {
            id: "py-w6-4-q6",
            question: "list(map(lambda x: x**2, [1, 2, 3])) 的结果是？",
            options: [
                "[1, 2, 3]",
                "[1, 4, 9]",
                "[[1], [4], [9]]",
                "(1, 4, 9)",
            ],
            answer: 1,
            rationale: "map 对每个元素应用 lambda，[1, 2, 3] 变成 [1, 4, 9]。",
        },
        {
            id: "py-w6-4-q7",
            question: "list(filter(lambda x: x > 0, [-1, 0, 1, 2])) 的结果是？",
            options: [
                "[-1, 0, 1, 2]",
                "[1, 2]",
                "[0, 1, 2]",
                "[-1]",
            ],
            answer: 1,
            rationale: "filter 过滤出 x > 0 的元素，结果是 [1, 2]。",
        },
        {
            id: "py-w6-4-q8",
            question: "[x**2 for x in list] 等价于什么？",
            options: [
                "filter(lambda x: x**2, list)",
                "list(map(lambda x: x**2, list))",
                "reduce(lambda x: x**2, list)",
                "sorted(list, key=lambda x: x**2)",
            ],
            answer: 1,
            rationale: "列表推导式 [x**2 for x in list] 等价于 list(map(lambda x: x**2, list))。",
        },
        {
            id: "py-w6-4-q9",
            question: "sorted(pairs, key=lambda p: p[1]) 按什么排序？",
            options: [
                "按元组第一个元素",
                "按元组第二个元素",
                "按元组长度",
                "按元组总和",
            ],
            answer: 1,
            rationale: "文档示例：key=lambda pair: pair[1] 按每个元组的第二个元素排序。",
        },
        {
            id: "py-w6-4-q10",
            question: "map 函数处理多个可迭代对象时，什么时候停止？",
            options: [
                "最长的迭代完",
                "最短的迭代完",
                "所有迭代完",
                "抛出错误",
            ],
            answer: 1,
            rationale: "文档说明：With multiple iterables, stops when the shortest is exhausted。",
        },
        {
            id: "py-w6-4-q11",
            question: "lambda 和 def 函数的主要区别是什么？",
            options: [
                "lambda 更快",
                "lambda 只能有一个表达式，不能有语句",
                "def 不能返回函数",
                "lambda 不能有参数",
            ],
            answer: 1,
            rationale: "文档说明：lambda 只能包含一个表达式；复杂逻辑应使用 def 定义命名函数。",
        },
        {
            id: "py-w6-4-q12",
            question: "以下哪种方式更 Pythonic？",
            options: [
                "list(map(lambda x: x**2, range(10)))",
                "[x**2 for x in range(10)]",
                "for x in range(10): result.append(x**2)",
                "map(pow, range(10), [2]*10)",
            ],
            answer: 1,
            rationale: "文档和 PEP 8 推荐：列表推导式比 map + lambda 更 Pythonic、更易读。",
        },
    ],
}
