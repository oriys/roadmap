import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week15Guides: Record<string, LessonGuide> = {
    "py-w15-1": {
        lessonId: "py-w15-1",
        background: [
            "【模块定义】模块是包含 Python 定义和语句的文件，文件名为模块名加 .py 后缀。模块可以包含可执行语句和函数定义。",
            "【import 语法】import module 导入整个模块；from module import name 导入特定对象；import module as alias 使用别名。",
            "【__name__ 变量】每个模块都有 __name__ 全局变量。作为脚本执行时为 '__main__'，作为模块导入时为模块名。",
            "【模块搜索路径】Python 按顺序搜索：内置模块、sys.path 中的目录（包括脚本目录、PYTHONPATH、site-packages）。",
            "【已编译模块】Python 将编译版本缓存到 __pycache__ 目录，命名格式为 module.cpython-version.pyc，加快加载速度。",
        ],
        keyDifficulties: [
            "【from import * 风险】from module import * 导入所有名称，但忽略下划线开头的名称，不推荐在生产代码中使用。",
            "【__all__ 控制导出】在模块中定义 __all__ 列表，控制 from module import * 导入的名称。未定义则导入所有公开名称。",
            "【重新加载模块】模块只导入一次，修改后需要 importlib.reload(module) 重新加载。交互式调试时常用。",
            "【sys.modules 缓存】导入的模块缓存在 sys.modules 中。删除缓存条目可强制重新导入。",
        ],
        handsOnPath: [
            "1. 创建模块：# mymodule.py\\ndef greet(name): return f'Hello {name}'",
            "2. 导入模块：import mymodule; mymodule.greet('Alice')",
            "3. from 导入：from mymodule import greet; greet('Bob')",
            "4. 检查 __name__：if __name__ == '__main__': main()",
            "5. 查看搜索路径：import sys; print(sys.path)",
            "6. 重新加载：import importlib; importlib.reload(mymodule)",
        ],
        selfCheck: [
            "模块和脚本有什么区别？",
            "__name__ 变量在不同情况下的值是什么？",
            "Python 按什么顺序搜索模块？",
            "__all__ 变量的作用是什么？",
            "如何重新加载已修改的模块？",
            ".pyc 文件存储在哪里？",
        ],
        extensions: [
            "学习 importlib 模块的高级功能",
            "了解导入钩子自定义导入行为",
            "探索 __import__ 函数的用法",
            "学习延迟导入优化启动时间",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/modules.html",
            "https://docs.python.org/3/reference/import.html",
            "https://docs.python.org/3/tutorial/modules.html#importing-from-a-package",
        ],
    },
    "py-w15-2": {
        lessonId: "py-w15-2",
        background: [
            "【包定义】包是包含 __init__.py 文件的目录。__init__.py 可以为空，也可以包含初始化代码。",
            "【包导入】import package.module 导入子模块；from package import module 导入特定模块；__init__.py 在包导入时执行。",
            "【命名空间包】PEP 420 引入的隐式命名空间包，无需 __init__.py，可以跨多个目录分布。",
            "【__path__ 属性】包有 __path__ 属性，列出包的搜索路径。命名空间包的 __path__ 动态计算。",
            "【相对导入】from . import module 当前包；from .. import module 父包；from ..sibling import module 兄弟包。",
        ],
        keyDifficulties: [
            "【__init__.py 作用】__init__.py 定义包的公开 API，可以从子模块导入名称到包级别，简化外部导入。",
            "【命名空间包特点】命名空间包没有 __init__.py，__path__ 动态更新，允许多个目录贡献同一包。",
            "【相对导入限制】主模块（__name__ == '__main__'）不能使用相对导入，必须使用绝对导入。",
            "【包 vs 模块】包是特殊的模块（有 __path__），可以包含子模块和子包。",
        ],
        handsOnPath: [
            "1. 创建包结构：mypackage/__init__.py, mypackage/module1.py",
            "2. __init__.py：from .module1 import func1  # 提升到包级别",
            "3. 导入包：from mypackage import func1",
            "4. 相对导入：from . import module2  # 在包内使用",
            "5. 命名空间包：无需 __init__.py 的目录结构",
            "6. 检查包路径：import mypackage; print(mypackage.__path__)",
        ],
        selfCheck: [
            "__init__.py 文件的作用是什么？",
            "命名空间包和普通包有什么区别？",
            "相对导入的语法是什么？",
            "为什么主模块不能用相对导入？",
            "__path__ 属性的作用是什么？",
            "如何将子模块的名称提升到包级别？",
        ],
        extensions: [
            "学习 pkgutil 模块扩展包路径",
            "了解 setuptools 的包发现功能",
            "探索 __init__.py 的最佳实践",
            "学习插件系统的包设计",
        ],
        sourceUrls: [
            "https://docs.python.org/3/tutorial/modules.html#packages",
            "https://docs.python.org/3/reference/import.html#namespace-packages",
            "https://peps.python.org/pep-0420/",
        ],
    },
    "py-w15-3": {
        lessonId: "py-w15-3",
        background: [
            "【venv 模块】Python 内置的虚拟环境创建工具。python -m venv .venv 创建轻量级隔离环境。",
            "【激活环境】source .venv/bin/activate（Unix）或 .venv\\Scripts\\activate（Windows）激活；deactivate 退出。",
            "【环境结构】虚拟环境包含：pyvenv.cfg 配置文件、bin/ 或 Scripts/ 目录、lib/pythonX.Y/site-packages/。",
            "【隔离原理】虚拟环境有独立的 site-packages，sys.prefix 指向虚拟环境目录，与系统 Python 隔离。",
            "【pip 集成】venv 默认安装 pip。使用 pip install package 在虚拟环境中安装包。",
        ],
        keyDifficulties: [
            "【不可移动性】虚拟环境包含绝对路径，不能直接移动或复制。需要重新创建并安装依赖。",
            "【系统包访问】--system-site-packages 选项允许访问系统 site-packages，但可能导致版本冲突。",
            "【检测虚拟环境】sys.prefix != sys.base_prefix 时表示在虚拟环境中运行。",
            "【VIRTUAL_ENV 变量】激活虚拟环境时设置 VIRTUAL_ENV 环境变量，指向环境路径。",
        ],
        handsOnPath: [
            "1. 创建环境：python -m venv .venv",
            "2. 激活（Unix）：source .venv/bin/activate",
            "3. 激活（Windows）：.venv\\Scripts\\activate",
            "4. 安装包：pip install requests",
            "5. 导出依赖：pip freeze > requirements.txt",
            "6. 退出环境：deactivate",
        ],
        selfCheck: [
            "如何创建虚拟环境？",
            "虚拟环境的目录结构是什么？",
            "为什么虚拟环境不能移动？",
            "如何检测是否在虚拟环境中？",
            "--system-site-packages 选项的作用是什么？",
            "如何导出和恢复依赖？",
        ],
        extensions: [
            "学习 virtualenv 的高级功能",
            "了解 conda 环境管理",
            "探索 pyenv 管理多个 Python 版本",
            "学习 Docker 容器化 Python 环境",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/venv.html",
            "https://docs.python.org/3/tutorial/venv.html",
            "https://pip.pypa.io/en/stable/",
        ],
    },
    "py-w15-4": {
        lessonId: "py-w15-4",
        background: [
            "【pyproject.toml】PEP 517/518 引入的现代项目配置文件，统一构建系统配置和项目元数据。",
            "【build-system 表】[build-system] 声明构建依赖和构建后端。requires 列出构建所需包，build-backend 指定后端。",
            "【project 表】[project] 定义项目元数据：name、version、dependencies、optional-dependencies 等。",
            "【动态元数据】dynamic 键列出由构建工具动态生成的字段，如从 git 标签获取版本号。",
            "【依赖规范】dependencies 使用 PEP 508 格式指定依赖，支持版本约束、extras、环境标记。",
        ],
        keyDifficulties: [
            "【静态 vs 动态】静态元数据直接写在文件中；动态元数据需要声明并由构建工具提供。",
            "【构建后端选择】setuptools、flit、hatch、poetry 等都支持 pyproject.toml，各有优势。",
            "【optional-dependencies】定义可选依赖组，如 [project.optional-dependencies] dev = ['pytest']。",
            "【向后兼容】pyproject.toml 可与 setup.py、setup.cfg 共存，支持渐进迁移。",
        ],
        handsOnPath: [
            "1. 基本结构：[build-system]\\nrequires = ['setuptools']\\nbuild-backend = 'setuptools.build_meta'",
            "2. 项目元数据：[project]\\nname = 'myproject'\\nversion = '1.0.0'",
            "3. 依赖声明：dependencies = ['requests>=2.28', 'click']",
            "4. 可选依赖：[project.optional-dependencies]\\ndev = ['pytest', 'black']",
            "5. 安装可选依赖：pip install -e '.[dev]'",
            "6. 构建包：python -m build",
        ],
        selfCheck: [
            "pyproject.toml 的主要作用是什么？",
            "build-system 表包含什么内容？",
            "如何声明项目依赖？",
            "静态元数据和动态元数据的区别是什么？",
            "如何定义可选依赖组？",
            "常用的构建后端有哪些？",
        ],
        extensions: [
            "学习 poetry 的依赖管理",
            "了解 uv 高性能包管理器",
            "探索 pip-tools 锁定依赖",
            "学习发布包到 PyPI",
        ],
        sourceUrls: [
            "https://packaging.python.org/en/latest/specifications/pyproject-toml/",
            "https://packaging.python.org/en/latest/",
            "https://peps.python.org/pep-0517/",
        ],
    },
}

export const week15Quizzes: Record<string, QuizQuestion[]> = {
    "py-w15-1": [
        {
            id: "py-w15-1-q1",
            question: "Python 模块是什么？",
            options: [
                "一个类定义",
                "包含 Python 定义和语句的 .py 文件",
                "一个函数集合",
                "一个目录结构",
            ],
            answer: 1,
            rationale: "文档说明：模块是包含 Python 定义和语句的文件，文件名为模块名加 .py 后缀。",
        },
        {
            id: "py-w15-1-q2",
            question: "__name__ 变量在模块作为脚本执行时的值是什么？",
            options: [
                "模块名",
                "'__main__'",
                "None",
                "文件路径",
            ],
            answer: 1,
            rationale: "文档说明：作为脚本执行时 __name__ == '__main__'，作为模块导入时为模块名。",
        },
        {
            id: "py-w15-1-q3",
            question: "Python 搜索模块的第一个位置是哪里？",
            options: [
                "当前目录",
                "内置模块",
                "site-packages",
                "PYTHONPATH",
            ],
            answer: 1,
            rationale: "文档说明：Python 首先检查内置模块（sys.builtin_module_names），然后搜索 sys.path。",
        },
        {
            id: "py-w15-1-q4",
            question: "已编译的 .pyc 文件存储在哪里？",
            options: [
                "模块同目录",
                "__pycache__ 目录",
                "临时目录",
                "site-packages",
            ],
            answer: 1,
            rationale: "文档说明：Python 将编译版本缓存到 __pycache__ 目录。",
        },
        {
            id: "py-w15-1-q5",
            question: "from module import * 的问题是什么？",
            options: [
                "语法错误",
                "导入所有名称可能污染命名空间，不推荐使用",
                "性能很差",
                "不支持别名",
            ],
            answer: 1,
            rationale: "文档警告：from module import * 导入所有名称，不推荐在生产代码中使用。",
        },
        {
            id: "py-w15-1-q6",
            question: "__all__ 变量的作用是什么？",
            options: [
                "列出所有函数",
                "控制 from module import * 导入的名称",
                "定义模块版本",
                "指定依赖",
            ],
            answer: 1,
            rationale: "文档说明：__all__ 列表控制 from module import * 导入的名称。",
        },
        {
            id: "py-w15-1-q7",
            question: "如何重新加载已导入的模块？",
            options: [
                "import module",
                "reload(module)",
                "importlib.reload(module)",
                "del module; import module",
            ],
            answer: 2,
            rationale: "文档说明：使用 importlib.reload(module) 重新加载已修改的模块。",
        },
        {
            id: "py-w15-1-q8",
            question: "sys.modules 的作用是什么？",
            options: [
                "列出所有模块文件",
                "缓存已导入的模块",
                "定义模块搜索路径",
                "存储模块源代码",
            ],
            answer: 1,
            rationale: "文档说明：导入的模块缓存在 sys.modules 字典中，键是模块名，值是模块对象。",
        },
        {
            id: "py-w15-1-q9",
            question: "import module as alias 的作用是什么？",
            options: [
                "复制模块",
                "为模块创建别名",
                "重命名模块文件",
                "创建模块副本",
            ],
            answer: 1,
            rationale: "文档说明：as 子句为导入的模块创建别名，可以用更短的名称引用。",
        },
        {
            id: "py-w15-1-q10",
            question: ".pyc 文件的命名格式是什么？",
            options: [
                "module.pyc",
                "module.cpython-version.pyc",
                "module.compiled.pyc",
                "__module__.pyc",
            ],
            answer: 1,
            rationale: "文档说明：命名格式为 module.cpython-version.pyc，如 spam.cpython-311.pyc。",
        },
        {
            id: "py-w15-1-q11",
            question: "PYTHONPATH 环境变量的作用是什么？",
            options: [
                "指定 Python 可执行文件位置",
                "添加额外的模块搜索路径",
                "设置 Python 版本",
                "配置编译选项",
            ],
            answer: 1,
            rationale: "文档说明：PYTHONPATH 环境变量指定的目录会被添加到 sys.path 模块搜索路径中。",
        },
        {
            id: "py-w15-1-q12",
            question: "dir(module) 返回什么？",
            options: [
                "模块的文件路径",
                "模块定义的所有名称列表",
                "模块的源代码",
                "模块的依赖",
            ],
            answer: 1,
            rationale: "文档说明：dir(module) 列出模块定义的所有名称，包括变量、函数、类等。",
        },
    ],
    "py-w15-2": [
        {
            id: "py-w15-2-q1",
            question: "什么是 Python 包？",
            options: [
                "一个 .py 文件",
                "包含 __init__.py 的目录",
                "一组函数",
                "一个类",
            ],
            answer: 1,
            rationale: "文档说明：包是包含 __init__.py 文件的目录，可以包含子模块和子包。",
        },
        {
            id: "py-w15-2-q2",
            question: "__init__.py 什么时候执行？",
            options: [
                "程序启动时",
                "包被导入时",
                "模块被调用时",
                "从不执行",
            ],
            answer: 1,
            rationale: "文档说明：__init__.py 在包导入时执行，用于初始化包。",
        },
        {
            id: "py-w15-2-q3",
            question: "命名空间包的特点是什么？",
            options: [
                "必须有 __init__.py",
                "无需 __init__.py，可跨多个目录",
                "只能包含类",
                "不能有子包",
            ],
            answer: 1,
            rationale: "PEP 420 说明：命名空间包无需 __init__.py，可以跨多个目录分布。",
        },
        {
            id: "py-w15-2-q4",
            question: "from . import module 中的 . 表示什么？",
            options: [
                "当前目录",
                "当前包",
                "父包",
                "根包",
            ],
            answer: 1,
            rationale: "文档说明：. 表示当前包，.. 表示父包，用于相对导入。",
        },
        {
            id: "py-w15-2-q5",
            question: "为什么主模块不能使用相对导入？",
            options: [
                "语法不支持",
                "主模块没有包名（__name__ == '__main__'）",
                "性能原因",
                "安全原因",
            ],
            answer: 1,
            rationale: "文档说明：主模块的 __name__ 是 '__main__'，没有包上下文，必须使用绝对导入。",
        },
        {
            id: "py-w15-2-q6",
            question: "__path__ 属性的作用是什么？",
            options: [
                "模块文件路径",
                "包的搜索路径列表",
                "Python 安装路径",
                "导入路径",
            ],
            answer: 1,
            rationale: "文档说明：包有 __path__ 属性，列出包的子模块搜索路径。",
        },
        {
            id: "py-w15-2-q7",
            question: "如何在 __init__.py 中将子模块的名称提升到包级别？",
            options: [
                "import submodule",
                "from .submodule import name",
                "export name",
                "public name",
            ],
            answer: 1,
            rationale: "文档说明：在 __init__.py 中使用 from .submodule import name 将名称提升到包级别。",
        },
        {
            id: "py-w15-2-q8",
            question: "from ..sibling import module 表示什么？",
            options: [
                "从当前包导入",
                "从父包的兄弟包导入",
                "从根包导入",
                "从系统包导入",
            ],
            answer: 1,
            rationale: ".. 表示父包，..sibling 表示父包下的 sibling 子包。",
        },
        {
            id: "py-w15-2-q9",
            question: "命名空间包的 __path__ 有什么特点？",
            options: [
                "固定不变",
                "动态计算，随 sys.path 变化更新",
                "为空",
                "只有一个元素",
            ],
            answer: 1,
            rationale: "PEP 420 说明：命名空间包的 __path__ 动态计算，当 sys.path 变化时自动更新。",
        },
        {
            id: "py-w15-2-q10",
            question: "包和模块的主要区别是什么？",
            options: [
                "包更大",
                "包有 __path__ 属性，可以包含子模块",
                "包不能有函数",
                "模块不能导入",
            ],
            answer: 1,
            rationale: "文档说明：包是特殊的模块，有 __path__ 属性，可以包含子模块和子包。",
        },
        {
            id: "py-w15-2-q11",
            question: "PEP 420 引入了什么功能？",
            options: [
                "类型注解",
                "隐式命名空间包",
                "异步编程",
                "模式匹配",
            ],
            answer: 1,
            rationale: "PEP 420 引入了隐式命名空间包，允许无 __init__.py 的包结构。",
        },
        {
            id: "py-w15-2-q12",
            question: "__init__.py 可以为空吗？",
            options: [
                "不能，必须有内容",
                "可以，表示这是一个包",
                "只能在测试中为空",
                "取决于 Python 版本",
            ],
            answer: 1,
            rationale: "文档说明：__init__.py 可以为空，其存在本身就表示目录是一个包。",
        },
    ],
    "py-w15-3": [
        {
            id: "py-w15-3-q1",
            question: "如何创建虚拟环境？",
            options: [
                "pip install venv",
                "python -m venv .venv",
                "virtualenv create .venv",
                "python --venv .venv",
            ],
            answer: 1,
            rationale: "文档说明：python -m venv .venv 使用内置 venv 模块创建虚拟环境。",
        },
        {
            id: "py-w15-3-q2",
            question: "在 Unix 系统上如何激活虚拟环境？",
            options: [
                ".venv/activate",
                "source .venv/bin/activate",
                "activate .venv",
                "python .venv/activate",
            ],
            answer: 1,
            rationale: "文档说明：Unix 系统使用 source .venv/bin/activate 激活虚拟环境。",
        },
        {
            id: "py-w15-3-q3",
            question: "虚拟环境为什么不能移动？",
            options: [
                "文件太大",
                "包含绝对路径",
                "需要管理员权限",
                "缺少依赖",
            ],
            answer: 1,
            rationale: "文档警告：虚拟环境包含绝对路径，移动后激活脚本会失效。",
        },
        {
            id: "py-w15-3-q4",
            question: "如何检测是否在虚拟环境中运行？",
            options: [
                "检查 __name__",
                "sys.prefix != sys.base_prefix",
                "os.getenv('VENV')",
                "import venv",
            ],
            answer: 1,
            rationale: "文档说明：sys.prefix != sys.base_prefix 时表示在虚拟环境中运行。",
        },
        {
            id: "py-w15-3-q5",
            question: "pyvenv.cfg 文件的作用是什么？",
            options: [
                "存储安装的包",
                "虚拟环境配置文件",
                "Python 源代码",
                "日志文件",
            ],
            answer: 1,
            rationale: "文档说明：pyvenv.cfg 是配置文件，包含 home 键指向基础 Python。",
        },
        {
            id: "py-w15-3-q6",
            question: "--system-site-packages 选项的作用是什么？",
            options: [
                "安装系统包",
                "允许访问系统 site-packages",
                "使用系统 Python",
                "复制系统配置",
            ],
            answer: 1,
            rationale: "文档说明：--system-site-packages 允许虚拟环境访问系统的 site-packages 目录。",
        },
        {
            id: "py-w15-3-q7",
            question: "如何退出虚拟环境？",
            options: [
                "exit",
                "deactivate",
                "quit",
                "leave",
            ],
            answer: 1,
            rationale: "文档说明：deactivate 命令退出虚拟环境，恢复系统 Python。",
        },
        {
            id: "py-w15-3-q8",
            question: "VIRTUAL_ENV 环境变量包含什么？",
            options: [
                "Python 版本",
                "虚拟环境的路径",
                "激活脚本",
                "包列表",
            ],
            answer: 1,
            rationale: "文档说明：激活虚拟环境时设置 VIRTUAL_ENV 环境变量，值为环境路径。",
        },
        {
            id: "py-w15-3-q9",
            question: "pip freeze 的作用是什么？",
            options: [
                "冻结 pip 版本",
                "输出已安装包的列表",
                "停止 pip",
                "清除缓存",
            ],
            answer: 1,
            rationale: "pip freeze 输出已安装包及其版本，常用于生成 requirements.txt。",
        },
        {
            id: "py-w15-3-q10",
            question: "虚拟环境默认安装什么工具？",
            options: [
                "setuptools",
                "pip",
                "wheel",
                "所有选项",
            ],
            answer: 1,
            rationale: "文档说明：venv 默认安装 pip（除非使用 --without-pip 选项）。",
        },
        {
            id: "py-w15-3-q11",
            question: "--clear 选项的作用是什么？",
            options: [
                "清除缓存",
                "清空现有目录后创建虚拟环境",
                "清除日志",
                "清除配置",
            ],
            answer: 1,
            rationale: "文档说明：--clear 选项清空目标目录后创建新的虚拟环境。",
        },
        {
            id: "py-w15-3-q12",
            question: "如何恢复虚拟环境的依赖？",
            options: [
                "pip restore",
                "pip install -r requirements.txt",
                "pip recover",
                "venv restore",
            ],
            answer: 1,
            rationale: "使用 pip install -r requirements.txt 从依赖文件恢复安装包。",
        },
    ],
    "py-w15-4": [
        {
            id: "py-w15-4-q1",
            question: "pyproject.toml 是什么？",
            options: [
                "Python 源代码文件",
                "现代项目配置文件",
                "虚拟环境配置",
                "日志文件",
            ],
            answer: 1,
            rationale: "文档说明：pyproject.toml 是 PEP 517/518 引入的现代项目配置文件。",
        },
        {
            id: "py-w15-4-q2",
            question: "[build-system] 表包含什么？",
            options: [
                "项目依赖",
                "构建依赖和构建后端",
                "测试配置",
                "文档设置",
            ],
            answer: 1,
            rationale: "文档说明：[build-system] 声明构建依赖（requires）和构建后端（build-backend）。",
        },
        {
            id: "py-w15-4-q3",
            question: "project 表中哪个字段是必需的？",
            options: [
                "version",
                "name",
                "description",
                "author",
            ],
            answer: 1,
            rationale: "文档说明：只有 name 是严格必需的静态元数据。",
        },
        {
            id: "py-w15-4-q4",
            question: "dynamic 键的作用是什么？",
            options: [
                "动态导入",
                "列出由构建工具动态生成的字段",
                "动态类型检查",
                "动态加载",
            ],
            answer: 1,
            rationale: "文档说明：dynamic 键列出由构建工具动态提供的元数据字段。",
        },
        {
            id: "py-w15-4-q5",
            question: "dependencies 使用什么格式指定依赖？",
            options: [
                "JSON 格式",
                "PEP 508 格式",
                "YAML 格式",
                "XML 格式",
            ],
            answer: 1,
            rationale: "文档说明：dependencies 使用 PEP 508 格式指定依赖，支持版本约束。",
        },
        {
            id: "py-w15-4-q6",
            question: "optional-dependencies 用于什么？",
            options: [
                "可选的 Python 版本",
                "定义可选依赖组（extras）",
                "可选的构建步骤",
                "可选的配置",
            ],
            answer: 1,
            rationale: "文档说明：optional-dependencies 定义可选依赖组，如 dev、test 等。",
        },
        {
            id: "py-w15-4-q7",
            question: "如何安装可选依赖组？",
            options: [
                "pip install project[dev]",
                "pip install -e '.[dev]'",
                "pip install --optional dev",
                "pip install dev",
            ],
            answer: 1,
            rationale: "使用 pip install -e '.[dev]' 安装项目及其 dev 可选依赖组。",
        },
        {
            id: "py-w15-4-q8",
            question: "常用的构建后端有哪些？",
            options: [
                "只有 pip",
                "setuptools、flit、hatch、poetry",
                "只有 setuptools",
                "只有 poetry",
            ],
            answer: 1,
            rationale: "文档说明：setuptools、flit、hatch、poetry 等都支持作为构建后端。",
        },
        {
            id: "py-w15-4-q9",
            question: "PEP 517/518 引入了什么？",
            options: [
                "类型注解",
                "构建系统规范和 pyproject.toml",
                "异步编程",
                "模式匹配",
            ],
            answer: 1,
            rationale: "PEP 517/518 定义了构建系统接口和 pyproject.toml 配置文件规范。",
        },
        {
            id: "py-w15-4-q10",
            question: "requires 键的作用是什么？",
            options: [
                "列出运行时依赖",
                "列出构建时依赖",
                "列出测试依赖",
                "列出开发依赖",
            ],
            answer: 1,
            rationale: "文档说明：[build-system].requires 列出构建项目所需的包。",
        },
        {
            id: "py-w15-4-q11",
            question: "pyproject.toml 可以与什么共存？",
            options: [
                "只能单独使用",
                "setup.py 和 setup.cfg",
                "只能与 requirements.txt",
                "不能与任何文件共存",
            ],
            answer: 1,
            rationale: "文档说明：pyproject.toml 可与 setup.py、setup.cfg 共存，支持渐进迁移。",
        },
        {
            id: "py-w15-4-q12",
            question: "如何构建 Python 包？",
            options: [
                "pip build",
                "python -m build",
                "setup.py build",
                "make build",
            ],
            answer: 1,
            rationale: "使用 python -m build 命令根据 pyproject.toml 构建包。",
        },
    ],
}
