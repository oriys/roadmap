import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week9Guides: Record<string, LessonGuide> = {
    "py-w9-1": {
        lessonId: "py-w9-1",
        background: [
            "【__repr__ 定义】官方文档：__repr__ 被 repr() 函数调用，计算对象的'官方'字符串表示。如果可能，应返回可用于重建对象的有效 Python 表达式。",
            "【__str__ 定义】官方文档：__str__ 被 str()、print() 和默认 __format__ 调用，返回对象的'非正式'或'友好'字符串表示。",
            "【两者区别】__repr__ 面向开发者，应信息丰富且无歧义；__str__ 面向用户，可以更简洁方便。若未定义 __str__，则使用 __repr__ 作为回退。",
            "【__format__ 方法】__format__(self, format_spec) 被 format() 和 f-string 调用。format_spec 定义格式化规范，包括对齐、填充、精度等。",
            "【格式化规范】格式：[[fill]align][sign][#][0][width][grouping][.precision][type]。对齐：< 左对齐、> 右对齐、^ 居中。类型：d 整数、f 浮点、s 字符串等。",
        ],
        keyDifficulties: [
            "【返回值要求】__repr__ 和 __str__ 必须返回字符串对象。__repr__ 理想情况应返回 eval() 可执行的表达式。",
            "【回退机制】如果类定义了 __repr__ 但没有 __str__，则 __repr__ 也用于'非正式'表示。object 的默认实现调用 __repr__。",
            "【调试与显示】__repr__ 主要用于调试和日志，应该是开发者友好的；__str__ 用于用户输出，应该是人类可读的。",
            "【格式化规范复杂性】format_spec 支持嵌套替换字段，如 '{0:{fill}{align}{width}}'。不同类型有不同的格式化选项。",
        ],
        handsOnPath: [
            "1. 定义 __repr__：class Point: def __repr__(self): return f'Point({self.x}, {self.y})'",
            "2. 定义 __str__：def __str__(self): return f'({self.x}, {self.y})'",
            "3. 测试回退：class NoStr: def __repr__(self): return 'NoStr()'; print(str(NoStr()))",
            "4. 使用 format：print(f'{3.14159:.2f}'); print('{:>10}'.format('test'))",
            "5. 定义 __format__：def __format__(self, spec): return format(str(self), spec)",
            "6. 格式化对齐：print(f'{\"text\":*^20}')",
        ],
        selfCheck: [
            "__repr__ 应该返回什么样的字符串？",
            "__str__ 和 __repr__ 的设计目标有什么不同？",
            "如果类没有定义 __str__，print(obj) 会怎样？",
            "__format__ 什么时候被调用？",
            "格式化规范中 < > ^ 分别表示什么？",
            "如何在 f-string 中指定数字精度？",
        ],
        extensions: [
            "学习 reprlib 模块安全截断大对象表示",
            "了解 pprint 模块美化输出",
            "探索 __bytes__ 方法返回字节表示",
            "学习 __html__ 等特定库的表示方法",
        ],
        sourceUrls: [
            "https://docs.python.org/3/reference/datamodel.html#object.__repr__",
            "https://docs.python.org/3/reference/datamodel.html#object.__str__",
            "https://docs.python.org/3/library/string.html#formatspec",
        ],
    },
    "py-w9-2": {
        lessonId: "py-w9-2",
        background: [
            "【算术运算符】__add__、__sub__、__mul__、__truediv__、__floordiv__、__mod__、__pow__ 实现 + - * / // % ** 运算符。",
            "【反射运算符】__radd__、__rsub__ 等是反射方法。当 x + y 中 x.__add__(y) 返回 NotImplemented 时，Python 尝试 y.__radd__(x)。",
            "【就地运算符】__iadd__、__isub__ 等实现 += -= 等就地运算。应该修改 self 并返回 self（对于可变对象）。",
            "【比较运算符】__lt__、__le__、__eq__、__ne__、__gt__、__ge__ 实现 < <= == != > >= 比较。应返回 True、False 或 NotImplemented。",
            "【total_ordering】functools.total_ordering 装饰器可以从一个比较方法（加 __eq__）自动生成所有比较方法，简化实现。",
        ],
        keyDifficulties: [
            "【NotImplemented 返回】当操作数类型不支持时应返回 NotImplemented（不是抛出异常），让 Python 尝试其他方法。",
            "【反射方法优先级】当两个操作数类型不同且右操作数是左操作数的子类时，右操作数的反射方法优先调用。",
            "【__eq__ 与 __hash__】定义 __eq__ 但不定义 __hash__ 会使实例不可哈希。比较方法之间没有隐含关系，(x<y or x==y) 不自动意味着 x<=y。",
            "【total_ordering 代价】使用 total_ordering 会降低执行速度并使堆栈跟踪更复杂。性能敏感场景应直接实现所有方法。",
        ],
        handsOnPath: [
            "1. 实现 __add__：class Vector: def __add__(self, other): return Vector(self.x + other.x, self.y + other.y)",
            "2. 实现 __radd__：def __radd__(self, other): return self.__add__(other)",
            "3. 实现 __iadd__：def __iadd__(self, other): self.x += other.x; self.y += other.y; return self",
            "4. 实现比较：def __eq__(self, other): return (self.x, self.y) == (other.x, other.y)",
            "5. 使用 total_ordering：from functools import total_ordering; @total_ordering class C: ...",
            "6. 返回 NotImplemented：def __add__(self, other): if not isinstance(other, Vector): return NotImplemented",
        ],
        selfCheck: [
            "__add__ 和 __radd__ 的区别是什么？",
            "什么时候应该返回 NotImplemented？",
            "__iadd__ 应该返回什么？",
            "定义 __eq__ 对 __hash__ 有什么影响？",
            "total_ordering 需要定义哪些方法？",
            "为什么比较方法之间没有隐含关系？",
        ],
        extensions: [
            "学习 __len__、__bool__ 实现真值测试",
            "了解 __contains__ 实现 in 运算符",
            "探索 __getitem__、__setitem__ 实现索引访问",
            "学习 numbers 抽象基类定义数值类型",
        ],
        sourceUrls: [
            "https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types",
            "https://docs.python.org/3/reference/datamodel.html#object.__lt__",
            "https://docs.python.org/3/library/functools.html#functools.total_ordering",
        ],
    },
    "py-w9-3": {
        lessonId: "py-w9-3",
        background: [
            "【property 函数】property(fget, fset, fdel, doc) 返回 property 属性对象。fget 是 getter，fset 是 setter，fdel 是 deleter。",
            "【@property 装饰器】@property 将方法变成只读属性。同名方法上使用 @attr.setter 和 @attr.deleter 添加 setter 和 deleter。",
            "【property 对象】property 是数据描述符，同时定义了 __get__ 和 __set__。访问属性时调用 __get__，设置时调用 __set__。",
            "【只读属性】只定义 getter（使用 @property）不定义 setter，属性就是只读的。尝试赋值会抛出 AttributeError。",
            "【计算属性】property 可以实现计算属性，每次访问时动态计算值，而不是存储固定值。",
        ],
        keyDifficulties: [
            "【方法命名规则】使用装饰器时，getter、setter、deleter 必须使用相同的方法名。否则会创建不同的属性。",
            "【私有存储】property 通常配合私有属性（如 _value）使用。避免在 getter/setter 中直接访问同名属性导致无限递归。",
            "【描述符实现】property 是描述符的典型应用。理解描述符协议（__get__、__set__、__delete__）有助于理解 property 工作原理。",
            "【继承中的 property】子类可以重写 property 的 getter/setter。使用 super() 可以调用父类的 property 方法。",
        ],
        handsOnPath: [
            "1. 只读属性：class C: @property def value(self): return self._value",
            "2. 可读写属性：@value.setter def value(self, v): self._value = v",
            "3. 带验证：@value.setter def value(self, v): if v < 0: raise ValueError; self._value = v",
            "4. 计算属性：@property def area(self): return self.width * self.height",
            "5. 删除器：@value.deleter def value(self): del self._value",
            "6. 传统方式：x = property(getx, setx, delx, 'x property')",
        ],
        selfCheck: [
            "@property 装饰器的作用是什么？",
            "如何添加 setter 方法？",
            "为什么 getter/setter/deleter 要同名？",
            "property 如何实现数据验证？",
            "只定义 getter 的 property 有什么特点？",
            "property 和直接属性访问有什么优势？",
        ],
        extensions: [
            "学习 functools.cached_property 实现缓存",
            "了解描述符协议的完整实现",
            "探索 dataclass 中的 field 和 property",
            "学习 attrs 库的属性验证",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/functions.html#property",
            "https://docs.python.org/3/howto/descriptor.html#properties",
            "https://docs.python.org/3/howto/descriptor.html",
        ],
    },
    "py-w9-4": {
        lessonId: "py-w9-4",
        background: [
            "【__getattribute__】每次属性访问都会调用 __getattribute__(self, name)。这是最基础的属性访问钩子，拦截所有属性查找。",
            "【__getattr__】只有当属性通过正常方式找不到时才调用 __getattr__(self, name)。它是缺失属性的后备方法。",
            "【__setattr__】所有属性赋值都调用 __setattr__(self, name, value)。它拦截 obj.attr = value 形式的赋值。",
            "【__delattr__】所有属性删除都调用 __delattr__(self, name)。它拦截 del obj.attr 操作。",
            "【__slots__】__slots__ 是类属性，显式声明允许的实例属性。它替代 __dict__，节省内存并限制动态属性。",
        ],
        keyDifficulties: [
            "【无限递归风险】在 __getattribute__ 或 __setattr__ 中访问/设置 self 的属性会递归调用自身。使用 super().__getattribute__() 或 object.__setattr__()。",
            "【__getattr__ vs __getattribute__】__getattribute__ 对每次访问都调用；__getattr__ 只在属性未找到时调用。前者更底层但性能影响更大。",
            "【__slots__ 限制】定义 __slots__ 后实例没有 __dict__，无法动态添加属性。子类必须也定义 __slots__，否则会恢复 __dict__。",
            "【__slots__ 与继承】如果父类有 __slots__，子类可以定义自己的 __slots__（只需列出新属性）。若不定义，子类实例会有 __dict__。",
        ],
        handsOnPath: [
            "1. 实现 __getattr__：def __getattr__(self, name): return f'{name} not found'",
            "2. 实现 __setattr__：def __setattr__(self, name, value): object.__setattr__(self, name, value)",
            "3. 使用 __slots__：class Point: __slots__ = ('x', 'y')",
            "4. 测试 __slots__：p = Point(); p.z = 1  # AttributeError",
            "5. 记录属性访问：def __getattribute__(self, name): print(f'Getting {name}'); return super().__getattribute__(name)",
            "6. __slots__ 与 __dict__：__slots__ = ('x', '__dict__')  # 保留灵活性",
        ],
        selfCheck: [
            "__getattr__ 和 __getattribute__ 的区别是什么？",
            "如何在 __setattr__ 中避免无限递归？",
            "__slots__ 有什么优势和限制？",
            "定义 __slots__ 后还能添加新属性吗？",
            "__delattr__ 什么时候被调用？",
            "如何让带 __slots__ 的类支持动态属性？",
        ],
        extensions: [
            "学习 __getattr__ 实现代理模式",
            "了解 __dict__ 和 __slots__ 的内存差异",
            "探索 __class__ 属性动态修改",
            "学习 weakref slots 的特殊处理",
        ],
        sourceUrls: [
            "https://docs.python.org/3/reference/datamodel.html#object.__getattr__",
            "https://docs.python.org/3/reference/datamodel.html#slots",
            "https://docs.python.org/3/reference/datamodel.html#customizing-attribute-access",
        ],
    },
}

export const week9Quizzes: Record<string, QuizQuestion[]> = {
    "py-w9-1": [
        {
            id: "py-w9-1-q1",
            question: "__repr__ 方法的目标是什么？",
            options: [
                "返回用户友好的字符串",
                "返回对象的'官方'字符串表示，理想情况下是有效的 Python 表达式",
                "返回 HTML 格式的字符串",
                "返回对象的哈希值",
            ],
            answer: 1,
            rationale: "文档说明：__repr__ 计算对象的'官方'字符串表示，如果可能应返回可重建对象的有效 Python 表达式。",
        },
        {
            id: "py-w9-1-q2",
            question: "__str__ 和 __repr__ 的主要区别是什么？",
            options: [
                "没有区别",
                "__str__ 面向用户，__repr__ 面向开发者",
                "__repr__ 更快",
                "__str__ 必须返回列表",
            ],
            answer: 1,
            rationale: "文档说明：__repr__ 应信息丰富且无歧义（面向开发者），__str__ 应友好可读（面向用户）。",
        },
        {
            id: "py-w9-1-q3",
            question: "如果类只定义了 __repr__ 没有定义 __str__，str(obj) 返回什么？",
            options: [
                "抛出 AttributeError",
                "返回空字符串",
                "使用 __repr__ 的返回值",
                "返回 None",
            ],
            answer: 2,
            rationale: "文档说明：如果类定义了 __repr__ 但没有 __str__，则 __repr__ 也用于'非正式'表示。",
        },
        {
            id: "py-w9-1-q4",
            question: "__format__ 方法什么时候被调用？",
            options: [
                "只有 print() 调用",
                "被 format()、f-string 和 str.format() 调用",
                "只有 repr() 调用",
                "从不自动调用",
            ],
            answer: 1,
            rationale: "文档说明：__format__ 被 format() 内置函数和 f-string 格式化调用。",
        },
        {
            id: "py-w9-1-q5",
            question: "格式化规范 '{:>10}' 表示什么？",
            options: [
                "左对齐，宽度 10",
                "右对齐，宽度 10",
                "居中对齐，宽度 10",
                "填充字符 >",
            ],
            answer: 1,
            rationale: "格式化规范中 > 表示右对齐，10 是字段宽度。",
        },
        {
            id: "py-w9-1-q6",
            question: "格式化规范 '{:.2f}' 表示什么？",
            options: [
                "整数格式，宽度 2",
                "浮点数格式，保留 2 位小数",
                "字符串格式，最大 2 个字符",
                "二进制格式",
            ],
            answer: 1,
            rationale: ".2 是精度，f 是浮点数类型指示符，组合起来表示保留 2 位小数的浮点数。",
        },
        {
            id: "py-w9-1-q7",
            question: "'{:*^20}' 格式化 'text' 的结果是什么？",
            options: [
                "'text****************'",
                "'****************text'",
                "'********text********'",
                "'text'",
            ],
            answer: 2,
            rationale: "* 是填充字符，^ 是居中对齐，20 是宽度。'text' 4 个字符，两边各填充 8 个 *。",
        },
        {
            id: "py-w9-1-q8",
            question: "__repr__ 和 __str__ 必须返回什么类型？",
            options: [
                "任意类型",
                "字符串对象",
                "字节对象",
                "布尔值",
            ],
            answer: 1,
            rationale: "文档明确要求：__repr__ 和 __str__ 必须返回字符串对象（str）。",
        },
        {
            id: "py-w9-1-q9",
            question: "格式化规范中 # 的作用是什么？",
            options: [
                "注释",
                "使用替代形式（如添加 0x、0b 前缀）",
                "忽略大小写",
                "强制正号",
            ],
            answer: 1,
            rationale: "文档说明：# 使用替代形式，为整数添加 0x、0b、0o 等前缀。",
        },
        {
            id: "py-w9-1-q10",
            question: "'{:,}'.format(1234567) 的结果是什么？",
            options: [
                "'1234567'",
                "'1,234,567'",
                "'1_234_567'",
                "'1.234.567'",
            ],
            answer: 1,
            rationale: "文档说明：, 作为分组选项，每 3 位添加逗号分隔符。",
        },
        {
            id: "py-w9-1-q11",
            question: "'{!r}'.format(obj) 和 '{}'.format(obj) 的区别是什么？",
            options: [
                "没有区别",
                "!r 调用 repr()，默认调用 str()",
                "!r 调用 str()，默认调用 repr()",
                "!r 是无效语法",
            ],
            answer: 1,
            rationale: "文档说明：!r 转换标志调用 repr()，!s 调用 str()，默认（无标志）调用 str()。",
        },
        {
            id: "py-w9-1-q12",
            question: "格式化规范中 + 符号的作用是什么？",
            options: [
                "字符串连接",
                "对正数和负数都显示符号",
                "加法运算",
                "匹配一个或多个",
            ],
            answer: 1,
            rationale: "文档说明：+ 符号选项表示对正数和负数都显示符号（+ 或 -）。",
        },
    ],
    "py-w9-2": [
        {
            id: "py-w9-2-q1",
            question: "__add__ 方法实现什么运算符？",
            options: [
                "- 减法",
                "+ 加法",
                "* 乘法",
                "/ 除法",
            ],
            answer: 1,
            rationale: "文档说明：__add__(self, other) 实现 + 加法运算符。",
        },
        {
            id: "py-w9-2-q2",
            question: "什么时候会调用 __radd__ 方法？",
            options: [
                "总是先调用",
                "当 __add__ 返回 NotImplemented 时",
                "只在右操作数是子类时",
                "永远不会调用",
            ],
            answer: 1,
            rationale: "文档说明：当 x + y 中 x.__add__(y) 返回 NotImplemented 时，Python 尝试 y.__radd__(x)。",
        },
        {
            id: "py-w9-2-q3",
            question: "__iadd__ 方法应该返回什么？",
            options: [
                "None",
                "True 或 False",
                "修改后的 self",
                "新对象",
            ],
            answer: 2,
            rationale: "文档说明：__iadd__ 等就地运算符应该修改 self 并返回 self（对于可变对象）。",
        },
        {
            id: "py-w9-2-q4",
            question: "当操作数类型不支持时，__add__ 应该返回什么？",
            options: [
                "抛出 TypeError",
                "返回 None",
                "返回 NotImplemented",
                "返回 False",
            ],
            answer: 2,
            rationale: "文档说明：当操作数类型不支持时应返回 NotImplemented，让 Python 尝试其他方法。",
        },
        {
            id: "py-w9-2-q5",
            question: "functools.total_ordering 需要定义哪些方法？",
            options: [
                "所有六个比较方法",
                "__eq__ 和任意一个其他比较方法",
                "只需要 __eq__",
                "只需要 __lt__",
            ],
            answer: 1,
            rationale: "文档说明：total_ordering 要求类定义 __eq__ 和 __lt__、__le__、__gt__、__ge__ 中的至少一个。",
        },
        {
            id: "py-w9-2-q6",
            question: "定义 __eq__ 但不定义 __hash__ 会怎样？",
            options: [
                "没有影响",
                "实例变为不可哈希",
                "自动生成 __hash__",
                "抛出错误",
            ],
            answer: 1,
            rationale: "文档说明：定义 __eq__ 但不定义 __hash__ 会使实例不可哈希，不能用作字典键或集合元素。",
        },
        {
            id: "py-w9-2-q7",
            question: "(x < y or x == y) 是否自动意味着 x <= y？",
            options: [
                "是，这是数学定律",
                "否，比较方法之间没有隐含关系",
                "只在数值类型中成立",
                "取决于实现",
            ],
            answer: 1,
            rationale: "文档说明：比较方法之间没有隐含关系，(x<y or x==y) 不自动意味着 x<=y。",
        },
        {
            id: "py-w9-2-q8",
            question: "__lt__ 实现什么比较？",
            options: [
                "等于",
                "不等于",
                "小于",
                "大于",
            ],
            answer: 2,
            rationale: "文档说明：__lt__(self, other) 实现 x < y 小于比较。",
        },
        {
            id: "py-w9-2-q9",
            question: "total_ordering 有什么性能代价？",
            options: [
                "没有代价",
                "执行速度变慢，堆栈跟踪更复杂",
                "内存占用增加",
                "只在 Python 2 有代价",
            ],
            answer: 1,
            rationale: "文档说明：使用 total_ordering 会导致执行速度变慢且堆栈跟踪更复杂。",
        },
        {
            id: "py-w9-2-q10",
            question: "__pow__ 可以接受几个参数？",
            options: [
                "只有 other",
                "other 和可选的 modulo",
                "只有 self",
                "三个必需参数",
            ],
            answer: 1,
            rationale: "文档说明：__pow__(self, other[, modulo]) 可接受可选的 modulo 参数实现模幂运算。",
        },
        {
            id: "py-w9-2-q11",
            question: "__truediv__ 实现什么运算符？",
            options: [
                "// 整除",
                "/ 真除法",
                "% 取模",
                "** 幂",
            ],
            answer: 1,
            rationale: "文档说明：__truediv__ 实现 / 真除法运算符，__floordiv__ 实现 // 整除。",
        },
        {
            id: "py-w9-2-q12",
            question: "比较方法的反射关系是什么？",
            options: [
                "__lt__ 和 __le__ 是反射",
                "__lt__ 和 __gt__ 是反射",
                "__eq__ 和 __ne__ 是反射",
                "没有反射关系",
            ],
            answer: 1,
            rationale: "文档说明：__lt__ 和 __gt__ 是反射关系，__le__ 和 __ge__ 是反射关系。",
        },
    ],
    "py-w9-3": [
        {
            id: "py-w9-3-q1",
            question: "@property 装饰器的作用是什么？",
            options: [
                "定义类属性",
                "将方法变成只读属性",
                "删除属性",
                "私有化属性",
            ],
            answer: 1,
            rationale: "文档说明：@property 装饰器将方法变成只读属性。",
        },
        {
            id: "py-w9-3-q2",
            question: "如何为 property 添加 setter？",
            options: [
                "@property.setter",
                "@attr.setter（attr 是属性名）",
                "@setter",
                "不能添加 setter",
            ],
            answer: 1,
            rationale: "文档说明：使用 @attr.setter 装饰器为名为 attr 的 property 添加 setter。",
        },
        {
            id: "py-w9-3-q3",
            question: "property 的 getter、setter、deleter 方法命名有什么要求？",
            options: [
                "可以任意命名",
                "必须使用相同的方法名",
                "必须以 get_、set_、del_ 开头",
                "必须是私有方法",
            ],
            answer: 1,
            rationale: "文档说明：使用装饰器时，getter、setter、deleter 必须使用相同的方法名。",
        },
        {
            id: "py-w9-3-q4",
            question: "只有 @property（没有 setter）的属性有什么特点？",
            options: [
                "可读写",
                "只读，尝试赋值会抛出 AttributeError",
                "可写不可读",
                "不能访问",
            ],
            answer: 1,
            rationale: "文档说明：只定义 getter 不定义 setter，属性就是只读的，尝试赋值会抛出 AttributeError。",
        },
        {
            id: "py-w9-3-q5",
            question: "property 内部是什么类型的描述符？",
            options: [
                "非数据描述符",
                "数据描述符",
                "类描述符",
                "不是描述符",
            ],
            answer: 1,
            rationale: "文档说明：property 是数据描述符，同时定义了 __get__ 和 __set__。",
        },
        {
            id: "py-w9-3-q6",
            question: "property(fget, fset, fdel, doc) 的参数顺序是什么？",
            options: [
                "setter, getter, deleter, doc",
                "getter, setter, deleter, doc",
                "doc, getter, setter, deleter",
                "deleter, setter, getter, doc",
            ],
            answer: 1,
            rationale: "文档说明：property(fget, fset, fdel, doc)，按 getter、setter、deleter、文档字符串顺序。",
        },
        {
            id: "py-w9-3-q7",
            question: "在 property 的 getter 中访问 self.attr（同名属性）会怎样？",
            options: [
                "正常返回值",
                "无限递归",
                "返回 None",
                "抛出 NameError",
            ],
            answer: 1,
            rationale: "在 getter 中访问同名属性会再次触发 getter，导致无限递归。应使用私有属性如 self._attr。",
        },
        {
            id: "py-w9-3-q8",
            question: "如何访问 property 对象的 getter 函数？",
            options: [
                "prop.get",
                "prop.fget",
                "prop.getter",
                "prop.__get__",
            ],
            answer: 1,
            rationale: "文档说明：property 对象有 fget、fset、fdel 属性分别存储 getter、setter、deleter 函数。",
        },
        {
            id: "py-w9-3-q9",
            question: "property 相比直接属性访问有什么优势？",
            options: [
                "更快",
                "可以添加验证、计算等逻辑",
                "节省内存",
                "自动序列化",
            ],
            answer: 1,
            rationale: "property 允许在属性访问时添加验证、计算属性等逻辑，而无需修改调用代码。",
        },
        {
            id: "py-w9-3-q10",
            question: "@property 装饰的方法返回值是什么？",
            options: [
                "方法对象",
                "函数对象",
                "property 对象",
                "None",
            ],
            answer: 2,
            rationale: "@property 装饰器返回一个 property 对象，而不是原来的方法。",
        },
        {
            id: "py-w9-3-q11",
            question: "如何为 property 添加文档字符串？",
            options: [
                "只能用 property() 的 doc 参数",
                "在 getter 方法中写 docstring",
                "不支持文档字符串",
                "用 __doc__ 属性",
            ],
            answer: 1,
            rationale: "文档说明：使用装饰器时，在 getter 方法中写 docstring 会成为 property 的文档。",
        },
        {
            id: "py-w9-3-q12",
            question: "property 的 deleter 什么时候被调用？",
            options: [
                "访问属性时",
                "设置属性时",
                "使用 del obj.attr 时",
                "对象销毁时",
            ],
            answer: 2,
            rationale: "文档说明：deleter 函数在使用 del 语句删除属性时被调用。",
        },
    ],
    "py-w9-4": [
        {
            id: "py-w9-4-q1",
            question: "__getattribute__ 和 __getattr__ 的区别是什么？",
            options: [
                "没有区别",
                "__getattribute__ 对每次访问都调用，__getattr__ 只在属性未找到时调用",
                "__getattr__ 对每次访问都调用",
                "__getattribute__ 只在属性未找到时调用",
            ],
            answer: 1,
            rationale: "文档说明：__getattribute__ 对每次属性访问都调用；__getattr__ 只在属性未找到时调用。",
        },
        {
            id: "py-w9-4-q2",
            question: "在 __setattr__ 中设置属性应该怎么做？",
            options: [
                "self.attr = value",
                "使用 object.__setattr__(self, name, value)",
                "直接赋值",
                "使用 setattr()",
            ],
            answer: 1,
            rationale: "文档说明：在 __setattr__ 中应使用 object.__setattr__() 或 super().__setattr__() 避免无限递归。",
        },
        {
            id: "py-w9-4-q3",
            question: "__slots__ 的主要优势是什么？",
            options: [
                "支持更多属性",
                "节省内存并限制动态属性",
                "更快的方法调用",
                "自动类型检查",
            ],
            answer: 1,
            rationale: "文档说明：__slots__ 替代 __dict__，节省内存并限制实例只能有声明的属性。",
        },
        {
            id: "py-w9-4-q4",
            question: "定义 __slots__ 后，实例还有 __dict__ 吗？",
            options: [
                "有",
                "没有，除非显式添加 '__dict__' 到 __slots__",
                "取决于属性数量",
                "只有类属性有",
            ],
            answer: 1,
            rationale: "文档说明：定义 __slots__ 后实例没有 __dict__，除非在 __slots__ 中显式添加 '__dict__'。",
        },
        {
            id: "py-w9-4-q5",
            question: "__getattr__ 什么时候被调用？",
            options: [
                "每次属性访问",
                "属性设置时",
                "属性通过正常方式找不到时",
                "对象创建时",
            ],
            answer: 2,
            rationale: "文档说明：__getattr__ 只有当属性通过正常方式找不到时才调用，是缺失属性的后备方法。",
        },
        {
            id: "py-w9-4-q6",
            question: "如果父类有 __slots__，子类不定义 __slots__ 会怎样？",
            options: [
                "继承父类的 __slots__",
                "子类实例会有 __dict__",
                "抛出错误",
                "子类无法实例化",
            ],
            answer: 1,
            rationale: "文档说明：如果子类不定义 __slots__，子类实例会恢复 __dict__，可以动态添加属性。",
        },
        {
            id: "py-w9-4-q7",
            question: "__delattr__ 什么时候被调用？",
            options: [
                "访问属性时",
                "设置属性时",
                "使用 del obj.attr 时",
                "对象销毁时",
            ],
            answer: 2,
            rationale: "文档说明：__delattr__(self, name) 拦截所有通过 del 语句删除属性的操作。",
        },
        {
            id: "py-w9-4-q8",
            question: "在 __getattribute__ 中访问 self.attr 会怎样？",
            options: [
                "正常返回值",
                "无限递归",
                "返回 None",
                "抛出 NameError",
            ],
            answer: 1,
            rationale: "在 __getattribute__ 中访问 self 的任何属性会再次触发 __getattribute__，导致无限递归。",
        },
        {
            id: "py-w9-4-q9",
            question: "__slots__ = ('x', 'y') 后能执行 obj.z = 1 吗？",
            options: [
                "可以",
                "不可以，抛出 AttributeError",
                "取决于 z 的类型",
                "只有在 __init__ 中可以",
            ],
            answer: 1,
            rationale: "文档说明：__slots__ 限制实例只能有声明的属性，添加未声明的属性会抛出 AttributeError。",
        },
        {
            id: "py-w9-4-q10",
            question: "如何在 __getattribute__ 中安全访问属性？",
            options: [
                "self.attr",
                "getattr(self, 'attr')",
                "super().__getattribute__('attr')",
                "self['attr']",
            ],
            answer: 2,
            rationale: "文档说明：在 __getattribute__ 中应使用 super().__getattribute__() 或 object.__getattribute__() 避免递归。",
        },
        {
            id: "py-w9-4-q11",
            question: "__slots__ 对属性访问速度有什么影响？",
            options: [
                "变慢",
                "更快（直接内存访问而非字典查询）",
                "没有影响",
                "只影响写入速度",
            ],
            answer: 1,
            rationale: "文档说明：__slots__ 使用固定内存位置存储属性，比字典查询更快。",
        },
        {
            id: "py-w9-4-q12",
            question: "子类的 __slots__ 应该包含什么？",
            options: [
                "父类和子类所有属性",
                "只需要子类新增的属性",
                "必须为空",
                "与父类相同",
            ],
            answer: 1,
            rationale: "文档说明：子类的 __slots__ 只需要声明子类新增的属性，父类的属性已在父类 __slots__ 中声明。",
        },
    ],
}
