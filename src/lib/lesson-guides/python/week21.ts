import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week21Guides: Record<string, LessonGuide> = {
    "py-w21-1": {
        lessonId: "py-w21-1",
        background: [
            "【requests 库】Python 最流行的 HTTP 客户端库，提供简洁直观的 API。安装：pip install requests。",
            "【HTTP 方法】requests.get()、post()、put()、delete() 等对应 HTTP 动词。",
            "【响应对象】response.status_code 状态码；response.text 文本内容；response.json() 解析 JSON；response.content 二进制内容。",
            "【Session 会话】requests.Session() 保持 cookie 和连接池，适合多次请求同一服务器。",
            "【认证支持】支持 Basic 认证 auth=('user', 'pass')，OAuth 1/2，自定义认证。",
        ],
        keyDifficulties: [
            "【JSON vs text】response.json() 自动解析 JSON 为字典；response.text 返回解码后的字符串。",
            "【查询参数】使用 params={'key': 'value'} 自动编码 URL 查询字符串。",
            "【超时设置】始终设置 timeout 参数，防止请求无限期挂起。timeout=(connect, read)。",
            "【SSL 验证】默认启用 SSL 验证。verify=False 关闭验证（不推荐）。",
        ],
        handsOnPath: [
            "1. 安装：pip install requests",
            "2. GET 请求：r = requests.get('https://api.github.com'); print(r.status_code)",
            "3. JSON 响应：data = r.json(); print(data['key'])",
            "4. POST 请求：r = requests.post(url, json={'name': 'value'})",
            "5. 会话管理：with requests.Session() as s: s.get(url)",
            "6. 设置超时：requests.get(url, timeout=5)",
        ],
        selfCheck: [
            "如何发送 GET 请求并获取状态码？",
            "response.text 和 response.json() 的区别是什么？",
            "如何发送带查询参数的请求？",
            "Session 的作用是什么？",
            "如何设置请求超时？",
            "如何发送 POST 请求并传递 JSON 数据？",
        ],
        extensions: [
            "学习 httpx 异步 HTTP 客户端",
            "了解 urllib3 底层库",
            "探索 requests-oauthlib OAuth 认证",
            "学习 requests-cache 缓存响应",
        ],
        sourceUrls: [
            "https://requests.readthedocs.io/",
            "https://docs.python.org/3/library/http.client.html",
            "https://docs.python.org/3/library/urllib.request.html",
        ],
    },
    "py-w21-2": {
        lessonId: "py-w21-2",
        background: [
            "【Flask 框架】Python 轻量级 Web 框架。Flask(__name__) 创建应用实例，__name__ 帮助定位资源。",
            "【路由装饰器】@app.route('/path') 将 URL 映射到视图函数。支持变量规则 <variable>。",
            "【请求对象】from flask import request 访问请求数据：request.method、request.form、request.args、request.files。",
            "【模板引擎】使用 Jinja2 模板。render_template('template.html', var=value) 渲染模板。",
            "【响应处理】返回字符串自动变成 200 响应；返回字典自动 JSON 化；使用 make_response() 自定义响应。",
        ],
        keyDifficulties: [
            "【变量规则转换器】<int:id> 转换为整数；<path:filename> 匹配含斜杠的路径；默认是 string。",
            "【尾部斜杠】/path/ 类似文件夹会重定向；/path 类似文件，/path/ 返回 404。",
            "【HTTP 方法】@app.route('/login', methods=['GET', 'POST']) 或快捷 @app.get()/@app.post()。",
            "【url_for()】使用 url_for('func_name') 生成 URL，自动处理转义和路径变化。",
        ],
        handsOnPath: [
            "1. 安装：pip install flask",
            "2. 最小应用：from flask import Flask; app = Flask(__name__)",
            "3. 定义路由：@app.route('/') def hello(): return 'Hello'",
            "4. 运行：flask --app hello run --debug",
            "5. 模板：return render_template('index.html', name='World')",
            "6. 获取表单：username = request.form['username']",
        ],
        selfCheck: [
            "如何创建 Flask 应用实例？",
            "如何定义带变量的路由？",
            "如何限制路由只接受 POST 请求？",
            "如何获取表单提交的数据？",
            "url_for() 的作用是什么？",
            "如何返回 JSON 响应？",
        ],
        extensions: [
            "学习 Flask Blueprint 组织大型应用",
            "了解 Flask-SQLAlchemy 数据库集成",
            "探索 Flask-Login 用户认证",
            "学习 Flask-RESTful API 开发",
        ],
        sourceUrls: [
            "https://flask.palletsprojects.com/",
            "https://flask.palletsprojects.com/en/stable/quickstart/",
            "https://jinja.palletsprojects.com/",
        ],
    },
    "py-w21-3": {
        lessonId: "py-w21-3",
        background: [
            "【FastAPI 框架】现代高性能 Python Web 框架。基于类型提示自动验证数据和生成文档。",
            "【自动文档】访问 /docs 获取 Swagger UI，/redoc 获取 ReDoc，基于 OpenAPI 规范自动生成。",
            "【Pydantic 集成】使用 Pydantic 模型定义请求体和响应模型，自动进行数据验证和序列化。",
            "【异步支持】原生支持 async/await，可以使用异步数据库和 HTTP 客户端。",
            "【依赖注入】使用 Depends() 实现依赖注入，处理认证、数据库连接等通用逻辑。",
        ],
        keyDifficulties: [
            "【路径参数】@app.get('/items/{item_id}') 中 item_id 自动转换为函数参数类型。",
            "【查询参数】函数参数不在路径中的自动成为查询参数：def read(skip: int = 0)。",
            "【请求体】使用 Pydantic 模型定义：async def create(item: Item)，自动验证 JSON 请求体。",
            "【类型验证】Pydantic 自动进行类型强制转换，验证失败返回 422 和详细错误信息。",
        ],
        handsOnPath: [
            "1. 安装：pip install 'fastapi[standard]'",
            "2. 创建应用：from fastapi import FastAPI; app = FastAPI()",
            "3. 定义路由：@app.get('/') async def root(): return {'message': 'Hello'}",
            "4. 运行：fastapi dev main.py",
            "5. Pydantic 模型：class Item(BaseModel): name: str; price: float",
            "6. 访问文档：http://127.0.0.1:8000/docs",
        ],
        selfCheck: [
            "FastAPI 如何自动生成 API 文档？",
            "路径参数和查询参数如何区分？",
            "如何定义请求体模型？",
            "Pydantic 验证失败返回什么状态码？",
            "如何运行 FastAPI 开发服务器？",
            "async def 和 def 在 FastAPI 中有什么区别？",
        ],
        extensions: [
            "学习 FastAPI 依赖注入系统",
            "了解 FastAPI 安全和认证",
            "探索 SQLModel 数据库集成",
            "学习 FastAPI 后台任务",
        ],
        sourceUrls: [
            "https://fastapi.tiangolo.com/",
            "https://fastapi.tiangolo.com/tutorial/",
            "https://docs.pydantic.dev/",
        ],
    },
    "py-w21-4": {
        lessonId: "py-w21-4",
        background: [
            "【REST 架构】表现层状态转移，使用 HTTP 方法表示操作：GET 读取、POST 创建、PUT 更新、DELETE 删除。",
            "【HTTP 状态码】2xx 成功（200 OK、201 Created、204 No Content）；4xx 客户端错误；5xx 服务器错误。",
            "【JSON 格式】REST API 通常使用 JSON 作为数据交换格式。Content-Type: application/json。",
            "【资源导向】URL 代表资源（名词），HTTP 方法代表操作（动词）。如 GET /users/1 获取用户。",
            "【无状态】每个请求包含所有必要信息，服务器不保存客户端状态。",
        ],
        keyDifficulties: [
            "【常用状态码】200 成功；201 已创建；400 错误请求；401 未认证；403 禁止访问；404 未找到；500 服务器错误。",
            "【幂等性】GET、PUT、DELETE 应该是幂等的（多次执行结果相同）；POST 通常不是幂等的。",
            "【版本控制】URL 路径 /api/v1/、请求头 Accept: application/vnd.api+json;version=1、查询参数 ?version=1。",
            "【错误响应】应返回一致的错误格式：{'error': {'code': 'NOT_FOUND', 'message': '...'}}。",
        ],
        handsOnPath: [
            "1. 设计资源 URL：GET /users, GET /users/{id}, POST /users",
            "2. 返回正确状态码：创建成功返回 201，删除成功返回 204",
            "3. JSON 响应格式：return jsonify({'id': 1, 'name': 'Alice'})",
            "4. 错误处理：return jsonify({'error': 'Not found'}), 404",
            "5. 分页响应：{'data': [...], 'page': 1, 'total': 100}",
            "6. HATEOAS 链接：{'id': 1, '_links': {'self': '/users/1'}}",
        ],
        selfCheck: [
            "GET、POST、PUT、DELETE 分别对应什么操作？",
            "201 和 204 状态码的含义是什么？",
            "什么是幂等性？哪些方法应该是幂等的？",
            "为什么 REST API 是无状态的？",
            "如何设计一致的错误响应格式？",
            "API 版本控制有哪些方式？",
        ],
        extensions: [
            "学习 GraphQL 替代方案",
            "了解 OpenAPI 规范",
            "探索 gRPC 高性能 RPC",
            "学习 API 速率限制设计",
        ],
        sourceUrls: [
            "https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm",
            "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status",
            "https://www.ietf.org/rfc/rfc9110.html",
        ],
    },
}

export const week21Quizzes: Record<string, QuizQuestion[]> = {
    "py-w21-1": [
        {
            id: "py-w21-1-q1",
            question: "如何发送 GET 请求？",
            options: [
                "requests.send('GET', url)",
                "requests.get(url)",
                "requests.fetch(url)",
                "requests.request(url)",
            ],
            answer: 1,
            rationale: "文档说明：使用 requests.get(url) 发送 GET 请求。",
        },
        {
            id: "py-w21-1-q2",
            question: "response.json() 返回什么？",
            options: [
                "JSON 字符串",
                "解析后的 Python 字典或列表",
                "Response 对象",
                "字节数据",
            ],
            answer: 1,
            rationale: "文档说明：response.json() 返回解析后的 JSON 数据（字典或列表）。",
        },
        {
            id: "py-w21-1-q3",
            question: "如何传递 URL 查询参数？",
            options: [
                "requests.get(url + '?key=value')",
                "requests.get(url, params={'key': 'value'})",
                "requests.get(url, query={'key': 'value'})",
                "requests.get(url, args={'key': 'value'})",
            ],
            answer: 1,
            rationale: "文档推荐：使用 params 参数传递查询字符串，自动编码。",
        },
        {
            id: "py-w21-1-q4",
            question: "requests.Session() 的主要优势是什么？",
            options: [
                "更快的请求速度",
                "保持 cookie 和连接池",
                "自动重试失败请求",
                "支持异步请求",
            ],
            answer: 1,
            rationale: "文档说明：Session 提供 cookie 持久化和连接池，减少多次请求的开销。",
        },
        {
            id: "py-w21-1-q5",
            question: "如何发送带 JSON 数据的 POST 请求？",
            options: [
                "requests.post(url, body={'key': 'value'})",
                "requests.post(url, json={'key': 'value'})",
                "requests.post(url, {'key': 'value'})",
                "requests.post(url, content={'key': 'value'})",
            ],
            answer: 1,
            rationale: "文档说明：使用 json 参数自动序列化数据并设置正确的 Content-Type。",
        },
        {
            id: "py-w21-1-q6",
            question: "response.text 和 response.content 的区别是什么？",
            options: [
                "没有区别",
                "text 是解码后的字符串，content 是原始字节",
                "text 是 JSON，content 是文本",
                "content 更快",
            ],
            answer: 1,
            rationale: "文档说明：.text 是自动解码的字符串，.content 是原始二进制内容。",
        },
        {
            id: "py-w21-1-q7",
            question: "如何设置请求超时？",
            options: [
                "requests.get(url, wait=5)",
                "requests.get(url, timeout=5)",
                "requests.get(url, max_time=5)",
                "requests.get(url, limit=5)",
            ],
            answer: 1,
            rationale: "文档说明：timeout 参数设置超时秒数，防止请求无限期挂起。",
        },
        {
            id: "py-w21-1-q8",
            question: "如何进行 Basic 认证？",
            options: [
                "requests.get(url, user='user', password='pass')",
                "requests.get(url, auth=('user', 'pass'))",
                "requests.get(url, basic_auth=('user', 'pass'))",
                "requests.get(url, credentials=('user', 'pass'))",
            ],
            answer: 1,
            rationale: "文档说明：auth 参数接受 (user, password) 元组进行 Basic 认证。",
        },
        {
            id: "py-w21-1-q9",
            question: "如何获取响应状态码？",
            options: [
                "response.code",
                "response.status_code",
                "response.status",
                "response.http_code",
            ],
            answer: 1,
            rationale: "文档说明：response.status_code 属性包含 HTTP 状态码。",
        },
        {
            id: "py-w21-1-q10",
            question: "requests 库默认是否验证 SSL 证书？",
            options: [
                "不验证",
                "是，默认启用 SSL 验证",
                "取决于 URL",
                "只验证自签名证书",
            ],
            answer: 1,
            rationale: "文档说明：requests 默认启用 SSL 验证，类似浏览器行为。",
        },
        {
            id: "py-w21-1-q11",
            question: "如何发送表单数据？",
            options: [
                "requests.post(url, form={'key': 'value'})",
                "requests.post(url, data={'key': 'value'})",
                "requests.post(url, formdata={'key': 'value'})",
                "requests.post(url, body={'key': 'value'})",
            ],
            answer: 1,
            rationale: "文档说明：data 参数用于发送表单编码的数据。",
        },
        {
            id: "py-w21-1-q12",
            question: "response.headers 返回什么类型？",
            options: [
                "普通字典",
                "不区分大小写的字典",
                "列表",
                "字符串",
            ],
            answer: 1,
            rationale: "文档说明：response.headers 是不区分大小写的字典，符合 HTTP 头规范。",
        },
    ],
    "py-w21-2": [
        {
            id: "py-w21-2-q1",
            question: "如何创建 Flask 应用实例？",
            options: [
                "Flask()",
                "Flask(__name__)",
                "Flask.create()",
                "new Flask()",
            ],
            answer: 1,
            rationale: "文档说明：Flask(__name__) 创建应用实例，__name__ 帮助定位资源。",
        },
        {
            id: "py-w21-2-q2",
            question: "如何定义路由？",
            options: [
                "@app.url('/')",
                "@app.route('/')",
                "@app.path('/')",
                "@app.endpoint('/')",
            ],
            answer: 1,
            rationale: "文档说明：@app.route('/path') 装饰器将 URL 映射到视图函数。",
        },
        {
            id: "py-w21-2-q3",
            question: "<int:id> 在路由中的作用是什么？",
            options: [
                "定义整数类型的路径变量",
                "定义 ID 参数",
                "验证整数范围",
                "生成整数序列",
            ],
            answer: 0,
            rationale: "文档说明：<converter:variable> 语法中，int 转换器将路径参数转换为整数。",
        },
        {
            id: "py-w21-2-q4",
            question: "如何获取 POST 请求的表单数据？",
            options: [
                "request.post['field']",
                "request.form['field']",
                "request.data['field']",
                "request.body['field']",
            ],
            answer: 1,
            rationale: "文档说明：request.form 字典包含 POST 请求的表单数据。",
        },
        {
            id: "py-w21-2-q5",
            question: "url_for() 函数的作用是什么？",
            options: [
                "解析 URL 参数",
                "根据函数名生成 URL",
                "重定向到 URL",
                "验证 URL 格式",
            ],
            answer: 1,
            rationale: "文档说明：url_for('func_name') 根据视图函数名生成对应的 URL。",
        },
        {
            id: "py-w21-2-q6",
            question: "如何限制路由只接受 POST 方法？",
            options: [
                "@app.route('/', type='POST')",
                "@app.route('/', methods=['POST'])",
                "@app.post('/')",
                "@app.route('/', method='POST')",
            ],
            answer: 1,
            rationale: "文档说明：methods 参数指定允许的 HTTP 方法列表。",
        },
        {
            id: "py-w21-2-q7",
            question: "Flask 使用什么模板引擎？",
            options: [
                "Mako",
                "Jinja2",
                "Django Templates",
                "Mustache",
            ],
            answer: 1,
            rationale: "文档说明：Flask 默认使用 Jinja2 模板引擎。",
        },
        {
            id: "py-w21-2-q8",
            question: "如何渲染模板？",
            options: [
                "template('index.html')",
                "render_template('index.html')",
                "render('index.html')",
                "Template('index.html').render()",
            ],
            answer: 1,
            rationale: "文档说明：render_template('template.html', var=value) 渲染 Jinja2 模板。",
        },
        {
            id: "py-w21-2-q9",
            question: "如何获取 URL 查询参数？",
            options: [
                "request.query.get('key')",
                "request.args.get('key')",
                "request.params.get('key')",
                "request.get('key')",
            ],
            answer: 1,
            rationale: "文档说明：request.args 是查询字符串参数的 ImmutableMultiDict。",
        },
        {
            id: "py-w21-2-q10",
            question: "视图函数返回字典时 Flask 如何处理？",
            options: [
                "抛出错误",
                "自动转换为 JSON 响应",
                "转换为字符串",
                "返回 404",
            ],
            answer: 1,
            rationale: "文档说明：返回字典或列表时，Flask 自动调用 jsonify() 转换为 JSON。",
        },
        {
            id: "py-w21-2-q11",
            question: "如何启用调试模式？",
            options: [
                "flask run --verbose",
                "flask run --debug",
                "flask debug run",
                "flask run -d",
            ],
            answer: 1,
            rationale: "文档说明：flask --app hello run --debug 启用调试模式。",
        },
        {
            id: "py-w21-2-q12",
            question: "secure_filename() 的作用是什么？",
            options: [
                "加密文件",
                "防止目录遍历攻击",
                "验证文件大小",
                "检查文件类型",
            ],
            answer: 1,
            rationale: "文档警告：使用 secure_filename() 处理用户上传的文件名，防止目录遍历攻击。",
        },
    ],
    "py-w21-3": [
        {
            id: "py-w21-3-q1",
            question: "FastAPI 如何自动生成 API 文档？",
            options: [
                "手动编写 Markdown",
                "基于类型提示自动生成 OpenAPI 规范",
                "使用外部工具",
                "从注释提取",
            ],
            answer: 1,
            rationale: "文档说明：FastAPI 基于类型提示自动生成 OpenAPI 规范和交互式文档。",
        },
        {
            id: "py-w21-3-q2",
            question: "如何访问 FastAPI 的 Swagger UI 文档？",
            options: [
                "/swagger",
                "/docs",
                "/api-docs",
                "/documentation",
            ],
            answer: 1,
            rationale: "文档说明：访问 /docs 获取 Swagger UI，/redoc 获取 ReDoc。",
        },
        {
            id: "py-w21-3-q3",
            question: "FastAPI 使用什么进行数据验证？",
            options: [
                "marshmallow",
                "Pydantic",
                "cerberus",
                "jsonschema",
            ],
            answer: 1,
            rationale: "文档说明：FastAPI 集成 Pydantic 进行数据验证和序列化。",
        },
        {
            id: "py-w21-3-q4",
            question: "函数参数不在路径中时会成为什么？",
            options: [
                "请求体",
                "查询参数",
                "请求头",
                "忽略",
            ],
            answer: 1,
            rationale: "文档说明：不在路径中的参数自动成为查询参数。",
        },
        {
            id: "py-w21-3-q5",
            question: "Pydantic 验证失败返回什么状态码？",
            options: [
                "400",
                "422",
                "500",
                "401",
            ],
            answer: 1,
            rationale: "文档说明：验证失败返回 422 Unprocessable Entity 和详细错误信息。",
        },
        {
            id: "py-w21-3-q6",
            question: "如何安装 FastAPI？",
            options: [
                "pip install fastapi",
                "pip install 'fastapi[standard]'",
                "pip install fastapi-full",
                "pip install fastapi-all",
            ],
            answer: 1,
            rationale: "文档推荐：pip install 'fastapi[standard]' 包含所有标准依赖。",
        },
        {
            id: "py-w21-3-q7",
            question: "如何启动 FastAPI 开发服务器？",
            options: [
                "python main.py",
                "fastapi dev main.py",
                "uvicorn main.py",
                "fastapi start main.py",
            ],
            answer: 1,
            rationale: "文档说明：fastapi dev main.py 启动开发服务器。",
        },
        {
            id: "py-w21-3-q8",
            question: "如何定义路径参数？",
            options: [
                "@app.get('/items/:item_id')",
                "@app.get('/items/{item_id}')",
                "@app.get('/items/<item_id>')",
                "@app.get('/items/[item_id]')",
            ],
            answer: 1,
            rationale: "文档说明：使用 {variable} 语法定义路径参数。",
        },
        {
            id: "py-w21-3-q9",
            question: "如何定义请求体模型？",
            options: [
                "class Item(dict):",
                "class Item(BaseModel):",
                "class Item(RequestBody):",
                "@body class Item:",
            ],
            answer: 1,
            rationale: "文档说明：继承 Pydantic BaseModel 定义请求体模型。",
        },
        {
            id: "py-w21-3-q10",
            question: "FastAPI 支持哪种并发模式？",
            options: [
                "只支持同步",
                "原生支持 async/await",
                "只支持多线程",
                "只支持多进程",
            ],
            answer: 1,
            rationale: "文档说明：FastAPI 原生支持异步处理，可使用 async def。",
        },
        {
            id: "py-w21-3-q11",
            question: "Depends() 的作用是什么？",
            options: [
                "定义依赖版本",
                "实现依赖注入",
                "检查依赖是否存在",
                "安装依赖",
            ],
            answer: 1,
            rationale: "文档说明：Depends() 实现依赖注入，处理认证、数据库连接等通用逻辑。",
        },
        {
            id: "py-w21-3-q12",
            question: "ReDoc 文档的访问路径是什么？",
            options: [
                "/docs",
                "/redoc",
                "/api",
                "/openapi",
            ],
            answer: 1,
            rationale: "文档说明：/docs 是 Swagger UI，/redoc 是 ReDoc 文档。",
        },
    ],
    "py-w21-4": [
        {
            id: "py-w21-4-q1",
            question: "REST 中 GET 方法对应什么操作？",
            options: [
                "创建资源",
                "读取资源",
                "更新资源",
                "删除资源",
            ],
            answer: 1,
            rationale: "REST 规范：GET 用于读取资源，POST 创建，PUT 更新，DELETE 删除。",
        },
        {
            id: "py-w21-4-q2",
            question: "201 状态码表示什么？",
            options: [
                "请求成功",
                "资源已创建",
                "无内容",
                "重定向",
            ],
            answer: 1,
            rationale: "HTTP 规范：201 Created 表示资源已成功创建，通常用于 POST 请求。",
        },
        {
            id: "py-w21-4-q3",
            question: "204 状态码表示什么？",
            options: [
                "资源未找到",
                "请求成功但无内容返回",
                "服务器错误",
                "未授权",
            ],
            answer: 1,
            rationale: "HTTP 规范：204 No Content 表示成功但没有内容返回，常用于 DELETE。",
        },
        {
            id: "py-w21-4-q4",
            question: "401 和 403 状态码的区别是什么？",
            options: [
                "没有区别",
                "401 未认证，403 已认证但无权限",
                "401 未找到，403 禁止访问",
                "401 服务器错误，403 客户端错误",
            ],
            answer: 1,
            rationale: "HTTP 规范：401 Unauthorized 需要认证，403 Forbidden 已认证但无权限。",
        },
        {
            id: "py-w21-4-q5",
            question: "什么是幂等性？",
            options: [
                "请求必须成功",
                "多次执行结果相同",
                "请求必须唯一",
                "响应必须快速",
            ],
            answer: 1,
            rationale: "REST 规范：幂等性指多次执行相同请求，结果与执行一次相同。",
        },
        {
            id: "py-w21-4-q6",
            question: "哪个 HTTP 方法通常不是幂等的？",
            options: [
                "GET",
                "POST",
                "PUT",
                "DELETE",
            ],
            answer: 1,
            rationale: "REST 规范：POST 创建资源，多次执行可能创建多个资源，因此不是幂等的。",
        },
        {
            id: "py-w21-4-q7",
            question: "REST API 为什么是无状态的？",
            options: [
                "为了简化实现",
                "每个请求包含所有必要信息，服务器不保存客户端状态",
                "不支持会话",
                "不能使用 cookie",
            ],
            answer: 1,
            rationale: "REST 原则：无状态意味着每个请求独立，包含所有必要信息。",
        },
        {
            id: "py-w21-4-q8",
            question: "422 状态码表示什么？",
            options: [
                "语法错误",
                "请求格式正确但语义错误（无法处理）",
                "服务器错误",
                "超时",
            ],
            answer: 1,
            rationale: "HTTP 规范：422 Unprocessable Content 表示请求格式正确但语义有误。",
        },
        {
            id: "py-w21-4-q9",
            question: "REST API 应该使用什么数据格式？",
            options: [
                "XML",
                "JSON",
                "YAML",
                "纯文本",
            ],
            answer: 1,
            rationale: "REST 最佳实践：现代 REST API 通常使用 JSON 作为数据交换格式。",
        },
        {
            id: "py-w21-4-q10",
            question: "429 状态码表示什么？",
            options: [
                "请求超时",
                "请求过多（速率限制）",
                "服务不可用",
                "网关错误",
            ],
            answer: 1,
            rationale: "HTTP 规范：429 Too Many Requests 表示客户端发送请求过多。",
        },
        {
            id: "py-w21-4-q11",
            question: "500 状态码表示什么？",
            options: [
                "客户端错误",
                "服务器内部错误",
                "资源未找到",
                "请求超时",
            ],
            answer: 1,
            rationale: "HTTP 规范：500 Internal Server Error 表示服务器遇到意外情况。",
        },
        {
            id: "py-w21-4-q12",
            question: "API 版本控制的常见方式是什么？",
            options: [
                "只能使用查询参数",
                "URL 路径（如 /api/v1/）、请求头或查询参数",
                "只能使用请求头",
                "不需要版本控制",
            ],
            answer: 1,
            rationale: "REST 最佳实践：版本控制可通过 URL 路径、请求头或查询参数实现。",
        },
    ],
}
