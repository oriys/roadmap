import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week13Guides: Record<string, LessonGuide> = {
    "py-w13-1": {
        lessonId: "py-w13-1",
        background: [
            "【装饰器定义】装饰器是一个返回另一个函数的函数，通常使用 @wrapper 语法作为函数变换应用。常见例子包括 classmethod() 和 staticmethod()。",
            "【语法糖本质】@decorator 是语法糖。@staticmethod def f(): ... 等价于 def f(): ...; f = staticmethod(f)。装饰器语法将变换移到函数声明处。",
            "【执行时机】装饰器表达式在函数定义时求值，而非调用时。求值结果必须是可调用对象，该对象以函数对象作为唯一参数调用。",
            "【多装饰器顺序】多个装饰器从下到上嵌套应用。@f1(arg) @f2 def func() 等价于 func = f1(arg)(f2(func))。",
            "【设计动机】PEP 318 解决了可读性问题：之前变换放在函数体后，分离使代码难以理解。装饰器语法将变换移到函数声明，提高代码组织性。",
        ],
        keyDifficulties: [
            "【装饰器求值顺序】装饰器表达式从上到下求值，但应用顺序从下到上。理解这个区别对于带参数装饰器很重要。",
            "【原函数不绑定】装饰过程中原始函数不会临时绑定到函数名。装饰器接收的是函数对象，返回值绑定到函数名。",
            "【Python 3.9+ 增强】Python 3.9 允许任意赋值表达式作为装饰器：@decorators[0] 或 @getattr(module, 'name') 都是有效的。",
            "【返回值要求】装饰器必须返回可调用对象。通常返回包装函数或原函数本身（如仅用于注册）。",
        ],
        handsOnPath: [
            "1. 简单装饰器：def log(f): def wrapper(*a): print('call'); return f(*a); return wrapper",
            "2. 使用装饰器：@log def greet(name): return f'Hello {name}'",
            "3. 验证效果：greet('Alice')  # 打印 'call' 然后返回 'Hello Alice'",
            "4. 手动应用：greet = log(greet)  # 等价于 @log",
            "5. 多装饰器：@decorator1 @decorator2 def f(): pass  # f = decorator1(decorator2(f))",
            "6. 不改变函数：def register(f): registry.append(f); return f",
        ],
        selfCheck: [
            "@decorator 语法等价于什么？",
            "装饰器表达式什么时候求值？",
            "多个装饰器的执行顺序是什么？",
            "装饰器必须返回什么类型？",
            "装饰器的设计动机是什么？",
            "Python 3.9 对装饰器语法有什么增强？",
        ],
        extensions: [
            "学习 wrapt 库实现通用装饰器",
            "了解装饰器与描述符的关系",
            "探索 typing.overload 装饰器",
            "学习 contextlib.contextmanager 装饰器",
        ],
        sourceUrls: [
            "https://docs.python.org/3/glossary.html#term-decorator",
            "https://docs.python.org/3/reference/compound_stmts.html#function-definitions",
            "https://peps.python.org/pep-0318/",
        ],
    },
    "py-w13-2": {
        lessonId: "py-w13-2",
        background: [
            "【装饰器工厂】带参数的装饰器实际上是返回装饰器的函数（工厂）。@deco(args) def f() 翻译为 f = deco(args)(f)。",
            "【两层调用】第一层调用接收装饰器参数返回实际装饰器；第二层调用接收被装饰函数返回包装函数。",
            "【functools.partial】partial(func, arg) 冻结函数的部分参数，返回新的可调用对象。可用于简化装饰器工厂实现。",
            "【partial 属性】partial 对象有三个只读属性：func（原函数）、args（预填充位置参数）、keywords（预填充关键字参数）。",
            "【嵌套装饰器】可以链式使用多个带参数的装饰器：@retry(3) @cache(ttl=60) def fetch(): ...。",
        ],
        keyDifficulties: [
            "【三层嵌套】带参数装饰器通常需要三层函数：外层接收参数、中层接收函数、内层是实际包装器。",
            "【可选参数装饰器】实现 @deco 和 @deco() 都能用的装饰器需要检查第一个参数是否是函数。",
            "【partial 简化】使用 partial 可以避免三层嵌套：decorator = partial(wrapper_factory, config=config)。",
            "【参数验证时机】装饰器参数在装饰时验证，而非函数调用时。这影响错误发现时机。",
        ],
        handsOnPath: [
            "1. 带参数装饰器：def repeat(n): def decorator(f): def wrapper(*a): for _ in range(n): f(*a); return wrapper; return decorator",
            "2. 使用：@repeat(3) def say_hello(): print('Hello')",
            "3. 等价于：say_hello = repeat(3)(say_hello)",
            "4. 使用 partial：from functools import partial; log_info = partial(log, level='INFO')",
            "5. 可选参数：def deco(f=None, *, opt=1): if f is None: return partial(deco, opt=opt); ...",
            "6. 验证效果：say_hello()  # 打印 3 次 'Hello'",
        ],
        selfCheck: [
            "@deco(args) def f() 翻译成什么？",
            "带参数装饰器为什么需要三层函数？",
            "functools.partial 的作用是什么？",
            "如何实现既支持 @deco 又支持 @deco() 的装饰器？",
            "partial 对象有哪些属性？",
            "装饰器参数什么时候被验证？",
        ],
        extensions: [
            "学习 click.option 等 CLI 装饰器实现",
            "了解 Flask 路由装饰器的工厂模式",
            "探索 functools.partialmethod 用于方法",
            "学习 attrs 库的属性装饰器",
        ],
        sourceUrls: [
            "https://docs.python.org/3/glossary.html#term-decorator",
            "https://docs.python.org/3/library/functools.html#functools.partial",
            "https://peps.python.org/pep-0318/#current-syntax",
        ],
    },
    "py-w13-3": {
        lessonId: "py-w13-3",
        background: [
            "【wraps 用途】functools.wraps 是便利装饰器，用于保留被装饰函数的元数据。没有 wraps，包装函数会丢失原函数的 __name__、__doc__ 等。",
            "【WRAPPER_ASSIGNMENTS】wraps 默认复制的属性：__module__、__name__、__qualname__、__annotations__、__type_params__、__doc__。",
            "【WRAPPER_UPDATES】wraps 默认更新的属性：__dict__（实例字典）。",
            "【__wrapped__ 属性】wraps 自动添加 __wrapped__ 属性指向原始函数，用于内省、绕过缓存装饰器等。",
            "【update_wrapper】wraps 是 partial(update_wrapper, ...) 的简写。update_wrapper 是底层实现。",
        ],
        keyDifficulties: [
            "【不用 wraps 的后果】包装函数的 __name__ 变成 'wrapper'，__doc__ 变成 None，影响调试和文档生成。",
            "【缺失属性处理】如果原函数缺少某个属性，wraps 会静默忽略，不会抛出错误。",
            "【自定义复制属性】可以通过 assigned 和 updated 参数自定义要复制和更新的属性。",
            "【多层装饰】每层装饰器都应使用 @wraps，否则 __wrapped__ 链会断裂。",
        ],
        handsOnPath: [
            "1. 标准用法：from functools import wraps",
            "2. 定义装饰器：def deco(f): @wraps(f) def wrapper(*a, **kw): return f(*a, **kw); return wrapper",
            "3. 应用装饰器：@deco def example(): '''文档字符串'''; pass",
            "4. 验证元数据：print(example.__name__)  # 'example' 而非 'wrapper'",
            "5. 验证文档：print(example.__doc__)  # '文档字符串'",
            "6. 访问原函数：print(example.__wrapped__)  # 原始 example 函数",
        ],
        selfCheck: [
            "不使用 wraps 会丢失什么？",
            "WRAPPER_ASSIGNMENTS 包含哪些属性？",
            "__wrapped__ 属性的作用是什么？",
            "wraps 和 update_wrapper 的关系是什么？",
            "如何自定义要复制的属性？",
            "wraps 如何处理缺失的属性？",
        ],
        extensions: [
            "学习 inspect.unwrap 解开装饰器链",
            "了解 functools.WRAPPER_ASSIGNMENTS 自定义",
            "探索装饰器与类型检查器的交互",
            "学习 typing.ParamSpec 保留参数类型",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/functools.html#functools.wraps",
            "https://docs.python.org/3/library/functools.html#functools.update_wrapper",
            "https://docs.python.org/3/library/functools.html#functools.WRAPPER_ASSIGNMENTS",
        ],
    },
    "py-w13-4": {
        lessonId: "py-w13-4",
        background: [
            "【类装饰器实现】类通过实现 __call__ 方法成为可调用对象。__call__(self, *args) 使实例可以像函数一样调用。",
            "【类装饰器优势】类装饰器可以维护状态（如调用计数），比闭包更清晰。实例变量代替闭包捕获的变量。",
            "【装饰类本身】装饰器也可以用于装饰类：@decorator class C: pass 等价于 C = decorator(C)。PEP 3129 引入此功能。",
            "【@dataclass 示例】dataclasses.dataclass 是类装饰器的典型例子，自动生成 __init__、__repr__、__eq__ 等方法。",
            "【类装饰器 vs 元类】类装饰器不会被继承，适合单类特定功能；元类会被继承，适合影响类层次结构。",
        ],
        keyDifficulties: [
            "【__call__ 签名】装饰器类的 __init__ 接收被装饰函数，__call__ 接收函数调用参数。",
            "【状态管理】类装饰器的状态是实例级别的。每个被装饰函数有独立的装饰器实例。",
            "【与 wraps 配合】类装饰器也应该保留元数据：在 __init__ 中使用 functools.update_wrapper(self, func)。",
            "【dataclass 参数】@dataclass 支持多个参数：frozen=True 冻结实例、order=True 生成比较方法、slots=True 使用 __slots__。",
        ],
        handsOnPath: [
            "1. 类装饰器：class Counter: def __init__(self, f): self.f = f; self.count = 0",
            "2. 实现 __call__：def __call__(self, *a): self.count += 1; return self.f(*a)",
            "3. 使用：@Counter def greet(name): return f'Hello {name}'",
            "4. 查看计数：greet('Alice'); greet('Bob'); print(greet.count)  # 2",
            "5. dataclass：from dataclasses import dataclass; @dataclass class Point: x: int; y: int",
            "6. 使用 dataclass：p = Point(1, 2); print(p)  # Point(x=1, y=2)",
        ],
        selfCheck: [
            "__call__ 方法的作用是什么？",
            "类装饰器相比函数装饰器有什么优势？",
            "装饰器用于装饰类时的语法是什么？",
            "@dataclass 自动生成哪些方法？",
            "类装饰器和元类有什么区别？",
            "如何在类装饰器中保留被装饰函数的元数据？",
        ],
        extensions: [
            "学习 dataclasses.field 高级用法",
            "了解 attrs 库的类装饰器",
            "探索 functools.singledispatch 单分派",
            "学习 PEP 557 dataclasses 设计",
        ],
        sourceUrls: [
            "https://docs.python.org/3/reference/datamodel.html#object.__call__",
            "https://peps.python.org/pep-3129/",
            "https://docs.python.org/3/library/dataclasses.html",
        ],
    },
}

export const week13Quizzes: Record<string, QuizQuestion[]> = {
    "py-w13-1": [
        {
            id: "py-w13-1-q1",
            question: "@decorator def f(): pass 等价于什么？",
            options: [
                "f = decorator; f()",
                "f = decorator(f)",
                "decorator = f",
                "f.decorator = True",
            ],
            answer: 1,
            rationale: "文档说明：@decorator 是语法糖，等价于 def f(): ...; f = decorator(f)。",
        },
        {
            id: "py-w13-1-q2",
            question: "装饰器表达式什么时候求值？",
            options: [
                "函数调用时",
                "函数定义时",
                "模块导入时",
                "程序退出时",
            ],
            answer: 1,
            rationale: "文档说明：装饰器表达式在函数定义时求值，而非调用时。",
        },
        {
            id: "py-w13-1-q3",
            question: "@f1 @f2 def func() 等价于什么？",
            options: [
                "func = f2(f1(func))",
                "func = f1(f2(func))",
                "func = f1(func); func = f2(func)",
                "func = f1 + f2",
            ],
            answer: 1,
            rationale: "文档说明：多个装饰器从下到上嵌套应用，@f1 @f2 def func 等价于 func = f1(f2(func))。",
        },
        {
            id: "py-w13-1-q4",
            question: "装饰器必须返回什么？",
            options: [
                "None",
                "字符串",
                "可调用对象",
                "任意类型",
            ],
            answer: 2,
            rationale: "文档说明：装饰器的求值结果必须是可调用对象。",
        },
        {
            id: "py-w13-1-q5",
            question: "PEP 318 引入装饰器语法的主要动机是什么？",
            options: [
                "提高性能",
                "解决可读性问题，将变换移到函数声明处",
                "支持类型检查",
                "兼容其他语言",
            ],
            answer: 1,
            rationale: "PEP 318 解决了可读性问题：之前变换放在函数体后，装饰器语法将变换移到函数声明。",
        },
        {
            id: "py-w13-1-q6",
            question: "Python 3.9 对装饰器语法有什么增强？",
            options: [
                "支持异步装饰器",
                "允许任意赋值表达式作为装饰器",
                "自动添加 wraps",
                "支持类型注解",
            ],
            answer: 1,
            rationale: "Python 3.9 允许任意赋值表达式作为装饰器：@decorators[0] 或 @getattr(module, 'name')。",
        },
        {
            id: "py-w13-1-q7",
            question: "以下哪个是内置装饰器？",
            options: [
                "@decorator",
                "@wrapper",
                "@staticmethod",
                "@function",
            ],
            answer: 2,
            rationale: "文档说明：常见内置装饰器包括 @classmethod、@staticmethod、@property。",
        },
        {
            id: "py-w13-1-q8",
            question: "装饰器接收什么作为参数？",
            options: [
                "函数名字符串",
                "函数调用的参数",
                "函数对象",
                "模块对象",
            ],
            answer: 2,
            rationale: "文档说明：装饰器以函数对象作为唯一参数调用。",
        },
        {
            id: "py-w13-1-q9",
            question: "装饰过程中原始函数是否临时绑定到函数名？",
            options: [
                "是",
                "否",
                "取决于装饰器",
                "只在调试模式下",
            ],
            answer: 1,
            rationale: "文档说明：装饰过程中原始函数不会临时绑定到函数名，装饰器的返回值直接绑定。",
        },
        {
            id: "py-w13-1-q10",
            question: "装饰器可以不修改函数而仅用于什么目的？",
            options: [
                "性能优化",
                "注册函数到某个列表",
                "类型检查",
                "内存管理",
            ],
            answer: 1,
            rationale: "装饰器可以仅用于注册：def register(f): registry.append(f); return f，不修改函数。",
        },
        {
            id: "py-w13-1-q11",
            question: "@f1(arg) @f2 def func() 的执行顺序是什么？",
            options: [
                "f1(arg) → f2 → func",
                "arg 求值 → f1(arg) 求值 → f2 求值 → f2(func) → f1(arg)(result)",
                "func → f2 → f1",
                "随机顺序",
            ],
            answer: 1,
            rationale: "表达式从上到下求值（arg、f1(arg)、f2），然后从下到上应用（f2(func)、f1(arg)(result)）。",
        },
        {
            id: "py-w13-1-q12",
            question: "装饰器可以用于函数和什么？",
            options: [
                "只能用于函数",
                "函数和类",
                "函数和变量",
                "函数和模块",
            ],
            answer: 1,
            rationale: "文档说明：装饰器可以用于函数装饰器和类装饰器，语法相同。",
        },
    ],
    "py-w13-2": [
        {
            id: "py-w13-2-q1",
            question: "@deco(args) def f() 翻译成什么？",
            options: [
                "f = deco(f, args)",
                "f = deco(args)(f)",
                "f = deco(args, f)",
                "f = args(deco(f))",
            ],
            answer: 1,
            rationale: "文档说明：@deco(args) def f() 翻译为 f = deco(args)(f)，装饰器工厂先接收参数。",
        },
        {
            id: "py-w13-2-q2",
            question: "带参数装饰器为什么通常需要三层函数？",
            options: [
                "提高性能",
                "外层接收参数、中层接收函数、内层是包装器",
                "Python 语法要求",
                "兼容性原因",
            ],
            answer: 1,
            rationale: "带参数装饰器需要：外层接收装饰器参数、中层接收被装饰函数、内层是实际的包装函数。",
        },
        {
            id: "py-w13-2-q3",
            question: "functools.partial 的作用是什么？",
            options: [
                "部分执行函数",
                "冻结函数的部分参数，返回新的可调用对象",
                "删除函数参数",
                "验证函数参数",
            ],
            answer: 1,
            rationale: "文档说明：partial 通过冻结部分参数和关键字参数，创建简化签名的新可调用对象。",
        },
        {
            id: "py-w13-2-q4",
            question: "partial 对象的 func 属性是什么？",
            options: [
                "包装后的函数",
                "原始函数对象",
                "参数列表",
                "返回值",
            ],
            answer: 1,
            rationale: "文档说明：partial 对象的 func 属性是原始函数对象。",
        },
        {
            id: "py-w13-2-q5",
            question: "如何实现既支持 @deco 又支持 @deco() 的装饰器？",
            options: [
                "使用两个不同的装饰器",
                "检查第一个参数是否是函数，用 partial 返回",
                "不可能实现",
                "使用元类",
            ],
            answer: 1,
            rationale: "检查第一个参数：if f is None: return partial(deco, opt=opt); 否则直接装饰。",
        },
        {
            id: "py-w13-2-q6",
            question: "partial 对象的 keywords 属性是什么？",
            options: [
                "函数名",
                "预填充的关键字参数字典",
                "函数文档",
                "返回类型",
            ],
            answer: 1,
            rationale: "文档说明：partial 对象的 keywords 属性是预填充的关键字参数字典。",
        },
        {
            id: "py-w13-2-q7",
            question: "装饰器参数什么时候被验证？",
            options: [
                "函数调用时",
                "装饰时（函数定义时）",
                "模块导入时",
                "程序退出时",
            ],
            answer: 1,
            rationale: "装饰器参数在装饰时验证，即函数定义时，而非函数调用时。",
        },
        {
            id: "py-w13-2-q8",
            question: "partial(int, base=2)('10010') 返回什么？",
            options: [
                "'10010'",
                "10010",
                "18",
                "TypeError",
            ],
            answer: 2,
            rationale: "文档示例：partial(int, base=2) 创建二进制转换函数，'10010' 二进制是 18。",
        },
        {
            id: "py-w13-2-q9",
            question: "partial 对象的 args 属性是什么？",
            options: [
                "函数名列表",
                "预填充的位置参数元组",
                "返回值列表",
                "异常类型",
            ],
            answer: 1,
            rationale: "文档说明：partial 对象的 args 属性是预填充的位置参数元组。",
        },
        {
            id: "py-w13-2-q10",
            question: "嵌套使用 partial 会怎样？",
            options: [
                "抛出错误",
                "可以将 partial 应用于另一个 partial 对象",
                "忽略外层 partial",
                "覆盖内层参数",
            ],
            answer: 1,
            rationale: "文档说明：可以嵌套 partial，将 partial 应用于另一个 partial 对象。",
        },
        {
            id: "py-w13-2-q11",
            question: "repeat(3)(func) 中 repeat(3) 返回什么？",
            options: [
                "func",
                "装饰器函数",
                "3",
                "None",
            ],
            answer: 1,
            rationale: "repeat(3) 是装饰器工厂，返回实际的装饰器函数，该装饰器接收 func 作为参数。",
        },
        {
            id: "py-w13-2-q12",
            question: "Python 3.14+ partial 的 Placeholder 用于什么？",
            options: [
                "表示可选参数",
                "预留特定位置供后续填充",
                "表示默认值",
                "表示类型",
            ],
            answer: 1,
            rationale: "文档说明：Placeholder 用于预留任意位置的参数，而不仅限于前导参数。",
        },
    ],
    "py-w13-3": [
        {
            id: "py-w13-3-q1",
            question: "不使用 wraps 会丢失什么？",
            options: [
                "函数功能",
                "__name__、__doc__ 等元数据",
                "函数参数",
                "返回值",
            ],
            answer: 1,
            rationale: "文档说明：没有 wraps，包装函数会丢失原函数的 __name__、__doc__ 等元数据。",
        },
        {
            id: "py-w13-3-q2",
            question: "WRAPPER_ASSIGNMENTS 默认包含哪些属性？",
            options: [
                "__name__ 和 __doc__",
                "__module__、__name__、__qualname__、__annotations__、__type_params__、__doc__",
                "只有 __name__",
                "__dict__ 和 __class__",
            ],
            answer: 1,
            rationale: "文档说明：WRAPPER_ASSIGNMENTS 包含 __module__、__name__、__qualname__、__annotations__、__type_params__、__doc__。",
        },
        {
            id: "py-w13-3-q3",
            question: "__wrapped__ 属性的作用是什么？",
            options: [
                "存储包装器名称",
                "指向原始函数，用于内省和绕过缓存",
                "存储装饰器参数",
                "存储调用次数",
            ],
            answer: 1,
            rationale: "文档说明：__wrapped__ 自动添加，指向原始函数，用于内省、绕过缓存装饰器等。",
        },
        {
            id: "py-w13-3-q4",
            question: "wraps 和 update_wrapper 的关系是什么？",
            options: [
                "完全相同",
                "wraps 是 partial(update_wrapper, ...) 的简写",
                "update_wrapper 是 wraps 的简写",
                "没有关系",
            ],
            answer: 1,
            rationale: "文档说明：wraps 是 partial(update_wrapper, wrapped=wrapped, ...) 的便利简写。",
        },
        {
            id: "py-w13-3-q5",
            question: "wraps 如何处理原函数缺失的属性？",
            options: [
                "抛出 AttributeError",
                "静默忽略，不会抛出错误",
                "设置为 None",
                "设置为空字符串",
            ],
            answer: 1,
            rationale: "文档说明：如果原函数缺少某个属性，wraps 会静默忽略，不会抛出错误。",
        },
        {
            id: "py-w13-3-q6",
            question: "WRAPPER_UPDATES 默认更新什么属性？",
            options: [
                "__name__",
                "__dict__",
                "__doc__",
                "__module__",
            ],
            answer: 1,
            rationale: "文档说明：WRAPPER_UPDATES 默认更新 __dict__（实例字典）。",
        },
        {
            id: "py-w13-3-q7",
            question: "@wraps(f) 应该放在哪里？",
            options: [
                "装饰器函数定义前",
                "包装函数定义前",
                "被装饰函数定义前",
                "模块开头",
            ],
            answer: 1,
            rationale: "@wraps(f) 装饰包装函数，应放在 def wrapper() 定义前。",
        },
        {
            id: "py-w13-3-q8",
            question: "多层装饰器应该如何使用 wraps？",
            options: [
                "只在最外层使用",
                "每层装饰器都应使用 @wraps",
                "只在最内层使用",
                "不需要使用",
            ],
            answer: 1,
            rationale: "每层装饰器都应使用 @wraps，否则 __wrapped__ 链会断裂。",
        },
        {
            id: "py-w13-3-q9",
            question: "如何自定义 wraps 复制的属性？",
            options: [
                "无法自定义",
                "通过 assigned 和 updated 参数",
                "修改原函数",
                "使用元类",
            ],
            answer: 1,
            rationale: "文档说明：可以通过 assigned 和 updated 参数自定义要复制和更新的属性。",
        },
        {
            id: "py-w13-3-q10",
            question: "不使用 wraps 时，wrapper.__name__ 是什么？",
            options: [
                "原函数名",
                "'wrapper'",
                "None",
                "空字符串",
            ],
            answer: 1,
            rationale: "不使用 wraps 时，包装函数的 __name__ 是其定义名 'wrapper'，不是原函数名。",
        },
        {
            id: "py-w13-3-q11",
            question: "Python 3.12 对 wraps 有什么更新？",
            options: [
                "删除了 wraps",
                "__type_params__ 默认被复制",
                "不再需要 wraps",
                "wraps 改名了",
            ],
            answer: 1,
            rationale: "文档说明：Python 3.12 版本将 __type_params__ 添加到默认复制的属性中。",
        },
        {
            id: "py-w13-3-q12",
            question: "如何访问被 wraps 包装的原始函数？",
            options: [
                "wrapper.original",
                "wrapper.__wrapped__",
                "wrapper.func",
                "unwrap(wrapper)",
            ],
            answer: 1,
            rationale: "wraps 自动添加 __wrapped__ 属性指向原始函数。",
        },
    ],
    "py-w13-4": [
        {
            id: "py-w13-4-q1",
            question: "__call__ 方法的作用是什么？",
            options: [
                "初始化对象",
                "使实例可以像函数一样调用",
                "销毁对象",
                "比较对象",
            ],
            answer: 1,
            rationale: "文档说明：__call__ 使实例可调用，instance(args) 会调用 instance.__call__(args)。",
        },
        {
            id: "py-w13-4-q2",
            question: "类装饰器相比函数装饰器有什么优势？",
            options: [
                "运行更快",
                "可以维护状态（如调用计数）",
                "代码更短",
                "兼容性更好",
            ],
            answer: 1,
            rationale: "类装饰器可以使用实例变量维护状态，比闭包更清晰直观。",
        },
        {
            id: "py-w13-4-q3",
            question: "@decorator class C 等价于什么？",
            options: [
                "class C(decorator)",
                "C = decorator(C)",
                "decorator = C",
                "C.decorator = True",
            ],
            answer: 1,
            rationale: "PEP 3129 说明：@decorator class C: pass 等价于 class C: pass; C = decorator(C)。",
        },
        {
            id: "py-w13-4-q4",
            question: "@dataclass 自动生成哪些方法？",
            options: [
                "只有 __init__",
                "__init__、__repr__、__eq__ 等",
                "只有 __repr__",
                "所有魔术方法",
            ],
            answer: 1,
            rationale: "文档说明：@dataclass 自动生成 __init__、__repr__、__eq__ 等特殊方法。",
        },
        {
            id: "py-w13-4-q5",
            question: "类装饰器和元类有什么区别？",
            options: [
                "没有区别",
                "类装饰器不会被继承，元类会被继承",
                "元类不会被继承",
                "类装饰器更复杂",
            ],
            answer: 1,
            rationale: "PEP 3129 说明：类装饰器不会被继承，适合单类特定功能；元类会被继承。",
        },
        {
            id: "py-w13-4-q6",
            question: "装饰器类的 __init__ 通常接收什么参数？",
            options: [
                "装饰器参数",
                "被装饰的函数",
                "函数调用参数",
                "类名",
            ],
            answer: 1,
            rationale: "装饰器类的 __init__ 接收被装饰函数，__call__ 接收函数调用参数。",
        },
        {
            id: "py-w13-4-q7",
            question: "@dataclass(frozen=True) 的作用是什么？",
            options: [
                "提高性能",
                "冻结实例，禁止修改属性",
                "冻结类定义",
                "禁止继承",
            ],
            answer: 1,
            rationale: "文档说明：frozen=True 使实例不可变，尝试修改属性会抛出 FrozenInstanceError。",
        },
        {
            id: "py-w13-4-q8",
            question: "dataclass 的 field(default_factory=list) 用于什么？",
            options: [
                "设置字段类型",
                "为可变默认值提供工厂函数",
                "验证字段值",
                "设置字段名",
            ],
            answer: 1,
            rationale: "文档说明：default_factory 用于可变默认值，确保每个实例有独立的对象。",
        },
        {
            id: "py-w13-4-q9",
            question: "如何在类装饰器中保留被装饰函数的元数据？",
            options: [
                "自动保留",
                "在 __init__ 中使用 functools.update_wrapper(self, func)",
                "使用 @wraps",
                "不需要保留",
            ],
            answer: 1,
            rationale: "类装饰器应在 __init__ 中调用 update_wrapper(self, func) 保留元数据。",
        },
        {
            id: "py-w13-4-q10",
            question: "@dataclass(order=True) 生成哪些方法？",
            options: [
                "只有 __eq__",
                "__lt__、__le__、__gt__、__ge__",
                "只有 __lt__",
                "__hash__",
            ],
            answer: 1,
            rationale: "文档说明：order=True 生成 __lt__、__le__、__gt__、__ge__ 比较方法。",
        },
        {
            id: "py-w13-4-q11",
            question: "类装饰器的状态是什么级别的？",
            options: [
                "类级别",
                "实例级别（每个被装饰函数独立）",
                "模块级别",
                "全局级别",
            ],
            answer: 1,
            rationale: "类装饰器的状态是实例级别的，每个被装饰函数有独立的装饰器实例。",
        },
        {
            id: "py-w13-4-q12",
            question: "PEP 3129 在哪个 Python 版本中被采纳？",
            options: [
                "Python 2.4",
                "Python 3.0",
                "Python 3.5",
                "Python 3.9",
            ],
            answer: 1,
            rationale: "PEP 3129 在 Python 3.0 中被采纳，实现了类装饰器功能。",
        },
    ],
}
