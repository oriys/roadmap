import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week20Guides: Record<string, LessonGuide> = {
    "py-w20-1": {
        lessonId: "py-w20-1",
        background: [
            "【pytest 测试框架】Python 最流行的测试框架，使用简单的 assert 语句，自动发现并运行测试。",
            "【测试发现】pytest 自动发现 test_*.py 或 *_test.py 文件，运行 test_ 开头的函数或方法。",
            "【assert 增强】pytest 重写 assert 语句，失败时智能显示中间值和比较结果，无需记忆专门的断言方法。",
            "【命令行选项】pytest -v 详细输出；pytest -q 简洁输出；pytest -k 选择特定测试；pytest -x 首次失败即停止。",
            "【测试类】以 Test 开头的类包含 test_ 方法，不需要继承 TestCase。",
        ],
        keyDifficulties: [
            "【assert vs assertEqual】pytest 直接用 assert a == b，unittest 需要 self.assertEqual(a, b)。",
            "【测试隔离】每个测试应独立运行，不依赖其他测试的结果或顺序。",
            "【测试命名】测试函数/方法必须以 test_ 开头才会被发现和执行。",
            "【退出码】pytest 返回 0 表示全部通过，非 0 表示有失败或错误。",
        ],
        handsOnPath: [
            "1. 安装：pip install pytest",
            "2. 写测试：def test_add(): assert 1 + 1 == 2",
            "3. 运行：pytest test_example.py",
            "4. 详细输出：pytest -v",
            "5. 运行特定测试：pytest -k 'test_add'",
            "6. 失败即停：pytest -x",
        ],
        selfCheck: [
            "pytest 如何发现测试？",
            "如何编写简单的测试函数？",
            "pytest 的 assert 和 unittest 的断言方法有什么区别？",
            "-v 和 -q 选项的作用是什么？",
            "如何只运行特定的测试？",
            "测试失败时 pytest 返回什么退出码？",
        ],
        extensions: [
            "学习 pytest-cov 测量代码覆盖率",
            "了解 pytest-mock 模拟对象",
            "探索 pytest-xdist 并行测试",
            "学习 pytest-asyncio 异步测试",
        ],
        sourceUrls: [
            "https://docs.pytest.org/",
            "https://docs.python.org/3/library/unittest.html",
            "https://docs.python.org/3/library/unittest.html#basic-example",
        ],
    },
    "py-w20-2": {
        lessonId: "py-w20-2",
        background: [
            "【fixture 机制】pytest 的 fixture 提供测试所需的资源。使用 @pytest.fixture 装饰器定义，通过参数名注入。",
            "【fixture 作用域】scope 参数控制生命周期：function（默认每个测试）、class、module、package、session。",
            "【参数化测试】@pytest.mark.parametrize('input,expected', [...]) 用同一测试代码测试多组数据。",
            "【内置 fixture】tmp_path 临时目录；capsys 捕获标准输出；monkeypatch 动态修改对象。",
            "【fixture 组合】fixture 可以依赖其他 fixture，通过参数请求，pytest 自动处理依赖关系。",
        ],
        keyDifficulties: [
            "【fixture vs setUp】fixture 更灵活，可按需注入，支持不同作用域。setUp 每个测试都执行。",
            "【autouse】autouse=True 的 fixture 自动应用于所有测试，无需显式请求。",
            "【yield fixture】使用 yield 代替 return，yield 后的代码在测试完成后执行（清理）。",
            "【conftest.py】定义在 conftest.py 中的 fixture 自动对同目录和子目录可用。",
        ],
        handsOnPath: [
            "1. 定义 fixture：@pytest.fixture def db(): return Database()",
            "2. 使用 fixture：def test_query(db): assert db.query() == []",
            "3. 参数化：@pytest.mark.parametrize('n,expected', [(1,1), (2,4)])",
            "4. 清理 fixture：@pytest.fixture def f(): yield resource; cleanup()",
            "5. 作用域：@pytest.fixture(scope='module')",
            "6. 临时目录：def test_file(tmp_path): path = tmp_path / 'test.txt'",
        ],
        selfCheck: [
            "fixture 和 setUp 有什么区别？",
            "如何定义模块级别的 fixture？",
            "@pytest.mark.parametrize 的作用是什么？",
            "yield fixture 的清理代码何时执行？",
            "conftest.py 文件的作用是什么？",
            "tmp_path fixture 提供什么？",
        ],
        extensions: [
            "学习 fixture 的依赖注入模式",
            "了解 factory fixture 模式",
            "探索 pytest-fixtures 插件",
            "学习 indirect parametrize",
        ],
        sourceUrls: [
            "https://docs.pytest.org/en/stable/explanation/fixtures.html",
            "https://docs.pytest.org/en/stable/how-to/parametrize.html",
            "https://docs.pytest.org/en/stable/reference/plugin_list.html",
        ],
    },
    "py-w20-3": {
        lessonId: "py-w20-3",
        background: [
            "【mypy 类型检查】静态类型检查器，在运行前发现类型错误。mypy script.py 检查文件。",
            "【ruff 代码质量】极快的 Python linter 和格式化工具，替代 flake8、isort、black 等多个工具。",
            "【类型注解检查】mypy 检查类型注解是否一致，函数参数和返回值类型是否正确。",
            "【strict 模式】mypy --strict 启用所有严格检查，要求更完整的类型注解。",
            "【pre-commit】Git 钩子框架，在提交前自动运行检查（mypy、ruff 等）。",
        ],
        keyDifficulties: [
            "【渐进式类型】可以逐步添加类型注解，mypy 只检查有注解的代码。",
            "【Any 类型】未注解的变量默认是 Any，跳过类型检查。使用 --strict 强制注解。",
            "【第三方库类型】有些库没有类型存根，需要安装 types-* 包或使用 # type: ignore。",
            "【ruff vs black/flake8】ruff 用 Rust 编写，速度比传统工具快 10-100 倍。",
        ],
        handsOnPath: [
            "1. 安装：pip install mypy ruff",
            "2. 类型检查：mypy script.py",
            "3. 严格模式：mypy --strict script.py",
            "4. ruff 检查：ruff check .",
            "5. ruff 格式化：ruff format .",
            "6. pre-commit：pre-commit install",
        ],
        selfCheck: [
            "mypy 在什么时候运行？",
            "如何启用 mypy 的严格模式？",
            "ruff 替代了哪些传统工具？",
            "第三方库没有类型存根怎么办？",
            "pre-commit 的作用是什么？",
            "如何忽略某行的类型检查？",
        ],
        extensions: [
            "学习 pyright 另一个类型检查器",
            "了解 mypy 配置文件",
            "探索 typing_extensions 模块",
            "学习 stubgen 生成类型存根",
        ],
        sourceUrls: [
            "https://mypy.readthedocs.io/",
            "https://docs.astral.sh/ruff/",
            "https://pre-commit.com/",
        ],
    },
    "py-w20-4": {
        lessonId: "py-w20-4",
        background: [
            "【pdb 调试器】Python 内置的交互式调试器。breakpoint() 设置断点（Python 3.7+）。",
            "【基本命令】n(ext) 执行下一行；s(tep) 进入函数；c(ontinue) 继续执行；p(rint) 打印变量；l(ist) 查看代码。",
            "【设置断点】breakpoint() 或 import pdb; pdb.set_trace() 在代码中设置断点。",
            "【命令行调试】python -m pdb script.py 从头开始调试脚本。",
            "【事后调试】pdb.pm() 在异常发生后进入调试，检查异常时的状态。",
        ],
        keyDifficulties: [
            "【n vs s】n(ext) 执行当前行，不进入函数；s(tep) 进入函数内部。",
            "【where 命令】w(here) 显示调用栈，帮助理解程序执行路径。",
            "【变量修改】在 pdb 中可以执行 Python 代码修改变量，测试不同场景。",
            "【条件断点】break lineno, condition 设置条件断点，只在条件满足时停止。",
        ],
        handsOnPath: [
            "1. 设置断点：breakpoint()  # Python 3.7+",
            "2. 基本调试：(Pdb) n  # 下一行；(Pdb) s  # 进入函数",
            "3. 查看变量：(Pdb) p variable_name",
            "4. 查看代码：(Pdb) l  # 当前位置；(Pdb) ll  # 整个函数",
            "5. 调用栈：(Pdb) w  # where，显示调用栈",
            "6. 事后调试：import pdb; pdb.pm()  # 异常后调试",
        ],
        selfCheck: [
            "如何在代码中设置断点？",
            "n(ext) 和 s(tep) 的区别是什么？",
            "如何查看变量的值？",
            "如何在调试中查看调用栈？",
            "什么是事后调试？",
            "如何设置条件断点？",
        ],
        extensions: [
            "学习 ipdb 增强版调试器",
            "了解 IDE 集成调试器",
            "探索 pdb++ 改进版",
            "学习远程调试技术",
        ],
        sourceUrls: [
            "https://docs.python.org/3/library/pdb.html",
            "https://docs.python.org/3/library/pdb.html#debugger-commands",
            "https://docs.python.org/3/library/functions.html#breakpoint",
        ],
    },
}

export const week20Quizzes: Record<string, QuizQuestion[]> = {
    "py-w20-1": [
        {
            id: "py-w20-1-q1",
            question: "pytest 如何自动发现测试文件？",
            options: [
                "所有 .py 文件",
                "test_*.py 或 *_test.py 文件",
                "tests/ 目录下的文件",
                "需要手动指定",
            ],
            answer: 1,
            rationale: "文档说明：pytest 自动发现 test_*.py 或 *_test.py 文件。",
        },
        {
            id: "py-w20-1-q2",
            question: "pytest 中如何编写断言？",
            options: [
                "self.assertEqual(a, b)",
                "assert a == b",
                "expect(a).toBe(b)",
                "verify(a, b)",
            ],
            answer: 1,
            rationale: "文档说明：pytest 使用 Python 原生 assert 语句，并增强失败信息。",
        },
        {
            id: "py-w20-1-q3",
            question: "pytest -v 选项的作用是什么？",
            options: [
                "验证测试",
                "详细输出",
                "版本信息",
                "可视化",
            ],
            answer: 1,
            rationale: "文档说明：-v 表示 verbose，显示详细的测试输出。",
        },
        {
            id: "py-w20-1-q4",
            question: "pytest -k 选项的作用是什么？",
            options: [
                "指定配置文件",
                "根据名称表达式选择测试",
                "跳过测试",
                "显示关键字",
            ],
            answer: 1,
            rationale: "文档说明：-k 'expression' 选择匹配表达式的测试。",
        },
        {
            id: "py-w20-1-q5",
            question: "测试函数必须满足什么命名规则？",
            options: [
                "以 check_ 开头",
                "以 test_ 开头",
                "以 verify_ 开头",
                "任意名称",
            ],
            answer: 1,
            rationale: "文档说明：测试函数必须以 test_ 开头才会被发现。",
        },
        {
            id: "py-w20-1-q6",
            question: "pytest -x 选项的作用是什么？",
            options: [
                "排除测试",
                "首次失败即停止",
                "显示详细信息",
                "并行执行",
            ],
            answer: 1,
            rationale: "文档说明：-x 表示 exit first，首次失败即停止测试。",
        },
        {
            id: "py-w20-1-q7",
            question: "pytest 测试类需要继承什么？",
            options: [
                "unittest.TestCase",
                "pytest.TestCase",
                "不需要继承任何类",
                "object",
            ],
            answer: 2,
            rationale: "文档说明：pytest 测试类以 Test 开头即可，无需继承。",
        },
        {
            id: "py-w20-1-q8",
            question: "pytest 所有测试通过时返回什么退出码？",
            options: [
                "1",
                "0",
                "-1",
                "100",
            ],
            answer: 1,
            rationale: "文档说明：退出码 0 表示全部通过，非 0 表示有失败。",
        },
        {
            id: "py-w20-1-q9",
            question: "如何运行 pytest？",
            options: [
                "python test.py",
                "pytest 或 python -m pytest",
                "run pytest",
                "test",
            ],
            answer: 1,
            rationale: "文档说明：使用 pytest 命令或 python -m pytest 运行测试。",
        },
        {
            id: "py-w20-1-q10",
            question: "pytest assert 失败时会显示什么？",
            options: [
                "只显示 AssertionError",
                "智能显示中间值和比较结果",
                "只显示行号",
                "不显示任何信息",
            ],
            answer: 1,
            rationale: "文档说明：pytest 增强 assert，失败时智能显示中间值。",
        },
        {
            id: "py-w20-1-q11",
            question: "pytest --fixtures 选项的作用是什么？",
            options: [
                "修复测试",
                "显示可用的 fixture",
                "固定测试顺序",
                "设置 fixture",
            ],
            answer: 1,
            rationale: "文档说明：--fixtures 显示所有可用的 fixture。",
        },
        {
            id: "py-w20-1-q12",
            question: "如何在类级别应用标记？",
            options: [
                "不支持类级别标记",
                "@pytest.mark 放在类上，隐式应用于所有测试方法",
                "需要单独标记每个方法",
                "使用类属性",
            ],
            answer: 1,
            rationale: "文档说明：类级别的 mark 隐式应用于所有测试方法。",
        },
    ],
    "py-w20-2": [
        {
            id: "py-w20-2-q1",
            question: "如何定义 pytest fixture？",
            options: [
                "def setUp():",
                "@pytest.fixture def resource():",
                "class Fixture:",
                "@fixture",
            ],
            answer: 1,
            rationale: "文档说明：使用 @pytest.fixture 装饰器定义 fixture。",
        },
        {
            id: "py-w20-2-q2",
            question: "fixture 默认的作用域是什么？",
            options: [
                "session",
                "function",
                "module",
                "class",
            ],
            answer: 1,
            rationale: "文档说明：fixture 默认作用域是 function，每个测试调用一次。",
        },
        {
            id: "py-w20-2-q3",
            question: "@pytest.mark.parametrize 的作用是什么？",
            options: [
                "参数验证",
                "用多组参数运行同一测试",
                "设置默认参数",
                "参数解析",
            ],
            answer: 1,
            rationale: "文档说明：parametrize 用同一测试代码测试多组数据。",
        },
        {
            id: "py-w20-2-q4",
            question: "yield fixture 中 yield 后的代码何时执行？",
            options: [
                "测试开始前",
                "测试完成后（清理）",
                "不执行",
                "与测试同时",
            ],
            answer: 1,
            rationale: "文档说明：yield 后的代码在测试完成后执行，用于清理。",
        },
        {
            id: "py-w20-2-q5",
            question: "conftest.py 文件的作用是什么？",
            options: [
                "配置测试",
                "定义共享的 fixture，自动对目录可用",
                "测试配置文件",
                "日志配置",
            ],
            answer: 1,
            rationale: "文档说明：conftest.py 中的 fixture 对同目录和子目录可用。",
        },
        {
            id: "py-w20-2-q6",
            question: "tmp_path fixture 提供什么？",
            options: [
                "临时变量",
                "测试唯一的临时目录",
                "临时配置",
                "缓存路径",
            ],
            answer: 1,
            rationale: "文档说明：tmp_path 提供每个测试唯一的临时目录。",
        },
        {
            id: "py-w20-2-q7",
            question: "fixture 如何请求其他 fixture？",
            options: [
                "import 导入",
                "作为函数参数列出",
                "继承",
                "全局变量",
            ],
            answer: 1,
            rationale: "文档说明：fixture 通过函数参数名请求依赖的 fixture。",
        },
        {
            id: "py-w20-2-q8",
            question: "autouse=True 的 fixture 有什么特点？",
            options: [
                "只执行一次",
                "自动应用于所有测试",
                "不需要定义",
                "必须返回值",
            ],
            answer: 1,
            rationale: "文档说明：autouse=True 的 fixture 自动应用，无需显式请求。",
        },
        {
            id: "py-w20-2-q9",
            question: "scope='module' 的 fixture 何时销毁？",
            options: [
                "每个测试后",
                "模块中所有测试完成后",
                "立即",
                "从不",
            ],
            answer: 1,
            rationale: "文档说明：module 作用域的 fixture 在模块所有测试后销毁。",
        },
        {
            id: "py-w20-2-q10",
            question: "capsys fixture 的用途是什么？",
            options: [
                "捕获系统调用",
                "捕获标准输出和标准错误",
                "系统配置",
                "大写转换",
            ],
            answer: 1,
            rationale: "文档说明：capsys 捕获 stdout 和 stderr 的输出。",
        },
        {
            id: "py-w20-2-q11",
            question: "parametrize 的参数格式是什么？",
            options: [
                "@pytest.parametrize(values)",
                "@pytest.mark.parametrize('names', [values])",
                "@parametrize",
                "@pytest.param",
            ],
            answer: 1,
            rationale: "使用 @pytest.mark.parametrize('arg1,arg2', [(val1, val2), ...])。",
        },
        {
            id: "py-w20-2-q12",
            question: "monkeypatch fixture 的用途是什么？",
            options: [
                "测试猴子",
                "动态修改对象、环境变量等",
                "补丁管理",
                "版本控制",
            ],
            answer: 1,
            rationale: "文档说明：monkeypatch 用于动态修改对象、字典、环境变量等。",
        },
    ],
    "py-w20-3": [
        {
            id: "py-w20-3-q1",
            question: "mypy 是什么类型的工具？",
            options: [
                "代码格式化",
                "静态类型检查器",
                "测试框架",
                "调试器",
            ],
            answer: 1,
            rationale: "文档说明：mypy 是 Python 的静态类型检查器。",
        },
        {
            id: "py-w20-3-q2",
            question: "mypy 在什么时候运行？",
            options: [
                "运行时",
                "代码执行前（静态分析）",
                "编译时",
                "测试时",
            ],
            answer: 1,
            rationale: "文档说明：mypy 在运行前进行静态分析，不执行代码。",
        },
        {
            id: "py-w20-3-q3",
            question: "mypy --strict 选项的作用是什么？",
            options: [
                "严格模式，更严格的错误处理",
                "启用所有严格类型检查",
                "严格输出格式",
                "严格缓存",
            ],
            answer: 1,
            rationale: "文档说明：--strict 启用所有严格检查，要求更完整的类型注解。",
        },
        {
            id: "py-w20-3-q4",
            question: "ruff 是用什么语言编写的？",
            options: [
                "Python",
                "Rust",
                "C",
                "Go",
            ],
            answer: 1,
            rationale: "ruff 用 Rust 编写，速度比传统 Python 工具快 10-100 倍。",
        },
        {
            id: "py-w20-3-q5",
            question: "ruff 可以替代哪些工具？",
            options: [
                "只有 black",
                "flake8、isort、black 等多个工具",
                "只有 flake8",
                "只有 pytest",
            ],
            answer: 1,
            rationale: "文档说明：ruff 是统一的 linter 和格式化工具，替代多个传统工具。",
        },
        {
            id: "py-w20-3-q6",
            question: "如何忽略某行的类型检查？",
            options: [
                "# noqa",
                "# type: ignore",
                "# skip",
                "# nocheck",
            ],
            answer: 1,
            rationale: "文档说明：使用 # type: ignore 注释忽略该行的类型检查。",
        },
        {
            id: "py-w20-3-q7",
            question: "pre-commit 的作用是什么？",
            options: [
                "提交前备份",
                "Git 钩子框架，提交前自动运行检查",
                "提交消息格式",
                "代码提交",
            ],
            answer: 1,
            rationale: "pre-commit 在 git commit 前自动运行配置的检查工具。",
        },
        {
            id: "py-w20-3-q8",
            question: "第三方库没有类型存根怎么办？",
            options: [
                "不能使用",
                "安装 types-* 包或使用 # type: ignore",
                "自动生成",
                "不需要处理",
            ],
            answer: 1,
            rationale: "可以安装对应的 types-* 包，或用 # type: ignore 忽略。",
        },
        {
            id: "py-w20-3-q9",
            question: "未注解的变量在 mypy 中是什么类型？",
            options: [
                "object",
                "Any",
                "None",
                "unknown",
            ],
            answer: 1,
            rationale: "文档说明：未注解的变量默认是 Any 类型，跳过类型检查。",
        },
        {
            id: "py-w20-3-q10",
            question: "ruff check 命令的作用是什么？",
            options: [
                "运行测试",
                "运行代码检查（linting）",
                "检查语法",
                "检查依赖",
            ],
            answer: 1,
            rationale: "ruff check 运行代码检查，发现问题和风格违规。",
        },
        {
            id: "py-w20-3-q11",
            question: "ruff format 命令的作用是什么？",
            options: [
                "检查格式",
                "自动格式化代码",
                "显示格式",
                "设置格式",
            ],
            answer: 1,
            rationale: "ruff format 自动格式化代码，类似 black。",
        },
        {
            id: "py-w20-3-q12",
            question: "什么是渐进式类型？",
            options: [
                "逐渐变慢的类型",
                "可以逐步添加类型注解的方式",
                "自动推断类型",
                "动态类型",
            ],
            answer: 1,
            rationale: "渐进式类型允许逐步添加注解，mypy 只检查有注解的代码。",
        },
    ],
    "py-w20-4": [
        {
            id: "py-w20-4-q1",
            question: "如何在代码中设置断点？",
            options: [
                "debug()",
                "breakpoint()",
                "stop()",
                "pause()",
            ],
            answer: 1,
            rationale: "文档说明：Python 3.7+ 使用 breakpoint() 设置断点。",
        },
        {
            id: "py-w20-4-q2",
            question: "pdb 中 n 命令的作用是什么？",
            options: [
                "新建变量",
                "执行下一行（不进入函数）",
                "显示数字",
                "下一个断点",
            ],
            answer: 1,
            rationale: "文档说明：n(ext) 执行下一行，不进入函数内部。",
        },
        {
            id: "py-w20-4-q3",
            question: "pdb 中 s 命令的作用是什么？",
            options: [
                "停止调试",
                "进入函数内部执行",
                "跳过",
                "保存",
            ],
            answer: 1,
            rationale: "文档说明：s(tep) 执行下一行，如果是函数调用则进入函数。",
        },
        {
            id: "py-w20-4-q4",
            question: "pdb 中如何查看变量的值？",
            options: [
                "show var",
                "p var",
                "echo var",
                "display var",
            ],
            answer: 1,
            rationale: "文档说明：p(rint) 命令打印变量或表达式的值。",
        },
        {
            id: "py-w20-4-q5",
            question: "pdb 中 c 命令的作用是什么？",
            options: [
                "清除断点",
                "继续执行直到下一个断点",
                "复制",
                "检查",
            ],
            answer: 1,
            rationale: "文档说明：c(ontinue) 继续执行直到遇到下一个断点。",
        },
        {
            id: "py-w20-4-q6",
            question: "pdb 中 w 命令的作用是什么？",
            options: [
                "写入文件",
                "显示调用栈（where）",
                "等待",
                "警告",
            ],
            answer: 1,
            rationale: "文档说明：w(here) 显示当前的调用栈。",
        },
        {
            id: "py-w20-4-q7",
            question: "如何从命令行启动 pdb 调试？",
            options: [
                "python debug script.py",
                "python -m pdb script.py",
                "pdb script.py",
                "debug script.py",
            ],
            answer: 1,
            rationale: "文档说明：python -m pdb script.py 从头开始调试脚本。",
        },
        {
            id: "py-w20-4-q8",
            question: "pdb.pm() 用于什么？",
            options: [
                "下午调试",
                "异常后事后调试",
                "性能监控",
                "内存管理",
            ],
            answer: 1,
            rationale: "文档说明：pdb.pm() 用于事后调试，在异常发生后检查状态。",
        },
        {
            id: "py-w20-4-q9",
            question: "pdb 中 l 命令的作用是什么？",
            options: [
                "加载文件",
                "列出源代码",
                "记录日志",
                "链接",
            ],
            answer: 1,
            rationale: "文档说明：l(ist) 列出当前位置周围的源代码。",
        },
        {
            id: "py-w20-4-q10",
            question: "如何设置条件断点？",
            options: [
                "break if condition",
                "break lineno, condition",
                "breakpoint(condition)",
                "if condition: breakpoint()",
            ],
            answer: 1,
            rationale: "文档说明：break lineno, condition 设置条件断点。",
        },
        {
            id: "py-w20-4-q11",
            question: "pdb 中如何退出调试？",
            options: [
                "exit",
                "q (quit)",
                "stop",
                "end",
            ],
            answer: 1,
            rationale: "文档说明：q(uit) 退出调试器。",
        },
        {
            id: "py-w20-4-q12",
            question: "pdb 中如何在调试中修改变量？",
            options: [
                "set var = value",
                "! var = value",
                "var := value",
                "不能修改",
            ],
            answer: 1,
            rationale: "文档说明：使用 ! 前缀执行 Python 语句，如 ! var = 42。",
        },
    ],
}
