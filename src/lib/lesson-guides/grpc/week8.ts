import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week8Guides: Record<string, LessonGuide> = {
    "grpc-w8-1": {
        lessonId: "grpc-w8-1",
        background: [
            "【TLS 集成】gRPC 内置 SSL/TLS 支持，用于服务器认证和客户端服务器之间的数据加密。",
            "【Channel Credentials】附加到 Channel 的凭据，如 SSL 凭据，用于建立安全传输。",
            "【现代配置】Mozilla 推荐 TLS 1.2 和 TLS 1.3，使用 ECDSA (P-256) 证书或 RSA (2048位) 证书。",
            "【推荐密码套件】GCM 模式和 CHACHA20-POLY1305，提供前向保密和认证加密。",
            "【证书生命周期】推荐 90 天证书有效期，鼓励自动化证书更新。",
        ],
        keyDifficulties: [
            "【mTLS 双向认证】客户端和服务器互相验证证书，比单向 TLS 更安全。",
            "【证书链验证】验证证书链完整性，从叶证书到根证书。",
            "【SNI 支持】服务器名称指示，允许同一 IP 承载多个 TLS 站点。",
            "【HSTS 配置】HTTP 严格传输安全，强制使用 HTTPS，推荐 2 年有效期。",
        ],
        handsOnPath: [
            "1. 生成 TLS 证书：使用 openssl 或 cfssl",
            "2. 服务端配置 TLS：grpc.Creds(credentials.NewServerTLSFromFile())",
            "3. 客户端配置 TLS：grpc.WithTransportCredentials()",
            "4. 实现 mTLS 双向认证",
            "5. 配置证书自动更新",
            "6. 测试 TLS 连接安全性",
        ],
        selfCheck: [
            "gRPC 使用什么协议进行传输安全？",
            "Channel Credentials 和 Call Credentials 的区别是什么？",
            "推荐的 TLS 版本是什么？",
            "mTLS 相比单向 TLS 有什么优势？",
            "为什么推荐 90 天的证书有效期？",
            "什么是前向保密（Forward Secrecy）？",
        ],
        extensions: [
            "学习 ALTS（应用层传输安全）",
            "了解证书钉扎（Certificate Pinning）",
            "探索 Let's Encrypt 自动证书",
            "研究 TLS 1.3 的改进",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/auth/",
            "https://grpc.io/docs/guides/",
            "https://wiki.mozilla.org/Security/Server_Side_TLS",
        ],
    },
    "grpc-w8-2": {
        lessonId: "grpc-w8-2",
        background: [
            "【Token 认证】gRPC 提供通用机制，通过 Metadata 附加基于 Token 的凭据到请求和响应。",
            "【Call Credentials】附加到单个调用的凭据，如 OAuth2 Token 或 JWT。",
            "【CompositeCredentials】组合 Channel Credentials 和 Call Credentials，实现安全传输加认证。",
            "【OAuth2 集成】gRPC 支持 OAuth2 Token 获取和附加，可集成 Auth0、Okta 等身份提供商。",
            "【JWT 验证】服务端验证 JWT Token 的签名、有效期和声明。",
        ],
        keyDifficulties: [
            "【Token 泄露风险】Google OAuth2 Token 只应发送给 Google 服务，发送给非 Google 服务可能导致 Token 被盗。",
            "【Token 刷新】Access Token 有效期有限，需要实现自动刷新机制。",
            "【安全传输要求】Token 必须通过 TLS 传输，否则可能被拦截。",
            "【Per-Call vs Per-Channel】Call Credentials 每次调用可以不同，Channel Credentials 通道级别共享。",
        ],
        handsOnPath: [
            "1. 客户端获取 OAuth2 Token",
            "2. 创建 Per-Call Credentials：oauth.NewOauthAccess()",
            "3. 组合 Credentials：credentials.NewCompositeCredentials()",
            "4. 服务端提取和验证 Token",
            "5. 实现 Token 刷新逻辑",
            "6. 集成 JWT 库进行验证",
            "7. 测试认证流程",
        ],
        selfCheck: [
            "Call Credentials 和 Channel Credentials 的区别是什么？",
            "为什么不能将 Google Token 发送给非 Google 服务？",
            "如何组合多种凭据？",
            "OAuth2 Token 如何附加到 gRPC 请求？",
            "服务端如何验证 JWT Token？",
            "Token 刷新的最佳实践是什么？",
        ],
        extensions: [
            "学习 OpenID Connect 集成",
            "了解 JWT 的安全最佳实践",
            "探索 Token 缓存策略",
            "研究 Service-to-Service 认证",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/auth/",
            "https://grpc.io/docs/guides/metadata/",
            "https://www.stackhawk.com/blog/best-practices-for-grpc-security/",
        ],
    },
    "grpc-w8-3": {
        lessonId: "grpc-w8-3",
        background: [
            "【MetadataCredentialsPlugin】抽象类，用于实现自定义认证方案，生成附加到请求的 Metadata。",
            "【自定义 CallCredentials】通过实现 MetadataCredentialsPlugin 创建非标准认证机制。",
            "【服务端授权】使用拦截器从 Metadata 提取凭据，验证后执行授权检查。",
            "【RBAC】基于角色的访问控制，根据用户角色决定访问权限。",
            "【ABAC】基于属性的访问控制，根据用户、资源、环境属性决定访问。",
        ],
        keyDifficulties: [
            "【认证 vs 授权】认证验证身份（你是谁），授权验证权限（你能做什么）。",
            "【方法级授权】不同 gRPC 方法可能需要不同的权限级别。",
            "【上下文传递】认证信息需要从拦截器传递到业务处理程序。",
            "【错误处理】认证失败返回 UNAUTHENTICATED，授权失败返回 PERMISSION_DENIED。",
        ],
        handsOnPath: [
            "1. 实现 MetadataCredentialsPlugin 接口",
            "2. 创建自定义 CallCredentials",
            "3. 实现服务端认证拦截器",
            "4. 从 Metadata 提取和验证凭据",
            "5. 实现方法级别的授权检查",
            "6. 将用户信息注入上下文",
            "7. 测试自定义认证授权流程",
        ],
        selfCheck: [
            "如何实现自定义的认证机制？",
            "MetadataCredentialsPlugin 的作用是什么？",
            "认证和授权的区别是什么？",
            "如何在拦截器中进行授权检查？",
            "认证失败和授权失败应返回什么状态码？",
            "如何将认证信息传递给业务处理程序？",
            "RBAC 和 ABAC 的区别是什么？",
        ],
        extensions: [
            "学习 OPA（Open Policy Agent）策略引擎",
            "了解 Casbin 授权库",
            "探索 API 网关的认证卸载",
            "研究 Zero Trust 安全模型",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/auth/",
            "https://grpc.io/docs/guides/interceptors/",
            "https://github.com/grpc-ecosystem/go-grpc-middleware",
        ],
    },
}

export const week8Quizzes: Record<string, QuizQuestion[]> = {
    "grpc-w8-1": [
        {
            id: "grpc-w8-1-q1",
            question: "gRPC 使用什么协议进行传输安全？",
            options: ["SSH", "SSL/TLS", "IPSec", "WPA"],
            answer: 1,
            rationale: "gRPC 内置 SSL/TLS 支持，用于服务器认证和数据加密。",
        },
        {
            id: "grpc-w8-1-q2",
            question: "Mozilla 推荐的 TLS 版本是什么？",
            options: ["TLS 1.0 和 1.1", "TLS 1.1 和 1.2", "TLS 1.2 和 1.3", "只有 TLS 1.3"],
            answer: 2,
            rationale: "Mozilla 推荐 TLS 1.2 和 TLS 1.3，提供最佳的安全性和兼容性。",
        },
        {
            id: "grpc-w8-1-q3",
            question: "Channel Credentials 的作用是什么？",
            options: [
                "单次调用认证",
                "建立安全传输通道",
                "用户认证",
                "数据压缩",
            ],
            answer: 1,
            rationale: "Channel Credentials 附加到 Channel，用于建立安全传输（如 TLS）。",
        },
        {
            id: "grpc-w8-1-q4",
            question: "mTLS 是什么？",
            options: [
                "最小 TLS",
                "双向 TLS，客户端和服务器互相验证证书",
                "多层 TLS",
                "移动 TLS",
            ],
            answer: 1,
            rationale: "mTLS（Mutual TLS）是双向认证，客户端和服务器互相验证对方的证书。",
        },
        {
            id: "grpc-w8-1-q5",
            question: "推荐的证书有效期是多长？",
            options: ["1 年", "90 天", "2 年", "30 天"],
            answer: 1,
            rationale: "推荐 90 天证书有效期，鼓励自动化证书更新，降低证书泄露风险。",
        },
        {
            id: "grpc-w8-1-q6",
            question: "推荐使用什么类型的证书？",
            options: [
                "RSA 1024 位",
                "ECDSA (P-256) 或 RSA (2048位)",
                "DSA",
                "MD5 签名",
            ],
            answer: 1,
            rationale: "推荐使用 ECDSA (P-256) 或 RSA (2048位) 证书，提供足够的安全性。",
        },
        {
            id: "grpc-w8-1-q7",
            question: "什么是前向保密（Forward Secrecy）？",
            options: [
                "加密速度更快",
                "即使私钥泄露，过去的通信仍然安全",
                "可以预测未来",
                "支持前向代理",
            ],
            answer: 1,
            rationale: "前向保密确保即使长期密钥泄露，过去的会话密钥和通信仍然安全。",
        },
        {
            id: "grpc-w8-1-q8",
            question: "HSTS 的推荐有效期是多长？",
            options: ["1 个月", "6 个月", "2 年", "5 年"],
            answer: 2,
            rationale: "HSTS 推荐 max-age 为 63072000 秒（2 年），强制使用 HTTPS。",
        },
        {
            id: "grpc-w8-1-q9",
            question: "Go 中如何配置服务端 TLS？",
            options: [
                "grpc.WithTLS()",
                "grpc.Creds(credentials.NewServerTLSFromFile())",
                "grpc.TLSConfig()",
                "tls.NewServer()",
            ],
            answer: 1,
            rationale: "使用 grpc.Creds(credentials.NewServerTLSFromFile()) 配置服务端 TLS。",
        },
        {
            id: "grpc-w8-1-q10",
            question: "SNI 的作用是什么？",
            options: [
                "加速连接",
                "允许同一 IP 承载多个 TLS 站点",
                "压缩数据",
                "加密 DNS",
            ],
            answer: 1,
            rationale: "SNI（Server Name Indication）允许同一 IP 地址承载多个使用不同证书的 TLS 站点。",
        },
        {
            id: "grpc-w8-1-q11",
            question: "ALTS 是什么？",
            options: [
                "另一种 TLS",
                "应用层传输安全，用于 Google 云环境",
                "高级日志传输",
                "自动负载测试",
            ],
            answer: 1,
            rationale: "ALTS（Application Layer Transport Security）是 Google 云环境的传输安全机制。",
        },
        {
            id: "grpc-w8-1-q12",
            question: "推荐的密码套件应具备什么特性？",
            options: [
                "速度最快",
                "前向保密和认证加密",
                "兼容性最好",
                "密钥最短",
            ],
            answer: 1,
            rationale: "推荐的密码套件应具备前向保密和认证加密，如 GCM 模式和 CHACHA20-POLY1305。",
        },
    ],
    "grpc-w8-2": [
        {
            id: "grpc-w8-2-q1",
            question: "Call Credentials 的作用是什么？",
            options: [
                "建立 TLS 连接",
                "附加到单个调用的认证凭据",
                "压缩请求",
                "路由请求",
            ],
            answer: 1,
            rationale: "Call Credentials 附加到单个调用，如 OAuth2 Token 或 JWT。",
        },
        {
            id: "grpc-w8-2-q2",
            question: "为什么不能将 Google OAuth2 Token 发送给非 Google 服务？",
            options: [
                "不兼容",
                "Token 可能被盗用",
                "会失效",
                "性能问题",
            ],
            answer: 1,
            rationale: "将 Google Token 发送给非 Google 服务可能导致 Token 被盗用。",
        },
        {
            id: "grpc-w8-2-q3",
            question: "如何组合 Channel Credentials 和 Call Credentials？",
            options: [
                "直接相加",
                "使用 CompositeCredentials",
                "不能组合",
                "使用链表",
            ],
            answer: 1,
            rationale: "使用 credentials.NewCompositeCredentials() 组合 Channel 和 Call Credentials。",
        },
        {
            id: "grpc-w8-2-q4",
            question: "OAuth2 Token 通过什么方式附加到 gRPC 请求？",
            options: ["请求体", "URL 参数", "Metadata/头部", "Cookie"],
            answer: 2,
            rationale: "gRPC 通过 Metadata（HTTP/2 头部）附加 Token 到请求。",
        },
        {
            id: "grpc-w8-2-q5",
            question: "Per-Call Credentials 和 Per-Channel Credentials 的区别是什么？",
            options: [
                "没有区别",
                "Per-Call 每次调用可不同，Per-Channel 通道级别共享",
                "Per-Call 更安全",
                "Per-Channel 更快",
            ],
            answer: 1,
            rationale: "Call Credentials 每次调用可以不同，Channel Credentials 在通道级别共享。",
        },
        {
            id: "grpc-w8-2-q6",
            question: "Token 为什么必须通过 TLS 传输？",
            options: [
                "更快",
                "防止被拦截和窃取",
                "兼容性",
                "压缩更好",
            ],
            answer: 1,
            rationale: "Token 必须通过 TLS 传输，否则可能被中间人拦截和窃取。",
        },
        {
            id: "grpc-w8-2-q7",
            question: "JWT 验证需要检查哪些内容？",
            options: [
                "只检查签名",
                "签名、有效期和声明",
                "只检查有效期",
                "只检查声明",
            ],
            answer: 1,
            rationale: "JWT 验证需要检查签名有效性、Token 有效期和声明内容。",
        },
        {
            id: "grpc-w8-2-q8",
            question: "Access Token 有什么限制？",
            options: [
                "无限制",
                "有效期有限，需要刷新",
                "只能用一次",
                "大小限制",
            ],
            answer: 1,
            rationale: "Access Token 有效期有限，需要实现自动刷新机制。",
        },
        {
            id: "grpc-w8-2-q9",
            question: "gRPC 可以集成哪些身份提供商？",
            options: [
                "只有 Google",
                "Auth0、Okta 等多种",
                "只有自建",
                "不支持集成",
            ],
            answer: 1,
            rationale: "gRPC 支持集成 Auth0、Okta 等多种身份提供商的 OAuth2。",
        },
        {
            id: "grpc-w8-2-q10",
            question: "服务端如何获取请求中的 Token？",
            options: [
                "自动获取",
                "从 Metadata 中提取",
                "从请求体读取",
                "从 URL 参数",
            ],
            answer: 1,
            rationale: "服务端从 Metadata（通常是 Authorization 头）中提取 Token。",
        },
        {
            id: "grpc-w8-2-q11",
            question: "GoogleDefaultCredentials() 适用于什么场景？",
            options: [
                "所有环境",
                "Service Account 和 Google Compute Engine",
                "只有本地开发",
                "只有生产环境",
            ],
            answer: 1,
            rationale: "GoogleDefaultCredentials() 适用于 Service Account 和 GCE 环境，自动处理 Token。",
        },
        {
            id: "grpc-w8-2-q12",
            question: "Token 刷新的最佳实践是什么？",
            options: [
                "每次请求都刷新",
                "在过期前自动刷新",
                "等待失败后刷新",
                "不需要刷新",
            ],
            answer: 1,
            rationale: "最佳实践是在 Token 过期前自动刷新，避免请求失败。",
        },
    ],
    "grpc-w8-3": [
        {
            id: "grpc-w8-3-q1",
            question: "MetadataCredentialsPlugin 的作用是什么？",
            options: [
                "加密 Metadata",
                "实现自定义认证方案",
                "压缩 Metadata",
                "路由请求",
            ],
            answer: 1,
            rationale: "MetadataCredentialsPlugin 是抽象类，用于实现自定义认证方案。",
        },
        {
            id: "grpc-w8-3-q2",
            question: "认证和授权的区别是什么？",
            options: [
                "没有区别",
                "认证验证身份，授权验证权限",
                "认证更重要",
                "授权更快",
            ],
            answer: 1,
            rationale: "认证验证身份（你是谁），授权验证权限（你能做什么）。",
        },
        {
            id: "grpc-w8-3-q3",
            question: "认证失败应返回什么状态码？",
            options: ["PERMISSION_DENIED", "UNAUTHENTICATED", "UNAUTHORIZED", "FORBIDDEN"],
            answer: 1,
            rationale: "认证失败返回 UNAUTHENTICATED（状态码 16）。",
        },
        {
            id: "grpc-w8-3-q4",
            question: "授权失败应返回什么状态码？",
            options: ["UNAUTHENTICATED", "PERMISSION_DENIED", "NOT_FOUND", "INVALID_ARGUMENT"],
            answer: 1,
            rationale: "授权失败返回 PERMISSION_DENIED（状态码 7）。",
        },
        {
            id: "grpc-w8-3-q5",
            question: "RBAC 是什么？",
            options: [
                "远程备份访问控制",
                "基于角色的访问控制",
                "基于请求的访问控制",
                "基于资源的访问控制",
            ],
            answer: 1,
            rationale: "RBAC（Role-Based Access Control）是基于角色的访问控制。",
        },
        {
            id: "grpc-w8-3-q6",
            question: "ABAC 与 RBAC 的主要区别是什么？",
            options: [
                "ABAC 更快",
                "ABAC 基于属性，RBAC 基于角色",
                "ABAC 更简单",
                "没有区别",
            ],
            answer: 1,
            rationale: "ABAC 基于用户、资源、环境等属性决定访问，RBAC 基于预定义角色。",
        },
        {
            id: "grpc-w8-3-q7",
            question: "如何将认证信息传递给业务处理程序？",
            options: [
                "全局变量",
                "通过上下文（context）传递",
                "返回值",
                "不需要传递",
            ],
            answer: 1,
            rationale: "认证拦截器通过 context.WithValue() 将认证信息注入上下文。",
        },
        {
            id: "grpc-w8-3-q8",
            question: "服务端授权检查通常在哪里实现？",
            options: [
                "客户端",
                "拦截器",
                "数据库",
                "网关",
            ],
            answer: 1,
            rationale: "服务端授权检查通常在拦截器中实现，验证后放行或拒绝请求。",
        },
        {
            id: "grpc-w8-3-q9",
            question: "方法级授权是什么意思？",
            options: [
                "所有方法相同权限",
                "不同 gRPC 方法需要不同的权限级别",
                "按方法数量计费",
                "方法签名检查",
            ],
            answer: 1,
            rationale: "方法级授权指不同 gRPC 方法可能需要不同的权限级别。",
        },
        {
            id: "grpc-w8-3-q10",
            question: "OPA 是什么？",
            options: [
                "开放平台 API",
                "Open Policy Agent，策略引擎",
                "OAuth 提供商",
                "操作审计",
            ],
            answer: 1,
            rationale: "OPA（Open Policy Agent）是通用策略引擎，可用于实现复杂授权逻辑。",
        },
        {
            id: "grpc-w8-3-q11",
            question: "自定义 CallCredentials 如何创建？",
            options: [
                "继承 Channel",
                "实现 MetadataCredentialsPlugin 并调用 MetadataCredentialsFromPlugin()",
                "直接创建",
                "配置文件",
            ],
            answer: 1,
            rationale: "实现 MetadataCredentialsPlugin 并使用 MetadataCredentialsFromPlugin() 创建。",
        },
        {
            id: "grpc-w8-3-q12",
            question: "Zero Trust 安全模型的核心原则是什么？",
            options: [
                "信任内部网络",
                "永不信任，始终验证",
                "只信任管理员",
                "信任已认证用户",
            ],
            answer: 1,
            rationale: "Zero Trust 的核心原则是永不信任、始终验证，无论请求来自内外部。",
        },
    ],
}
