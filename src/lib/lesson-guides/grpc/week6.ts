import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week6Guides: Record<string, LessonGuide> = {
    "grpc-w6-1": {
        lessonId: "grpc-w6-1",
        background: [
            "【Metadata 定义】Metadata 是附加到 RPC 调用的键值对信息，通过 HTTP/2 头部传输，常用于传递认证信息等上下文数据。",
            "【键命名规则】键名不区分大小写，由 ASCII 字母、数字和 -_.  组成，不能以 grpc- 开头（保留前缀）。",
            "【二进制值】键名以 -bin 后缀结尾时，值可以是二进制数据，无需 base64 编码。",
            "【Initial Metadata】Headers，在请求数据前从客户端发送到服务器，或在响应数据前从服务器发送到客户端。",
            "【Trailing Metadata】Trailers，只由服务器在消息数据之后发送，传达 RPC 结果和应用级详情。",
        ],
        keyDifficulties: [
            "【大小限制】服务器可能限制请求头大小，默认建议 8KB，过大的 Metadata 可能被拒绝。",
            "【传播机制】Metadata 在服务间调用时需要显式传播，不会自动传递到下游服务。",
            "【Headers vs Trailers】Headers 在数据传输前发送，Trailers 在数据传输后发送，用于传达最终状态。",
            "【保留键前缀】grpc- 前缀的键由 gRPC 框架使用，用户代码不应使用此前缀。",
        ],
        handsOnPath: [
            "1. 创建和设置 Metadata：metadata.New() 或 metadata.Pairs()",
            "2. 将 Metadata 附加到上下文：metadata.NewOutgoingContext()",
            "3. 服务端提取 Metadata：metadata.FromIncomingContext()",
            "4. 服务端发送初始 Metadata：grpc.SendHeader()",
            "5. 服务端发送尾部 Metadata：grpc.SetTrailer()",
            "6. 客户端接收 Metadata：通过 CallOption 获取 Header 和 Trailer",
        ],
        selfCheck: [
            "Metadata 在 gRPC 中是如何传输的？",
            "键名有哪些命名规则和限制？",
            "如何传递二进制数据到 Metadata？",
            "Initial Metadata 和 Trailing Metadata 的区别是什么？",
            "为什么不能使用 grpc- 前缀的键名？",
            "Metadata 大小限制是多少？",
        ],
        extensions: [
            "学习使用拦截器统一处理 Metadata",
            "了解分布式追踪 ID 在 Metadata 中的传递",
            "探索自定义认证信息的 Metadata 实现",
            "研究 Metadata 在负载均衡中的应用",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/metadata/",
            "https://grpc.io/docs/what-is-grpc/core-concepts/",
            "https://grpc.io/docs/guides/auth/",
        ],
    },
    "grpc-w6-2": {
        lessonId: "grpc-w6-2",
        background: [
            "【Deadline 定义】Deadline 是客户端愿意等待服务器响应的最后时间点，超过则 RPC 以 DEADLINE_EXCEEDED 失败。",
            "【Timeout vs Deadline】Timeout 是持续时间，Deadline 是绝对时间点。Timeout 在调用开始时转换为 Deadline。",
            "【无默认值】gRPC 没有默认 Deadline，应始终在客户端显式设置合理的 Deadline。",
            "【服务端行为】服务器超过 Deadline 后自动取消 RPC，返回 CANCELLED 状态。",
            "【Deadline 传播】服务器作为客户端调用其他服务时，应传播剩余的 Deadline 时间。",
        ],
        keyDifficulties: [
            "【合理设置】Deadline 需要根据网络延迟和服务器处理时间估算，并通过负载测试验证。",
            "【时钟偏差】gRPC 将 Deadline 转换为 Timeout 传输，扣除已用时间，避免时钟同步问题。",
            "【资源清理】框架只负责取消信号，应用程序必须主动停止已启动的进程和清理资源。",
            "【链式调用】多级服务调用时，上游已用时间会从 Deadline 中扣除，下游可用时间减少。",
        ],
        handsOnPath: [
            "1. 客户端设置 Deadline：ctx, cancel := context.WithDeadline(ctx, time)",
            "2. 客户端设置 Timeout：ctx, cancel := context.WithTimeout(ctx, duration)",
            "3. 服务端检查剩余时间：deadline, ok := ctx.Deadline()",
            "4. 服务端检查是否已取消：ctx.Err() == context.DeadlineExceeded",
            "5. 传播 Deadline 到下游服务调用",
            "6. 处理 DEADLINE_EXCEEDED 错误",
        ],
        selfCheck: [
            "Deadline 和 Timeout 有什么区别？",
            "为什么应该始终设置 Deadline？",
            "服务端超过 Deadline 后会发生什么？",
            "如何在服务端检查剩余时间？",
            "Deadline 传播时为什么要扣除已用时间？",
            "gRPC 为什么没有默认 Deadline？",
        ],
        extensions: [
            "学习 Deadline 与熔断器的配合使用",
            "了解不同语言中 Deadline API 的差异",
            "探索动态 Deadline 调整策略",
            "研究 Deadline 在微服务链路中的最佳实践",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/deadlines/",
            "https://grpc.io/docs/what-is-grpc/core-concepts/",
            "https://grpc.io/docs/guides/cancellation/",
        ],
    },
    "grpc-w6-3": {
        lessonId: "grpc-w6-3",
        background: [
            "【取消机制】当客户端不再需要 RPC 结果时，可以取消操作，通知服务器停止不必要的工作。",
            "【取消 API】客户端通过调用 call 对象或 context 的方法取消 RPC，可附带取消原因字符串。",
            "【取消传播】取消会自动级联传播，客户端取消对 Server1 的请求，Server1 应将取消传播到 Server2。",
            "【服务端检测】服务端必须周期性检查请求是否已被取消，框架无法强制中断应用处理程序。",
            "【资源释放】检测到取消后，服务端应停止本地处理并取消所有发起的上游 RPC。",
        ],
        keyDifficulties: [
            "【非强制中断】gRPC 框架不能强制中断应用处理程序，服务端必须主动检查取消状态。",
            "【长时操作】长时间运行的 RPC 处理程序需要在循环或关键点检查取消。",
            "【自动传播】部分语言（Java、Go、C++）自动取消出站 RPC，其他语言需要手动实现。",
            "【取消不回滚】取消会终止 RPC，但之前的修改不会自动回滚。",
        ],
        handsOnPath: [
            "1. 客户端取消 RPC：cancel() 函数或 CancelFunc",
            "2. 客户端设置取消原因：WithCancel 返回的 cancel 函数",
            "3. 服务端检查取消状态：ctx.Err() == context.Canceled",
            "4. 服务端监听取消信号：select { case <-ctx.Done(): }",
            "5. 传播取消到下游 RPC 调用",
            "6. 清理部分完成的操作和资源",
        ],
        selfCheck: [
            "客户端如何取消一个 RPC？",
            "取消如何在服务间传播？",
            "服务端如何检测请求是否被取消？",
            "为什么框架不能强制中断处理程序？",
            "取消后之前的修改会回滚吗？",
            "哪些语言自动取消出站 RPC？",
            "长时操作如何正确处理取消？",
        ],
        extensions: [
            "学习取消与事务回滚的配合",
            "了解取消在流式 RPC 中的行为",
            "探索取消超时与重试的交互",
            "研究取消日志和监控最佳实践",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/cancellation/",
            "https://grpc.io/docs/guides/deadlines/",
            "https://grpc.io/docs/what-is-grpc/core-concepts/",
        ],
    },
}

export const week6Quizzes: Record<string, QuizQuestion[]> = {
    "grpc-w6-1": [
        {
            id: "grpc-w6-1-q1",
            question: "gRPC Metadata 是通过什么方式传输的？",
            options: ["请求体", "HTTP/2 头部", "WebSocket", "独立 TCP 连接"],
            answer: 1,
            rationale: "Metadata 通过 HTTP/2 头部传输，作为 RPC 调用的附加信息。",
        },
        {
            id: "grpc-w6-1-q2",
            question: "Metadata 键名有什么限制？",
            options: [
                "必须大写",
                "不能以 grpc- 开头",
                "必须数字开头",
                "必须包含下划线",
            ],
            answer: 1,
            rationale: "Metadata 键名不能以 grpc- 开头，这是 gRPC 框架的保留前缀。",
        },
        {
            id: "grpc-w6-1-q3",
            question: "如何在 Metadata 中传递二进制数据？",
            options: [
                "使用 base64 编码",
                "使用 -bin 后缀的键名",
                "使用特殊前缀",
                "不支持二进制数据",
            ],
            answer: 1,
            rationale: "键名以 -bin 后缀结尾时，值可以是二进制数据，无需手动编码。",
        },
        {
            id: "grpc-w6-1-q4",
            question: "Trailing Metadata（Trailers）是由谁发送的？",
            options: ["只有客户端", "只有服务器", "双方都可以", "代理服务器"],
            answer: 1,
            rationale: "Trailers 只由服务器在消息数据之后发送，传达 RPC 结果。",
        },
        {
            id: "grpc-w6-1-q5",
            question: "服务器建议的请求头大小限制是多少？",
            options: ["1KB", "4KB", "8KB", "16KB"],
            answer: 2,
            rationale: "服务器可能限制请求头大小，默认建议 8KB。",
        },
        {
            id: "grpc-w6-1-q6",
            question: "Initial Metadata（Headers）何时发送？",
            options: [
                "在消息数据之后",
                "在消息数据之前",
                "与消息数据同时",
                "RPC 结束时",
            ],
            answer: 1,
            rationale: "Headers 在请求/响应数据传输之前发送。",
        },
        {
            id: "grpc-w6-1-q7",
            question: "Metadata 键名的字符规则是什么？",
            options: [
                "只能是字母",
                "ASCII 字母、数字和 -_. 组成",
                "可以包含任意字符",
                "只能是小写字母",
            ],
            answer: 1,
            rationale: "键名由 ASCII 字母、数字和 -_.  组成，不区分大小写。",
        },
        {
            id: "grpc-w6-1-q8",
            question: "Metadata 在服务间调用时会自动传播吗？",
            options: [
                "会自动传播",
                "不会，需要显式传播",
                "只传播 grpc- 前缀的键",
                "取决于配置",
            ],
            answer: 1,
            rationale: "Metadata 需要显式传播，不会自动传递到下游服务。",
        },
        {
            id: "grpc-w6-1-q9",
            question: "Go 语言中如何创建带 Metadata 的上下文？",
            options: [
                "context.WithMetadata()",
                "metadata.NewOutgoingContext()",
                "grpc.WithMetadata()",
                "ctx.SetMetadata()",
            ],
            answer: 1,
            rationale: "Go 中使用 metadata.NewOutgoingContext() 创建带 Metadata 的上下文。",
        },
        {
            id: "grpc-w6-1-q10",
            question: "服务端如何发送 Trailing Metadata？",
            options: [
                "metadata.SetTrailer()",
                "grpc.SetTrailer()",
                "ctx.SetTrailer()",
                "自动发送",
            ],
            answer: 1,
            rationale: "服务端使用 grpc.SetTrailer() 发送尾部 Metadata。",
        },
        {
            id: "grpc-w6-1-q11",
            question: "Metadata 常用于传递什么信息？",
            options: [
                "只有错误信息",
                "认证、追踪、自定义头部等",
                "只有请求 ID",
                "只有版本号",
            ],
            answer: 1,
            rationale: "Metadata 常用于认证（OAuth2、JWT）、分布式追踪、自定义头部等。",
        },
        {
            id: "grpc-w6-1-q12",
            question: "客户端如何接收服务端的 Metadata？",
            options: [
                "自动解析",
                "通过 CallOption 获取 Header 和 Trailer",
                "从响应体读取",
                "通过环境变量",
            ],
            answer: 1,
            rationale: "客户端通过 grpc.Header() 和 grpc.Trailer() CallOption 获取 Metadata。",
        },
    ],
    "grpc-w6-2": [
        {
            id: "grpc-w6-2-q1",
            question: "Deadline 超过后 RPC 返回什么状态码？",
            options: ["CANCELLED", "DEADLINE_EXCEEDED", "TIMEOUT", "UNAVAILABLE"],
            answer: 1,
            rationale: "Deadline 超过后，RPC 以 DEADLINE_EXCEEDED 状态失败。",
        },
        {
            id: "grpc-w6-2-q2",
            question: "gRPC 有默认的 Deadline 吗？",
            options: [
                "有，30 秒",
                "有，60 秒",
                "没有默认值",
                "有，10 秒",
            ],
            answer: 2,
            rationale: "gRPC 没有默认 Deadline，应始终在客户端显式设置。",
        },
        {
            id: "grpc-w6-2-q3",
            question: "Timeout 和 Deadline 的区别是什么？",
            options: [
                "没有区别",
                "Timeout 是持续时间，Deadline 是绝对时间点",
                "Timeout 更长",
                "Deadline 只用于服务端",
            ],
            answer: 1,
            rationale: "Timeout 是持续时间，Deadline 是绝对时间点。调用开始时 Timeout 转换为 Deadline。",
        },
        {
            id: "grpc-w6-2-q4",
            question: "服务端超过 Deadline 后会发生什么？",
            options: [
                "继续处理",
                "自动取消 RPC，返回 CANCELLED 状态",
                "等待客户端确认",
                "重新计时",
            ],
            answer: 1,
            rationale: "服务器超过 Deadline 后自动取消 RPC，返回 CANCELLED 状态。",
        },
        {
            id: "grpc-w6-2-q5",
            question: "Deadline 传播时为什么要扣除已用时间？",
            options: [
                "节省资源",
                "避免时钟同步问题",
                "提高性能",
                "简化计算",
            ],
            answer: 1,
            rationale: "gRPC 将 Deadline 转换为 Timeout 传输，扣除已用时间，避免时钟偏差问题。",
        },
        {
            id: "grpc-w6-2-q6",
            question: "Go 语言中如何设置 Deadline？",
            options: [
                "grpc.WithDeadline()",
                "context.WithDeadline(ctx, time)",
                "ctx.SetDeadline()",
                "deadline.Set()",
            ],
            answer: 1,
            rationale: "Go 中使用 context.WithDeadline(ctx, time) 设置 Deadline。",
        },
        {
            id: "grpc-w6-2-q7",
            question: "服务端如何检查剩余时间？",
            options: [
                "ctx.TimeLeft()",
                "ctx.Deadline() 返回截止时间",
                "grpc.GetDeadline()",
                "自动获取",
            ],
            answer: 1,
            rationale: "服务端使用 ctx.Deadline() 获取截止时间，计算剩余时间。",
        },
        {
            id: "grpc-w6-2-q8",
            question: "链式调用中 Deadline 如何处理？",
            options: [
                "每级独立计算",
                "上游已用时间从 Deadline 扣除，下游可用时间减少",
                "重置为初始值",
                "忽略下游 Deadline",
            ],
            answer: 1,
            rationale: "多级调用时，上游已用时间会从 Deadline 扣除，下游可用时间相应减少。",
        },
        {
            id: "grpc-w6-2-q9",
            question: "Deadline 超时后谁负责清理资源？",
            options: [
                "gRPC 框架自动清理",
                "应用程序必须主动清理",
                "客户端清理",
                "不需要清理",
            ],
            answer: 1,
            rationale: "框架只负责取消信号，应用程序必须主动停止进程和清理资源。",
        },
        {
            id: "grpc-w6-2-q10",
            question: "如何确定合理的 Deadline 值？",
            options: [
                "固定为 30 秒",
                "根据网络延迟和处理时间估算，通过负载测试验证",
                "尽可能大",
                "尽可能小",
            ],
            answer: 1,
            rationale: "Deadline 需要根据网络延迟和服务器处理时间估算，并通过负载测试验证。",
        },
        {
            id: "grpc-w6-2-q11",
            question: "Go 语言中如何设置 Timeout？",
            options: [
                "context.WithTimeout(ctx, duration)",
                "grpc.WithTimeout()",
                "ctx.SetTimeout()",
                "timeout.Set()",
            ],
            answer: 0,
            rationale: "Go 中使用 context.WithTimeout(ctx, duration) 设置 Timeout。",
        },
        {
            id: "grpc-w6-2-q12",
            question: "哪些语言自动传播 Deadline？",
            options: [
                "所有语言",
                "Java 和 Go 自动传播，C++ 需要显式启用",
                "只有 Python",
                "没有语言自动传播",
            ],
            answer: 1,
            rationale: "Java 和 Go 默认自动传播 Deadline，C++ 需要显式启用。",
        },
    ],
    "grpc-w6-3": [
        {
            id: "grpc-w6-3-q1",
            question: "客户端取消 RPC 后服务端会收到什么？",
            options: [
                "没有通知",
                "取消信号",
                "重试请求",
                "超时信号",
            ],
            answer: 1,
            rationale: "客户端取消后，服务端会收到取消信号，可以通过检查 context 状态发现。",
        },
        {
            id: "grpc-w6-3-q2",
            question: "gRPC 框架能强制中断应用处理程序吗？",
            options: [
                "能，自动中断",
                "不能，服务端必须主动检查取消状态",
                "只能中断流式 RPC",
                "取决于语言",
            ],
            answer: 1,
            rationale: "gRPC 框架不能强制中断应用处理程序，服务端必须主动检查取消状态。",
        },
        {
            id: "grpc-w6-3-q3",
            question: "取消会在服务间自动传播吗？",
            options: [
                "会自动级联传播",
                "不会传播",
                "只传播一级",
                "需要配置才传播",
            ],
            answer: 0,
            rationale: "取消会自动级联传播，客户端取消对 Server1 的请求，应传播到 Server2。",
        },
        {
            id: "grpc-w6-3-q4",
            question: "Go 语言中如何检查请求是否被取消？",
            options: [
                "ctx.IsCanceled()",
                "ctx.Err() == context.Canceled",
                "grpc.IsCanceled()",
                "ctx.Canceled()",
            ],
            answer: 1,
            rationale: "Go 中使用 ctx.Err() == context.Canceled 检查是否被取消。",
        },
        {
            id: "grpc-w6-3-q5",
            question: "取消后之前的修改会自动回滚吗？",
            options: [
                "会自动回滚",
                "不会，需要应用程序处理",
                "只回滚数据库操作",
                "取决于配置",
            ],
            answer: 1,
            rationale: "取消会终止 RPC，但之前的修改不会自动回滚，需要应用程序处理。",
        },
        {
            id: "grpc-w6-3-q6",
            question: "哪些语言自动取消出站 RPC？",
            options: [
                "所有语言",
                "Java、Go、C++",
                "只有 Go",
                "只有 Java",
            ],
            answer: 1,
            rationale: "Java、Go、C++ 自动取消出站 RPC，其他语言需要手动实现。",
        },
        {
            id: "grpc-w6-3-q7",
            question: "Go 语言中如何监听取消信号？",
            options: [
                "ctx.Listen()",
                "select { case <-ctx.Done(): }",
                "ctx.OnCancel()",
                "grpc.OnCancel()",
            ],
            answer: 1,
            rationale: "Go 中使用 select { case <-ctx.Done(): } 监听取消信号。",
        },
        {
            id: "grpc-w6-3-q8",
            question: "取消时可以附带什么信息？",
            options: [
                "只有状态码",
                "取消原因字符串",
                "只有时间戳",
                "不能附带信息",
            ],
            answer: 1,
            rationale: "取消时可以附带取消原因字符串，出现在客户端异常和日志中。",
        },
        {
            id: "grpc-w6-3-q9",
            question: "长时间运行的 RPC 应该如何处理取消？",
            options: [
                "忽略取消",
                "在循环或关键点检查取消状态",
                "等待自动取消",
                "设置长超时",
            ],
            answer: 1,
            rationale: "长时间运行的 RPC 需要在循环或关键点周期性检查取消状态。",
        },
        {
            id: "grpc-w6-3-q10",
            question: "检测到取消后应该做什么？",
            options: [
                "继续处理完成",
                "停止本地处理并取消上游 RPC",
                "重试操作",
                "等待超时",
            ],
            answer: 1,
            rationale: "检测到取消后应停止本地处理并取消所有发起的上游 RPC。",
        },
        {
            id: "grpc-w6-3-q11",
            question: "取消和 Deadline 超时在服务端如何区分？",
            options: [
                "无法区分",
                "ctx.Err() 返回 Canceled 或 DeadlineExceeded",
                "通过状态码区分",
                "通过 Metadata 区分",
            ],
            answer: 1,
            rationale: "ctx.Err() 返回 context.Canceled 或 context.DeadlineExceeded 区分。",
        },
        {
            id: "grpc-w6-3-q12",
            question: "Python 中取消传播需要怎么处理？",
            options: [
                "自动传播",
                "需要手动实现",
                "不支持取消",
                "只支持超时",
            ],
            answer: 1,
            rationale: "Python 不自动传播取消，需要手动实现取消传播逻辑。",
        },
    ],
}
