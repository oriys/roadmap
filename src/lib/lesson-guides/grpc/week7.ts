import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week7Guides: Record<string, LessonGuide> = {
    "grpc-w7-1": {
        lessonId: "grpc-w7-1",
        background: [
            "【拦截器定义】拦截器是应用于多个 RPC 方法的通用行为，类似于其他框架中的过滤器或中间件。",
            "【逐调用机制】拦截器在每次 RPC 调用时执行，无法管理 TCP 连接、配置端口或设置 TLS。",
            "【拦截器类型】分为客户端拦截器和服务端拦截器，各有不同的 API。",
            "【Unary 拦截器】用于一元 RPC（请求-响应模式），处理单个请求和响应。",
            "【Stream 拦截器】用于流式 RPC，可以拦截流的创建和消息的发送接收。",
        ],
        keyDifficulties: [
            "【拦截器顺序】链式拦截器的顺序影响行为，靠近网络的拦截器控制传输，靠近应用的可见应用行为。",
            "【不适用场景】客户端认证应使用 gRPC 专用的 call credentials API，而非拦截器。",
            "【流拦截器复杂性】流拦截器需要处理流的生命周期和多条消息，比 Unary 拦截器复杂。",
            "【上下文传递】拦截器需要正确传递和修改上下文，避免丢失信息。",
        ],
        handsOnPath: [
            "1. 理解拦截器接口：UnaryClientInterceptor、UnaryServerInterceptor",
            "2. 实现简单的日志拦截器",
            "3. 使用 grpc.ChainUnaryInterceptor() 链接多个拦截器",
            "4. 理解 StreamClientInterceptor、StreamServerInterceptor",
            "5. 实现流式 RPC 的拦截器",
            "6. 测试拦截器的执行顺序",
        ],
        selfCheck: [
            "拦截器和中间件有什么关系？",
            "Unary 拦截器和 Stream 拦截器的区别是什么？",
            "拦截器链的执行顺序如何影响行为？",
            "为什么认证应该使用 call credentials 而非拦截器？",
            "拦截器能管理 TCP 连接吗？",
        ],
        extensions: [
            "学习 go-grpc-middleware 库的拦截器实现",
            "了解拦截器在分布式追踪中的应用",
            "探索拦截器与依赖注入的结合",
            "研究拦截器的性能开销",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/interceptors/",
            "https://grpc.io/docs/languages/go/basics/",
            "https://github.com/grpc-ecosystem/go-grpc-middleware",
        ],
    },
    "grpc-w7-2": {
        lessonId: "grpc-w7-2",
        background: [
            "【go-grpc-middleware】提供服务端拦截器实现的综合库，包含日志、认证、恢复等常用功能。",
            "【日志拦截器】可配置的日志中间件，支持 zap、logrus、slog 等多种日志后端。",
            "【Recovery 拦截器】捕获 panic 并转换为 gRPC 错误，防止服务崩溃。",
            "【Auth 拦截器】通过自定义 AuthFunc 实现认证逻辑，支持从 Metadata 提取凭据。",
            "【Validator 拦截器】自动验证请求消息，支持 proto options 定义的验证规则。",
        ],
        keyDifficulties: [
            "【拦截器链设计】需要合理设计拦截器顺序：metrics → logging → auth → recovery。",
            "【错误处理】拦截器中的错误应转换为适当的 gRPC 状态码，避免泄露内部信息。",
            "【性能考量】过多拦截器会增加延迟，需要权衡功能和性能。",
            "【上下文增强】拦截器可以向上下文添加信息，供后续处理使用。",
        ],
        handsOnPath: [
            "1. 安装 go-grpc-middleware/v2",
            "2. 配置 Recovery 拦截器处理 panic",
            "3. 实现自定义 AuthFunc 进行认证",
            "4. 添加日志拦截器记录请求信息",
            "5. 使用 Validator 拦截器验证请求",
            "6. 组合多个拦截器形成处理链",
            "7. 测试拦截器链的错误处理",
        ],
        selfCheck: [
            "go-grpc-middleware 提供哪些常用拦截器？",
            "Recovery 拦截器如何处理 panic？",
            "如何实现自定义认证逻辑？",
            "拦截器链的推荐顺序是什么？",
            "Validator 拦截器如何验证请求？",
            "如何在拦截器中向上下文添加信息？",
        ],
        extensions: [
            "学习限流拦截器的实现",
            "了解 Prometheus 指标拦截器",
            "探索 OpenTelemetry 追踪拦截器",
            "研究自定义拦截器的最佳实践",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/interceptors/",
            "https://github.com/grpc-ecosystem/go-grpc-middleware",
            "https://grpc.io/docs/guides/auth/",
        ],
    },
    "grpc-w7-3": {
        lessonId: "grpc-w7-3",
        background: [
            "【客户端拦截器用途】处理 Metadata、日志、故障注入、缓存、指标收集等横切关注点。",
            "【重试拦截器】客户端自动重试失败的 RPC，支持配置重试策略和可重试状态码。",
            "【超时拦截器】为所有 RPC 设置默认超时，避免无限等待。",
            "【OpenTelemetry 集成】通过拦截器自动收集 gRPC 指标和追踪信息。",
            "【链式处理】客户端拦截器可以链式组合，按顺序处理请求和响应。",
        ],
        keyDifficulties: [
            "【请求修改】客户端拦截器可以修改请求 Metadata，添加认证令牌等信息。",
            "【响应处理】拦截器可以处理响应，进行日志记录、指标更新等操作。",
            "【错误处理】需要正确处理和转换错误，决定是否重试或向上传播。",
            "【流式拦截】流式 RPC 的客户端拦截器需要处理流的多条消息。",
        ],
        handsOnPath: [
            "1. 实现添加认证 Token 的客户端拦截器",
            "2. 配置重试拦截器处理暂时性故障",
            "3. 添加超时拦截器设置默认 Deadline",
            "4. 集成 OpenTelemetry 收集客户端指标",
            "5. 实现请求 ID 传播拦截器",
            "6. 测试客户端拦截器链的行为",
        ],
        selfCheck: [
            "客户端拦截器的主要用途有哪些？",
            "如何在客户端拦截器中添加 Metadata？",
            "重试拦截器如何决定是否重试？",
            "OpenTelemetry 拦截器收集哪些信息？",
            "客户端拦截器的执行顺序是怎样的？",
            "流式 RPC 的客户端拦截器有什么特殊之处？",
            "如何测试客户端拦截器？",
        ],
        extensions: [
            "学习断路器拦截器的实现",
            "了解客户端负载均衡拦截器",
            "探索请求压缩拦截器",
            "研究客户端缓存拦截器策略",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/interceptors/",
            "https://grpc.io/docs/guides/retry/",
            "https://grpc.io/docs/guides/opentelemetry-metrics/",
        ],
    },
}

export const week7Quizzes: Record<string, QuizQuestion[]> = {
    "grpc-w7-1": [
        {
            id: "grpc-w7-1-q1",
            question: "gRPC 拦截器最类似于什么概念？",
            options: ["数据库触发器", "中间件/过滤器", "事件监听器", "回调函数"],
            answer: 1,
            rationale: "拦截器类似于其他框架中的过滤器或中间件，用于处理横切关注点。",
        },
        {
            id: "grpc-w7-1-q2",
            question: "拦截器能管理 TCP 连接吗？",
            options: ["能", "不能，只在 RPC 层面工作", "只有服务端能", "取决于配置"],
            answer: 1,
            rationale: "拦截器在每次 RPC 调用时执行，无法管理 TCP 连接、端口或 TLS。",
        },
        {
            id: "grpc-w7-1-q3",
            question: "Unary 拦截器处理什么类型的 RPC？",
            options: ["流式 RPC", "一元 RPC（请求-响应）", "双向流", "所有类型"],
            answer: 1,
            rationale: "Unary 拦截器用于一元 RPC，处理单个请求和响应。",
        },
        {
            id: "grpc-w7-1-q4",
            question: "客户端认证应该使用什么机制？",
            options: [
                "客户端拦截器",
                "gRPC 专用的 call credentials API",
                "服务端拦截器",
                "Metadata",
            ],
            answer: 1,
            rationale: "客户端认证应使用 gRPC 专用的 call credentials API，而非拦截器。",
        },
        {
            id: "grpc-w7-1-q5",
            question: "链式拦截器的顺序如何影响行为？",
            options: [
                "没有影响",
                "靠近网络的控制传输，靠近应用的可见应用行为",
                "只影响性能",
                "只影响日志",
            ],
            answer: 1,
            rationale: "拦截器顺序很重要，靠近网络的拦截器控制传输，靠近应用的可见应用行为。",
        },
        {
            id: "grpc-w7-1-q6",
            question: "Go 语言中链接多个 Unary 拦截器使用什么函数？",
            options: [
                "grpc.LinkInterceptors()",
                "grpc.ChainUnaryInterceptor()",
                "grpc.AddInterceptor()",
                "grpc.WithInterceptor()",
            ],
            answer: 1,
            rationale: "Go 中使用 grpc.ChainUnaryInterceptor() 链接多个 Unary 拦截器。",
        },
        {
            id: "grpc-w7-1-q7",
            question: "Stream 拦截器比 Unary 拦截器复杂的原因是什么？",
            options: [
                "API 不同",
                "需要处理流的生命周期和多条消息",
                "性能要求更高",
                "支持的语言更少",
            ],
            answer: 1,
            rationale: "Stream 拦截器需要处理流的生命周期和多条消息，比 Unary 拦截器复杂。",
        },
        {
            id: "grpc-w7-1-q8",
            question: "拦截器常用于哪些场景？",
            options: [
                "只有日志",
                "Metadata 处理、日志、指标、认证授权等",
                "只有认证",
                "只有错误处理",
            ],
            answer: 1,
            rationale: "拦截器常用于 Metadata 处理、日志、故障注入、缓存、指标、策略执行、认证授权等。",
        },
        {
            id: "grpc-w7-1-q9",
            question: "服务端 Unary 拦截器的接口类型是什么？",
            options: [
                "grpc.ServerInterceptor",
                "grpc.UnaryServerInterceptor",
                "grpc.ServerUnaryInterceptor",
                "grpc.Interceptor",
            ],
            answer: 1,
            rationale: "服务端 Unary 拦截器的接口类型是 grpc.UnaryServerInterceptor。",
        },
        {
            id: "grpc-w7-1-q10",
            question: "拦截器在什么时候添加到 gRPC 服务？",
            options: [
                "运行时动态添加",
                "构建 channel 或 server 时",
                "每次 RPC 调用时",
                "连接建立时",
            ],
            answer: 1,
            rationale: "拦截器在构建 channel 或 server 时添加，应用于该资源的所有 RPC。",
        },
        {
            id: "grpc-w7-1-q11",
            question: "哪些语言提供官方的拦截器示例？",
            options: [
                "只有 Go",
                "C++、Go、Java、Python",
                "只有 Java 和 Go",
                "所有语言",
            ],
            answer: 1,
            rationale: "gRPC 官方为 C++、Go、Java、Python 提供拦截器示例。",
        },
        {
            id: "grpc-w7-1-q12",
            question: "拦截器如何传递信息给处理程序？",
            options: [
                "全局变量",
                "通过修改上下文（context）",
                "返回值",
                "Metadata",
            ],
            answer: 1,
            rationale: "拦截器通过修改上下文传递信息，如认证结果等，供后续处理使用。",
        },
    ],
    "grpc-w7-2": [
        {
            id: "grpc-w7-2-q1",
            question: "go-grpc-middleware 是什么？",
            options: [
                "gRPC 核心库",
                "提供常用服务端拦截器实现的库",
                "日志库",
                "测试框架",
            ],
            answer: 1,
            rationale: "go-grpc-middleware 是提供服务端和客户端拦截器实现的综合库。",
        },
        {
            id: "grpc-w7-2-q2",
            question: "Recovery 拦截器的主要作用是什么？",
            options: [
                "数据恢复",
                "捕获 panic 并转换为 gRPC 错误",
                "连接恢复",
                "服务恢复",
            ],
            answer: 1,
            rationale: "Recovery 拦截器捕获 panic 并转换为 gRPC 错误，防止服务崩溃。",
        },
        {
            id: "grpc-w7-2-q3",
            question: "拦截器链的推荐顺序是什么？",
            options: [
                "auth → logging → metrics → recovery",
                "metrics → logging → auth → recovery",
                "recovery → auth → logging → metrics",
                "顺序不重要",
            ],
            answer: 1,
            rationale: "推荐顺序是 metrics → logging → auth → recovery，确保指标和日志记录所有请求。",
        },
        {
            id: "grpc-w7-2-q4",
            question: "Auth 拦截器如何实现自定义认证？",
            options: [
                "配置文件",
                "实现自定义 AuthFunc",
                "注解",
                "环境变量",
            ],
            answer: 1,
            rationale: "通过实现自定义 AuthFunc 函数，从 Metadata 提取凭据并验证。",
        },
        {
            id: "grpc-w7-2-q5",
            question: "go-grpc-middleware 的日志中间件支持哪些日志后端？",
            options: [
                "只有 log 标准库",
                "zap、logrus、slog 等多种后端",
                "只有 zap",
                "只有 logrus",
            ],
            answer: 1,
            rationale: "日志中间件支持 zap、logrus、slog 等多种日志后端。",
        },
        {
            id: "grpc-w7-2-q6",
            question: "Validator 拦截器如何定义验证规则？",
            options: [
                "代码注解",
                "proto options",
                "配置文件",
                "JSON Schema",
            ],
            answer: 1,
            rationale: "Validator 拦截器使用 proto options 定义的验证规则自动验证请求。",
        },
        {
            id: "grpc-w7-2-q7",
            question: "拦截器中的错误应该如何处理？",
            options: [
                "直接抛出异常",
                "转换为适当的 gRPC 状态码",
                "忽略错误",
                "返回 nil",
            ],
            answer: 1,
            rationale: "拦截器中的错误应转换为适当的 gRPC 状态码，避免泄露内部信息。",
        },
        {
            id: "grpc-w7-2-q8",
            question: "go-grpc-middleware v2 的安装路径是什么？",
            options: [
                "github.com/grpc-ecosystem/go-grpc-middleware",
                "github.com/grpc-ecosystem/go-grpc-middleware/v2",
                "google.golang.org/grpc/middleware",
                "grpc.io/middleware",
            ],
            answer: 1,
            rationale: "v2 版本使用 /v2 路径：github.com/grpc-ecosystem/go-grpc-middleware/v2。",
        },
        {
            id: "grpc-w7-2-q9",
            question: "过多拦截器会带来什么问题？",
            options: [
                "编译错误",
                "增加延迟，影响性能",
                "内存泄漏",
                "不会有问题",
            ],
            answer: 1,
            rationale: "过多拦截器会增加请求延迟，需要权衡功能和性能。",
        },
        {
            id: "grpc-w7-2-q10",
            question: "拦截器如何向上下文添加信息？",
            options: [
                "修改全局变量",
                "使用 context.WithValue() 等方法",
                "写入 Metadata",
                "修改请求",
            ],
            answer: 1,
            rationale: "拦截器使用 context.WithValue() 向上下文添加信息，供后续处理使用。",
        },
        {
            id: "grpc-w7-2-q11",
            question: "go-grpc-middleware 支持哪些类型的拦截器？",
            options: [
                "只有服务端",
                "服务端和客户端",
                "只有 Unary",
                "只有 Stream",
            ],
            answer: 1,
            rationale: "go-grpc-middleware 同时支持服务端和客户端的 Unary 和 Stream 拦截器。",
        },
        {
            id: "grpc-w7-2-q12",
            question: "限流拦截器通常使用什么算法？",
            options: [
                "随机算法",
                "令牌桶或漏桶算法",
                "轮询算法",
                "排队算法",
            ],
            answer: 1,
            rationale: "限流拦截器通常使用令牌桶或漏桶算法控制请求速率。",
        },
    ],
    "grpc-w7-3": [
        {
            id: "grpc-w7-3-q1",
            question: "客户端拦截器的主要用途有哪些？",
            options: [
                "只有日志",
                "Metadata 处理、日志、重试、超时、指标等",
                "只有认证",
                "只有缓存",
            ],
            answer: 1,
            rationale: "客户端拦截器用于处理 Metadata、日志、故障注入、缓存、指标收集等。",
        },
        {
            id: "grpc-w7-3-q2",
            question: "重试拦截器根据什么决定是否重试？",
            options: [
                "随机决定",
                "可重试状态码和重试策略",
                "响应时间",
                "服务器负载",
            ],
            answer: 1,
            rationale: "重试拦截器根据配置的可重试状态码和重试策略决定是否重试。",
        },
        {
            id: "grpc-w7-3-q3",
            question: "如何在客户端拦截器中添加认证 Token？",
            options: [
                "修改请求体",
                "通过修改 Metadata 添加 Authorization 头",
                "环境变量",
                "命令行参数",
            ],
            answer: 1,
            rationale: "客户端拦截器可以修改请求 Metadata，添加认证令牌等信息。",
        },
        {
            id: "grpc-w7-3-q4",
            question: "OpenTelemetry 客户端拦截器收集哪些信息？",
            options: [
                "只有日志",
                "指标、追踪、调用时长等",
                "只有错误",
                "只有请求大小",
            ],
            answer: 1,
            rationale: "OpenTelemetry 拦截器收集 gRPC 指标、分布式追踪和调用时长等信息。",
        },
        {
            id: "grpc-w7-3-q5",
            question: "超时拦截器的作用是什么？",
            options: [
                "增加超时时间",
                "为所有 RPC 设置默认超时",
                "取消超时",
                "记录超时",
            ],
            answer: 1,
            rationale: "超时拦截器为所有 RPC 设置默认超时，避免无限等待。",
        },
        {
            id: "grpc-w7-3-q6",
            question: "客户端拦截器链的执行顺序是怎样的？",
            options: [
                "随机顺序",
                "按添加顺序，请求时正序，响应时逆序",
                "并行执行",
                "按字母顺序",
            ],
            answer: 1,
            rationale: "客户端拦截器按添加顺序执行，请求时正序处理，响应时逆序处理。",
        },
        {
            id: "grpc-w7-3-q7",
            question: "流式 RPC 的客户端拦截器有什么特殊之处？",
            options: [
                "不支持流式拦截",
                "需要处理流的多条消息",
                "只能处理第一条消息",
                "自动处理所有消息",
            ],
            answer: 1,
            rationale: "流式 RPC 的客户端拦截器需要处理流的多条消息，而非单个请求响应。",
        },
        {
            id: "grpc-w7-3-q8",
            question: "请求 ID 传播拦截器的作用是什么？",
            options: [
                "生成请求 ID",
                "在分布式调用中传播追踪 ID",
                "验证请求 ID",
                "删除请求 ID",
            ],
            answer: 1,
            rationale: "请求 ID 传播拦截器在分布式调用中传播追踪 ID，实现链路追踪。",
        },
        {
            id: "grpc-w7-3-q9",
            question: "客户端拦截器中如何处理错误？",
            options: [
                "忽略所有错误",
                "决定是否重试或向上传播",
                "自动重试",
                "转换为成功",
            ],
            answer: 1,
            rationale: "拦截器需要正确处理错误，决定是否重试或向上传播给调用者。",
        },
        {
            id: "grpc-w7-3-q10",
            question: "断路器拦截器的作用是什么？",
            options: [
                "加密连接",
                "在服务不可用时快速失败，避免级联故障",
                "增加连接数",
                "缓存响应",
            ],
            answer: 1,
            rationale: "断路器拦截器在检测到服务不可用时快速失败，避免级联故障。",
        },
        {
            id: "grpc-w7-3-q11",
            question: "grpc.client.call.duration 指标表示什么？",
            options: [
                "连接时长",
                "端到端 RPC 完成时间",
                "重试时长",
                "排队时长",
            ],
            answer: 1,
            rationale: "grpc.client.call.duration 是 OpenTelemetry 指标，表示端到端 RPC 完成时间。",
        },
        {
            id: "grpc-w7-3-q12",
            question: "客户端缓存拦截器应该考虑什么？",
            options: [
                "只缓存成功响应",
                "缓存策略、过期时间、缓存键生成",
                "缓存所有响应",
                "不需要考虑",
            ],
            answer: 1,
            rationale: "客户端缓存拦截器需要考虑缓存策略、过期时间、缓存键生成等因素。",
        },
    ],
}
