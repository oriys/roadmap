import type { LessonGuide } from "../types"
import type { QuizQuestion } from "@/lib/types"

export const week5Guides: Record<string, LessonGuide> = {
    "grpc-w5-1": {
        lessonId: "grpc-w5-1",
        background: [
            "【状态码体系】gRPC 返回包含整数状态码和字符串描述的 status 对象，定义了 17 个标准状态码（0-16）。",
            "【OK 状态】状态码 0（OK）表示操作成功完成，是唯一表示成功的状态码。",
            "【CANCELLED】状态码 1，表示操作被取消，通常由调用方主动取消。",
            "【DEADLINE_EXCEEDED】状态码 4，表示在操作完成前截止时间已过期。",
            "【UNAVAILABLE】状态码 14，表示服务暂时不可用，客户端可以使用退避策略重试。",
            "【UNAUTHENTICATED】状态码 16，表示请求未提供有效的认证凭据。",
        ],
        keyDifficulties: [
            "【用户 vs 框架状态码】部分状态码只能由用户代码返回（如 INVALID_ARGUMENT、NOT_FOUND），不会由 gRPC 框架自动生成。",
            "【重试决策】UNAVAILABLE 适合客户端重试，ABORTED 适合更高层级重试，FAILED_PRECONDITION 需要先修正系统状态。",
            "【UNKNOWN 状态】状态码 2 表示未知错误，通常是从不熟悉的错误空间接收到的错误。",
            "【PERMISSION_DENIED vs UNAUTHENTICATED】前者表示已认证但无权限，后者表示未认证或凭据无效。",
        ],
        handsOnPath: [
            "1. 创建返回不同状态码的 gRPC 服务方法",
            "2. 使用 status.New() 或 status.Error() 构建错误响应",
            "3. 实现参数验证返回 INVALID_ARGUMENT",
            "4. 实现资源查找返回 NOT_FOUND",
            "5. 测试客户端接收和处理不同状态码",
            "6. 记录日志包含状态码和描述信息",
        ],
        selfCheck: [
            "gRPC 定义了多少个标准状态码？",
            "哪些状态码只能由用户代码返回？",
            "UNAVAILABLE 和 INTERNAL 的区别是什么？",
            "如何区分 NOT_FOUND、PERMISSION_DENIED 和 UNAUTHENTICATED？",
            "什么情况下应该返回 FAILED_PRECONDITION？",
        ],
        extensions: [
            "学习各语言 SDK 中状态码的表示方式",
            "了解 HTTP 状态码与 gRPC 状态码的映射",
            "探索自定义错误消息的最佳实践",
            "研究状态码在可观测性系统中的应用",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/status-codes/",
            "https://grpc.io/docs/guides/error/",
            "https://grpc.io/docs/what-is-grpc/core-concepts/",
        ],
    },
    "grpc-w5-2": {
        lessonId: "grpc-w5-2",
        background: [
            "【Rich Error Model】Google 扩展的错误模型，通过额外的 protobuf 消息提供更详细的错误信息。",
            "【ErrorInfo】必需的错误详情类型，包含 reason（UPPER_SNAKE_CASE）、domain（服务名）和 metadata（键值对）。",
            "【RetryInfo】告知客户端何时可以安全重试，包含 retry_delay 字段指定最小等待时间。",
            "【BadRequest】描述请求中的语法错误，包含 FieldViolation 列表说明哪些字段无效及原因。",
            "【QuotaFailure】解释配额检查失败，包含 subject、description 和配额相关的详细信息。",
            "【PreconditionFailure】列出失败的前置条件，如未接受服务条款等。",
        ],
        keyDifficulties: [
            "【语言支持差异】C++、Go、Java、Python、Ruby 支持 Rich Error Model，Node.js 和 grpc-web 支持有限。",
            "【头部大小限制】错误详情过大可能超出协议限制（HTTP/2 默认最大头部 8KB）。",
            "【压缩干扰】较大的错误载荷可能影响 HTTP/2 头部压缩效率。",
            "【监控盲区】标准 HTTP 处理器无法查看错误详情，影响监控能力。",
        ],
        handsOnPath: [
            "1. 定义使用 google.rpc.Status 的错误响应",
            "2. 创建包含 ErrorInfo 的详细错误",
            "3. 添加 BadRequest.FieldViolation 描述字段错误",
            "4. 实现 RetryInfo 指导客户端重试",
            "5. 客户端解析 status.Details() 提取错误详情",
            "6. 测试错误详情的序列化和反序列化",
        ],
        selfCheck: [
            "Rich Error Model 相比标准错误模型有什么优势？",
            "ErrorInfo 的三个主要字段是什么？",
            "如何使用 BadRequest 描述多个字段验证错误？",
            "RetryInfo 的 retry_delay 字段有什么作用？",
            "为什么错误详情不应该过大？",
            "哪些编程语言原生支持 Rich Error Model？",
        ],
        extensions: [
            "学习 google/rpc/error_details.proto 的完整定义",
            "了解 LocalizedMessage 实现多语言错误消息",
            "探索 Help 类型提供文档链接",
            "研究 DebugInfo 在调试中的应用",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/error/",
            "https://google.aip.dev/193",
            "https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto",
        ],
    },
    "grpc-w5-3": {
        lessonId: "grpc-w5-3",
        background: [
            "【自动重试】gRPC 内置重试逻辑，通过 Service Config 配置，支持指数退避和抖动。",
            "【重试策略参数】maxAttempts（最大尝试次数）、initialBackoff（初始延迟）、maxBackoff（最大延迟）、backoffMultiplier（倍数）。",
            "【可重试状态码】retryableStatusCodes 指定哪些状态码触发重试，通常是 UNAVAILABLE。",
            "【透明重试】没有显式策略时，gRPC 对服务器处理前的失败执行透明重试。",
            "【请求对冲】Hedging 策略同时向多个后端发送请求副本，使用最先返回的响应。",
            "【Wait-for-Ready】允许 RPC 在服务器不可用时排队等待，而非立即失败。",
        ],
        keyDifficulties: [
            "【退避抖动】实际延迟有 ±20% 的随机抖动，避免重试风暴。",
            "【重试限流】通过 maxTokens 和 tokenRatio 限制重试频率，防止服务器过载。",
            "【对冲 vs 重试】对冲主动发送多个请求减少尾延迟，重试等待失败后才重试。",
            "【Wait-for-Ready 超时】等待期间仍受 deadline 限制，超时会失败。",
        ],
        handsOnPath: [
            "1. 配置 Service Config 启用重试策略",
            "2. 设置 retryableStatusCodes: [\"UNAVAILABLE\"]",
            "3. 调整 initialBackoff、maxBackoff 和 backoffMultiplier",
            "4. 配置 retryThrottling 防止重试风暴",
            "5. 测试对冲策略的 hedgingDelay 参数",
            "6. 启用 Wait-for-Ready 处理临时连接问题",
            "7. 使用 OpenTelemetry 监控重试指标",
        ],
        selfCheck: [
            "重试策略的主要配置参数有哪些？",
            "透明重试和显式重试策略有什么区别？",
            "重试抖动的作用是什么？",
            "如何配置重试限流防止服务器过载？",
            "对冲策略适用于什么场景？",
            "Wait-for-Ready 如何处理通道状态？",
            "hedgingDelay 为 0 时会发生什么？",
        ],
        extensions: [
            "学习 grpc-retry-pushback-ms 元数据的使用",
            "了解断路器模式与重试的结合",
            "探索客户端负载均衡对重试的影响",
            "研究幂等性与重试安全的关系",
        ],
        sourceUrls: [
            "https://grpc.io/docs/guides/retry/",
            "https://grpc.io/docs/guides/request-hedging/",
            "https://grpc.io/docs/guides/wait-for-ready/",
        ],
    },
}

export const week5Quizzes: Record<string, QuizQuestion[]> = {
    "grpc-w5-1": [
        {
            id: "grpc-w5-1-q1",
            question: "gRPC 定义了多少个标准状态码？",
            options: ["10 个", "15 个", "17 个（0-16）", "20 个"],
            answer: 2,
            rationale: "gRPC 定义了 17 个标准状态码，从 OK(0) 到 UNAUTHENTICATED(16)。",
        },
        {
            id: "grpc-w5-1-q2",
            question: "哪个状态码表示操作成功完成？",
            options: ["OK (0)", "SUCCESS (1)", "COMPLETED (2)", "DONE (3)"],
            answer: 0,
            rationale: "OK（状态码 0）是唯一表示成功的状态码。",
        },
        {
            id: "grpc-w5-1-q3",
            question: "以下哪个状态码只能由用户代码返回，不会由 gRPC 框架生成？",
            options: ["CANCELLED", "UNKNOWN", "NOT_FOUND", "DEADLINE_EXCEEDED"],
            answer: 2,
            rationale: "NOT_FOUND 只能由用户代码返回，gRPC 框架不会自动生成此状态码。",
        },
        {
            id: "grpc-w5-1-q4",
            question: "客户端主动取消操作时应返回哪个状态码？",
            options: ["ABORTED", "CANCELLED", "UNAVAILABLE", "UNKNOWN"],
            answer: 1,
            rationale: "CANCELLED（状态码 1）表示操作被取消，通常由调用方主动取消。",
        },
        {
            id: "grpc-w5-1-q5",
            question: "哪个状态码最适合客户端使用退避策略重试？",
            options: ["INTERNAL", "UNAVAILABLE", "FAILED_PRECONDITION", "DATA_LOSS"],
            answer: 1,
            rationale: "UNAVAILABLE（状态码 14）表示服务暂时不可用，适合客户端使用退避策略重试。",
        },
        {
            id: "grpc-w5-1-q6",
            question: "DEADLINE_EXCEEDED 的状态码值是多少？",
            options: ["2", "3", "4", "5"],
            answer: 2,
            rationale: "DEADLINE_EXCEEDED 的状态码值是 4，表示截止时间已过期。",
        },
        {
            id: "grpc-w5-1-q7",
            question: "请求未提供有效认证凭据时应返回哪个状态码？",
            options: ["PERMISSION_DENIED", "UNAUTHENTICATED", "UNAUTHORIZED", "FORBIDDEN"],
            answer: 1,
            rationale: "UNAUTHENTICATED（状态码 16）表示请求未提供有效的认证凭据。",
        },
        {
            id: "grpc-w5-1-q8",
            question: "PERMISSION_DENIED 和 UNAUTHENTICATED 的主要区别是什么？",
            options: [
                "没有区别",
                "前者表示已认证但无权限，后者表示未认证",
                "前者用于读操作，后者用于写操作",
                "前者是客户端错误，后者是服务端错误",
            ],
            answer: 1,
            rationale: "PERMISSION_DENIED 表示已认证但没有权限，UNAUTHENTICATED 表示未认证或凭据无效。",
        },
        {
            id: "grpc-w5-1-q9",
            question: "哪个状态码表示系统不在执行操作所需的状态？",
            options: ["ABORTED", "FAILED_PRECONDITION", "INVALID_ARGUMENT", "UNAVAILABLE"],
            answer: 1,
            rationale: "FAILED_PRECONDITION（状态码 9）表示系统不在执行操作所需的状态。",
        },
        {
            id: "grpc-w5-1-q10",
            question: "RESOURCE_EXHAUSTED 通常表示什么情况？",
            options: [
                "资源不存在",
                "资源被删除",
                "配额耗尽或磁盘空间不足等资源枯竭",
                "资源正在使用中",
            ],
            answer: 2,
            rationale: "RESOURCE_EXHAUSTED（状态码 8）表示资源枯竭，如配额、磁盘空间等。",
        },
        {
            id: "grpc-w5-1-q11",
            question: "ABORTED 状态码通常用于什么场景？",
            options: [
                "用户主动取消",
                "并发冲突导致操作中止",
                "参数无效",
                "权限不足",
            ],
            answer: 1,
            rationale: "ABORTED（状态码 10）表示操作因并发问题（如事务冲突）而中止。",
        },
        {
            id: "grpc-w5-1-q12",
            question: "UNIMPLEMENTED 状态码的值是多少？",
            options: ["10", "11", "12", "13"],
            answer: 2,
            rationale: "UNIMPLEMENTED 的状态码值是 12，表示操作未实现或不支持。",
        },
    ],
    "grpc-w5-2": [
        {
            id: "grpc-w5-2-q1",
            question: "Rich Error Model 通过什么方式提供详细错误信息？",
            options: [
                "HTTP 头部",
                "额外的 protobuf 消息",
                "JSON 格式",
                "XML 格式",
            ],
            answer: 1,
            rationale: "Rich Error Model 通过额外的 protobuf 消息提供更详细的错误信息。",
        },
        {
            id: "grpc-w5-2-q2",
            question: "ErrorInfo 的 reason 字段应该使用什么格式？",
            options: [
                "camelCase",
                "UPPER_SNAKE_CASE",
                "kebab-case",
                "任意格式",
            ],
            answer: 1,
            rationale: "ErrorInfo 的 reason 字段应使用 UPPER_SNAKE_CASE 格式，最多 63 个字符。",
        },
        {
            id: "grpc-w5-2-q3",
            question: "哪个错误详情类型用于指导客户端何时可以重试？",
            options: ["ErrorInfo", "RetryInfo", "BadRequest", "DebugInfo"],
            answer: 1,
            rationale: "RetryInfo 包含 retry_delay 字段，告知客户端最小等待时间后可重试。",
        },
        {
            id: "grpc-w5-2-q4",
            question: "BadRequest 用于描述什么类型的错误？",
            options: [
                "认证失败",
                "请求中的语法/字段验证错误",
                "服务器内部错误",
                "网络连接错误",
            ],
            answer: 1,
            rationale: "BadRequest 描述请求中的语法错误，包含 FieldViolation 列表说明无效字段。",
        },
        {
            id: "grpc-w5-2-q5",
            question: "以下哪些语言原生支持 Rich Error Model？",
            options: [
                "只有 Go 和 Java",
                "C++、Go、Java、Python、Ruby",
                "所有 gRPC 支持的语言",
                "只有 C++ 和 Python",
            ],
            answer: 1,
            rationale: "C++、Go、Java、Python 和 Ruby 原生支持 Rich Error Model，Node.js 和 grpc-web 支持有限。",
        },
        {
            id: "grpc-w5-2-q6",
            question: "为什么错误详情不应该过大？",
            options: [
                "会导致编译错误",
                "可能超出 HTTP/2 头部大小限制",
                "会降低服务器性能",
                "客户端无法解析",
            ],
            answer: 1,
            rationale: "较大的错误载荷可能超出协议限制（HTTP/2 默认最大头部 8KB）并影响压缩效率。",
        },
        {
            id: "grpc-w5-2-q7",
            question: "ErrorInfo 的 domain 字段通常填写什么？",
            options: [
                "错误域名",
                "服务名，如 pubsub.googleapis.com",
                "客户端地址",
                "错误类型",
            ],
            answer: 1,
            rationale: "domain 是逻辑分组或注册的服务名，如 pubsub.googleapis.com。",
        },
        {
            id: "grpc-w5-2-q8",
            question: "QuotaFailure 用于解释什么类型的错误？",
            options: [
                "认证失败",
                "配额检查失败",
                "前置条件失败",
                "参数验证失败",
            ],
            answer: 1,
            rationale: "QuotaFailure 解释配额检查失败和资源限制超出的情况。",
        },
        {
            id: "grpc-w5-2-q9",
            question: "LocalizedMessage 的主要用途是什么？",
            options: [
                "本地化服务",
                "提供特定语言/区域的错误消息",
                "本地缓存",
                "本地日志",
            ],
            answer: 1,
            rationale: "LocalizedMessage 提供用户安全的错误消息，支持特定语言环境（如 en-US、fr-CH）。",
        },
        {
            id: "grpc-w5-2-q10",
            question: "Help 错误详情类型包含什么信息？",
            options: [
                "帮助热线",
                "文档链接和描述",
                "帮助命令",
                "帮助文件路径",
            ],
            answer: 1,
            rationale: "Help 包含 Link 列表，每个 Link 有 description 和 url，指向文档或解决方案。",
        },
        {
            id: "grpc-w5-2-q11",
            question: "DebugInfo 类型包含哪些字段？",
            options: [
                "调试命令和工具",
                "stack_entries 和 detail",
                "调试端口和地址",
                "调试开关和选项",
            ],
            answer: 1,
            rationale: "DebugInfo 包含 stack_entries（堆栈跟踪）和 detail（额外调试信息）字段。",
        },
        {
            id: "grpc-w5-2-q12",
            question: "PreconditionFailure 中的 Violation 包含哪些字段？",
            options: [
                "code 和 message",
                "type、subject 和 description",
                "field 和 value",
                "error 和 detail",
            ],
            answer: 1,
            rationale: "PreconditionFailure.Violation 包含 type（类型）、subject（主题）和 description（如何解决）。",
        },
    ],
    "grpc-w5-3": [
        {
            id: "grpc-w5-3-q1",
            question: "gRPC 重试策略通过什么方式配置？",
            options: [
                "代码硬编码",
                "Service Config",
                "环境变量",
                "命令行参数",
            ],
            answer: 1,
            rationale: "gRPC 重试策略通过 Service Config 在方法级别配置。",
        },
        {
            id: "grpc-w5-3-q2",
            question: "重试策略中 maxAttempts 参数表示什么？",
            options: [
                "最大连接数",
                "总尝试次数上限",
                "最大并发数",
                "最大超时时间",
            ],
            answer: 1,
            rationale: "maxAttempts 表示允许的总重试尝试次数上限。",
        },
        {
            id: "grpc-w5-3-q3",
            question: "重试退避延迟的随机抖动范围是多少？",
            options: ["±5%", "±10%", "±20%", "±30%"],
            answer: 2,
            rationale: "gRPC 重试使用 ±20% 的随机抖动，防止同步重试风暴。",
        },
        {
            id: "grpc-w5-3-q4",
            question: "透明重试（Transparent Retry）在什么情况下执行？",
            options: [
                "所有失败",
                "服务器处理前的失败",
                "超时失败",
                "认证失败",
            ],
            answer: 1,
            rationale: "没有显式策略时，gRPC 对服务器处理前的失败执行透明重试。",
        },
        {
            id: "grpc-w5-3-q5",
            question: "请求对冲（Hedging）策略的主要目的是什么？",
            options: [
                "提高吞吐量",
                "减少尾延迟",
                "节省带宽",
                "增加可靠性",
            ],
            answer: 1,
            rationale: "Hedging 同时向多个后端发送请求副本，使用最先返回的响应来减少尾延迟。",
        },
        {
            id: "grpc-w5-3-q6",
            question: "对冲策略的 maxAttempts 最大值是多少？",
            options: ["3", "5", "10", "无限制"],
            answer: 1,
            rationale: "对冲策略的 maxAttempts 限制为 5，即使配置更高也只会使用 5。",
        },
        {
            id: "grpc-w5-3-q7",
            question: "重试限流使用哪两个参数控制？",
            options: [
                "rate 和 burst",
                "maxTokens 和 tokenRatio",
                "limit 和 window",
                "count 和 interval",
            ],
            answer: 1,
            rationale: "重试限流使用 maxTokens（令牌上限）和 tokenRatio（成功时增加的比例）控制。",
        },
        {
            id: "grpc-w5-3-q8",
            question: "Wait-for-Ready 在通道处于 TRANSIENT_FAILURE 状态时会怎样？",
            options: [
                "立即返回失败",
                "排队等待连接恢复",
                "自动重连",
                "切换服务器",
            ],
            answer: 1,
            rationale: "启用 Wait-for-Ready 后，在 TRANSIENT_FAILURE 状态下会排队等待连接恢复。",
        },
        {
            id: "grpc-w5-3-q9",
            question: "对冲策略中 hedgingDelay 为 0 会发生什么？",
            options: [
                "禁用对冲",
                "所有请求同时发送",
                "使用默认延迟",
                "报错",
            ],
            answer: 1,
            rationale: "hedgingDelay 为 0 或未设置时，所有对冲请求会同时发送。",
        },
        {
            id: "grpc-w5-3-q10",
            question: "哪个状态码通常配置为可重试？",
            options: ["INVALID_ARGUMENT", "NOT_FOUND", "UNAVAILABLE", "PERMISSION_DENIED"],
            answer: 2,
            rationale: "UNAVAILABLE 通常配置为可重试状态码，表示暂时性故障。",
        },
        {
            id: "grpc-w5-3-q11",
            question: "服务器如何告知客户端不要重试？",
            options: [
                "返回 NO_RETRY 状态码",
                "使用 grpc-retry-pushback-ms 元数据",
                "关闭连接",
                "返回空响应",
            ],
            answer: 1,
            rationale: "服务器可以使用 grpc-retry-pushback-ms 元数据头明确告知客户端不要重试。",
        },
        {
            id: "grpc-w5-3-q12",
            question: "Wait-for-Ready 等待期间受什么限制？",
            options: [
                "不受任何限制",
                "deadline 仍然生效",
                "只有 10 秒限制",
                "只受服务器限制",
            ],
            answer: 1,
            rationale: "Wait-for-Ready 等待期间仍受 deadline 限制，超时会失败。",
        },
    ],
}
