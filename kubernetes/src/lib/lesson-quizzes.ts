export type QuizQuestion = { id: string; question: string; options: string[]; answer: number; rationale: string }

export const customLessonQuizzes: Record<string, QuizQuestion[]> = {
  // Week 1
  "w1-1": [
    {
      id: "w1-1-q1",
      question: "在 namespaces(7) 的“Namespace types”表格中，哪组 Flag → 类型/隔离对象的对应关系正确？",
      options: [
        "CLONE_NEWUSER → User（隔离 UID/GID）",
        "CLONE_NEWNET → Mount（隔离挂载点）",
        "CLONE_NEWNS → PID（隔离进程号）",
        "CLONE_NEWPID → Network（隔离网络设备/端口）",
      ],
      answer: 0,
      rationale: "namespaces(7) 表格明确：CLONE_NEWUSER 对应 User namespace，隔离 user/group IDs。",
    },
    {
      id: "w1-1-q2",
      question: "要让当前进程加入一个已存在的 namespace，namespaces(7) 建议使用哪个系统调用？",
      options: [
        "setns(2)：通过指向 /proc/<pid>/ns/* 的文件描述符加入",
        "unshare(2)：加入现有 namespace（不创建新的）",
        "clone(2)：不创建子进程也能加入现有 namespace",
        "ioctl(2)：直接切换到目标 namespace",
      ],
      answer: 0,
      rationale: "namespaces(7) 描述 setns(2) 用于加入已存在的 namespace，目标通过 /proc/pid/ns 下的 fd 指定。",
    },
    {
      id: "w1-1-q3",
      question: "关于创建新 namespace 的权限要求，哪个说法符合 namespaces(7)？",
      options: [
        "大多数类型需要 CAP_SYS_ADMIN；User namespace 是例外（Linux 3.8 起无特权也可创建）",
        "所有 namespace 都必须 root 才能创建",
        "只有 Network namespace 需要 CAP_NET_ADMIN，其它都不需要",
        "创建 User namespace 需要 CAP_SYS_ADMIN，但其它都不需要",
      ],
      answer: 0,
      rationale: "namespaces(7) 指出：除 user namespace 外，clone/unshare 创建新 namespace 在多数情况下需要 CAP_SYS_ADMIN。",
    },
    {
      id: "w1-1-q4",
      question: "/proc/<pid>/ns/pid 与 /proc/<pid>/ns/pid_for_children 的区别是？",
      options: [
        "pid 指向当前进程所属 PID namespace（生命周期内不变）；pid_for_children 影响子进程的 PID namespace，可能因 unshare/setns 改变",
        "两者完全等价，只是名字不同",
        "pid_for_children 记录父进程 PID 值，pid 记录子进程 PID",
        "pid 可通过 setns 改变，pid_for_children 永远不变",
      ],
      answer: 0,
      rationale: "namespaces(7) 说明：/proc/<pid>/ns/pid 对进程来说是固定成员关系；pid_for_children 可因 unshare/setns 改变并影响后续子进程。",
    },
    {
      id: "w1-1-q5",
      question: "namespaces(7) 提到，/proc/<pid>/ns/pid_for_children 可能 readlink 返回空缓冲区的典型原因是？",
      options: [
        "该进程还没有在该 namespace 中创建过子进程",
        "该进程不是 root",
        "系统未启用 cgroup v2",
        "内核不支持 PID namespace",
      ],
      answer: 0,
      rationale: "namespaces(7) 说明 pid_for_children 在第一次在该 namespace 创建子进程前可能是空链接。",
    },
    {
      id: "w1-1-q6",
      question: "当 namespace 内已没有成员进程时，怎样才能“pin”住它使其继续存在？",
      options: [
        "保持 /proc/<pid>/ns/* 的打开 fd 或对其做 bind mount",
        "删除 /proc/<pid>/ns/* 以阻止回收",
        "把 /proc 重新挂载为只读",
        "发送 SIGSTOP 给 init",
      ],
      answer: 0,
      rationale: "namespaces(7) 提到：打开 fd 或 bind mount /proc/<pid>/ns/* 会保持对应 namespace 的引用从而不被回收。",
    },
    {
      id: "w1-1-q7",
      question: "以下哪一项不会导致一个没有成员进程的 namespace 仍然存活（被 pin 住）？",
      options: [
        "存在指向 /proc/<pid>/ns/* 的打开 fd",
        "该 PID namespace 仍被一个 proc 文件系统挂载引用",
        "该 user namespace 拥有（owns）某个非 user namespace",
        "关闭所有终端会话（TTY）",
      ],
      answer: 3,
      rationale: "namespaces(7) 的“Namespace lifetime”列举了多种 pin 因素；TTY 会话状态不是其中之一。",
    },
    {
      id: "w1-1-q8",
      question: "namespaces(7) 中 /proc/sys/user 目录下的 max_*_namespaces 文件主要用于？",
      options: [
        "限制每个用户在当前 user namespace 下可创建的各类 namespace 数量；超限时 clone/unshare 失败并返回 ENOSPC",
        "列出当前系统所有 namespace 的 inode 列表",
        "修改后会立即删除已存在的 namespace",
        "只对 UID 0 生效",
      ],
      answer: 0,
      rationale: "namespaces(7) 说明 /proc/sys/user/max_*_namespaces 是 per-user 限制，触发时 clone/unshare 返回 ENOSPC。",
    },
    {
      id: "w1-1-q9",
      question: "namespaces(7) 提到，读取 /proc/<pid>/ns/* 符号链接的权限主要受什么机制影响？",
      options: [
        "ptrace 的访问模式检查（PTRACE_MODE_READ_FSCREDS）",
        "必须先关闭 SELinux",
        "必须在同一个 mount namespace",
        "仅与文件权限位（rwx）有关",
      ],
      answer: 0,
      rationale: "namespaces(7) 指出 dereference/readlink 这些链接受 ptrace 的访问模式检查约束。",
    },
    {
      id: "w1-1-q10",
      question: "执行 `unshare -Ur` 的典型结果是？",
      options: [
        "创建新的 user namespace（-U），并把调用者映射为新 userns 内的 root（-r）",
        "创建新的 UTS namespace 并修改 hostname",
        "加入一个已存在的 user namespace",
        "创建新的 PID namespace 并让当前进程 PID 变为 1",
      ],
      answer: 0,
      rationale: "unshare(1) 的 -U 创建 user namespace，-r 将调用者映射为新 userns 内的 root（但不等于宿主机 root）。",
    },
    {
      id: "w1-1-q11",
      question: "namespaces(7) 提到的 `/proc/sys/user` 目录从哪个内核版本开始提供？",
      options: ["Linux 3.8", "Linux 4.9", "Linux 5.7", "Linux 6.8"],
      answer: 1,
      rationale: "namespaces(7) 说明：/proc/sys/user 目录自 Linux 4.9 起提供，用于暴露各类 namespace 创建上限。",
    },
    {
      id: "w1-1-q12",
      question: "要限制每个用户可创建的 Mount namespaces 数量，应调整哪个 sysctl 文件？",
      options: ["/proc/sys/user/max_mnt_namespaces", "/proc/sys/user/max_mount_namespaces", "/proc/sys/user/max_fs_namespaces", "/proc/sys/user/max_vfs_namespaces"],
      answer: 0,
      rationale: "namespaces(7) 在 /proc/sys/user 列表中明确给出 max_mnt_namespaces。",
    },
    {
      id: "w1-1-q13",
      question: "关于 `/proc/sys/user/max_*_namespaces` 的“per-user limit”，namespaces(7) 的解释是？",
      options: [
        "同一 user namespace 内，每个用户可分别创建 namespace 直到达到该上限",
        "整个系统共享同一个计数器，达到上限后任何人都不能创建",
        "只有 UID 0 受限制，普通用户不受限制",
        "只对 systemd 管理的进程生效",
      ],
      answer: 0,
      rationale: "namespaces(7) 指出 limits are per-user：同一 user namespace 内，每个用户各自受限。",
    },
    {
      id: "w1-1-q14",
      question: "namespaces(7) 对 `/proc/sys/user/max_*_namespaces` 的说明中，哪项是正确的？",
      options: ["这些限制对所有用户生效，包括 UID 0", "仅对非 root 用户生效", "仅对容器内用户生效", "只对 Network namespace 生效"],
      answer: 0,
      rationale: "namespaces(7) 明确：These limits apply to all users, including UID 0。",
    },
    {
      id: "w1-1-q15",
      question: "namespaces(7) 指出，进程读到的 `/proc/sys/user/max_*_namespaces` 值属于哪个 user namespace？",
      options: [
        "打开该文件的进程所在的 user namespace",
        "永远是 initial user namespace",
        "永远是宿主机的 user namespace",
        "由 PID namespace 决定",
      ],
      answer: 0,
      rationale: "namespaces(7) 说明：这些文件暴露的是 opening process 所在 user namespace 的限制。",
    },
    {
      id: "w1-1-q16",
      question: "当达到 `/proc/sys/user/max_*_namespaces` 上限时，clone(2)/unshare(2) 典型会返回哪个错误？",
      options: ["ENOSPC", "EACCES", "EINVAL", "EEXIST"],
      answer: 0,
      rationale: "namespaces(7) 指出：遇到这些限制时 clone(2) 与 unshare(2) 会以 ENOSPC 失败。",
    },
    {
      id: "w1-1-q17",
      question: "namespaces(7) 提到 initial user namespace 中 `/proc/sys/user/max_*_namespaces` 的默认值通常与什么有关？",
      options: [
        "约等于 `/proc/sys/kernel/threads-max` 的一半",
        "固定为 1024",
        "固定为 MAXINT",
        "等于 CPU 核数",
      ],
      answer: 0,
      rationale: "namespaces(7) 说明：initial user namespace 默认值为 threads-max 的一半。",
    },
    {
      id: "w1-1-q18",
      question: "namespaces(7) 提到 descendant user namespaces 中 `/proc/sys/user/max_*_namespaces` 的默认值通常是？",
      options: ["MAXINT", "threads-max 的一半", "0（默认禁止）", "由 systemd 动态计算"],
      answer: 0,
      rationale: "namespaces(7) 指出：在所有 descendant user namespaces 中，默认值为 MAXINT。",
    },
    {
      id: "w1-1-q19",
      question: "namespaces(7) 的“accounted against ancestor namespaces”含义更接近哪项？",
      options: [
        "创建 namespace 会同时计入祖先 user namespaces 的配额，从而避免用创建新 user namespace 逃逸限制",
        "创建 namespace 只计入当前 user namespace，不会影响祖先",
        "创建 namespace 只计入 PID namespace，与 user namespace 无关",
        "创建 namespace 后会自动提升进程权限",
      ],
      answer: 0,
      rationale: "namespaces(7) 指出创建会计入祖先 user namespaces，确保无法用新 userns 绕过已有限制。",
    },
    {
      id: "w1-1-q20",
      question: "namespaces(7) 中哪种 namespace 被称为 hierarchical（层级型）namespace？",
      options: ["PID 或 User namespace", "Network namespace", "Mount namespace", "UTS namespace"],
      answer: 0,
      rationale: "namespaces(7) 在 Namespace lifetime 部分举例说明 hierarchical namespaces 包括 PID 与 user。",
    },
    {
      id: "w1-1-q21",
      question: "namespaces(7) 提到，以下哪项可能 pin 住一个 IPC namespace（即使其中已无成员进程）？",
      options: ["存在一个 mqueue 文件系统挂载引用该 IPC namespace", "宿主机打开了一个 TCP 监听端口", "有进程在其它 user namespace 中运行", "系统启用了 swap"],
      answer: 0,
      rationale: "namespaces(7) 的 Namespace lifetime 列表包含：IPC namespace 可能被 mqueue 文件系统挂载引用而存活。",
    },
    {
      id: "w1-1-q22",
      question: "namespaces(7) 提到，以下哪项可能 pin 住一个 PID namespace（即使其中已无成员进程）？",
      options: ["存在一个 proc(5) 文件系统挂载引用该 PID namespace", "容器使用 hostNetwork", "禁用 ptrace", "开启 cgroup v2 io 控制器"],
      answer: 0,
      rationale: "namespaces(7) 的 Namespace lifetime 列表包含：PID namespace 可能被对应的 proc(5) 挂载引用。",
    },
    {
      id: "w1-1-q23",
      question: "在 `/proc/<pid>/ns/` 目录中，哪个条目代表“该进程未来创建的子进程所处的 PID namespace”？",
      options: ["pid_for_children", "pid", "net", "mnt"],
      answer: 0,
      rationale: "namespaces(7) 说明：pid_for_children 表示子进程的 PID namespace，可能随 unshare/setns 改变。",
    },
    {
      id: "w1-1-q24",
      question: "`ls -l /proc/$$/ns` 输出里常见的 `net:[4026531969]` 这种格式中，方括号内的数字最接近什么含义？",
      options: ["namespace 的内核对象标识（inode 号）", "该 namespace 内的最大 PID", "网卡数量", "cgroup 层级深度"],
      answer: 0,
      rationale: "namespaces(7) 的示例输出把 /proc/pid/ns/* 展示为 `type:[inode]`，用于区分不同 namespace 对象。",
    },
    {
      id: "w1-1-q25",
      question: "namespaces(7) 总结的 namespaces API 中，除 /proc 文件外包含哪些系统调用？",
      options: ["clone(2) / setns(2) / unshare(2) / ioctl(2)", "fork(2) / execve(2) / wait(2) / kill(2)", "mount(2) / umount(2) / chroot(2) / pivot_root(2)", "socket(2) / bind(2) / connect(2) / accept(2)"],
      answer: 0,
      rationale: "namespaces(7) 在 The namespaces API 部分列出 clone(2)、setns(2)、unshare(2) 与 ioctl_nsfs(2)。",
    },
    {
      id: "w1-1-q26",
      question: "Namespaces compatibility list 文档提示：为何不应把 IPCID/pgid 这类“namespace 内 ID”暴露给不同 namespace 的任务？",
      options: [
        "该 ID 只在获取它的 namespace 内有效，在另一个 namespace 可能指向完全不同的对象",
        "因为会导致内核立刻崩溃",
        "因为这些 ID 一定是全局唯一且可移植",
        "因为暴露 ID 会自动打破 user namespace 隔离",
      ],
      answer: 0,
      rationale: "compatibility-list 指出：IPC/PID 提供的 ID 只在各自 namespace 内有效，跨 namespace 暴露可能引用到别的对象。",
    },
    {
      id: "w1-1-q27",
      question: "Namespaces compatibility list 文档的第 2 点强调：不同 user namespaces 内数值相同的 UID，从 VFS 权限视角应当如何对待？",
      options: [
        "不应被视为同一个用户，访问权限不应等价",
        "应当被视为同一个用户，权限完全等价",
        "只要 GID 不同就没有风险",
        "只影响网络访问，不影响文件权限",
      ],
      answer: 0,
      rationale: "compatibility-list 指出：相同 UID 在不同 user namespaces 中从 VFS 角度不应等价，否则会造成权限语义混乱。",
    },
    {
      id: "w1-1-q28",
      question: "Namespaces compatibility list 文档指出的一个已知问题是？",
      options: [
        "当共享 IPC namespace 时，不同 user namespaces 的用户可能仍能访问相同 IPC 对象（即便 UID 数值相同也不应等价）",
        "共享 Net namespace 会让 CPU 限制失效",
        "共享 UTS namespace 会导致文件系统只读",
        "共享 Mount namespace 会让 PID namespace 被删除",
      ],
      answer: 0,
      rationale: "compatibility-list 的第 2 点说明了这种“不应等价但目前仍可能等价”的问题，涉及共享 IPC namespace 的场景。",
    },
    {
      id: "w1-1-q29",
      question: "《User namespaces and resource control》文档建议：启用 user namespaces 的系统应优先启用哪类 cgroup 来缓解资源滥用风险？",
      options: ["memory control groups（内存控制）", "net_cls（网络分类）", "freezer（冻结）", "rdma（RDMA 限制）"],
      answer: 0,
      rationale: "resource-control 文档建议管理员启用 memory control groups，并配置上限以限制不可信用户的最大内存使用。",
    },
    {
      id: "w1-1-q30",
      question: "《User namespaces and resource control》文档提到的一种配置思路是安装 libcgroup 并配置哪些内容？",
      options: [
        "编辑 /etc/cgrules.conf 与 /etc/cgconfig.conf，并设置 libpam-cgroup",
        "仅编辑 /etc/hosts",
        "仅修改 grub 启动参数",
        "只需重启 docker 服务即可",
      ],
      answer: 0,
      rationale: "resource-control 文档给出示例：可通过 libcgroup 包并配置 /etc/cgrules.conf、/etc/cgconfig.conf 以及 libpam-cgroup。",
    },
  ],
  // Week 16
  "w16-1": [
    {
      id: "w16-1-q1",
      question: "使用 etcdctl 需注意设置什么环境变量？",
      options: [
        "ETCDCTL_API=3，确保使用 v3 API",
        "KUBECONFIG",
        "PATH",
        "ETCDCTL_USE_V2",
      ],
      answer: 0,
      rationale: "etcd 备份/恢复官方示例要求显式设置 API 版本。",
    },
    {
      id: "w16-1-q2",
      question: "创建快照的命令示例？",
      options: [
        "etcdctl --endpoints=https://127.0.0.1:2379 --cacert=... --cert=... --key=... snapshot save backup.db",
        "etcdctl backup",
        "kubectl get etcd",
        "tar /var/lib/etcd",
      ],
      answer: 0,
      rationale: "官方指南使用 snapshot save 并提供证书与端点。",
    },
    {
      id: "w16-1-q3",
      question: "恢复 snapshot 时必须做什么？",
      options: [
        "使用 snapshot restore 到新的数据目录，并更新启动参数指向该目录",
        "直接覆盖旧数据目录并启动",
        "无需停止集群",
        "在运行中的 etcd 执行恢复",
      ],
      answer: 0,
      rationale: "恢复需离线，使用 restore 生成新 data-dir，再以新目录启动。",
    },
    {
      id: "w16-1-q4",
      question: "多节点 etcd 集群恢复后的 cluster-token/initial-cluster 配置应？",
      options: [
        "使用新的 token/cluster 配置，避免与旧集群产生冲突",
        "保持不变",
        "无需配置",
        "使用随机端口",
      ],
      answer: 0,
      rationale: "恢复新集群需更新集群标识，防止成员 ID 冲突。",
    },
    {
      id: "w16-1-q5",
      question: "如何验证 snapshot 完整性？",
      options: [
        "etcdctl snapshot status backup.db",
        "直接打开文件",
        "kubectl get secrets",
        "没有办法验证",
      ],
      answer: 0,
      rationale: "snapshot status 显示快照信息/校验。",
    },
    {
      id: "w16-1-q6",
      question: "Kubernetes Master 节点 etcd 数据目录默认位置？",
      options: [
        "/var/lib/etcd",
        "/etc/kubernetes/pki",
        "/var/log/etcd",
        "/opt/etcd",
      ],
      answer: 0,
      rationale: "kubeadm 默认 etcd 数据目录在 /var/lib/etcd。",
    },
    {
      id: "w16-1-q7",
      question: "从备份恢复到单节点测试环境的步骤包括？",
      options: [
        "停止 kube-apiserver/etcd -> restore 到新目录 -> 修改静态 Pod 清单使用新目录 -> 重启",
        "直接删除 kubelet",
        "仅重启 kube-proxy",
        "使用 kubectl apply backup.db",
      ],
      answer: 0,
      rationale: "官方 CKA 考点演示了离线恢复需要修改静态 Pod 清单。",
    },
    {
      id: "w16-1-q8",
      question: "快照跨版本兼容性注意？",
      options: [
        "主要兼容相邻小版本，跨大版本需谨慎并遵循发布说明",
        "完全兼容任何版本",
        "不可恢复",
        "只要同一云厂商即可",
      ],
      answer: 0,
      rationale: "etcd 建议同版本或兼容范围内恢复。",
    },
    {
      id: "w16-1-q9",
      question: "查看集群成员信息的命令？",
      options: [
        "etcdctl member list",
        "kubectl get etcd",
        "kubectl get nodes",
        "etcdctl peers",
      ],
      answer: 0,
      rationale: "member list 显示成员 ID/状态，恢复时常用。",
    },
    {
      id: "w16-1-q10",
      question: "为何建议定期做 etcd 备份？",
      options: [
        "防止数据损坏/误操作，快速恢复控制平面",
        "为了扩容节点",
        "减少日志",
        "提高 HPA 精度",
      ],
      answer: 0,
      rationale: "etcd 持有集群状态，备份是灾备关键环节。",
    },
  ],
  "w16-2": [
    {
      id: "w16-2-q1",
      question: "Pod 被标记 OOMKilled 的常见原因？",
      options: [
        "容器内存使用超过 limit，内核 OOM 杀死进程",
        "磁盘不足",
        "CPU 使用过低",
        "镜像不存在",
      ],
      answer: 0,
      rationale: "OOMKilled 由内核/容器 runtime 触发，通常因内存限制。",
    },
    {
      id: "w16-2-q2",
      question: "排查 OOMKilled 时应查看？",
      options: [
        "kubectl describe pod 事件、容器内存请求/限制、应用日志",
        "kube-proxy 日志",
        "仅节点数量",
        "etcd 证书",
      ],
      answer: 0,
      rationale: "描述信息与资源配置是首要线索。",
    },
    {
      id: "w16-2-q3",
      question: "CrashLoopBackOff 常见原因？",
      options: [
        "容器启动后立即退出（配置缺失、探针失败、依赖不可用等）",
        "镜像拉取失败",
        "节点宕机",
        "网络策略生效",
      ],
      answer: 0,
      rationale: "重复崩溃触发退避，需检查日志/探针/依赖。",
    },
    {
      id: "w16-2-q4",
      question: "排查 CrashLoopBackOff 的技巧？",
      options: [
        "kubectl logs --previous / 使用 sleep 包装启动 / 启用临时容器调试",
        "只看事件",
        "删除 Pod 即可",
        "修改 kube-proxy",
      ],
      answer: 0,
      rationale: "可查看前次日志或使用临时容器进入环境排查。",
    },
    {
      id: "w16-2-q5",
      question: "ImagePullBackOff 的主要原因？",
      options: [
        "镜像不存在/名称错误、私有仓库认证失败、网络不可达",
        "Pod 配额超限",
        "节点时间不同步",
        "Service 未创建",
      ],
      answer: 0,
      rationale: "事件中通常显示 ErrImagePull，需检查镜像/凭证/网络。",
    },
    {
      id: "w16-2-q6",
      question: "调试 ImagePullBackOff 的首要步骤？",
      options: [
        "kubectl describe pod 查看事件并验证 image/secret/registry 可达",
        "重启 API Server",
        "扩容节点",
        "修改 Deployment 名称",
      ],
      answer: 0,
      rationale: "事件信息指明拉取失败原因，如 401/404/timeout。",
    },
    {
      id: "w16-2-q7",
      question: "节点资源压力导致的驱逐现象？",
      options: [
        "Pod 状态显示 Evicted/Terminating，事件包含内存/磁盘压力",
        "显示 Running",
        "变为 Completed",
        "ImagePullBackOff",
      ],
      answer: 0,
      rationale: "kubelet 在压力下可能驱逐低优先级 Pod。",
    },
    {
      id: "w16-2-q8",
      question: "查看集群事件时间序列的命令？",
      options: [
        "kubectl get events --sort-by=.metadata.creationTimestamp",
        "kubectl logs kubelet",
        "kubectl top pods",
        "kubectl describe node",
      ],
      answer: 0,
      rationale: "排序事件有助于定位故障发生顺序。",
    },
    {
      id: "w16-2-q9",
      question: "镜像拉取私有仓库需确保？",
      options: [
        "imagePullSecret 已绑定，节点可访问 registry，证书/域名正确",
        "Pod 使用 hostNetwork",
        "节点有 GPU",
        "禁用 HPA",
      ],
      answer: 0,
      rationale: "认证/网络/证书问题常导致 ErrImagePull。",
    },
    {
      id: "w16-2-q10",
      question: "kubelet 日志在故障排查中的作用？",
      options: [
        "可提供调度/拉取/探针/驱逐等节点侧的详细错误信息",
        "无任何作用",
        "只记录 CPU 使用率",
        "仅记录网络策略",
      ],
      answer: 0,
      rationale: "节点侧日志有助于深入理解 Pod 失败原因。",
    },
  ],
  "w16-3": [
    {
      id: "w16-3-q1",
      question: "CKA 与 CKAD 的定位差异？",
      options: [
        "CKA 偏集群管理/运维/故障排查，CKAD 偏应用设计/开发",
        "两者相同",
        "CKA 仅考 Helm",
        "CKAD 只考网络",
      ],
      answer: 0,
      rationale: "官方考纲区分管理与应用侧技能。",
    },
    {
      id: "w16-3-q2",
      question: "考试形式是什么？",
      options: [
        "在线监考的实操命令行任务，需要在规定时间内完成",
        "选择题",
        "开放式论文",
        "线下笔试",
      ],
      answer: 0,
      rationale: "CKA/CKAD 皆为动手操作题。",
    },
    {
      id: "w16-3-q3",
      question: "官方允许的资料？",
      options: [
        "可访问 kubernetes.io/docs 和 GitHub 官方仓库（只读）",
        "可访问互联网任意网站",
        "必须离线",
        "可携带纸质资料",
      ],
      answer: 0,
      rationale: "考试允许查阅官方文档，禁止其他网站。",
    },
    {
      id: "w16-3-q4",
      question: "高效答题的技巧？",
      options: [
        "使用 kubectl 别名/自动补全、模板文件、先做高分题、保存关键命令历史",
        "逐题完整阅读手册后再做",
        "不需要规划时间",
        "全部使用 GUI",
      ],
      answer: 0,
      rationale: "时间管理与命令熟练度是通过考试关键。",
    },
    {
      id: "w16-3-q5",
      question: "考试环境切换集群的方式？",
      options: [
        "题目提供的 context 切换命令，或使用 kubectl config use-context <ctx>",
        "修改 /etc/hosts",
        "重启节点",
        "更换 kubelet",
      ],
      answer: 0,
      rationale: "每题可能有不同 context，需要正确切换。",
    },
    {
      id: "w16-3-q6",
      question: "为什么掌握命令式创建对象有帮助？",
      options: [
        "可快速生成 YAML 骨架（kubectl create/Run --dry-run=client -o yaml）节省时间",
        "考试禁止 YAML",
        "只能使用 GUI",
        "与考试无关",
      ],
      answer: 0,
      rationale: "命令式生成模板再编辑是提速常见技巧。",
    },
    {
      id: "w16-3-q7",
      question: "CKA/CKAD 时间/题量（以最新官方为准）通常是？",
      options: [
        "约 2 小时，十余道实操任务",
        "30 分钟，3 道题",
        "一整天",
        "无固定时间",
      ],
      answer: 0,
      rationale: "目前考试时长约 2 小时左右，题目数量十几道。",
    },
    {
      id: "w16-3-q8",
      question: "考场常见失分点？",
      options: [
        "忘记切 context/命名空间、未保存 YAML、覆盖现有资源、时间分配不均",
        "不会写代码",
        "网络不通",
        "缺少浏览器",
      ],
      answer: 0,
      rationale: "操作细节易出错，需谨慎检查。",
    },
    {
      id: "w16-3-q9",
      question: "练习资源推荐？",
      options: [
        "官方考纲任务、killer.sh/CKA 模拟环境、Kind/Minikube 本地练习",
        "仅阅读文档",
        "生产环境练习",
        "无可用资源",
      ],
      answer: 0,
      rationale: "实践练习是通过考试的关键。",
    },
    {
      id: "w16-3-q10",
      question: "CKA vs CKAD 通过分数？",
      options: [
        "需达到官方规定的及格线（通常 66% 左右，具体以当前公告为准）",
        "必须 100%",
        "只要提交即通过",
        "由考官主观评定",
      ],
      answer: 0,
      rationale: "考试有明确的通过分数线，以官方发布为准。",
    },
  ],
  "w16-4": [
    {
      id: "w16-4-q1",
      question: "构建个人云原生技能树的要点？",
      options: [
        "覆盖基础（容器/网络/存储）→ 编排/服务治理 → 安全/观测 → 自动化/IaC",
        "只学一种工具",
        "只看文档不实践",
        "随意排列",
      ],
      answer: 0,
      rationale: "体系化技能树有助于持续成长与复习。",
    },
    {
      id: "w16-4-q2",
      question: "作品集/简历中可展示什么？",
      options: [
        "实战项目、实验仓库、故障复盘、开源贡献、自动化脚本",
        "仅列出课程名称",
        "只写兴趣爱好",
        "不需要展示",
      ],
      answer: 0,
      rationale: "可量化的产出/代码仓库能证明能力。",
    },
    {
      id: "w16-4-q3",
      question: "与社区互动的方式？",
      options: [
        "参与 CNCF/项目 Issue/PR、KubeCon/Meetup、答疑分享",
        "只在内部群聊",
        "保持沉默",
        "关闭邮件",
      ],
      answer: 0,
      rationale: "社区参与能获取最新实践并建立人脉。",
    },
    {
      id: "w16-4-q4",
      question: "面试前的复盘重点？",
      options: [
        "梳理项目场景、技术决策、问题排查案例以及量化结果",
        "只背诵命令",
        "完全不准备",
        "只看八股",
      ],
      answer: 0,
      rationale: "具体案例与结果更能体现经验。",
    },
    {
      id: "w16-4-q5",
      question: "保持学习节奏的建议？",
      options: [
        "定期练习/写笔记/复盘错题，结合实战小项目迭代",
        "只在考试前突击",
        "每天更换方向",
        "依赖运气",
      ],
      answer: 0,
      rationale: "持续实践和复盘才能固化知识。",
    },
    {
      id: "w16-4-q6",
      question: "在团队推广云原生实践时，首要步骤？",
      options: [
        "从小范围 PoC/自动化脚本开始，度量收益后再逐步推广",
        "一次性全量替换",
        "忽略现有流程",
        "只做文档",
      ],
      answer: 0,
      rationale: "渐进式落地更易获得支持并降低风险。",
    },
    {
      id: "w16-4-q7",
      question: "面向生产运维应关注哪些指标？",
      options: [
        "稳定性（SLO/可用性）、成本、性能、安全合规",
        "只关注代码风格",
        "只关注节点数量",
        "只关注镜像大小",
      ],
      answer: 0,
      rationale: "生产环境需综合考虑可用性/成本/安全等目标。",
    },
    {
      id: "w16-4-q8",
      question: "如何规划后续深度学习路线？",
      options: [
        "根据兴趣/岗位选择专项（安全/数据面/运维/SRE），结合开源项目实践",
        "随机学习",
        "只做练习题",
        "完全停下学习",
      ],
      answer: 0,
      rationale: "定向深入 + 实践有助于成为领域专家。",
    },
    {
      id: "w16-4-q9",
      question: "在项目中沉淀知识的方式？",
      options: [
        "编写 Runbook/Playbook、自动化脚本、最佳实践文档",
        "仅口头传达",
        "完全不记录",
        "依赖第三方博客",
      ],
      answer: 0,
      rationale: "可复用的文档和工具能提升团队效率。",
    },
    {
      id: "w16-4-q10",
      question: "持续提升软技能的建议？",
      options: [
        "练习复盘表达/沟通，学会将技术影响转化为业务价值",
        "只写代码不交流",
        "避免分享",
        "忽略反馈",
      ],
      answer: 0,
      rationale: "沟通与复盘能力是工程师成长的重要部分。",
    },
  ],
  // Week 15
  "w15-1": [
    {
      id: "w15-1-q1",
      question: "Horizontal Pod Autoscaler (HPA) 的工作原理？",
      options: [
        "基于指标（CPU/内存/自定义/外部）计算期望副本数并调整 Deployment/ReplicaSet",
        "直接创建节点",
        "修改 Service",
        "仅按时间表扩容",
      ],
      answer: 0,
      rationale: "HPA 通过 Metrics API 获取指标计算 desired replicas。",
    },
    {
      id: "w15-1-q2",
      question: "Cluster Autoscaler 的职责是？",
      options: [
        "根据不可调度的 Pod 自动扩容/缩容节点（云提供商节点组）",
        "调度 Pod",
        "管理镜像仓库",
        "执行滚动更新",
      ],
      answer: 0,
      rationale: "CA 监控 pending Pod 与利用率，调整节点池。",
    },
    {
      id: "w15-1-q3",
      question: "HPA 依赖的默认数据源？",
      options: [
        "metrics-server 提供的资源指标 API",
        "kube-proxy",
        "etcd",
        "Prometheus 必须",
      ],
      answer: 0,
      rationale: "资源指标来自 metrics-server；自定义指标需额外适配器。",
    },
    {
      id: "w15-1-q4",
      question: "为什么正确设置 Pod requests 很重要？",
      options: [
        "HPA 计算 CPUUtilization 基于 requests，错误的 requests 会导致扩缩容不准",
        "只影响限流",
        "与 HPA 无关",
        "只影响节点标签",
      ],
      answer: 0,
      rationale: "利用率基于请求值，requests 失真会误导 HPA。",
    },
    {
      id: "w15-1-q5",
      question: "HPA 防抖机制是什么？",
      options: [
        "stabilizationWindowSeconds/cooldown，防止频繁伸缩",
        "通过重启 Pod",
        "依赖 PDB",
        "暂停 HPA",
      ],
      answer: 0,
      rationale: "HPA 提供稳定窗口与增减速率限制。",
    },
    {
      id: "w15-1-q6",
      question: "自定义指标 HPA 需要什么组件？",
      options: [
        "自定义/外部指标适配器（如 Prometheus Adapter）提供 metrics API",
        "只需要 metrics-server",
        "必须修改 kubelet",
        "使用 ConfigMap",
      ],
      answer: 0,
      rationale: "Adapter 将外部指标暴露为 custom.metrics.k8s.io API。",
    },
    {
      id: "w15-1-q7",
      question: "Cluster Autoscaler 缩容前会考虑？",
      options: [
        "PodDisruptionBudget、Pod 优先级、是否可在其他节点调度",
        "只看 CPU 使用率",
        "只看节点名称",
        "忽略 PDB",
      ],
      answer: 0,
      rationale: "CA 避免驱逐受 PDB/不可迁移的 Pod。",
    },
    {
      id: "w15-1-q8",
      question: "HPA 与 CA 的协同方式？",
      options: [
        "HPA 增加副本可能导致 Pod Pending，CA 观察到后扩容节点",
        "两者无关联",
        "CA 控制 Pod 数量",
        "HPA 控制节点数量",
      ],
      answer: 0,
      rationale: "HPA 负责 Pod 层，CA 负责节点层，协作满足资源需求。",
    },
    {
      id: "w15-1-q9",
      question: "水平扩缩容的最小/最大副本由谁定义？",
      options: [
        "HPA spec.minReplicas/maxReplicas",
        "Deployment replicas",
        "kube-scheduler",
        "Service 配置",
      ],
      answer: 0,
      rationale: "HPA 资源定义 min/max 范围。",
    },
    {
      id: "w15-1-q10",
      question: "常见的扩容指标选择建议是？",
      options: [
        "选择与用户体验直接相关的指标（如 QPS、延迟、自定义业务指标），并配合资源指标",
        "只看节点数",
        "仅依赖内存",
        "不需要指标",
      ],
      answer: 0,
      rationale: "业务+系统指标结合能更准确反映负载。",
    },
  ],
  "w15-2": [
    {
      id: "w15-2-q1",
      question: "Knative Serving 的核心资源包含？",
      options: [
        "Service、Route、Configuration、Revision",
        "Deployment、Service、Pod",
        "Job、CronJob",
        "Ingress、Endpoint",
      ],
      answer: 0,
      rationale: "Serving 使用四个 CRD 管理无服务器工作负载与修订。",
    },
    {
      id: "w15-2-q2",
      question: "为什么 Knative 能实现 Scale-to-Zero？",
      options: [
        "Knative Pod Autoscaler (KPA) 基于并发/请求率，Activator 可在无流量时缩到 0 并缓冲新请求",
        "依赖 HPA 仅基于 CPU",
        "通过删除 Deployment",
        "需要手动缩容",
      ],
      answer: 0,
      rationale: "KPA + Activator 支持零流量缩容与冷启动缓冲。",
    },
    {
      id: "w15-2-q3",
      question: "每次配置/镜像变更会生成什么？",
      options: [
        "新的 Revision（不可变），Route 可路由到不同 Revision",
        "覆盖旧 Revision",
        "仅更新 Deployment",
        "更新 Node",
      ],
      answer: 0,
      rationale: "Revision 表示不可变版本，便于流量切分与回滚。",
    },
    {
      id: "w15-2-q4",
      question: "默认网络层实现可以是？",
      options: [
        "Kourier（默认）、Istio、Contour 等",
        "仅 kube-proxy",
        "只能使用 Nginx",
        "必须使用 MetalLB",
      ],
      answer: 0,
      rationale: "Knative 支持多种 Ingress 实现，默认常用 Kourier。",
    },
    {
      id: "w15-2-q5",
      question: "并发度配置使用哪个注解？",
      options: [
        "autoscaling.knative.dev/target 或 container-concurrency",
        "hpa.autoscaling/scale",
        "deployment.kubernetes.io/concurrency",
        "ingress.knative.dev/concurrency",
      ],
      answer: 0,
      rationale: "Knative 可通过 annotations/containerConcurrency 控制每 Pod 并发。",
    },
    {
      id: "w15-2-q6",
      question: "冷启动的影响？",
      options: [
        "从 0 扩容时需要拉起 Pod，会增加首请求延迟",
        "无任何影响",
        "只影响日志",
        "只在 HPA 中出现",
      ],
      answer: 0,
      rationale: "Scale-to-zero 会带来冷启动延迟，需优化镜像/并发缓冲。",
    },
    {
      id: "w15-2-q7",
      question: "Knative Service 默认访问域名格式？",
      options: [
        "<service>.<namespace>.<domain>（由域名配置决定）",
        "固定为 example.com",
        "使用 Pod IP",
        "需要手工配置 DNS 记录",
      ],
      answer: 0,
      rationale: "Knative 会根据域配置生成子域。",
    },
    {
      id: "w15-2-q8",
      question: "自动/手动切流量的方式？",
      options: [
        "在 Route/Service spec 中设置 traffic 百分比到不同 Revision",
        "只能全量切换",
        "通过 HPA",
        "通过 NodePort",
      ],
      answer: 0,
      rationale: "Route 支持按百分比或标签路由到各个 Revision。",
    },
    {
      id: "w15-2-q9",
      question: "Knative Serving 依赖的自动扩缩容类注解有哪些？",
      options: [
        "autoscaling.knative.dev/class（kpa/hpa）、metric、target、minScale/maxScale",
        "podDisruptionBudget",
        "deployment.kubernetes.io/revision",
        "networking.knative.dev/ingress",
      ],
      answer: 0,
      rationale: "Knative 支持 KPA/HPA 类与指标、最小/最大副本注解。",
    },
    {
      id: "w15-2-q10",
      question: "Knative 的 CLI/CRD 观察命令示例？",
      options: [
        "kubectl get ksvc, revisions, routes",
        "kubectl get deployment",
        "helm list",
        "istioctl proxy-status",
      ],
      answer: 0,
      rationale: "Knative 定义了 ksvc/route/configuration/revision CRD，可通过 kubectl 查看。",
    },
  ],
  "w15-3": [
    {
      id: "w15-3-q1",
      question: "Knative Eventing 中 Broker 的作用？",
      options: [
        "作为事件入口/分发枢纽，结合 Trigger 做过滤和路由",
        "存储镜像",
        "控制 HPA",
        "生成日志",
      ],
      answer: 0,
      rationale: "Broker 接收事件并交给 Trigger 转发到 Sink。",
    },
    {
      id: "w15-3-q2",
      question: "Trigger 过滤依据是什么？",
      options: [
        "根据 CloudEvents 属性（type/source/subject 等）匹配，将事件送到指定 Sink",
        "根据 Pod 标签",
        "根据节点",
        "随机发送",
      ],
      answer: 0,
      rationale: "Trigger 使用属性过滤将事件路由到 Knative Service 等。",
    },
    {
      id: "w15-3-q3",
      question: "CloudEvents 规范中的必需属性包括？",
      options: [
        "id、source、type、specversion（可选 subject/time 等）",
        "host、user-agent",
        "namespace、name",
        "checksum",
      ],
      answer: 0,
      rationale: "CloudEvents 定义通用事件元数据。",
    },
    {
      id: "w15-3-q4",
      question: "常见事件源（Source）示例？",
      options: [
        "ApiServerSource、PingSource、KafkaSource 等",
        "Deployment",
        "Service",
        "Node",
      ],
      answer: 0,
      rationale: "Knative 提供多种 Source CRD 接入外部事件。",
    },
    {
      id: "w15-3-q5",
      question: "Channel/Subscription 模型的用途？",
      options: [
        "实现可插拔的中间件（如 Kafka）提供事件持久化/扇出",
        "控制 CPU 使用",
        "配置 HPA",
        "管理域名",
      ],
      answer: 0,
      rationale: "Channel 抽象底层队列，Subscription 把事件送到订阅端。",
    },
    {
      id: "w15-3-q6",
      question: "DeliverySpec（重试/死信队列）配置在哪？",
      options: [
        "Broker/Trigger/Subscription 可设置 retry/backoff 与 deadLetterSink",
        "仅在 Service",
        "必须在 Deployment",
        "不能配置",
      ],
      answer: 0,
      rationale: "Knative 支持可配置的投递重试与死信处理。",
    },
    {
      id: "w15-3-q7",
      question: "Knative Eventing 中事件接收方称为？",
      options: ["Sink（通常是 Knative Service/URL）", "Node", "Ingress", "PodDisruptionBudget"],
      answer: 0,
      rationale: "Sink 是 Trigger/Subscription 投递目标。",
    },
    {
      id: "w15-3-q8",
      question: "CloudEvents HTTP 头的前缀是？",
      options: [
        "ce-（如 ce-type/ce-source/ce-id）",
        "x-cloud-",
        "k8s-",
        "cloudevent-",
      ],
      answer: 0,
      rationale: "CloudEvents 以 ce- 前缀携带属性。",
    },
    {
      id: "w15-3-q9",
      question: "为什么使用 Broker/Trigger 而非直接订阅？",
      options: [
        "提供中心化事件路由与过滤，简化多订阅者场景",
        "性能更差",
        "因为不支持 HTTP",
        "必须依赖 Kafka",
      ],
      answer: 0,
      rationale: "Broker/Trigger 解耦生产者/消费者，提供过滤与统一入口。",
    },
    {
      id: "w15-3-q10",
      question: "PingSource 的作用？",
      options: [
        "按定时触发 CloudEvents（cron 表达式），常用于心跳/测试",
        "监控节点",
        "创建 DNS",
        "执行 HPA",
      ],
      answer: 0,
      rationale: "PingSource 是内置定时事件源。",
    },
  ],
  "w15-4": [
    {
      id: "w15-4-q1",
      question: "Operator 模式的核心组成？",
      options: [
        "自定义资源（CRD）+ 控制器（Reconcile Loop）实现特定领域运维自动化",
        "仅 Deployment",
        "仅脚本",
        "只使用 Helm",
      ],
      answer: 0,
      rationale: "Operator 通过 CRD/Controller 实现知识编码。",
    },
    {
      id: "w15-4-q2",
      question: "Reconcile 的含义是？",
      options: [
        "持续对比期望状态（CR）与实际状态，执行必要操作达到收敛",
        "一次性执行",
        "只在错误时触发",
        "仅在启动时运行",
      ],
      answer: 0,
      rationale: "与 Kubernetes 控制器模式一致，Operator 自定义领域逻辑。",
    },
    {
      id: "w15-4-q3",
      question: "kubebuilder/operator-sdk 提供什么？",
      options: [
        "脚手架/代码生成/测试工具，加速 Operator 开发",
        "镜像仓库",
        "节点管理",
        "日志代理",
      ],
      answer: 0,
      rationale: "工具链生成 CRD/Controller 框架与样板代码。",
    },
    {
      id: "w15-4-q4",
      question: "自定义资源（CR）的作用域可以是？",
      options: [
        "Namespaced 或 Cluster 范围，取决于 CRD 定义",
        "仅 Namespaced",
        "仅 Cluster",
        "必须与 Deployment 同名",
      ],
      answer: 0,
      rationale: "CRD 支持两种 scope，需根据场景选择。",
    },
    {
      id: "w15-4-q5",
      question: "Operator 常见的运维自动化示例？",
      options: [
        "数据库备份/恢复、应用升级、伸缩、配置校验",
        "仅创建 ConfigMap",
        "只监控 CPU",
        "仅创建 Service",
      ],
      answer: 0,
      rationale: "Operator 将专业运维流程编程化。",
    },
    {
      id: "w15-4-q6",
      question: "与 Helm Chart 相比 Operator 的优势？",
      options: [
        "可编排有状态/有序操作并处理反馈（如备份/滚动升级），不仅是模板渲染",
        "部署更简单",
        "完全无代码",
        "不会访问 API Server",
      ],
      answer: 0,
      rationale: "Operator 可在运行时感知状态并执行复杂逻辑。",
    },
    {
      id: "w15-4-q7",
      question: "Controller Watch 的对象通常包括？",
      options: [
        "自定义资源本身以及相关的 Secrets/Deployments/Services 等依赖",
        "仅 CR 自身",
        "仅节点",
        "仅 Pod 日志",
      ],
      answer: 0,
      rationale: "控制器通常 watch 关联资源，触发 reconcile。",
    },
    {
      id: "w15-4-q8",
      question: "编写 Operator 时为什么要保证幂等？",
      options: [
        "reconcile 可能被频繁调用，幂等确保重复执行也能正确收敛",
        "为了加快速度",
        "避免创建 CR",
        "只为调试",
      ],
      answer: 0,
      rationale: "幂等是控制器模式的基本要求。",
    },
    {
      id: "w15-4-q9",
      question: "CRD 版本升级（v1alpha1->v1beta1）需要注意？",
      options: [
        "提供转换/存储版本，或使用 conversion webhook，更新 CR 示例",
        "无需任何处理",
        "删除所有 CR",
        "只能重新创建集群",
      ],
      answer: 0,
      rationale: "CRD 版本迁移需处理存储版本与转换。",
    },
    {
      id: "w15-4-q10",
      question: "Operator 运行时权限如何控制？",
      options: [
        "通过 RBAC 授予最小所需权限（Roles/ClusterRoles/Bindings）",
        "必须 cluster-admin",
        "无需 RBAC",
        "只要节点权限",
      ],
      answer: 0,
      rationale: "遵循最小权限原则，Operator 仅应访问必要资源。",
    },
  ],
  // Week 14
  "w14-1": [
    {
      id: "w14-1-q1",
      question: "4C 安全模型的层次分别是？",
      options: [
        "Cloud、Cluster、Container、Code",
        "CPU、Cache、Compiler、Code",
        "Client、Controller、Config、Code",
        "Cloud、Config、Cost、Cache",
      ],
      answer: 0,
      rationale: "NSA 等指南强调从云到代码的四层防护。",
    },
    {
      id: "w14-1-q2",
      question: "Pod Security Standards 的三个级别？",
      options: [
        "Privileged、Baseline、Restricted",
        "Admin、User、Guest",
        "High、Medium、Low",
        "None、Partial、Full",
      ],
      answer: 0,
      rationale: "K8s PSS 定义的安全基线与受限级别。",
    },
    {
      id: "w14-1-q3",
      question: "Restricted 模式通常禁止什么？",
      options: [
        "特权容器、hostNetwork/PID/IPC、rootfs 可写、提权能力等",
        "使用 ConfigMap",
        "使用 Service",
        "使用 Liveness 探针",
      ],
      answer: 0,
      rationale: "受限配置旨在最小化逃逸面。",
    },
    {
      id: "w14-1-q4",
      question: "NSA/CISA 指南强调的集群安全措施包括？",
      options: [
        "RBAC 最小权限、审计、NetworkPolicy、ETCD 加密、禁用匿名等",
        "关闭日志",
        "禁用 TLS",
        "所有组件运行为 root",
      ],
      answer: 0,
      rationale: "指南提供多项硬化建议覆盖控制面/节点。",
    },
    {
      id: "w14-1-q5",
      question: "镜像安全的基础做法？",
      options: [
        "使用最小化基础镜像、定期扫描、固定 tag/digest",
        "使用 latest 且不扫描",
        "在容器内下载依赖",
        "关闭健康检查",
      ],
      answer: 0,
      rationale: "镜像源与漏洞管理是容器层关键。",
    },
    {
      id: "w14-1-q6",
      question: "节点安全的常见措施？",
      options: [
        "限制 SSH、开启主机防火墙/SELinux/AppArmor、分离控制平面与工作节点",
        "允许任意 root 登录",
        "关闭 kubelet 认证",
        "禁用补丁更新",
      ],
      answer: 0,
      rationale: "硬化节点是 4C 模型中 Cluster/Cloud 层的重点。",
    },
    {
      id: "w14-1-q7",
      question: "为何建议开启 etcd 加密 Secret？",
      options: [
        "防止磁盘/备份泄露敏感数据",
        "减少 CPU",
        "提高调度速度",
        "改善网络延迟",
      ],
      answer: 0,
      rationale: "EncryptionConfiguration 可保护存储在 etcd 的敏感信息。",
    },
    {
      id: "w14-1-q8",
      question: "网络隔离的推荐做法？",
      options: [
        "使用 NetworkPolicy/防火墙限制东西向流量与入口出口",
        "仅依赖 kube-proxy",
        "只在节点上配置路由",
        "完全关闭网络",
      ],
      answer: 0,
      rationale: "网络策略是集群安全的重要一环。",
    },
    {
      id: "w14-1-q9",
      question: "代码层安全的例子？",
      options: [
        "安全编码、依赖管理、SAST/DAST、秘密管理",
        "仅依赖防火墙",
        "禁用日志",
        "使用 root 用户开发",
      ],
      answer: 0,
      rationale: "4C 最内层强调代码级安全与扫描。",
    },
    {
      id: "w14-1-q10",
      question: "PodSecurity（PSS 替代 PSP）在新版本中的实现方式？",
      options: [
        "通过 Pod Security Admission（命名空间级 enforce/audit/warn 模式）",
        "使用 PodSecurityPolicy",
        "使用 NodeSelector",
        "通过 kube-proxy",
      ],
      answer: 0,
      rationale: "PSA 控制器基于 namespace 标签执行 PSS，PSP 已弃用。",
    },
  ],
  "w14-2": [
    {
      id: "w14-2-q1",
      question: "Cosign 的核心功能是？",
      options: [
        "为容器镜像生成/验证签名（支持密钥或无密钥 OIDC/Fulcio）",
        "构建镜像",
        "部署 Kubernetes",
        "扫描漏洞",
      ],
      answer: 0,
      rationale: "Cosign 是 Sigstore 工具，用于签名与验证镜像/制品。",
    },
    {
      id: "w14-2-q2",
      question: "cosign verify 做什么？",
      options: [
        "从注册表/rekor 获取签名并验证镜像满足信任策略",
        "推送镜像",
        "删除镜像",
        "生成 SBOM",
      ],
      answer: 0,
      rationale: "verify 校验签名/证书链，保证镜像来源可信。",
    },
    {
      id: "w14-2-q3",
      question: "Admission 阶段如何阻止未签名镜像运行？",
      options: [
        "使用 Sigstore policy-controller/Kyverno/Gatekeeper 编写策略验证签名",
        "依赖 kube-proxy",
        "修改 Dockerfile",
        "重启 kubelet",
      ],
      answer: 0,
      rationale: "准入策略可校验签名，拒绝不符合供应链要求的镜像。",
    },
    {
      id: "w14-2-q4",
      question: "Cosign 支持的证明材料除了签名还有？",
      options: [
        "Attestation/SBOM，可用于记录构建元数据/合规性",
        "仅签名",
        "只能存储日志",
        "只支持漏洞报告",
      ],
      answer: 0,
      rationale: "Cosign 可存储/验证 attestations，如 SLSA 元数据。",
    },
    {
      id: "w14-2-q5",
      question: "Keyless 模式依赖什么？",
      options: [
        "OIDC 身份 + Fulcio（临时证书） + Rekor 透明日志",
        "离线私钥",
        "HSM 才能使用",
        "只能在本地使用",
      ],
      answer: 0,
      rationale: "Sigstore 提供基于 OIDC 的无密钥签名，证书记录在 Rekor。",
    },
    {
      id: "w14-2-q6",
      question: "为什么要固定镜像 digest 而非 tag？",
      options: [
        "digest 唯一对应镜像内容，可防止 tag 漂移或供应链攻击",
        "digest 更短",
        "tag 无法使用",
        "只为美观",
      ],
      answer: 0,
      rationale: "供应链安全强调不可变引用。",
    },
    {
      id: "w14-2-q7",
      question: "ImagePolicyWebhook 的用途？",
      options: [
        "在准入阶段调用外部服务验证镜像策略（如签名/漏洞）",
        "实现 HPA",
        "替代 kubelet",
        "配置网络策略",
      ],
      answer: 0,
      rationale: "ImagePolicyWebhook 可将镜像验证交给外部策略服务。",
    },
    {
      id: "w14-2-q8",
      question: "SBOM 在供应链中的作用？",
      options: [
        "列出软件组成/依赖，便于漏洞追踪与合规审计",
        "提升性能",
        "减少镜像大小",
        "只用于计费",
      ],
      answer: 0,
      rationale: "SBOM 帮助快速定位受影响组件。",
    },
    {
      id: "w14-2-q9",
      question: "构建到部署的可信链条需要什么？",
      options: [
        "可信源代码、受控构建（签名）、制品存储、准入验证与运行时监控",
        "仅签名",
        "只需扫描漏洞",
        "只需要 RBAC",
      ],
      answer: 0,
      rationale: "供应链安全覆盖全生命周期，从源到运行都需验证。",
    },
    {
      id: "w14-2-q10",
      question: "policy-controller（Sigstore）主要作用？",
      options: [
        "在准入时校验 Cosign 签名/公钥/证书策略",
        "创建 Pod",
        "管理 HPA",
        "生成 Helm Chart",
      ],
      answer: 0,
      rationale: "Sigstore policy-controller 提供准入验证，拒绝不合规镜像。",
    },
  ],
  "w14-3": [
    {
      id: "w14-3-q1",
      question: "OPA Gatekeeper 策略由哪些对象组成？",
      options: [
        "ConstraintTemplate（定义 Rego 逻辑）与 Constraint（实例化具体限制）",
        "只需要 ConfigMap",
        "只用 Rego 文件",
        "CRD 与 Deployment 无关",
      ],
      answer: 0,
      rationale: "Gatekeeper 使用模板+约束分离策略逻辑与实例。",
    },
    {
      id: "w14-3-q2",
      question: "Kyverno 策略类型包括？",
      options: [
        "validate、mutate、generate（加上 verifyImages）",
        "仅 validate",
        "仅 mutate",
        "仅 generate",
      ],
      answer: 0,
      rationale: "Kyverno 提供验证/变更/生成/镜像签名校验等能力。",
    },
    {
      id: "w14-3-q3",
      question: "两者的规则执行位置？",
      options: [
        "都通过 Admission Webhook 拦截请求（可配置 enforce/audit/dry-run）",
        "运行在 kube-proxy",
        "仅运行在客户端",
        "只在 etcd 中",
      ],
      answer: 0,
      rationale: "Gatekeeper/Kyverno 作为准入控制器工作。",
    },
    {
      id: "w14-3-q4",
      question: "编写 Gatekeeper 规则使用哪种语言？",
      options: [
        "Rego（OPA 策略语言）",
        "Lua",
        "Python",
        "YAML 纯配置",
      ],
      answer: 0,
      rationale: "ConstraintTemplate 中的逻辑使用 Rego。",
    },
    {
      id: "w14-3-q5",
      question: "Kyverno 与 Gatekeeper 的主要差异？",
      options: [
        "Kyverno 使用原生 YAML 声明规则，支持 mutate/generate；Gatekeeper 基于 Rego",
        "Gatekeeper 只能 mutate",
        "Kyverno 不能验证",
        "两者完全相同",
      ],
      answer: 0,
      rationale: "Kyverno 以 YAML 为主，Gatekeeper 使用 Rego。",
    },
    {
      id: "w14-3-q6",
      question: "策略库/样例的来源？",
      options: [
        "官方/社区提供的 policy library（如 Pod 安全、镜像仓库限制）",
        "必须自己写",
        "只在商业版提供",
        "需要修改内核",
      ],
      answer: 0,
      rationale: "两者社区均提供丰富示例可直接应用。",
    },
    {
      id: "w14-3-q7",
      question: "Audit 模式的意义？",
      options: [
        "只记录违规但不拦截请求，便于观察影响",
        "自动修复",
        "关闭策略",
        "必须与 enforce 一起用",
      ],
      answer: 0,
      rationale: "审计模式帮助评估策略效果，逐步启用。",
    },
    {
      id: "w14-3-q8",
      question: "Kyverno verifyImages 用途？",
      options: [
        "在准入时验证镜像签名（如 Cosign），拒绝未签名镜像",
        "生成镜像",
        "扫描漏洞",
        "替代 HPA",
      ],
      answer: 0,
      rationale: "Kyverno 支持镜像签名验证，常用于供应链安全。",
    },
    {
      id: "w14-3-q9",
      question: "Gatekeeper Sync 配置的作用？",
      options: [
        "将集群资源同步到 OPA 数据库供约束引用",
        "同步镜像到节点",
        "同步 etcd",
        "同步 kubeconfig",
      ],
      answer: 0,
      rationale: "Sync 允许规则访问集群资源数据作为输入。",
    },
    {
      id: "w14-3-q10",
      question: "逐步推广策略的实践？",
      options: [
        "先在 audit 模式观察，再切换 enforce，配合排除/命名空间选择器",
        "直接全局 enforce",
        "不需要测试",
        "全部禁用",
      ],
      answer: 0,
      rationale: "渐进式发布降低误拦风险，使用 namespaceSelector/exclude 控制范围。",
    },
  ],
  "w14-4": [
    {
      id: "w14-4-q1",
      question: "Falco 的检测原理是？",
      options: [
        "通过内核模块/eBPF 捕获系统调用，与规则匹配检测异常行为",
        "读取 Pod 日志",
        "扫描镜像",
        "使用 kubelet 事件",
      ],
      answer: 0,
      rationale: "Falco 监控 syscalls，利用规则识别可疑行为。",
    },
    {
      id: "w14-4-q2",
      question: "在 Kubernetes 中部署 Falco 的常见方式？",
      options: [
        "以 DaemonSet 形式运行，覆盖所有节点",
        "部署为 CronJob",
        "仅在控制平面节点",
        "以 ConfigMap 运行",
      ],
      answer: 0,
      rationale: "DaemonSet 确保每个节点都有探针。",
    },
    {
      id: "w14-4-q3",
      question: "Falco 规则常见检测哪些行为？",
      options: [
        "特权提升、在容器内执行 shell、修改敏感文件/二进制、意外的网络访问",
        "CPU 使用率过高",
        "节点磁盘空间",
        "Pod 重启次数",
      ],
      answer: 0,
      rationale: "默认规则涵盖常见攻击/越权行为。",
    },
    {
      id: "w14-4-q4",
      question: "Falco 的输出渠道包括？",
      options: [
        "stdout/文件、syslog、gRPC、webhook/Slack 等",
        "仅 stdout",
        "只能写数据库",
        "没有输出",
      ],
      answer: 0,
      rationale: "Falco 支持多种告警输出方式。",
    },
    {
      id: "w14-4-q5",
      question: "为什么需要自定义/调优规则？",
      options: [
        "适配业务场景、减少误报并覆盖特定风险",
        "为了提高性能",
        "因为默认规则无效",
        "只能这样才能运行",
      ],
      answer: 0,
      rationale: "自定义规则可降低噪声并捕获特定威胁。",
    },
    {
      id: "w14-4-q6",
      question: "Falco 运行需要哪些权限？",
      options: [
        "需要访问内核事件（通常以特权/HostPID/HostNetwork 或 eBPF 特权运行）",
        "无需任何权限",
        "只需用户态",
        "需要修改 etcd",
      ],
      answer: 0,
      rationale: "捕获 syscalls 需相应 host 权限或加载 eBPF/内核模块。",
    },
    {
      id: "w14-4-q7",
      question: "使用 eBPF 运行 Falco 的好处？",
      options: [
        "避免内核模块依赖，更易兼容托管环境",
        "性能更差",
        "无法捕获系统调用",
        "需要重启节点",
      ],
      answer: 0,
      rationale: "eBPF 方式减少对内核模块的要求，适合受限环境。",
    },
    {
      id: "w14-4-q8",
      question: "Falco 如何与 Kubernetes 元数据关联？",
      options: [
        "通过 kube-apiserver 获取 Pod/命名空间/标签信息，丰富告警上下文",
        "写入 ConfigMap",
        "读取 etcd 数据目录",
        "不支持关联",
      ],
      answer: 0,
      rationale: "Falco 可查询 API 获取资源标签以增强告警可读性。",
    },
    {
      id: "w14-4-q9",
      question: "Falco Helm chart 提供哪些便利？",
      options: [
        "快速部署 DaemonSet/配置规则/输出，支持启用 eBPF/driver 选项",
        "只能安装单节点",
        "不支持自定义",
        "没有输出配置",
      ],
      answer: 0,
      rationale: "Helm chart 封装安装与配置选项，便于定制。",
    },
    {
      id: "w14-4-q10",
      question: "运行时安全与事前策略的关系？",
      options: [
        "运行时监控（Falco）补充准入/签名等预防手段，提供实时检测与响应",
        "完全替代准入控制",
        "与策略无关",
        "仅用于性能优化",
      ],
      answer: 0,
      rationale: "安全需要预防+检测+响应多层防护。",
    },
  ],
  // Week 13
  "w13-1": [
    {
      id: "w13-1-q1",
      question: "Service Mesh 主要解决哪些微服务难题？",
      options: [
        "流量治理（熔断/重试/灰度）、可观测性、零信任安全（mTLS）等",
        "只解决存储问题",
        "仅提供日志聚合",
        "只提升 CPU 性能",
      ],
      answer: 0,
      rationale: "官方介绍指出 Mesh 侧重流量控制、观测与安全。",
    },
    {
      id: "w13-1-q2",
      question: "Sidecar 模式如何拦截流量？",
      options: [
        "通过 iptables 重定向 Pod 进出流量到 Envoy 代理",
        "直接修改应用代码",
        "使用物理负载均衡器",
        "依赖 kube-proxy",
      ],
      answer: 0,
      rationale: "Sidecar 通过流量劫持透明代理应用流量。",
    },
    {
      id: "w13-1-q3",
      question: "Service Mesh 的数据面和控制面分别是什么？",
      options: [
        "数据面是每个 Pod 的 Sidecar 代理，控制面负责策略下发与证书管理",
        "数据面是 API Server，控制面是 kubelet",
        "数据面是 etcd，控制面是 scheduler",
        "两者相同",
      ],
      answer: 0,
      rationale: "典型 Mesh 架构分为代理数据面与集中控制面。",
    },
    {
      id: "w13-1-q4",
      question: "mTLS 在网格中的作用？",
      options: [
        "提供服务间双向认证与加密，强化零信任",
        "仅用于压缩流量",
        "只在入口网关生效",
        "替代应用级认证",
      ],
      answer: 0,
      rationale: "Mesh 下发证书并自动建立 mTLS 通道。",
    },
    {
      id: "w13-1-q5",
      question: "引入服务网格的成本是？",
      options: [
        "增加资源开销与运维复杂度，需要权衡",
        "完全无开销",
        "必须修改内核",
        "需要停机",
      ],
      answer: 0,
      rationale: "Sidecar/控制面会占用资源并带来管理复杂度。",
    },
    {
      id: "w13-1-q6",
      question: "SPIFFE ID 在网格中用于？",
      options: [
        "标识服务身份（如 spiffe://cluster.local/ns/ns/sa/sa），配合 mTLS 授权",
        "标识节点 CPU",
        "标识 Helm Chart",
        "替代 Pod 名称",
      ],
      answer: 0,
      rationale: "Mesh 通常采用 SPIFFE 规范的身份标识。",
    },
    {
      id: "w13-1-q7",
      question: "流量治理能力通常无需？",
      options: [
        "修改业务代码，利用 sidecar 透明实现重试/超时/熔断",
        "安装应用 SDK",
        "更改 kube-proxy",
        "修改 Dockerfile",
      ],
      answer: 0,
      rationale: "Mesh 目标是透明下推网络策略，减少业务改动。",
    },
    {
      id: "w13-1-q8",
      question: "常见的可观测性增强包括？",
      options: [
        "自动生成指标、分布式追踪上下文与访问日志",
        "只记录 CPU 使用率",
        "只记录事件",
        "关闭日志",
      ],
      answer: 0,
      rationale: "Sidecar 可自动上报指标/追踪/访问日志。",
    },
    {
      id: "w13-1-q9",
      question: "没有服务网格也可实现上述能力吗？",
      options: [
        "可以，但需在应用或边车自行实现；网格提供统一落地与策略管理",
        "完全不行",
        "必须改内核",
        "只能用硬件",
      ],
      answer: 0,
      rationale: "Mesh 统一实现但并非唯一方式，需权衡引入成本。",
    },
    {
      id: "w13-1-q10",
      question: "Service Mesh Interface (SMI) 的目标是？",
      options: [
        "为不同 Mesh 提供通用 API 规范，简化可移植性",
        "实现 K8s 网络策略",
        "替代 Istio 控制面",
        "提供日志收集",
      ],
      answer: 0,
      rationale: "SMI 提供抽象标准，便于在不同 Mesh 之间切换。",
    },
  ],
  "w13-2": [
    {
      id: "w13-2-q1",
      question: "Istio 控制面的核心组件是？",
      options: [
        "istiod（整合 Pilot/Citadel/Galley 功能）",
        "kube-proxy",
        "Envoy Proxy",
        "CoreDNS",
      ],
      answer: 0,
      rationale: "istiod 负责配置分发、证书签发等。",
    },
    {
      id: "w13-2-q2",
      question: "Sidecar 代理在 Istio 中通常使用？",
      options: ["Envoy", "Nginx", "HAProxy", "Envoy 或 Nginx 随机"],
      answer: 0,
      rationale: "Istio 数据面默认 Envoy。",
    },
    {
      id: "w13-2-q3",
      question: "启用自动注入 Sidecar 的常见方式？",
      options: [
        "在 Namespace 加标签 istio-injection=enabled 或使用 revision 标签",
        "编辑 kubelet",
        "必须手工在 Pod 定义中添加容器",
        "通过 Service 注解",
      ],
      answer: 0,
      rationale: "标签触发 mutating webhook 注入 sidecar。",
    },
    {
      id: "w13-2-q4",
      question: "istioctl install --set profile=demo 的作用？",
      options: [
        "安装带示例配置的 demo profile，适合本地测试",
        "仅安装数据面",
        "卸载 Istio",
        "创建 Ingress",
      ],
      answer: 0,
      rationale: "demo profile 安装全套组件供体验使用。",
    },
    {
      id: "w13-2-q5",
      question: "Sidecar 与 istiod 通信使用的协议？",
      options: [
        "xDS（gRPC）下发配置/证书",
        "HTTP REST",
        "TCP 原始套接字",
        "仅通过文件",
      ],
      answer: 0,
      rationale: "Envoy 通过 xDS API 接收路由与证书更新。",
    },
    {
      id: "w13-2-q6",
      question: "Istio Ingress Gateway 的作用？",
      options: [
        "网格入口，承载 Gateway/VirtualService 规则并暴露到集群外部",
        "替代 kube-proxy",
        "存储日志",
        "管理 Pod 生命周期",
      ],
      answer: 0,
      rationale: "Ingress Gateway 是暴露网格流量的 L4/L7 入口。",
    },
    {
      id: "w13-2-q7",
      question: "安装后验证 Istio 健康的命令？",
      options: [
        "istioctl verify-install",
        "kubectl get istio",
        "helm status istio",
        "curl istiod",
      ],
      answer: 0,
      rationale: "官方推荐 verify-install 进行组件检查。",
    },
    {
      id: "w13-2-q8",
      question: "控制面升级/多版本并存的方式？",
      options: [
        "使用 revision 标签安装多个 istiod，逐步迁移命名空间",
        "只能全量覆盖升级",
        "需删除数据面",
        "必须停机",
      ],
      answer: 0,
      rationale: "修订版支持灰度控制面，便于逐步迁移。",
    },
    {
      id: "w13-2-q9",
      question: "iptables 重定向由哪个组件完成？",
      options: [
        "istio-init（或 istio-cni）为 Pod 设置流量劫持规则",
        "kube-proxy",
        "istiod",
        "Prometheus",
      ],
      answer: 0,
      rationale: "init 容器或 CNI 插件负责插入重定向规则。",
    },
    {
      id: "w13-2-q10",
      question: "Istio 安装会创建哪些 CRD？",
      options: [
        "VirtualService、DestinationRule、Gateway、ServiceEntry、PeerAuthentication 等",
        "只有 Deployment",
        "仅 NetworkPolicy",
        "没有 CRD",
      ],
      answer: 0,
      rationale: "Istio 依赖一系列 CRD 定义流量/安全策略。",
    },
  ],
  "w13-3": [
    {
      id: "w13-3-q1",
      question: "VirtualService 与 DestinationRule 的关系？",
      options: [
        "VirtualService 定义路由规则，DestinationRule 定义目标子集/策略（如 TLS/熔断）",
        "两者相同",
        "VirtualService 定义 Pod 模板",
        "DestinationRule 用于入口",
      ],
      answer: 0,
      rationale: "二者配合实现路由与后端策略。",
    },
    {
      id: "w13-3-q2",
      question: "如何实现金丝雀流量切分？",
      options: [
        "在 VirtualService 中设置 weighted routes（如 90/10）指向不同 subset",
        "修改 Service 类型",
        "使用 HPA",
        "通过 ConfigMap",
      ],
      answer: 0,
      rationale: "使用权重路由到不同版本的 subset。",
    },
    {
      id: "w13-3-q3",
      question: "subset 在 DestinationRule 中如何定义？",
      options: [
        "通过 labels selector（如 version: v1/v2）指定 Pod 子集",
        "按节点选择",
        "按端口选择",
        "随机选择",
      ],
      answer: 0,
      rationale: "子集基于 Pod 标签，与 VirtualService 路由匹配。",
    },
    {
      id: "w13-3-q4",
      question: "实现故障注入的资源是？",
      options: [
        "VirtualService（fault: abort/delay）",
        "DestinationRule",
        "ServiceEntry",
        "PeerAuthentication",
      ],
      answer: 0,
      rationale: "VirtualService 支持注入延迟/错误模拟故障。",
    },
    {
      id: "w13-3-q5",
      question: "熔断/连接池配置在哪里？",
      options: [
        "DestinationRule 的 trafficPolicy（connectionPool、outlierDetection、retries）",
        "VirtualService",
        "Gateway",
        "Pod 模板",
      ],
      answer: 0,
      rationale: "后端连接策略在 DestinationRule 中定义。",
    },
    {
      id: "w13-3-q6",
      question: "请求超时与重试通常配置在哪？",
      options: [
        "VirtualService 的 http.timeout/retries",
        "Deployment",
        "Service",
        "Gateway",
      ],
      answer: 0,
      rationale: "路由层配置超时和重试策略。",
    },
    {
      id: "w13-3-q7",
      question: "流量镜像（shadow traffic）的配置？",
      options: [
        "VirtualService 中 mirror/mirror_percent 将流量副本发送到另一个目标",
        "DestinationRule",
        "Gateway",
        "HPA",
      ],
      answer: 0,
      rationale: "镜像用于无影响地观测新版本。",
    },
    {
      id: "w13-3-q8",
      question: "基于 Header 的路由属于？",
      options: [
        "VirtualService 匹配条件（match headers/cookies）",
        "Service",
        "Deployment",
        "ConfigMap",
      ],
      answer: 0,
      rationale: "VirtualService 支持按 header/cookie 路由。",
    },
    {
      id: "w13-3-q9",
      question: "ServiceEntry 的作用？",
      options: [
        "将外部服务纳入网格，定义可访问的主机/端口/协议",
        "控制访问日志",
        "管理 mTLS",
        "配置 HPA",
      ],
      answer: 0,
      rationale: "ServiceEntry 声明外部/虚拟服务供 Envoy 识别。",
    },
    {
      id: "w13-3-q10",
      question: "Gateway 资源用于？",
      options: [
        "声明网格入口/出口监听端口/协议，与 VirtualService 组合路由",
        "替代 Service",
        "配置节点亲和",
        "管理卷",
      ],
      answer: 0,
      rationale: "Gateway 定义 L4/L6 入口，VirtualService 指定路由。",
    },
  ],
  "w13-4": [
    {
      id: "w13-4-q1",
      question: "Istio 中启用 mTLS 的资源是？",
      options: [
        "PeerAuthentication（设置 mtls mode: STRICT/PERMISSIVE 等）",
        "VirtualService",
        "Gateway",
        "Deployment",
      ],
      answer: 0,
      rationale: "PeerAuthentication 控制入站 mTLS 策略。",
    },
    {
      id: "w13-4-q2",
      question: "服务身份在 Istio 中通常使用什么格式？",
      options: [
        "SPIFFE ID：spiffe://<trust-domain>/ns/<namespace>/sa/<serviceaccount>",
        "Pod IP",
        "Node 名称",
        "随机 UUID",
      ],
      answer: 0,
      rationale: "Istio 证书中使用 SPIFFE ID 作为主体。",
    },
    {
      id: "w13-4-q3",
      question: "AuthorizationPolicy 可以基于哪些条件？",
      options: [
        "主体(principals)/源 IP/命名空间/请求方法/路径等",
        "仅 Pod 名称",
        "只能基于节点",
        "只能允许全部",
      ],
      answer: 0,
      rationale: "授权策略支持多维度匹配请求。",
    },
    {
      id: "w13-4-q4",
      question: "证书由谁签发并分发给 Sidecar？",
      options: [
        "istiod（Citadel 功能）通过 SDS 向 Envoy 分发证书/密钥",
        "kube-proxy",
        "CoreDNS",
        "kubectl",
      ],
      answer: 0,
      rationale: "istiod 担任 CA，下发证书给 sidecar。",
    },
    {
      id: "w13-4-q5",
      question: "启用全局 STRICT mTLS 的常见做法？",
      options: [
        "在 mesh/default 命名空间创建 PeerAuthentication mtls: STRICT 并逐步覆盖例外",
        "修改 kubelet",
        "通过 Deployment 注解",
        "需要重启集群",
      ],
      answer: 0,
      rationale: "全局策略可通过 mesh-wide PeerAuthentication 设置严格模式。",
    },
    {
      id: "w13-4-q6",
      question: "入口网关 TLS 终止需要哪些资源？",
      options: [
        "Gateway 定义端口/证书引用，VirtualService 定义路由",
        "仅 VirtualService",
        "仅 DestinationRule",
        "仅 ConfigMap",
      ],
      answer: 0,
      rationale: "Gateway 管理 listener/TLS，VirtualService 绑定路由。",
    },
    {
      id: "w13-4-q7",
      question: "Sidecar 注入与安全策略的关系？",
      options: [
        "未注入 Sidecar 的 Pod 无法享受 mTLS/授权策略，需要确保关键命名空间开启注入",
        "无关系",
        "授权策略自动作用所有 Pod",
        "只影响 Ingress",
      ],
      answer: 0,
      rationale: "策略依赖 Envoy 执行，未注入则无法 enforcement。",
    },
    {
      id: "w13-4-q8",
      question: "启用 RBAC 授权的默认行为？",
      options: [
        "未匹配的请求默认拒绝（ALLOW-ALL 需显式配置）",
        "默认允许全部",
        "只检查 mTLS",
        "只作用外部流量",
      ],
      answer: 0,
      rationale: "AuthorizationPolicy 默认为拒绝未知请求，需明确规则。",
    },
    {
      id: "w13-4-q9",
      question: "Egress 流量控制可用的资源是？",
      options: [
        "ServiceEntry + egress Gateway + VirtualService，实现外部访问管控/审计",
        "NetworkPolicy",
        "只需 Ingress",
        "HPA",
      ],
      answer: 0,
      rationale: "Istio 支持 egress gateway/ServiceEntry 控制出口流量。",
    },
    {
      id: "w13-4-q10",
      question: "为何建议定期轮换网格证书？",
      options: [
        "减少长期凭证被盗风险，符合零信任原则",
        "提升性能",
        "避免日志过大",
        "与安全无关",
      ],
      answer: 0,
      rationale: "证书轮换是安全最佳实践，Istio 支持自动续期。",
    },
  ],
  // Week 12
  "w12-1": [
    {
      id: "w12-1-q1",
      question: "Kubernetes 官方推荐应用如何输出日志？",
      options: [
        "写到 stdout/stderr，由容器运行时重定向到节点日志文件",
        "直接写本地文件并手工收集",
        "通过 API Server 上传",
        "写入 etcd",
      ],
      answer: 0,
      rationale: "日志最佳实践是输出到标准输出，便于 kubectl logs 与采集。",
    },
    {
      id: "w12-1-q2",
      question: "DaemonSet 日志代理（如 Fluent Bit）的优势？",
      options: [
        "在每个节点收集所有容器日志，集中转发，无需改应用",
        "必须修改应用代码",
        "只能收集一个容器",
        "无法处理轮转",
      ],
      answer: 0,
      rationale: "节点级代理可统一采集，兼容大多数工作负载。",
    },
    {
      id: "w12-1-q3",
      question: "Sidecar 日志收集模式的特点？",
      options: [
        "同 Pod 内的日志代理共享卷读取主容器日志，适合定制处理但会增加资源开销",
        "只能在无 DaemonSet 时使用",
        "默认由 kubelet 创建",
        "无法访问主容器文件",
      ],
      answer: 0,
      rationale: "Sidecar 可处理特定格式/协议，但增加 Pod 复杂度。",
    },
    {
      id: "w12-1-q4",
      question: "kubectl logs 读取的文件路径通常是？",
      options: [
        "/var/log/containers 下的符号链接（指向 /var/log/pods/.../container.log）",
        "/etc/kubernetes/logs",
        "/tmp",
        "/var/lib/docker/images",
      ],
      answer: 0,
      rationale: "日志默认存放在 /var/log/containers，指向真实容器日志。",
    },
    {
      id: "w12-1-q5",
      question: "日志轮转通常由谁负责？",
      options: [
        "容器运行时/kubelet 依据配置（如 containerLogMaxSize/Files）",
        "应用自行删除",
        "etcd 自动清理",
        "需要手工 rm",
      ],
      answer: 0,
      rationale: "kubelet 支持配置日志文件大小/数量进行轮转。",
    },
    {
      id: "w12-1-q6",
      question: "多容器 Pod 内共享日志的方式？",
      options: [
        "使用 emptyDir 等共享卷，主容器写文件，sidecar 读取处理",
        "必须使用 hostPath",
        "无解",
        "需要修改 API Server",
      ],
      answer: 0,
      rationale: "共享卷是 Sidecar 模式常见做法。",
    },
    {
      id: "w12-1-q7",
      question: "集群默认是否提供日志集中存储？",
      options: [
        "否，K8s 只提供接口，需要自建/托管的收集与存储方案",
        "是，etcd 自动存储",
        "是，kube-proxy 存储",
        "是，kubelet 存储 30 天",
      ],
      answer: 0,
      rationale: "官方文档强调日志管道需自建或使用云产品。",
    },
    {
      id: "w12-1-q8",
      question: "短暂 Pod 的日志注意事项？",
      options: [
        "Pod 删除后日志文件可能被清理，需及时收集或使用持久化方案",
        "日志会永久保留",
        "不需要采集",
        "kubectl logs 会自动存档",
      ],
      answer: 0,
      rationale: "短生命周期任务需确保日志及时转存或收集。",
    },
    {
      id: "w12-1-q9",
      question: "Container Runtime Interface 对日志格式的要求？",
      options: [
        "CRI 定义了基本 JSON 行格式（时间/流/日志），kubelet 解析后暴露",
        "无要求",
        "必须是 syslog",
        "要求 protobuf",
      ],
      answer: 0,
      rationale: "CRI 规范了日志输出格式以供 kubelet 处理。",
    },
    {
      id: "w12-1-q10",
      question: "选择 DaemonSet 与 Sidecar 的权衡？",
      options: [
        "DaemonSet 通用且易运维；Sidecar 更灵活但占用资源/需改 Pod 模板",
        "Sidecar 一定更省资源",
        "DaemonSet 无法收集多容器日志",
        "两者完全相同",
      ],
      answer: 0,
      rationale: "官方文档比较两种模式：节点代理 vs 每 Pod Sidecar 各有利弊。",
    },
  ],
  "w12-2": [
    {
      id: "w12-2-q1",
      question: "Loki 的设计与传统日志系统有何不同？",
      options: [
        "仅索引标签（labels），日志内容不建立全文索引以降低成本",
        "完全不存储日志",
        "只支持结构化日志",
        "需要 Elasticsearch 作为后端",
      ],
      answer: 0,
      rationale: "Loki 采用标签索引+块存储策略，强调低成本。",
    },
    {
      id: "w12-2-q2",
      question: "LogQL 基本查询格式是？",
      options: [
        "{label=\"value\", app=~\"api|web\"} |= \"error\"",
        "SELECT * FROM logs",
        "kubectl logs -l app=web",
        "curl /logs",
      ],
      answer: 0,
      rationale: "LogQL 使用 PromQL 类似的标签过滤加管道过滤。",
    },
    {
      id: "w12-2-q3",
      question: "|= 与 |~ 在 LogQL 中的区别？",
      options: [
        "|= 为字符串包含过滤，|~ 为正则匹配",
        "两者都为正则",
        "|= 是赋值",
        "|~ 表示管道",
      ],
      answer: 0,
      rationale: "运算符语义与 Promtail/Loki 文档一致。",
    },
    {
      id: "w12-2-q4",
      question: "将日志转为指标的方式？",
      options: [
        "使用度量查询，如 sum by (level) (rate({app=\"api\"} |= \"error\" [5m]))",
        "仅能全文检索",
        "需要导出到 Prometheus",
        "无法转换",
      ],
      answer: 0,
      rationale: "LogQL 支持 metric queries 基于 log stream 计算率/计数。",
    },
    {
      id: "w12-2-q5",
      question: "避免高基数标签的原因？",
      options: [
        "高基数会导致索引膨胀和查询缓慢",
        "可以提升性能",
        "必须索引每个字段",
        "不会影响性能",
      ],
      answer: 0,
      rationale: "Loki 与 Prometheus 类似，高基数标签成本高。",
    },
    {
      id: "w12-2-q6",
      question: "Promtail 在 Kubernetes 场景常用的 pipeline stage 是？",
      options: [
        "cri/docker 解析、json 解码、labeldrop/replace 等",
        "仅 regex",
        "必须使用 syslog",
        "只支持静态文件",
      ],
      answer: 0,
      rationale: "Promtail 提供丰富 pipeline stage 适配 CRI/Docker 日志与结构化解析。",
    },
    {
      id: "w12-2-q7",
      question: "LogQL 的 limit 参数作用？",
      options: [
        "限制返回的日志行数，默认 1000",
        "限制时间范围",
        "限制标签数",
        "限制文件大小",
      ],
      answer: 0,
      rationale: "limit 可控制返回行数，避免过多输出。",
    },
    {
      id: "w12-2-q8",
      question: "Loki Helm 安装通常包含哪些组件？",
      options: [
        "Loki 本身、Promtail/Agent、Grafana（可选）",
        "仅 Loki",
        "只安装 Prometheus",
        "必须安装 Elasticsearch",
      ],
      answer: 0,
      rationale: "官方 chart 可同时部署 Loki、Promtail、Grafana。",
    },
    {
      id: "w12-2-q9",
      question: "LogQL 支持的时间范围语法？",
      options: [
        "[5m]" ,
        "LIMIT 5",
        "OFFSET 5",
        "SAMPLE BY 5",
      ],
      answer: 0,
      rationale: "与 PromQL 类似，区间向量使用 [duration] 表示窗口。",
    },
    {
      id: "w12-2-q10",
      question: "使用 | json 管道的目的？",
      options: [
        "将日志行解析为结构化字段，便于后续过滤/格式化",
        "压缩日志",
        "转换为指标",
        "删除标签",
      ],
      answer: 0,
      rationale: "json 管道解析 JSON 日志，方便提取字段进行查询。",
    },
  ],
  "w12-3": [
    {
      id: "w12-3-q1",
      question: "Trace 与 Span 的关系是？",
      options: [
        "Trace 是跨服务调用的完整链路，由多个 Span（操作）组成",
        "Span 包含多个 Trace",
        "二者相同",
        "Span 仅表示日志",
      ],
      answer: 0,
      rationale: "链路追踪模型：Trace = 多个 Span 构成的有向图。",
    },
    {
      id: "w12-3-q2",
      question: "Span Context 通常包含？",
      options: [
        "trace_id、span_id、采样标记、baggage 等用于传播的元数据",
        "用户密码",
        "日志级别",
        "CPU 信息",
      ],
      answer: 0,
      rationale: "上下文携带标识符与可选 baggage 用于跨进程传递。",
    },
    {
      id: "w12-3-q3",
      question: "W3C Trace Context 的 HTTP 头是？",
      options: [
        "traceparent（可选 tracestate）",
        "x-request-id",
        "authorization",
        "content-type",
      ],
      answer: 0,
      rationale: "W3C 标准化 traceparent/tracestate 进行传播。",
    },
    {
      id: "w12-3-q4",
      question: "Head vs Tail Sampling 的区别？",
      options: [
        "Head 在入口决定采样，Tail 根据完成后的特征/错误再决定保留",
        "Tail 在入口采样",
        "两者相同",
        "仅影响日志",
      ],
      answer: 0,
      rationale: "Tail 允许根据结果决定保留，适合低错误率场景。",
    },
    {
      id: "w12-3-q5",
      question: "常见的 Span 属性包括？",
      options: [
        "name、start/end time、attributes、events、status、links",
        "only name",
        "仅日志",
        "仅返回码",
      ],
      answer: 0,
      rationale: "Span 除了时间戳还包含属性/事件/状态等丰富信息。",
    },
    {
      id: "w12-3-q6",
      question: "自动与手动埋点的区别？",
      options: [
        "自动埋点通过框架探针自动生成 Span；手动埋点需要显式创建/传递 context",
        "两者相同",
        "手动埋点性能更差",
        "自动埋点必须修改业务代码",
      ],
      answer: 0,
      rationale: "自动/手动各有优缺点，手动更灵活。",
    },
    {
      id: "w12-3-q7",
      question: "Span 链接（links）的作用？",
      options: [
        "关联并行/消息队列等非父子关系的 Span",
        "必然表示父子关系",
        "仅用于日志",
        "无作用",
      ],
      answer: 0,
      rationale: "links 用于表示因果关系而非直接父子。",
    },
    {
      id: "w12-3-q8",
      question: "跨进程传播上下文需要？",
      options: [
        "在出站请求注入 trace context（HTTP 头、gRPC metadata 等）并在入站提取",
        "仅在进程内存储",
        "依赖数据库",
        "无需任何操作",
      ],
      answer: 0,
      rationale: "传播是分布式追踪的关键，需要在请求链路中传递标识。",
    },
    {
      id: "w12-3-q9",
      question: "采样率过低会导致？",
      options: [
        "缺少重要错误/性能信息，难以分析",
        "性能下降",
        "Span 无限增长",
        "不影响任何数据",
      ],
      answer: 0,
      rationale: "采样权衡数据量与可见度，过低会失去洞察。",
    },
    {
      id: "w12-3-q10",
      question: "追踪数据通常发送到哪些后端？",
      options: [
        "Jaeger/Zipkin/Tempo 等追踪存储与查询系统",
        "Prometheus",
        "Elasticsearch 日志",
        "CoreDNS",
      ],
      answer: 0,
      rationale: "采集 SDK/Collector 将数据导出到兼容追踪后端。",
    },
  ],
  "w12-4": [
    {
      id: "w12-4-q1",
      question: "OpenTelemetry 的关键组件？",
      options: [
        "SDK/Auto-Instrumentation、Collector（接收/处理/导出）、协议 OTLP",
        "仅 Jaeger",
        "只包含日志",
        "必须使用 Zipkin",
      ],
      answer: 0,
      rationale: "OTel 提供规范与实现，包括 SDK 和 Collector 管道。",
    },
    {
      id: "w12-4-q2",
      question: "Collector pipeline 的基本结构？",
      options: [
        "receivers -> processors -> exporters",
        "import -> build -> deploy",
        "producer -> queue -> consumer",
        "source -> sink",
      ],
      answer: 0,
      rationale: "官方配置示例即三段式流水线。",
    },
    {
      id: "w12-4-q3",
      question: "Jaeger UI 能做什么？",
      options: [
        "按服务/操作/标签搜索 Trace，查看 Span 时间线与依赖图",
        "管理 RBAC",
        "调整 kubelet",
        "构建镜像",
      ],
      answer: 0,
      rationale: "Jaeger 提供查询、过滤、可视化 Trace 细节。",
    },
    {
      id: "w12-4-q4",
      question: "OTLP 的优势是？",
      options: [
        "统一指标/日志/追踪的传输协议，减少协议转换",
        "仅适用于日志",
        "需要专有代理",
        "不支持加密",
      ],
      answer: 0,
      rationale: "OTLP 标准化传输，支持 gRPC/HTTP 并可 TLS。",
    },
    {
      id: "w12-4-q5",
      question: "快速试用 Jaeger 的方式？",
      options: [
        "部署 jaeger-all-in-one 或运行官方 demo 示例",
        "必须搭建完整生产集群",
        "只能在本地编译",
        "需要修改内核",
      ],
      answer: 0,
      rationale: "官方提供 all-in-one 镜像用于快速体验。",
    },
    {
      id: "w12-4-q6",
      question: "使用 Collector 进行批处理的 processor 是？",
      options: [
        "batch 处理器，可聚合/限速再导出",
        "memory_limiter",
        "routing",
        "k8sattributes",
      ],
      answer: 0,
      rationale: "batch 处理器是常用组件以提高吞吐和控制导出频率。",
    },
    {
      id: "w12-4-q7",
      question: "配置服务名的常见方式？",
      options: [
        "在 SDK/环境变量（如 OTEL_SERVICE_NAME）中设置",
        "由 Collector 自动生成随机名",
        "只能写在 Jaeger UI",
        "不需要设置",
      ],
      answer: 0,
      rationale: "OTel SDK 与 Collector 支持通过 env 设定服务名。",
    },
    {
      id: "w12-4-q8",
      question: "将 OTLP 数据导出到 Jaeger 的配置思路？",
      options: [
        "Collector 接收 OTLP -> 可选处理 -> 导出到 jaeger exporter/HTTP gRPC 端点",
        "应用直接写数据库",
        "必须使用 Zipkin exporter",
        "只能通过日志",
      ],
      answer: 0,
      rationale: "Collector 支持 jaeger exporter 或 OTLP -> Jaeger 接收端。",
    },
    {
      id: "w12-4-q9",
      question: "Jaeger 组件中负责接收代理流量的是？",
      options: [
        "Jaeger Agent（或采集器接收端）负责接收客户端/SDK 数据",
        "Query 服务",
        "UI",
        "Prometheus",
      ],
      answer: 0,
      rationale: "Agent/Collector 接收并处理数据，Query/UI 供查询展示。",
    },
    {
      id: "w12-4-q10",
      question: "OTel Demo 展示了什么？",
      options: [
        "完整示例应用 + Collector + 后端，演示追踪/指标/日志的接入",
        "仅日志功能",
        "仅指标功能",
        "只包含 CLI",
      ],
      answer: 0,
      rationale: "官方 demo 提供端到端可观测性示例，便于学习。",
    },
  ],
  // Week 11
  "w11-1": [
    {
      id: "w11-1-q1",
      question: "Prometheus 默认的采集模型是？",
      options: [
        "Pull：定期从目标端点抓取 /metrics 暴露的指标",
        "Push：目标主动推送到 Prometheus",
        "仅通过日志收集",
        "依赖消息队列",
      ],
      answer: 0,
      rationale: "架构文档指出 Prom 采用拉取模式，必要时可用 Pushgateway 适配短任务。",
    },
    {
      id: "w11-1-q2",
      question: "Exporter 的作用是？",
      options: [
        "将系统/应用指标暴露为 Prometheus 可抓取的 HTTP 接口",
        "存储 TSDB 数据",
        "提供告警通知",
        "替代 Service Discovery",
      ],
      answer: 0,
      rationale: "Exporter 负责适配不同系统并以文本格式导出指标。",
    },
    {
      id: "w11-1-q3",
      question: "Prometheus TSDB 的存储单元是？",
      options: [
        "以时间块（block）存储，默认每 2 小时一个 block，包含 chunk/WAL",
        "单个大文件",
        "MySQL 表",
        "只存内存不落盘",
      ],
      answer: 0,
      rationale: "存储引擎使用 2h block，带索引/chunk，WAL 加速写入。",
    },
    {
      id: "w11-1-q4",
      question: "prometheus.yml 中 scrape_configs 的作用？",
      options: [
        "定义抓取目标、间隔、relabel/service discovery 配置",
        "配置告警接收人",
        "设置 Grafana 地址",
        "指定日志格式",
      ],
      answer: 0,
      rationale: "抓取配置决定 Prom 如何发现并采集目标。",
    },
    {
      id: "w11-1-q5",
      question: "Alerting 规则触发后如何处理？",
      options: [
        "推送到 Alertmanager 进行分组、路由、通知与静默",
        "直接发邮件",
        "存入 TSDB",
        "写入 kube-apiserver",
      ],
      answer: 0,
      rationale: "Prometheus 将告警发送给 Alertmanager，再由后者通知。",
    },
    {
      id: "w11-1-q6",
      question: "Remote Write 的用途？",
      options: [
        "将采集数据流式发送到远端存储/长时序数据库",
        "发送日志",
        "推送配置",
        "导出 Grafana Dashboard",
      ],
      answer: 0,
      rationale: "Remote Write 允许扩展存储/聚合，如 Cortex/Mimir/VictoriaMetrics。",
    },
    {
      id: "w11-1-q7",
      question: "Pushgateway 适用于什么场景？",
      options: [
        "短生命周期/批处理任务无法被定期拉取时临时上报指标",
        "长时间运行服务",
        "存储日志",
        "替代 Alertmanager",
      ],
      answer: 0,
      rationale: "Pushgateway 缓存短任务指标供 Prom 抓取，不适合一般服务。",
    },
    {
      id: "w11-1-q8",
      question: "Prometheus 暴露的指标格式是？",
      options: [
        "文本 exposition 格式（# HELP/# TYPE + name value）",
        "JSON",
        "CSV",
        "XML",
      ],
      answer: 0,
      rationale: "标准指标格式是纯文本，包含 HELP/TYPE 与样本行。",
    },
    {
      id: "w11-1-q9",
      question: "常见的服务发现方式包括？",
      options: [
        "Kubernetes 服务发现、文件静态配置、Consul、DNS 等",
        "只能静态配置",
        "仅支持 AWS",
        "必须使用 etcd",
      ],
      answer: 0,
      rationale: "Prometheus 支持多种 SD 插件，K8s 集成是常见用法。",
    },
    {
      id: "w11-1-q10",
      question: "保留时长与存储容量如何控制？",
      options: [
        "--storage.tsdb.retention.time/size 或通过 flags/配置调整",
        "无法控制，固定 15 天",
        "仅能通过删除数据目录",
        "必须修改源码",
      ],
      answer: 0,
      rationale: "retention 选项可设置时间或大小限制。",
    },
  ],
  "w11-2": [
    {
      id: "w11-2-q1",
      question: "PromQL 中 rate 与 irate 的差别？",
      options: [
        "rate 使用整个区间回归估算平均速率；irate 仅使用最后两个点反映瞬时速率",
        "两者相同",
        "irate 只能用于 gauge",
        "rate 只看最后一个点",
      ],
      answer: 0,
      rationale: "rate 平滑，irate 敏感；文档建议监控趋势用 rate。",
    },
    {
      id: "w11-2-q2",
      question: "sum by (job) (rate(http_requests_total[5m])) 的含义？",
      options: [
        "按 job 维度汇总 5 分钟窗口内每秒请求速率",
        "计算当前瞬时值",
        "过滤掉 job 标签",
        "求最大值",
      ],
      answer: 0,
      rationale: "sum by 聚合，rate 计算每秒增量。",
    },
    {
      id: "w11-2-q3",
      question: "直方图分位数常用组合是？",
      options: [
        "histogram_quantile(0.95, sum by (le) (rate(<metric>_bucket[5m])))",
        "avg_over_time(metric[5m])",
        "quantile(0.95, metric)",
        "max by (le) (metric)",
      ],
      answer: 0,
      rationale: "官方示例使用 rate + sum by (le) 再计算分位。",
    },
    {
      id: "w11-2-q4",
      question: "向量匹配 on()/ignoring() 的作用？",
      options: [
        "定义二元运算匹配时参与或忽略的标签集合",
        "控制采样频率",
        "设置告警级别",
        "过滤 NaN",
      ],
      answer: 0,
      rationale: "PromQL 二元运算需要明确标签匹配规则。",
    },
    {
      id: "w11-2-q5",
      question: "increase(counter[1h]) 返回什么？",
      options: [
        "过去 1 小时内计数器的增长总量",
        "当前值",
        "每秒速率",
        "最大值",
      ],
      answer: 0,
      rationale: "increase 适用于 counter，返回区间增量。",
    },
    {
      id: "w11-2-q6",
      question: "offset 关键字的作用？",
      options: [
        "取过去/未来偏移时间的样本用于对比（如 rate(http_requests_total[5m] offset 1h)）",
        "偏移标签值",
        "设置时间戳格式",
        "延迟告警",
      ],
      answer: 0,
      rationale: "offset 允许在表达式中引用过去时间的序列。",
    },
    {
      id: "w11-2-q7",
      question: "label_replace 的用途？",
      options: [
        "基于正则添加/修改标签值",
        "删除时间序列",
        "计算速率",
        "设置告警阈值",
      ],
      answer: 0,
      rationale: "label_replace 可在聚合前调整标签，文档给出示例。",
    },
    {
      id: "w11-2-q8",
      question: "Group 左/右（on()/ignoring() + group_left/right）的含义？",
      options: [
        "在向量匹配时允许一对多，保留左/右侧的额外标签",
        "控制算术运算优先级",
        "只在 sum 使用",
        "决定时间窗口大小",
      ],
      answer: 0,
      rationale: "group_left/right 解决一对多匹配并携带额外标签。",
    },
    {
      id: "w11-2-q9",
      question: "absent() 函数用于？",
      options: [
        "当没有匹配的时间序列时返回 1，用于检测缺失/掉线",
        "计算绝对值",
        "返回空结果",
        "统计样本数量",
      ],
      answer: 0,
      rationale: "absent 用于告警缺失数据等场景。",
    },
    {
      id: "w11-2-q10",
      question: "PromQL gauge 与 counter 的区别是？",
      options: [
        "gauge 可上升下降，counter 单调递增（重启归零）",
        "两者相同",
        "counter 只用于内存",
        "gauge 必须 reset",
      ],
      answer: 0,
      rationale: "指标类型文档明确 gauge 可上下波动，counter 单调递增。",
    },
  ],
  "w11-3": [
    {
      id: "w11-3-q1",
      question: "Grafana 添加数据源的常见步骤？",
      options: [
        "在 UI/配置中选择数据源类型（如 Prometheus）并填入 URL/认证信息",
        "必须修改数据库",
        "需要重启 Prometheus",
        "只能通过命令行",
      ],
      answer: 0,
      rationale: "数据源配置可以通过 UI 或 Provisioning 文件。",
    },
    {
      id: "w11-3-q2",
      question: "导入社区 Dashboard 的方式？",
      options: [
        "在 Dashboard -> Import 中输入 ID/上传 JSON",
        "只能手工重建",
        "需要连接数据库",
        "使用 helm install",
      ],
      answer: 0,
      rationale: "Grafana 支持通过 JSON/ID 快速导入。",
    },
    {
      id: "w11-3-q3",
      question: "变量（Templating）的作用？",
      options: [
        "让用户在面板中切换数据集（如集群/namespace），复用同一查询模板",
        "控制登录权限",
        "改变存储周期",
        "启用告警",
      ],
      answer: 0,
      rationale: "变量可动态替换查询参数，提高复用性。",
    },
    {
      id: "w11-3-q4",
      question: "Grafana Explore 模式用于？",
      options: [
        "临时 ad-hoc 查询/调试，快速查看数据源返回",
        "导出 Dashboard",
        "管理用户",
        "配置告警",
      ],
      answer: 0,
      rationale: "Explore 便于交互式排查指标或日志。",
    },
    {
      id: "w11-3-q5",
      question: "Dashboard 可视化类型的示例？",
      options: [
        "Graph/Time series、Table、Stat、Heatmap 等",
        "只有表格",
        "仅文本",
        "只能折线",
      ],
      answer: 0,
      rationale: "Grafana 提供多种可视化组件。",
    },
    {
      id: "w11-3-q6",
      question: "Grafana Alert（8+）基于什么？",
      options: [
        "基于数据源查询的 Alert Rule，支持多数据源与通知渠道",
        "仅基于 Prometheus 规则",
        "只能发送邮件",
        "需要修改 kubelet",
      ],
      answer: 0,
      rationale: "Grafana 内置告警可跨数据源配置通知。",
    },
    {
      id: "w11-3-q7",
      question: "Provisioning Dashboard/DataSource 的好处？",
      options: [
        "以代码/配置文件管理仪表板和数据源，便于版本化与自动化部署",
        "只能手工调整",
        "会禁用 UI",
        "仅适用于本地",
      ],
      answer: 0,
      rationale: "声明式配置提升一致性和可重复性。",
    },
    {
      id: "w11-3-q8",
      question: "使用 Prometheus 数据源查询时，时间区间如何决定？",
      options: [
        "由面板/URL 的 from/to 参数控制，Grafana 会附带 step（分辨率）",
        "固定 5 分钟",
        "由 Prometheus 决定",
        "与告警无关",
      ],
      answer: 0,
      rationale: "Grafana 将 UI 选择的时间窗口传给数据源。",
    },
    {
      id: "w11-3-q9",
      question: "分享 Dashboard 时应注意？",
      options: [
        "导出时可去除敏感数据源信息，或使用 snapshot 仅含渲染数据",
        "必须公开数据源密码",
        "无法共享",
        "只能截图",
      ],
      answer: 0,
      rationale: "Snapshot/导出可选择是否包含实时数据与凭证。",
    },
    {
      id: "w11-3-q10",
      question: "常见的权限控制做法？",
      options: [
        "使用组织/团队/用户角色（Viewer/Editor/Admin）限制 Dashboard 编辑与数据访问",
        "Grafana 不支持权限",
        "只能通过网络隔离",
        "需要修改 Prometheus",
      ],
      answer: 0,
      rationale: "Grafana 内置分级权限与团队管理。",
    },
  ],
  "w11-4": [
    {
      id: "w11-4-q1",
      question: "Alertmanager 的主要职责是？",
      options: [
        "接收 Prometheus 告警，进行分组、去重、抑制与通知路由",
        "存储指标",
        "生成 Dashboard",
        "调度 Pod",
      ],
      answer: 0,
      rationale: "Alertmanager 负责告警后处理与通知。",
    },
    {
      id: "w11-4-q2",
      question: "路由树（route）配置的核心字段包括？",
      options: [
        "receiver、matchers、group_by、group_wait/interval/timeout",
        "promQL",
        "数据源",
        "kubeconfig",
      ],
      answer: 0,
      rationale: "路由控制如何分组和发送到接收器。",
    },
    {
      id: "w11-4-q3",
      question: "抑制（inhibit rules）的作用？",
      options: [
        "当高优先级/主告警存在时，静音相关低优先级告警",
        "延长告警时间",
        "提高告警频率",
        "删除告警",
      ],
      answer: 0,
      rationale: "抑制规则防止同一事件产生噪声告警。",
    },
    {
      id: "w11-4-q4",
      question: "Silence 与 Inhibit 的区别？",
      options: [
        "Silence 是临时静默基于匹配器；Inhibit 依赖另一告警触发才静默",
        "两者相同",
        "Silence 只能在 CLI 使用",
        "Inhibit 只能静默全部告警",
      ],
      answer: 0,
      rationale: "Silence 是手工/时间窗口静默，Inhibit 是告警间依赖。",
    },
    {
      id: "w11-4-q5",
      question: "Alertmanager HA 的特点？",
      options: [
        "多个实例通过 gossip 协调状态，需共享或同步 silence/notification 状态",
        "必须使用单节点",
        "依赖 etcd",
        "与 Prometheus 无法同时 HA",
      ],
      answer: 0,
      rationale: "官方建议至少两个实例，使用 mesh 同步静默等状态。",
    },
    {
      id: "w11-4-q6",
      question: "常见的通知渠道（receivers）包括？",
      options: [
        "Email、Slack/Webhook、PagerDuty/OPS 工具等",
        "仅 Email",
        "只能写文件",
        "仅短信",
      ],
      answer: 0,
      rationale: "Alertmanager 支持多种 receiver 类型及自定义 webhook。",
    },
    {
      id: "w11-4-q7",
      question: "group_wait/group_interval 的意义？",
      options: [
        "控制分组后的首个通知等待时间及后续通知间隔，避免告警风暴",
        "设置 CPU 配额",
        "定义告警级别",
        "用于 RBAC",
      ],
      answer: 0,
      rationale: "分组等待可聚合相似告警减少通知量。",
    },
    {
      id: "w11-4-q8",
      question: "resolve_timeout 的作用？",
      options: [
        "在未收到 resolved 通知时，自动在指定时间后标记告警已解决",
        "设置 HTTP 超时",
        "决定重试次数",
        "控制日志输出",
      ],
      answer: 0,
      rationale: "resolve_timeout 保护在长时间无更新时自动标记结束。",
    },
    {
      id: "w11-4-q9",
      question: "模板化通知消息使用的语言是？",
      options: [
        "Go template，Alertmanager 支持在消息中引用标签/注释",
        "Jinja2",
        "Mustache",
        "无模板功能",
      ],
      answer: 0,
      rationale: "Alertmanager 使用 Go 模板定制通知内容。",
    },
    {
      id: "w11-4-q10",
      question: "Prometheus 如何找到 Alertmanager？",
      options: [
        "在 prometheus.yml 中配置 alerting > alertmanagers 地址列表",
        "通过 Service Discovery 自动发现",
        "写入 etcd",
        "需要部署在同一 Pod",
      ],
      answer: 0,
      rationale: "Prom 配置 alertmanagers 节点以推送告警。",
    },
  ],
  // Week 10
  "w10-1": [
    {
      id: "w10-1-q1",
      question: "ArgoCD 的核心组件包括？",
      options: [
        "API Server/Server、Repo Server、Application Controller（可选 Dex）",
        "kube-scheduler 与 kube-proxy",
        "Flannel 与 Calico",
        "Helm Tiller",
      ],
      answer: 0,
      rationale: "官方架构：api-server 提供 UI/CLI，repo-server 渲染，controller 调和。",
    },
    {
      id: "w10-1-q2",
      question: "ArgoCD 管理的自定义资源是？",
      options: ["Application（以及 AppProject）", "Deployment", "ReplicaSet", "CRDDefinition"],
      answer: 0,
      rationale: "ArgoCD 通过 Application CRD 描述要同步的清单。",
    },
    {
      id: "w10-1-q3",
      question: "Repo Server 的职责是？",
      options: [
        "从 Git 拉取仓库并渲染 Kustomize/Helm/Plain YAML",
        "调度 Pod",
        "存储镜像",
        "提供 DNS",
      ],
      answer: 0,
      rationale: "repo-server 负责模板渲染与生成 manifests。",
    },
    {
      id: "w10-1-q4",
      question: "Application Controller 的作用是？",
      options: [
        "比较 Git 期望状态与集群实际状态并执行同步",
        "提供用户登录",
        "存储 Helm Chart",
        "管理节点",
      ],
      answer: 0,
      rationale: "controller 实现持续调和，确保资源与源匹配。",
    },
    {
      id: "w10-1-q5",
      question: "初始管理员密码获取方式？",
      options: [
        "来自 argocd-initial-admin-secret（data.password）",
        "使用 kubectl config view",
        "默认 admin/admin",
        "需要手工生成",
      ],
      answer: 0,
      rationale: "安装后 Secret 中存储初始密码，需修改后删除 Secret。",
    },
    {
      id: "w10-1-q6",
      question: "ArgoCD 支持哪些模板类型？",
      options: [
        "原生 YAML、Kustomize、Helm、Ksonnet（旧）、Jsonnet 等",
        "仅 YAML",
        "仅 Helm",
        "仅 Json",
      ],
      answer: 0,
      rationale: "repo-server 可渲染多种类型。",
    },
    {
      id: "w10-1-q7",
      question: "访问 ArgoCD API/UI 的常见方式？",
      options: [
        "kubectl port-forward svc/argocd-server -n argocd 8080:443",
        "直接访问 kube-apiserver",
        "ssh 到节点",
        "使用 CoreDNS",
      ],
      answer: 0,
      rationale: "文档提供 port-forward 方式快速访问 UI/API。",
    },
    {
      id: "w10-1-q8",
      question: "AppProject 的作用是？",
      options: [
        "定义一组 Application 的边界（源仓库/目标集群/命名空间/白名单）与 RBAC",
        "存储镜像",
        "提供网络策略",
        "管理日志",
      ],
      answer: 0,
      rationale: "项目用于隔离与授权，控制应用可访问的资源范围。",
    },
    {
      id: "w10-1-q9",
      question: "ArgoCD 采用哪种模式获取清单？",
      options: [
        "从 Git/OCI Registry 拉取声明式配置",
        "直接 watch etcd",
        "通过 kubelet 同步",
        "随机生成",
      ],
      answer: 0,
      rationale: "ArgoCD 将 Git/OCI 作为期望状态源。",
    },
    {
      id: "w10-1-q10",
      question: "argocd CLI 与 UI 认证的默认方式？",
      options: [
        "与 argocd-server 交互，使用用户名/密码或 SSO（Dex/OIDC）",
        "直接使用 kubeconfig",
        "不需要认证",
        "仅支持 TLS 客户端证书",
      ],
      answer: 0,
      rationale: "ArgoCD 有自己认证层，可集成 OIDC。",
    },
  ],
  "w10-2": [
    {
      id: "w10-2-q1",
      question: "自动同步的三要素是？",
      options: [
        "syncPolicy.automated 下可启用 prune、自愈（selfHeal）与自动 apply",
        "只需要手动点击 Sync",
        "仅依赖 webhook",
        "需要修改 kube-apiserver",
      ],
      answer: 0,
      rationale: "automated 模式可配置 prune/selfHeal 自动调和漂移。",
    },
    {
      id: "w10-2-q2",
      question: "Prune 的作用？",
      options: [
        "删除 Git 中已移除的资源，保持集群与源一致",
        "清理镜像缓存",
        "重启 Pod",
        "更新 Helm Chart",
      ],
      answer: 0,
      rationale: "Prune 防止残留资源，避免漂移。",
    },
    {
      id: "w10-2-q3",
      question: "SelfHeal 的含义？",
      options: [
        "检测到集群与期望不一致时自动重新同步恢复",
        "自动扩容",
        "自动修复节点",
        "自动更新 Helm repo",
      ],
      answer: 0,
      rationale: "SelfHeal 能在漂移时主动恢复状态。",
    },
    {
      id: "w10-2-q4",
      question: "使用 CLI 触发同步的命令？",
      options: ["argocd app sync <app>", "kubectl rollout sync", "helm sync", "argo sync"],
      answer: 0,
      rationale: "argocd CLI 提供 app sync 立即同步。",
    },
    {
      id: "w10-2-q5",
      question: "Sync Wave 用于？",
      options: [
        "通过注解/字段控制资源同步顺序（数字越小越先）",
        "控制回滚",
        "设置资源配额",
        "配置日志级别",
      ],
      answer: 0,
      rationale: "ArgoCD 支持 sync-wave 注解管理依赖顺序。",
    },
    {
      id: "w10-2-q6",
      question: "Sync Options: CreateNamespace=true 的效果？",
      options: [
        "目标命名空间不存在时自动创建",
        "强制删除命名空间",
        "启用 Helm",
        "忽略 CRD",
      ],
      answer: 0,
      rationale: "同步时可自动创建缺失的 namespace。",
    },
    {
      id: "w10-2-q7",
      question: "同步重试策略可配置什么？",
      options: [
        "重试次数与间隔（backoff），失败后可重试同步",
        "控制副本数",
        "修改 Helm 值",
        "更改 RBAC",
      ],
      answer: 0,
      rationale: "syncPolicy.retry 支持 backoff/limit 设置。",
    },
    {
      id: "w10-2-q8",
      question: "PrunePropagationPolicy/PruneLast 的用途？",
      options: [
        "控制删除级联方式（Foreground/Background）以及是否最后一步再删除",
        "控制日志",
        "调整健康检查",
        "设置超时",
      ],
      answer: 0,
      rationale: "可避免级联删除顺序问题。",
    },
    {
      id: "w10-2-q9",
      question: "Sync Windows 的作用？",
      options: [
        "定义允许/禁止同步的时间窗口，防止敏感时段自动变更",
        "设置 Pod 生命周期",
        "控制日志保留",
        "强制回滚",
      ],
      answer: 0,
      rationale: "Sync Windows 用于运维冻结或限制自动同步时间。",
    },
    {
      id: "w10-2-q10",
      question: "差异比对（Diff）模式可选择？",
      options: [
        "三方合并、忽略特定字段（例如 status/annotations）",
        "仅支持全量",
        "必须手动 patch",
        "只能忽略 metadata",
      ],
      answer: 0,
      rationale: "ArgoCD diff 设置可忽略某些字段，或开启 server-side apply 比对。",
    },
  ],
  "w10-3": [
    {
      id: "w10-3-q1",
      question: "在 ArgoCD 中使用 Kustomize 的常见方式？",
      options: [
        "Application.spec.source 指定 path，kustomize.namePrefix/overlays 等由 repo-server 构建",
        "必须先手动 kustomize build",
        "不支持 Kustomize",
        "只能结合 Helm",
      ],
      answer: 0,
      rationale: "ArgoCD 原生支持 Kustomize 渲染。",
    },
    {
      id: "w10-3-q2",
      question: "管理多环境（dev/prod）的常见做法？",
      options: [
        "为每个环境创建独立 Application，指向不同路径/overlay 或不同 values 文件",
        "在一个 Application 里写多个 namespace",
        "只能一个环境",
        "手动编辑 Pod",
      ],
      answer: 0,
      rationale: "多环境通过不同源路径/参数定义多应用。",
    },
    {
      id: "w10-3-q3",
      question: "Helm 参数在 ArgoCD 中如何覆盖？",
      options: [
        "在 source.helm.valueFiles/parameters 或 helm.parameters 中设置",
        "只能用默认值",
        "必须修改 Chart",
        "使用 ConfigMap",
      ],
      answer: 0,
      rationale: "Application 允许指定值文件和参数覆盖。",
    },
    {
      id: "w10-3-q4",
      question: "destination 字段包含哪些关键子字段？",
      options: [
        "server（集群 API 地址或 https://kubernetes.default.svc）与 namespace",
        "Pod IP 与端口",
        "镜像仓库地址",
        "Helm 仓库",
      ],
      answer: 0,
      rationale: "destination 指定目标集群与命名空间。",
    },
    {
      id: "w10-3-q5",
      question: "AppProject 可以限制什么？",
      options: [
        "允许的源仓库、目标集群/命名空间、可用资源白名单、同步窗口等",
        "只能限制副本数",
        "仅控制日志",
        "仅控制 Helm 版本",
      ],
      answer: 0,
      rationale: "Project 用于团队/环境隔离与安全限制。",
    },
    {
      id: "w10-3-q6",
      question: "同步时自动创建命名空间的选项？",
      options: [
        "syncOptions: [\"CreateNamespace=true\"]",
        "必须手工 kubectl create ns",
        "使用 Helm 钩子",
        "无法创建",
      ],
      answer: 0,
      rationale: "ArgoCD 支持在 syncOptions 中启用创建 namespace。",
    },
    {
      id: "w10-3-q7",
      question: "将目标修订版本设为特定 tag/commit 的字段？",
      options: [
        "targetRevision（支持 branch/tag/commit/hash）",
        "syncPolicy",
        "destination.namespace",
        "project",
      ],
      answer: 0,
      rationale: "Application.source.targetRevision 控制 checkout 的版本。",
    },
    {
      id: "w10-3-q8",
      question: "对 Helm Chart 使用特定 release 名的方式？",
      options: [
        "source.helm.releaseName 指定，或使用 metadata.name 默认",
        "必须与 Application 同名",
        "不可更改",
        "在 values.yaml 中写",
      ],
      answer: 0,
      rationale: "ArgoCD 可自定义 Helm release 名称。",
    },
    {
      id: "w10-3-q9",
      question: "多集群部署同一应用时需注意？",
      options: [
        "为不同 cluster/destination 创建独立 Application，并确保凭证/项目允许",
        "必须复制集群",
        "只能部署一个集群",
        "需要修改 kube-proxy",
      ],
      answer: 0,
      rationale: "ArgoCD 支持多个 destination，每个 Application 指定其目标。",
    },
    {
      id: "w10-3-q10",
      question: "对 Kubernetes 资源使用 Kustomize Patch 的路径是？",
      options: [
        "在 Kustomization.yaml 中指定 patches/overlays 目录",
        "在 Application.metadata 中指定",
        "通过 syncPolicy",
        "必须使用 Helm",
      ],
      answer: 0,
      rationale: "Kustomize overlays/patches 管理差异，ArgoCD 会调用 kustomize build。",
    },
  ],
  "w10-4": [
    {
      id: "w10-4-q1",
      question: "App of Apps 模式的核心做法是？",
      options: [
        "用一个“根” Application 部署其他子 Application 清单，实现级联管理",
        "使用 Helm 安装所有服务",
        "把所有资源放在一个 YAML",
        "只部署 ConfigMap",
      ],
      answer: 0,
      rationale: "根应用指向包含多个 Application 定义的目录，实现层次化管理。",
    },
    {
      id: "w10-4-q2",
      question: "使用 App of Apps 时需注意的删除行为是？",
      options: [
        "删除根应用会连带删除子应用及其托管资源（若启用自动清理）",
        "只删除根应用，不影响子应用",
        "会删除整个集群",
        "无法删除",
      ],
      answer: 0,
      rationale: "级联删除需谨慎，可通过同步策略控制。",
    },
    {
      id: "w10-4-q3",
      question: "为什么 App of Apps 适合集群引导/大规模服务？",
      options: [
        "可分层管理组件，按 Sync Wave 排序，便于拆分团队边界",
        "性能更高",
        "避免使用 Git",
        "减少 YAML 数量到 1 个",
      ],
      answer: 0,
      rationale: "层次化使复杂平台/多服务可控，支持分批同步。",
    },
    {
      id: "w10-4-q4",
      question: "AppProject 权限如何影响 App of Apps？",
      options: [
        "根/子应用必须被所属项目允许创建 Application 资源并访问对应目标",
        "项目不影响",
        "只需 root 应用权限",
        "需要 cluster-admin",
      ],
      answer: 0,
      rationale: "项目白名单需包含 applications 及目的地，否则创建失败。",
    },
    {
      id: "w10-4-q5",
      question: "同步顺序控制在 App of Apps 中如何实现？",
      options: [
        "使用 sync-wave 注解或资源 hook，确保依赖顺序",
        "无法控制顺序",
        "只能靠文件名排序",
        "通过 kube-scheduler",
      ],
      answer: 0,
      rationale: "同步波与 hook 可安排子应用/资源顺序。",
    },
    {
      id: "w10-4-q6",
      question: "根应用引用子应用清单的常见方式？",
      options: [
        "目录模式（directory）开启 recurse 或直接列出多个子 Application YAML",
        "必须使用 Helm Chart",
        "使用 ConfigMap",
        "仅单文件",
      ],
      answer: 0,
      rationale: "可指向包含多个应用定义的目录递归渲染。",
    },
    {
      id: "w10-4-q7",
      question: "避免循环依赖的注意点？",
      options: [
        "不要让子应用再次引用根目录或互相创建对方，保持单向层次",
        "允许任意互指",
        "使用 webhook",
        "依赖 kube-proxy",
      ],
      answer: 0,
      rationale: "循环会导致同步/删除异常，应保持树状结构。",
    },
    {
      id: "w10-4-q8",
      question: "App of Apps 中如何限制子应用的同步策略？",
      options: [
        "在子 Application 中单独设置 syncPolicy/automated/prune",
        "只能继承根应用",
        "无法限制",
        "通过 kubelet 配置",
      ],
      answer: 0,
      rationale: "每个子应用有自己的同步策略与项目限制。",
    },
    {
      id: "w10-4-q9",
      question: "对密钥/敏感配置的最佳实践？",
      options: [
        "结合密钥管理（Vault/SealedSecrets）或外部仓库，避免在 App of Apps 仓库明文存储",
        "直接写入 Git",
        "放在 argocd-cm",
        "通过 ConfigMap 明文存储",
      ],
      answer: 0,
      rationale: "App of Apps 也需遵循密钥管理原则，避免明文。",
    },
    {
      id: "w10-4-q10",
      question: "根应用通常部署到哪个命名空间？",
      options: [
        "argocd 或指定管理命名空间，便于隔离",
        "default",
        "kube-system 必须",
        "任意 Pod 命名空间均可无需考虑",
      ],
      answer: 0,
      rationale: "常将管理类应用放在 argocd 等专用 namespace 方便管理。",
    },
  ],
  // Week 9
  "w9-1": [
    {
      id: "w9-1-q1",
      question: "持续集成（CI）的核心目标是？",
      options: [
        "每次提交自动构建/测试，尽早发现问题",
        "仅在发布时编译",
        "只在本地运行",
        "替代代码评审",
      ],
      answer: 0,
      rationale: "CI 强调频繁集成与自动化验证。",
    },
    {
      id: "w9-1-q2",
      question: "持续交付与持续部署的区别？",
      options: [
        "持续交付交付到可随时上线的阶段，持续部署则自动上线到生产",
        "两者完全相同",
        "持续交付只做测试",
        "持续部署只在本地",
      ],
      answer: 0,
      rationale: "持续部署进一步自动化发布步骤。",
    },
    {
      id: "w9-1-q3",
      question: "云原生 CI/CD 的常见挑战是？",
      options: [
        "镜像构建、K8s 清单管理、环境隔离与安全扫描",
        "缺少代码仓库",
        "无法使用容器",
        "需要手动部署",
      ],
      answer: 0,
      rationale: "容器/集群带来镜像、配置与安全的额外复杂度。",
    },
    {
      id: "w9-1-q4",
      question: "为什么建议在流水线早期进行安全扫描？",
      options: [
        "Shift Left，可尽早阻断漏洞/合规问题，避免后期返工",
        "为了加快部署",
        "与安全无关",
        "只为生成报告",
      ],
      answer: 0,
      rationale: "提前发现问题成本更低。",
    },
    {
      id: "w9-1-q5",
      question: "容器镜像构建的最佳实践之一是？",
      options: [
        "使用可重复的 Dockerfile 并尽量利用缓存/多阶段构建",
        "只在生产环境构建",
        "使用 latest 标签即可",
        "避免使用版本控制",
      ],
      answer: 0,
      rationale: "可重复构建和缓存提高速度与可追溯性。",
    },
    {
      id: "w9-1-q6",
      question: "流水线触发策略常见有哪些？",
      options: [
        "PR/代码提交触发、定时任务、手动触发",
        "仅手动触发",
        "只能定时",
        "只能在合并后",
      ],
      answer: 0,
      rationale: "CI 系统支持多种触发方式覆盖不同场景。",
    },
    {
      id: "w9-1-q7",
      question: "为什么要将制品推送到集中仓库？",
      options: [
        "便于后续部署、追溯与缓存复用",
        "为了删除本地代码",
        "避免使用版本控制",
        "只为计费",
      ],
      answer: 0,
      rationale: "集中制品库确保环境一致与回滚可行。",
    },
    {
      id: "w9-1-q8",
      question: "在云原生环境中部署配置通常如何管理？",
      options: [
        "声明式清单（Kustomize/Helm）存放在 Git，并由流水线或 GitOps 驱动",
        "手工编辑集群",
        "直接在节点上改文件",
        "使用 FTP",
      ],
      answer: 0,
      rationale: "声明式配置配合版本控制是最佳实践。",
    },
    {
      id: "w9-1-q9",
      question: "流水线中常见的质量门槛有？",
      options: [
        "测试覆盖率、Lint、安全扫描、部署前人工审批等",
        "仅看提交次数",
        "无任何校验",
        "只依赖手工测试",
      ],
      answer: 0,
      rationale: "质量门确保标准达标后才继续后续阶段。",
    },
    {
      id: "w9-1-q10",
      question: "容器化 CI 节点的好处？",
      options: [
        "隔离构建环境、可快速弹性扩缩、便于缓存与复用",
        "增加构建时间",
        "无法访问网络",
        "不支持并行",
      ],
      answer: 0,
      rationale: "容器化执行器提供隔离与可扩展性，适合云原生。",
    },
  ],
  "w9-2": [
    {
      id: "w9-2-q1",
      question: "将镜像推送到注册表前需要做什么？",
      options: [
        "登录目标 registry（如使用 docker/login-action 或 Jenkins 凭证）",
        "删除 Dockerfile",
        "修改 kubeconfig",
        "重启集群",
      ],
      answer: 0,
      rationale: "推送前需认证 registry，否则会被拒绝。",
    },
    {
      id: "w9-2-q2",
      question: "GitHub Actions 构建镜像的常见步骤是？",
      options: [
        "actions/checkout -> 设置 Buildx/登录 -> docker build/push -> 输出 digest",
        "仅运行 npm install",
        "直接 kubectl apply",
        "修改 etcd",
      ],
      answer: 0,
      rationale: "官方示例使用 checkout、buildx、login、build-push 动作。",
    },
    {
      id: "w9-2-q3",
      question: "为何推荐使用唯一 tag（如 commit SHA）推送镜像？",
      options: [
        "保证可追溯与幂等部署，避免 latest 漂移",
        "减小镜像体积",
        "避免需要登录",
        "防止缓存命中",
      ],
      answer: 0,
      rationale: "唯一 tag 便于回滚与追踪。",
    },
    {
      id: "w9-2-q4",
      question: "Jenkins Pipeline 推镜像常用的语法是？",
      options: [
        "docker.build(...).push() 或使用 withCredentials 登录后 push",
        "kubectl push",
        "git push 镜像",
        "helm push",
      ],
      answer: 0,
      rationale: "Jenkins 支持 Docker Pipeline 插件进行 build/push。",
    },
    {
      id: "w9-2-q5",
      question: "为什么在 CI 中启用 BuildKit/Buildx？",
      options: [
        "获得缓存、并行、多架构构建等能力",
        "减少安全性",
        "只能在本地使用",
        "会禁用多阶段",
      ],
      answer: 0,
      rationale: "Buildx 提供高性能和多架构支持。",
    },
    {
      id: "w9-2-q6",
      question: "如何保护 registry 凭证？",
      options: [
        "存放在 CI 的 Secret/凭证管理中，避免写入仓库",
        "直接写在 Dockerfile",
        "提交到 Git",
        "硬编码到镜像",
      ],
      answer: 0,
      rationale: "敏感信息应存储在安全的 Secret 管理器。",
    },
    {
      id: "w9-2-q7",
      question: "构建完成后通常需要产出什么供后续阶段使用？",
      options: [
        "镜像 tag/digest、制品元数据（artifact）",
        "Pod YAML",
        "etcd 备份",
        "SSH 密钥",
      ],
      answer: 0,
      rationale: "后续部署/扫描需要知道镜像标识与工件路径。",
    },
    {
      id: "w9-2-q8",
      question: "GitHub Actions 中缓存依赖的常用方式？",
      options: [
        "actions/cache 或 buildx cache-from/cache-to",
        "禁用缓存",
        "手写文件",
        "使用 Helm",
      ],
      answer: 0,
      rationale: "缓存可显著缩短构建时间。",
    },
    {
      id: "w9-2-q9",
      question: "在流水线中使用 docker layer 缓存的前提？",
      options: [
        "稳定的构建上下文与合理的 Dockerfile 指令顺序",
        "关闭缓存",
        "必须使用 root",
        "只能在 Jenkins 使用",
      ],
      answer: 0,
      rationale: "缓存命中取决于上下文未变化与层顺序。",
    },
    {
      id: "w9-2-q10",
      question: "推送镜像失败常见原因？",
      options: [
        "未登录/权限不足、网络不可达、tag 冲突或 registry 地址错误",
        "Dockerfile 缺少 FROM",
        "Pod 重启",
        "kube-proxy 版本过低",
      ],
      answer: 0,
      rationale: "需检查认证、网络与仓库地址/权限。",
    },
  ],
  "w9-3": [
    {
      id: "w9-3-q1",
      question: "Trivy 可以扫描哪些对象？",
      options: [
        "容器镜像、文件系统、Git repo/制品等",
        "仅镜像",
        "只能扫描主机",
        "只能扫描 Pod",
      ],
      answer: 0,
      rationale: "Trivy 支持 image/fs/repo 等多种目标。",
    },
    {
      id: "w9-3-q2",
      question: "在 CI 中希望发现高危漏洞就失败，通常怎么配置？",
      options: [
        "设置 severity/exit-code（如 --severity HIGH,CRITICAL --exit-code 1）",
        "只打印日志",
        "修改 kubelet",
        "无法配置",
      ],
      answer: 0,
      rationale: "Trivy 提供 severity 和 exit-code 控制流水线是否失败。",
    },
    {
      id: "w9-3-q3",
      question: "为什么要缓存 Trivy 数据库？",
      options: [
        "减少每次更新漏洞数据库的时间，加快扫描",
        "提升安全性",
        "避免扫描",
        "为了删除镜像",
      ],
      answer: 0,
      rationale: "缓存 DB 可显著减少扫描时延。",
    },
    {
      id: "w9-3-q4",
      question: "Trivy GitHub Action 的常用配置参数包括？",
      options: [
        "image/ref、severity、vuln-type、ignore-unfixed、format 等",
        "podSelector、policyTypes",
        "helmVersion",
        "kubeconfig",
      ],
      answer: 0,
      rationale: "Action 支持指定目标镜像、漏洞类型、输出格式等。",
    },
    {
      id: "w9-3-q5",
      question: "扫描结果的处理最佳实践是？",
      options: [
        "输出报告/工件供审计，并与基线比较修复后再继续部署",
        "忽略所有输出",
        "只在生产扫描",
        "删除 state",
      ],
      answer: 0,
      rationale: "报告应保留并驱动修复流程。",
    },
    {
      id: "w9-3-q6",
      question: "Trivy 可以检测的类型包含？",
      options: [
        "OS 包漏洞与应用依赖（如 npm/pip），还支持 misconfiguration",
        "仅 OS 包",
        "仅配置错误",
        "只能扫描 Dockerfile",
      ],
      answer: 0,
      rationale: "Trivy 支持多类型扫描，包括 IaC 配置。",
    },
    {
      id: "w9-3-q7",
      question: "在流水线中通常把安全扫描放在哪个阶段？",
      options: [
        "构建镜像后、部署前（或作为质量门）",
        "部署完成后再扫描",
        "只在开发机",
        "不需要扫描",
      ],
      answer: 0,
      rationale: "构建后扫描能阻断高危镜像进入生产。",
    },
    {
      id: "w9-3-q8",
      question: "忽略未修复漏洞的参数是？",
      options: [
        "--ignore-unfixed",
        "--skip-files",
        "--timeout",
        "--light",
      ],
      answer: 0,
      rationale: "ignore-unfixed 可过滤暂未有补丁的漏洞。",
    },
    {
      id: "w9-3-q9",
      question: "为什么要在 CI 中固定 Trivy 版本？",
      options: [
        "确保结果可复现，避免版本变动影响扫描策略",
        "为了增加漏洞数量",
        "不需要固定",
        "减少网络流量",
      ],
      answer: 0,
      rationale: "固定工具版本是可重复性的常见做法。",
    },
    {
      id: "w9-3-q10",
      question: "Trivy 失败的常见原因？",
      options: [
        "无法拉取镜像、网络访问数据库失败、权限不足或格式参数错误",
        "Helm 安装失败",
        "kubelet 崩溃",
        "PodNotReady",
      ],
      answer: 0,
      rationale: "需检查镜像可达性、网络与参数配置。",
    },
  ],
  "w9-4": [
    {
      id: "w9-4-q1",
      question: "GitOps 的核心思想是？",
      options: [
        "以 Git 作为单一事实源，集群状态通过控制器与仓库声明保持一致",
        "直接在集群上改配置",
        "手动 SSH 部署",
        "仅用于备份",
      ],
      answer: 0,
      rationale: "GitOps 强调声明式配置与自动调和。",
    },
    {
      id: "w9-4-q2",
      question: "Push 与 Pull 模式的区别？",
      options: [
        "Push 由 CI 直接部署到集群，Pull 由集群内控制器从 Git 拉取/调和",
        "Pull 需要人工确认",
        "Push 更安全",
        "两者相同",
      ],
      answer: 0,
      rationale: "ArgoCD/Flux 采用 Pull 模式，CI 触发或 Webhook 通知。",
    },
    {
      id: "w9-4-q3",
      question: "GitOps 带来的好处包括？",
      options: [
        "审计可追溯、易回滚、减少手工漂移",
        "部署速度必然变慢",
        "无需权限控制",
        "消除测试需求",
      ],
      answer: 0,
      rationale: "版本控制与自动调和带来可追溯性与一致性。",
    },
    {
      id: "w9-4-q4",
      question: "为什么要避免直接在集群内手动改对象？",
      options: [
        "会造成漂移，GitOps 控制器会回滚或冲突，且无法审计",
        "更安全",
        "无法修改",
        "因为会影响 kube-proxy",
      ],
      answer: 0,
      rationale: "手动修改与 Git 源脱节，影响一致性和审计。",
    },
    {
      id: "w9-4-q5",
      question: "触发 GitOps 同步的常见方式？",
      options: [
        "轮询 Git/仓库 Webhook 或手动 Sync",
        "仅在节点重启时",
        "只能手动 SSH",
        "通过 kubelet 重启",
      ],
      answer: 0,
      rationale: "控制器支持定期拉取或接收 Webhook 触发同步。",
    },
    {
      id: "w9-4-q6",
      question: "GitOps 声明文件通常包含？",
      options: [
        "Kubernetes 清单/Helm/Kustomize 配置",
        "仅二进制镜像",
        "数据库快照",
        "etcd 配置",
      ],
      answer: 0,
      rationale: "Git 里保存声明式配置，控制器据此部署。",
    },
    {
      id: "w9-4-q7",
      question: "常见 GitOps 工具有？",
      options: ["ArgoCD、Flux", "Helm 和 Kustomize", "Jenkins 和 Git", "kubectl 和 kubeadm"],
      answer: 0,
      rationale: "ArgoCD/Flux 是 GitOps 控制器代表。",
    },
    {
      id: "w9-4-q8",
      question: "GitOps 如何实现回滚？",
      options: [
        "回退 Git 提交，控制器自动同步到旧版本",
        "手动删除资源",
        "修改节点标签",
        "重启 kubelet",
      ],
      answer: 0,
      rationale: "Git 历史即版本控制，控制器调和到对应状态。",
    },
    {
      id: "w9-4-q9",
      question: "为避免越权访问，GitOps Controller 通常使用？",
      options: [
        "最小权限的 ServiceAccount/RBAC，限制仅能管理目标命名空间/资源",
        "集群管理员账户",
        "root 用户",
        "无需凭证",
      ],
      answer: 0,
      rationale: "遵循最小权限原则降低风险。",
    },
    {
      id: "w9-4-q10",
      question: "将应用声明与集群基座配置分仓的好处？",
      options: [
        "降低耦合，便于团队分工与权限控制",
        "减少 Git 文件数量",
        "避免使用 CI",
        "使回滚更困难",
      ],
      answer: 0,
      rationale: "分层仓库便于职责划分与独立演进。",
    },
  ],
  // Week 8
  "w8-1": [
    {
      id: "w8-1-q1",
      question: "terraform init 的作用是？",
      options: [
        "下载 provider/模块并初始化工作目录",
        "执行计划",
        "销毁资源",
        "生成文档",
      ],
      answer: 0,
      rationale: "init 会安装 provider、初始化 backend 等。",
    },
    {
      id: "w8-1-q2",
      question: "state 文件默认存放在哪里？",
      options: [
        "当前工作目录的 terraform.tfstate（可配置远端后端）",
        "etcd",
        "云厂商自动托管",
        "不存在 state",
      ],
      answer: 0,
      rationale: "默认本地 tfstate，生产常配置 S3/GCS 等远端后端。",
    },
    {
      id: "w8-1-q3",
      question: "查看计划但不执行的命令？",
      options: ["terraform plan", "terraform preview", "terraform show", "terraform fmt"],
      answer: 0,
      rationale: "plan 用于生成并显示执行计划。",
    },
    {
      id: "w8-1-q4",
      question: "HCL 中定义资源的基本语法？",
      options: [
        "resource \"<provider_resource>\" \"<name>\" { ... }",
        "resources: {...}",
        "module {...}",
        "apply {...}",
      ],
      answer: 0,
      rationale: "Terraform 资源块使用 resource 关键字与类型、名称。",
    },
    {
      id: "w8-1-q5",
      question: "变量值的常见传递方式？",
      options: [
        "tfvars 文件、环境变量 TF_VAR_x、命令行 -var/-var-file",
        "只能硬编码",
        "必须在 main.tf 顶部定义",
        "仅支持环境变量",
      ],
      answer: 0,
      rationale: "官方推荐使用 tfvars 或环境变量传递变量值。",
    },
    {
      id: "w8-1-q6",
      question: "terraform apply -auto-approve 的作用？",
      options: [
        "跳过交互确认直接执行计划",
        "生成文档",
        "格式化代码",
        "仅验证语法",
      ],
      answer: 0,
      rationale: "auto-approve 适合 CI 中无人值守执行。",
    },
    {
      id: "w8-1-q7",
      question: "使用远程后端（如 S3 + DynamoDB）能解决什么问题？",
      options: [
        "共享/锁定 state，避免多人并发修改冲突",
        "加速镜像下载",
        "替代 provider",
        "自动创建 IAM",
      ],
      answer: 0,
      rationale: "远端 backend 支持状态锁与集中存储。",
    },
    {
      id: "w8-1-q8",
      question: "data 源块的用途？",
      options: [
        "读取现有资源/信息供配置引用",
        "创建资源",
        "删除资源",
        "生成文档",
      ],
      answer: 0,
      rationale: "data source 用于查询已有资源，如 AMI、VPC 等。",
    },
    {
      id: "w8-1-q9",
      question: ".terraform.lock.hcl 的意义？",
      options: [
        "锁定 provider 版本以保证一致性",
        "存储敏感密钥",
        "保存计划文件",
        "记录资源依赖",
      ],
      answer: 0,
      rationale: "锁文件记录精确 provider 版本，便于可重复构建。",
    },
    {
      id: "w8-1-q10",
      question: "terraform destroy 会做什么？",
      options: [
        "根据 state 计划并销毁所有受管资源",
        "删除代码文件",
        "仅删除本地 state",
        "升级 provider",
      ],
      answer: 0,
      rationale: "destroy 会对 state 中资源执行删除操作。",
    },
  ],
  "w8-2": [
    {
      id: "w8-2-q1",
      question: "创建 EKS/GKE 集群前通常需要哪些底层资源？",
      options: [
        "VPC/子网/安全组（或 GCP 网络与子网）等网络资源",
        "仅需要 IAM 用户",
        "只要 Kubernetes 清单",
        "必须预先创建 Pod",
      ],
      answer: 0,
      rationale: "EKS/GKE 需要网络与 IAM 等基础设施，Terraform 可一并管理。",
    },
    {
      id: "w8-2-q2",
      question: "aws_eks_cluster 创建后工作节点通常由什么管理？",
      options: [
        "托管节点组 aws_eks_node_group 或自管理 ASG",
        "自动创建 Pod",
        "无需节点即可运行",
        "CloudFormation 外部模板",
      ],
      answer: 0,
      rationale: "Terraform 可创建托管节点组或自管 AutoScaling Group。",
    },
    {
      id: "w8-2-q3",
      question: "获取 kubeconfig 的常见做法？",
      options: [
        "使用输出的 endpoint/证书或 aws/gcloud CLI 生成配置",
        "直接 kubectl apply",
        "编辑 state 文件",
        "使用 Helm 生成",
      ],
      answer: 0,
      rationale: "Terraform 输出集群信息，可配合 AWS CLI/GCloud 写入 kubeconfig。",
    },
    {
      id: "w8-2-q4",
      question: "GKE 集群资源名称是？",
      options: ["google_container_cluster", "gke_cluster", "google_kubernetes", "google_cluster_v2"],
      answer: 0,
      rationale: "GCP 提供 google_container_cluster 资源创建 GKE。",
    },
    {
      id: "w8-2-q5",
      question: "EKS 工作节点访问集群 API 需要什么？",
      options: [
        "适当的 IAM 角色/Instance Profile，并在 aws-auth ConfigMap 中映射",
        "不需要 IAM",
        "使用 service account token",
        "修改 kube-proxy",
      ],
      answer: 0,
      rationale: "节点角色需要在 aws-auth 中映射为 system:node。",
    },
    {
      id: "w8-2-q6",
      question: "删除集群时常见的遗留资源是什么？",
      options: [
        "外部 Load Balancer/EBS 卷等，需确认依赖被清理",
        "ConfigMap",
        "Pod 日志",
        "Helm release",
      ],
      answer: 0,
      rationale: "云资源可能因保护策略保留，需要额外销毁。",
    },
    {
      id: "w8-2-q7",
      question: "为什么推荐使用官方模块（如 terraform-aws-eks）？",
      options: [
        "封装了安全/可用性最佳实践，简化配置",
        "无法自定义",
        "只适合测试",
        "会锁死版本",
      ],
      answer: 0,
      rationale: "社区模块减少样板代码并内置合理默认。",
    },
    {
      id: "w8-2-q8",
      question: "配置 Terraform Provider 访问 AWS/GCP 的常见方式？",
      options: [
        "环境变量/共享凭证文件或通过 Cloud SDK 注入的临时凭证",
        "必须写死在代码里",
        "只能使用 kubeconfig",
        "需要本地 etcd",
      ],
      answer: 0,
      rationale: "Provider 支持多种安全的凭证加载方式。",
    },
    {
      id: "w8-2-q9",
      question: "使用 WaitForFirstConsumer 类似的功能在节点组/卷时的意义？",
      options: [
        "确保资源放置与可用区拓扑匹配，避免跨区",
        "提升日志性能",
        "减少 Helm 冲突",
        "避免拉取镜像",
      ],
      answer: 0,
      rationale: "拓扑感知可以避免创建错误区域的资源。",
    },
    {
      id: "w8-2-q10",
      question: "维护 Terraform 与集群内手工变更的关系应？",
      options: [
        "尽量通过 Terraform 管理基础设施，手工改动需导入或避免漂移",
        "随意手工修改",
        "删除 state 即可",
        "完全依赖 kubectl",
      ],
      answer: 0,
      rationale: "手工更改可能导致 state 漂移，需 plan/apply 或 import 修正。",
    },
  ],
  "w8-3": [
    {
      id: "w8-3-q1",
      question: "Ansible Playbook 的基本结构包含？",
      options: [
        "hosts、tasks、vars（可选）、handlers 等",
        "apiVersion、kind、spec",
        "Dockerfile 指令",
        "Makefile 目标",
      ],
      answer: 0,
      rationale: "Playbook 以 YAML 描述任务、目标主机和变量。",
    },
    {
      id: "w8-3-q2",
      question: "Ansible 连接方式的特点？",
      options: [
        "默认使用 SSH 无 Agent，不需在目标主机安装守护进程",
        "需要在目标机安装 Agent",
        "使用 HTTP API",
        "必须有 VPN",
      ],
      answer: 0,
      rationale: "Ansible 无 Agent，依赖 SSH/WinRM 等远程协议。",
    },
    {
      id: "w8-3-q3",
      question: "模块的作用是什么？",
      options: [
        "提供幂等操作单元（如 package/file/service），由任务调用",
        "定义变量",
        "渲染模板",
        "存储日志",
      ],
      answer: 0,
      rationale: "模块是 Ansible 任务的执行单元，强调幂等。",
    },
    {
      id: "w8-3-q4",
      question: "handlers 何时被触发？",
      options: [
        "被任务 notify 时，在 play 末尾或指定时机运行",
        "总是立即运行",
        "随机执行",
        "只能在失败时执行",
      ],
      answer: 0,
      rationale: "handlers 被 notify 触发，常用于重启服务。",
    },
    {
      id: "w8-3-q5",
      question: "gather_facts 的默认行为？",
      options: [
        "默认 true，会在 play 开始收集目标主机事实（硬件/OS 信息）",
        "默认关闭",
        "仅收集网络信息",
        "只在失败时执行",
      ],
      answer: 0,
      rationale: "收集 facts 便于后续任务使用变量。",
    },
    {
      id: "w8-3-q6",
      question: "以不同用户执行任务的方式？",
      options: [
        "使用 become/become_user 提升或切换身份",
        "必须手动 ssh",
        "只能使用 root",
        "通过修改 hosts 文件",
      ],
      answer: 0,
      rationale: "become 提供 sudo 等提权能力。",
    },
    {
      id: "w8-3-q7",
      question: "检查模式（--check）的作用？",
      options: [
        "模拟执行并显示将做的变更，不实际修改",
        "强制执行所有任务",
        "禁用幂等",
        "只运行 handlers",
      ],
      answer: 0,
      rationale: "check mode 用于预览变更，类似 dry-run。",
    },
    {
      id: "w8-3-q8",
      question: "inventory 的作用？",
      options: [
        "定义目标主机和分组，供 play 选择",
        "存储变量",
        "保存日志",
        "管理依赖",
      ],
      answer: 0,
      rationale: "Inventory 列出主机与组，是执行范围的基础。",
    },
    {
      id: "w8-3-q9",
      question: "运行 playbook 的命令示例？",
      options: [
        "ansible-playbook -i inventory site.yml",
        "ansible run site.yml",
        "ansible exec site.yml",
        "kubectl apply -f site.yml",
      ],
      answer: 0,
      rationale: "ansible-playbook 是标准执行入口。",
    },
    {
      id: "w8-3-q10",
      question: "模板渲染使用什么引擎？",
      options: [
        "Jinja2，可通过 template 模块渲染到目标文件",
        "Go template",
        "Mustache",
        "无模板功能",
      ],
      answer: 0,
      rationale: "Ansible 使用 Jinja2 渲染模板和变量。",
    },
  ],
  "w8-4": [
    {
      id: "w8-4-q1",
      question: "Terraform 与 Ansible 组合的常见分工是？",
      options: [
        "Terraform 负责基础设施/云资源，Ansible 负责主机配置与软件部署",
        "两者都只做配置",
        "Ansible 管理云资源，Terraform 管理应用",
        "只能二选一",
      ],
      answer: 0,
      rationale: "基础设施即代码与配置管理分层，避免重复。",
    },
    {
      id: "w8-4-q2",
      question: "如何将 Terraform 产出的主机信息提供给 Ansible？",
      options: [
        "通过 Terraform output（或 remote state）生成动态 inventory/hosts 文件",
        "手动复制到 YAML",
        "只能静态写死",
        "使用 Helm",
      ],
      answer: 0,
      rationale: "输出可被 Ansible 动态 inventory 脚本或插件消费。",
    },
    {
      id: "w8-4-q3",
      question: "常见的流水线顺序是？",
      options: [
        "terraform apply -> 生成/刷新 inventory -> ansible-playbook 部署配置",
        "ansible-playbook -> terraform apply",
        "同时运行两者",
        "先运行 kubectl",
      ],
      answer: 0,
      rationale: "需要先有基础设施再做配置。",
    },
    {
      id: "w8-4-q4",
      question: "为什么需要管理 SSH 密钥或凭证？",
      options: [
        "Ansible 通过 SSH 连接新建节点，需要凭证；Terraform 也可能创建这些密钥",
        "只要有 kubeconfig 即可",
        "Terraform 会自动创建密码",
        "无需凭证",
      ],
      answer: 0,
      rationale: "访问节点必须有 SSH 密钥/密码，通常由 Terraform 创建或预置。",
    },
    {
      id: "w8-4-q5",
      question: "保持状态一致性的最佳实践是？",
      options: [
        "避免手工更改；Terraform state 与 Ansible 期望应保持一致，漂移需修复",
        "手工修改即可",
        "删除 state 文件",
        "频繁重建集群",
      ],
      answer: 0,
      rationale: "漂移会导致不可预测结果，应通过代码更改并更新 state。",
    },
    {
      id: "w8-4-q6",
      question: "如何使用 Ansible 配置 Terraform 创建的 K8s 集群？",
      options: [
        "使用 Ansible k8s/kubectl 模块并引用 Terraform 输出的 kubeconfig/endpoint",
        "必须登录节点手工执行",
        "需要重新创建集群",
        "只能用 Helm",
      ],
      answer: 0,
      rationale: "Ansible 可以消费输出的 kubeconfig 执行 Kubernetes 任务。",
    },
    {
      id: "w8-4-q7",
      question: "Terraform local-exec/provisioner 用于？",
      options: [
        "在资源创建阶段触发本地命令（如生成 inventory/调用 Ansible），但不宜滥用",
        "代替 provider",
        "自动销毁资源",
        "配置 RBAC",
      ],
      answer: 0,
      rationale: "provisioner 可用于轻量衔接，但官方建议尽量保持声明式。",
    },
    {
      id: "w8-4-q8",
      question: "为何推荐使用 Ansible Roles？",
      options: [
        "模块化可复用，便于在 Terraform 创建的不同环境重复应用配置",
        "因为 Terraform 需要",
        "避免使用变量",
        "提升执行速度",
      ],
      answer: 0,
      rationale: "Role 将任务/文件/模板分层，提高复用与维护性。",
    },
    {
      id: "w8-4-q9",
      question: "动态 Inventory 的优势是？",
      options: [
        "自动根据 Terraform state/云 API 生成主机列表，避免手写",
        "更安全的密码存储",
        "提升网络性能",
        "必须配合 Helm",
      ],
      answer: 0,
      rationale: "动态 inventory 确保最新主机信息，减少人为错误。",
    },
    {
      id: "w8-4-q10",
      question: "分离 Terraform 与 Ansible 状态的原因？",
      options: [
        "二者职责不同，Terraform 维护基础设施 state，Ansible 依靠幂等任务而非集中 state",
        "便于加密",
        "为了提升 CI 速度",
        "否则无法使用 Helm",
      ],
      answer: 0,
      rationale: "保持职责分离使各自管理方式与恢复流程清晰。",
    },
  ],
  // Week 7
  "w7-1": [
    {
      id: "w7-1-q1",
      question: "Role 与 ClusterRole 的区别？",
      options: [
        "Role 作用于单个 Namespace，ClusterRole 可跨命名空间或集群级资源",
        "ClusterRole 只能用于节点",
        "两者完全相同",
        "Role 只能绑定用户，ClusterRole 只能绑定 ServiceAccount",
      ],
      answer: 0,
      rationale: "RBAC 文档定义作用域不同：Role 为 namespace 内，ClusterRole 可跨 namespace。",
    },
    {
      id: "w7-1-q2",
      question: "RoleBinding vs ClusterRoleBinding？",
      options: [
        "RoleBinding 作用于命名空间，可绑定 Role/ClusterRole；ClusterRoleBinding 跨全局",
        "RoleBinding 只能绑定 ClusterRole",
        "ClusterRoleBinding 只能绑定用户",
        "二者无差异",
      ],
      answer: 0,
      rationale: "绑定决定权限作用范围。",
    },
    {
      id: "w7-1-q3",
      question: "RBAC 规则中的动词 verbs 示例有？",
      options: [
        "get/list/watch/create/update/patch/delete",
        "allow/deny",
        "read/write/execute",
        "open/close",
      ],
      answer: 0,
      rationale: "RBAC verbs 与 API 操作对应。",
    },
    {
      id: "w7-1-q4",
      question: "subjects 可以包含哪些类型？",
      options: [
        "User、Group、ServiceAccount（以及外部用户标识）",
        "只有用户",
        "只有 ServiceAccount",
        "仅节点",
      ],
      answer: 0,
      rationale: "RoleBinding 支持多种主体类型。",
    },
    {
      id: "w7-1-q5",
      question: "授予某 namespace 内 default ServiceAccount 查看 Pod 权限的方式？",
      options: [
        "kubectl create rolebinding viewer --clusterrole=view --serviceaccount=<ns>:default -n <ns>",
        "编辑 kubelet 配置",
        "修改 CoreDNS",
        "创建 ConfigMap",
      ],
      answer: 0,
      rationale: "通过 RoleBinding 绑定内置 view ClusterRole 到 SA。",
    },
    {
      id: "w7-1-q6",
      question: "RBAC 权限是如何组合的？",
      options: [
        "基于允许列表累加，多条绑定叠加权限",
        "采用最小权限交集",
        "按绑定创建时间覆盖",
        "随机选择一条",
      ],
      answer: 0,
      rationale: "RBAC 是允许即通过的累加模型，不存在显式拒绝。",
    },
    {
      id: "w7-1-q7",
      question: "resourceNames 的用途？",
      options: [
        "将规则限定到特定资源名称集合",
        "指定命名空间",
        "定义节点名",
        "控制副本数",
      ],
      answer: 0,
      rationale: "resourceNames 细化到具体对象名称。",
    },
    {
      id: "w7-1-q8",
      question: "内置聚合角色（aggregate-to-admin 等）的作用？",
      options: [
        "通过标签自动聚合到 admin/edit/view 等高阶角色",
        "只在 kube-system 可用",
        "用于节点权限",
        "提供审计日志",
      ],
      answer: 0,
      rationale: "带聚合标签的 ClusterRole 会自动并入目标聚合角色。",
    },
    {
      id: "w7-1-q9",
      question: "Node Authorizer 授权的主体通常是？",
      options: [
        "kubelet 使用的节点证书（system:node:<nodename>）",
        "任意用户",
        "仅管理员",
        "只允许匿名",
      ],
      answer: 0,
      rationale: "节点证书请求由 Node Authorizer 检查并授予有限权限。",
    },
    {
      id: "w7-1-q10",
      question: "检查请求的 RBAC 决策可以使用？",
      options: [
        "kubectl auth can-i <verb> <resource> [--as user]",
        "kubectl get rbac",
        "查看 etcd 日志",
        "需要访问控制平面主机",
      ],
      answer: 0,
      rationale: "auth can-i 是官方提供的快速自测命令。",
    },
  ],
  "w7-2": [
    {
      id: "w7-2-q1",
      question: "Pod 未指定 serviceAccountName 时默认使用？",
      options: [
        "所在 Namespace 的 default ServiceAccount",
        "无法启动",
        "自动创建一个新的 ServiceAccount",
        "集群级 admin 账户",
      ],
      answer: 0,
      rationale: "API Server 会注入 default SA（除非被修改）。",
    },
    {
      id: "w7-2-q2",
      question: "automountServiceAccountToken: false 的效果？",
      options: [
        "阻止将 API 令牌自动挂载到 Pod",
        "加密令牌",
        "自动刷新令牌",
        "强制使用 root 用户",
      ],
      answer: 0,
      rationale: "可在 Pod 或 ServiceAccount 层关闭自动挂载，提升安全性。",
    },
    {
      id: "w7-2-q3",
      question: "Bound Service Account Token 的特性是？",
      options: [
        "短周期、可撤销、与具体 Pod 绑定并投射为投影卷",
        "长期不过期",
        "存储在 Secret 对象中",
        "只能在 kube-system 使用",
      ],
      answer: 0,
      rationale: "新式 Token 通过 TokenRequest API 获取，具备过期时间。",
    },
    {
      id: "w7-2-q4",
      question: "ServiceAccount 令牌包含哪些关键信息？",
      options: [
        "Bearer Token + 集群 CA 证书 + API Server 地址",
        "用户密码",
        "etcd 密钥",
        "容器镜像",
      ],
      answer: 0,
      rationale: "投射卷中包含 token、ca.crt、namespace 文件供客户端访问 API。",
    },
    {
      id: "w7-2-q5",
      question: "imagePullSecrets 通常挂在哪个对象上？",
      options: [
        "ServiceAccount 或 Pod，用于拉取私有镜像",
        "ConfigMap",
        "Node 对象",
        "Deployment 的 spec.selector",
      ],
      answer: 0,
      rationale: "可在 SA 上统一配置镜像拉取凭证。",
    },
    {
      id: "w7-2-q6",
      question: "如何为特定 Pod 指定 ServiceAccount？",
      options: [
        "在 Pod spec.serviceAccountName 写入目标 SA 名称",
        "通过标签自动匹配",
        "只能用注解",
        "无法更改",
      ],
      answer: 0,
      rationale: "Pod spec.serviceAccountName 控制使用的 SA。",
    },
    {
      id: "w7-2-q7",
      question: "kubectl create token <sa>（1.24+）的作用？",
      options: [
        "基于 TokenRequest API 获取短期令牌",
        "创建 ServiceAccount",
        "刷新 kubeconfig",
        "创建 Secret",
      ],
      answer: 0,
      rationale: "该命令调用 TokenRequest 生成可短期使用的 Bearer Token。",
    },
    {
      id: "w7-2-q8",
      question: "ServiceAccount 的作用域是？",
      options: [
        "命名空间级，不能跨 Namespace 使用",
        "集群级，可任意使用",
        "节点级",
        "仅 Pod 级",
      ],
      answer: 0,
      rationale: "每个 SA 属于一个 Namespace，需要跨命名空间需重新创建/绑定。",
    },
    {
      id: "w7-2-q9",
      question: "关闭 SA 自动挂载的常见场景？",
      options: [
        "无须访问 API 的作业/sidecar 以减少凭证暴露",
        "所有 Pod 都应关闭",
        "必须开启才能访问 DNS",
        "与 RBAC 无关",
      ],
      answer: 0,
      rationale: "安全最佳实践：不需要访问 API 的工作负载可禁用令牌挂载。",
    },
    {
      id: "w7-2-q10",
      question: "旧版基于 Secret 的长效 Token 问题是？",
      options: [
        "默认不过期且易被滥用，已被 Bound Token 替代",
        "性能过低",
        "无法在命名空间使用",
        "需要重启 kubelet",
      ],
      answer: 0,
      rationale: "旧 token 长期有效，安全性差，新版本引入可撤销的投射 token。",
    },
  ],
  "w7-3": [
    {
      id: "w7-3-q1",
      question: "Helm Chart 的核心文件/目录有哪些？",
      options: [
        "Chart.yaml、values.yaml、templates/、charts/",
        "Dockerfile、Makefile",
        "package.json、index.ts",
        "config.json、pods/",
      ],
      answer: 0,
      rationale: "Chart 结构文档列出必需文件与模板目录。",
    },
    {
      id: "w7-3-q2",
      question: "安装一个 Chart 的命令示例？",
      options: [
        "helm install <release-name> <chart>",
        "kubectl apply -f chart",
        "helm create",
        "helm push",
      ],
      answer: 0,
      rationale: "helm install 创建一个 release。",
    },
    {
      id: "w7-3-q3",
      question: "Release 名称的作用域？",
      options: [
        "在同一命名空间内唯一，不同 namespace 可重复",
        "全局唯一",
        "与 Chart 名相同即可",
        "必须与 Service 名一致",
      ],
      answer: 0,
      rationale: "Helm 将 release 归属于 namespace，名称局部唯一。",
    },
    {
      id: "w7-3-q4",
      question: "覆盖默认 values 的方式？",
      options: [
        "使用 -f/--values 指定文件或 --set/--set-file 设置键值",
        "只能修改 Chart.yaml",
        "必须编辑模板",
        "不支持覆盖",
      ],
      answer: 0,
      rationale: "Helm 支持文件与命令行覆盖 values。",
    },
    {
      id: "w7-3-q5",
      question: "helm upgrade --install 的作用？",
      options: [
        "存在则升级，不存在则安装（幂等部署）",
        "只升级，不安装",
        "只安装，不升级",
        "删除后再安装",
      ],
      answer: 0,
      rationale: "常用模式确保命令可重入。",
    },
    {
      id: "w7-3-q6",
      question: "查看已安装 release 的命令？",
      options: ["helm list", "helm status all", "kubectl get releases", "helm repo list"],
      answer: 0,
      rationale: "helm list 显示当前命名空间的 release。",
    },
    {
      id: "w7-3-q7",
      question: "回滚到某个修订版本的命令？",
      options: [
        "helm rollback <release> <revision>",
        "kubectl rollout undo",
        "helm undo",
        "helm reset",
      ],
      answer: 0,
      rationale: "Helm 提供 rollback 命令恢复历史版本。",
    },
    {
      id: "w7-3-q8",
      question: "helm template 的作用？",
      options: [
        "本地渲染模板并输出 Kubernetes 清单而不安装",
        "创建 Chart",
        "校验语法",
        "管理仓库索引",
      ],
      answer: 0,
      rationale: "helm template 便于查看渲染结果用于调试。",
    },
    {
      id: "w7-3-q9",
      question: "Chart.yaml 中 appVersion 与 version 的区别？",
      options: [
        "version 是 Chart 本身版本，appVersion 表示打包应用版本",
        "两者完全相同",
        "appVersion 控制依赖",
        "version 仅供显示",
      ],
      answer: 0,
      rationale: "Helm 文档区分 Chart 版本与应用版本。",
    },
    {
      id: "w7-3-q10",
      question: "添加远程仓库后需执行？",
      options: [
        "helm repo update 以刷新索引",
        "helm upgrade",
        "kubectl apply",
        "删除本地缓存",
      ],
      answer: 0,
      rationale: "更新仓库索引后才能拉取最新 Chart。",
    },
  ],
  "w7-4": [
    {
      id: "w7-4-q1",
      question: "Helm 模板使用的语言/函数来源是？",
      options: [
        "Go template + Sprig 函数库",
        "Jinja2",
        "Mustache",
        "Lua",
      ],
      answer: 0,
      rationale: "Helm 使用 Go 模板并内置 Sprig 函数。",
    },
    {
      id: "w7-4-q2",
      question: "_helpers.tpl 通常存放什么？",
      options: [
        "命名模板/局部函数（如 fullname、labels）供其他模板复用",
        "镜像列表",
        "RBAC 规则",
        "测试用例",
      ],
      answer: 0,
      rationale: "Helm 官方推荐在 _helpers.tpl 定义可复用模板片段。",
    },
    {
      id: "w7-4-q3",
      question: "values 文件与 --set 的优先级？",
      options: [
        "命令行 --set 优先级最高，覆盖 values 文件",
        "values 文件覆盖 --set",
        "无优先级，随机",
        "由 Chart 决定",
      ],
      answer: 0,
      rationale: "Helm 按 CLI > values 文件 > Chart 默认的顺序合并。",
    },
    {
      id: "w7-4-q4",
      question: "helm lint 的作用？",
      options: [
        "静态检查 Chart 结构与模板常见问题",
        "渲染模板",
        "安装依赖",
        "生成证书",
      ],
      answer: 0,
      rationale: "lint 可提前发现常见错误。",
    },
    {
      id: "w7-4-q5",
      question: "helm test 的用途？",
      options: [
        "运行 chart 定义的测试 hook（如 Pod）验证部署",
        "执行单元测试框架",
        "升级 Chart",
        "生成文档",
      ],
      answer: 0,
      rationale: "helm test 会运行带 test hook 的资源，常用于验收。",
    },
    {
      id: "w7-4-q6",
      question: "Helm hook 的常见事件包括？",
      options: [
        "pre-install、post-install、pre-upgrade、post-upgrade 等",
        "pre-run、post-run",
        "before-apply、after-apply",
        "只有 install",
      ],
      answer: 0,
      rationale: "Helm 支持多种生命周期 hook。",
    },
    {
      id: "w7-4-q7",
      question: "Library Chart 的作用？",
      options: [
        "提供可复用的模板函数/片段，不会单独渲染资源",
        "提供公共镜像仓库",
        "自动生成 values",
        "必须与子 Chart 同名",
      ],
      answer: 0,
      rationale: "Library chart 仅供依赖引用复用模板。",
    },
    {
      id: "w7-4-q8",
      question: "管理 Chart 依赖的命令是？",
      options: [
        "helm dependency update/build",
        "helm repo list",
        "kubectl apply -k",
        "helm sync",
      ],
      answer: 0,
      rationale: "依赖信息在 Chart.yaml，需用 dependency update/build 下载。",
    },
    {
      id: "w7-4-q9",
      question: "values.schema.json 用途是？",
      options: [
        "为 values 提供 JSON Schema 校验，帮助发现配置错误",
        "存储默认值",
        "生成 RBAC",
        "控制发布策略",
      ],
      answer: 0,
      rationale: "Helm 支持根据 schema 校验 values。",
    },
    {
      id: "w7-4-q10",
      question: "调试渲染输出并查看渲染值可以使用？",
      options: [
        "helm template --debug 或 helm install --dry-run --debug",
        "kubectl describe",
        "helm render-only",
        "必须部署后查看",
      ],
      answer: 0,
      rationale: "dry-run+debug 可输出渲染模板与使用的 values。",
    },
  ],
  // Week 6
  "w6-1": [
    {
      id: "w6-1-q1",
      question: "nodeSelector 与 nodeAffinity 的主要区别？",
      options: [
        "nodeAffinity 支持表达式/优先级，nodeSelector 仅简单键值匹配",
        "两者完全相同",
        "nodeSelector 只能在 StatefulSet 使用",
        "nodeAffinity 只能写在注解中",
      ],
      answer: 0,
      rationale: "Node Affinity 提供 matchExpressions 与软/硬要求，替代简单 nodeSelector。",
    },
    {
      id: "w6-1-q2",
      question: "requiredDuringSchedulingIgnoredDuringExecution 表示？",
      options: [
        "调度时必须满足，调度后即使标签变化也不驱逐",
        "调度时可以不满足",
        "运行时也会强制驱逐",
        "仅影响探针",
      ],
      answer: 0,
      rationale: "名字即含义：调度阶段强约束，执行阶段忽略变化。",
    },
    {
      id: "w6-1-q3",
      question: "preferredDuringSchedulingIgnoredDuringExecution 的特点？",
      options: [
        "软亲和性，调度器按权重倾向满足但可回退",
        "与 required 相同",
        "用于强制驱逐",
        "只支持单个 label",
      ],
      answer: 0,
      rationale: "preferred 提供加分项，不满足也可调度。",
    },
    {
      id: "w6-1-q4",
      question: "PodAntiAffinity 常用来？",
      options: [
        "避免同一应用副本落在同一拓扑（如节点/机架）上",
        "强制全部副本集中同一节点",
        "取代 HPA",
        "控制网络策略",
      ],
      answer: 0,
      rationale: "Pod 反亲和用于分散部署，提高容错。",
    },
    {
      id: "w6-1-q5",
      question: "topologyKey 在 PodAffinity/AntiAffinity 中的作用？",
      options: [
        "定义亲和/反亲和计算的拓扑域（如 kubernetes.io/hostname）",
        "设置 Service 类型",
        "指定探针端口",
        "决定 CPU 亲和",
      ],
      answer: 0,
      rationale: "topologyKey 控制在何种粒度上判定同/不同拓扑。",
    },
    {
      id: "w6-1-q6",
      question: "nodeAffinity 使用的标签来自哪里？",
      options: [
        "节点对象的 labels",
        "Pod labels",
        "ConfigMap",
        "镜像标签",
      ],
      answer: 0,
      rationale: "节点亲和性匹配 Node 的 labels。",
    },
    {
      id: "w6-1-q7",
      question: "PodAffinity 与 PodAntiAffinity 的选择对象是？",
      options: [
        "其他 Pod 的标签（通过 podSelector + topologyKey）",
        "节点标签",
        "Service 名称",
        "Namespace 名称",
      ],
      answer: 0,
      rationale: "Pod 亲和性根据其他 Pod 标签与拓扑决定调度。",
    },
    {
      id: "w6-1-q8",
      question: "若同时指定多个 requiredDuringScheduling 的 terms，会如何评估？",
      options: [
        "必须全部满足（AND），每个 term 内的 matchExpressions 也按 AND 处理",
        "只需满足任意一个（OR）",
        "随机选择一个",
        "忽略后续 term",
      ],
      answer: 0,
      rationale: "亲和性条目默认 AND 组合。",
    },
    {
      id: "w6-1-q9",
      question: "PodAntiAffinity 使用 topologyKey=“kubernetes.io/hostname” 的效果？",
      options: [
        "避免匹配的 Pod 落在同一节点",
        "禁止 Pod 调度到任意节点",
        "仅允许同一节点",
        "无效配置",
      ],
      answer: 0,
      rationale: "指定 hostname 可实现节点级别分散。",
    },
    {
      id: "w6-1-q10",
      question: "与 topologySpreadConstraints 的区别是？",
      options: [
        "affinity 是基于匹配/排斥，spreadConstraints 关注副本分布均衡",
        "两者完全等价",
        "spreadConstraints 只能在 StatefulSet 用",
        "affinity 只能在节点层面",
      ],
      answer: 0,
      rationale: "亲和/反亲和与均衡约束关注点不同，可配合使用。",
    },
  ],
  "w6-2": [
    {
      id: "w6-2-q1",
      question: "Taint 的三种 Effect 是？",
      options: [
        "NoSchedule、PreferNoSchedule、NoExecute",
        "Allow、Deny、Block",
        "Read、Write、Exec",
        "Schedule、Execute、Evict",
      ],
      answer: 0,
      rationale: "官方文档定义三种效果，分别对应禁止/倾向/驱逐。",
    },
    {
      id: "w6-2-q2",
      question: "NoExecute 与 NoSchedule 的区别？",
      options: [
        "NoExecute 会驱逐已在节点上但不容忍的 Pod，NoSchedule 仅影响新调度",
        "两者完全相同",
        "NoExecute 只影响 DaemonSet",
        "NoSchedule 只影响 PodAntiAffinity",
      ],
      answer: 0,
      rationale: "NoExecute 同时阻止调度并驱逐不容忍的已有 Pod。",
    },
    {
      id: "w6-2-q3",
      question: "tolerationSeconds 适用于哪种情况？",
      options: [
        "仅针对 NoExecute taint，控制可容忍的驱逐延迟",
        "适用于所有 taint",
        "控制 Pod 生命周期",
        "控制探针超时",
      ],
      answer: 0,
      rationale: "tolerationSeconds 用于 NoExecute 延迟驱逐。",
    },
    {
      id: "w6-2-q4",
      question: "以下哪个格式是合法 taint？",
      options: [
        "kubectl taint nodes node1 key=value:NoSchedule",
        "kubectl taint node1 key NoSchedule",
        "kubectl taint nodes key:Prefer",
        "kubectl taint nodes key=value:Allow",
      ],
      answer: 0,
      rationale: "命令格式 key[=value]:Effect。",
    },
    {
      id: "w6-2-q5",
      question: "默认控制平面节点的 taint 是？",
      options: [
        "node-role.kubernetes.io/control-plane=:NoSchedule（或 node-role.kubernetes.io/master）",
        "node.kubernetes.io/memory-pressure",
        "node.cloudprovider.kubernetes.io/uninitialized",
        "无默认 taint",
      ],
      answer: 0,
      rationale: "控制平面有 NoSchedule taint 以阻止普通工作负载。",
    },
    {
      id: "w6-2-q6",
      question: "Pod 定义了多个 tolerations 时，调度判定是？",
      options: [
        "需要满足节点上所有 taint（否则无法调度）",
        "只要匹配一个即可",
        "忽略所有 taint",
        "只检查 PreferNoSchedule",
      ],
      answer: 0,
      rationale: "未被 Pod 容忍的 taint 会阻止调度或驱逐。",
    },
    {
      id: "w6-2-q7",
      question: "Toleration 只能允许调度，不能？",
      options: [
        "强制调度到带 taint 的节点，仍需其它调度条件满足",
        "改变节点标签",
        "调整资源请求",
        "影响网络策略",
      ],
      answer: 0,
      rationale: "容忍只是去除 taint 的阻止作用，不保证调度成功。",
    },
    {
      id: "w6-2-q8",
      question: "operator: Exists 的作用？",
      options: [
        "无需指定值，只要匹配 key 即可容忍该 taint",
        "要求值完全匹配",
        "只容忍 PreferNoSchedule",
        "禁止匹配任何 taint",
      ],
      answer: 0,
      rationale: "Exists 可容忍指定 key 的任意值 taint。",
    },
    {
      id: "w6-2-q9",
      question: "移除 taint 的命令示例？",
      options: [
        "kubectl taint nodes node1 key:NoSchedule-",
        "kubectl taint nodes node1 key:Remove",
        "kubectl delete taint key",
        "kubectl cordon node1",
      ],
      answer: 0,
      rationale: "在命令末尾加 - 号移除。",
    },
    {
      id: "w6-2-q10",
      question: "节点存在多个 taint 时，Pod 需要？",
      options: [
        "对所有 effect=NoSchedule/NoExecute taint 提供容忍才可调度和存活",
        "只容忍一个即可",
        "忽略 PreferNoSchedule",
        "由 kube-proxy 自动处理",
      ],
      answer: 0,
      rationale: "未容忍的阻断 taint 任一存在都会阻止/驱逐 Pod。",
    },
  ],
  "w6-3": [
    {
      id: "w6-3-q1",
      question: "没有任何 NetworkPolicy 时的默认行为是？",
      options: [
        "默认允许所有进出流量",
        "默认拒绝所有流量",
        "仅允许 DNS",
        "只允许同命名空间",
      ],
      answer: 0,
      rationale: "NetworkPolicy 为白名单模型，未定义时全放行。",
    },
    {
      id: "w6-3-q2",
      question: "NetworkPolicy 中 podSelector 的作用是？",
      options: [
        "选择被此策略作用的 Pod（目标）",
        "选择允许通信的来源",
        "选择 Service",
        "选择节点",
      ],
      answer: 0,
      rationale: "podSelector 定义策略适用的 Pod 集合。",
    },
    {
      id: "w6-3-q3",
      question: "policyTypes 未指定时默认包含？",
      options: [
        "根据规则自动推断，若仅有 ingress 则为 Ingress，若有 egress 则含 Egress",
        "总是 Ingress+Egress",
        "仅 Ingress",
        "仅 Egress",
      ],
      answer: 0,
      rationale: "未指定时由规则推断，官方文档说明默认行为。",
    },
    {
      id: "w6-3-q4",
      question: "要实现默认拒绝 ingress，需要？",
      options: [
        "创建选择目标 Pod 的策略，ingress 规则为空（或不包含允许），只允许同策略定义的流量",
        "删除 Service",
        "修改 kube-proxy",
        "开启 RBAC",
      ],
      answer: 0,
      rationale: "白名单策略定义后未允许的流量被拒绝。",
    },
    {
      id: "w6-3-q5",
      question: "NetworkPolicy 生效的前提是？",
      options: [
        "CNI 插件实现了 NetworkPolicy（如 Calico/Cilium）",
        "仅需安装 kube-proxy",
        "安装 CoreDNS",
        "使用 StatefulSet",
      ],
      answer: 0,
      rationale: "需使用支持策略的网络插件，否则策略被忽略。",
    },
    {
      id: "w6-3-q6",
      question: "namespaceSelector 与 podSelector 同时使用时的关系是？",
      options: [
        "常用作组合：筛选命名空间后再选其中 Pod，条件按 AND 应用",
        "按 OR 合并",
        "随机选择",
        "两者不能同时使用",
      ],
      answer: 0,
      rationale: "peer 条目可包含 namespaceSelector+podSelector 共同约束。",
    },
    {
      id: "w6-3-q7",
      question: "ipBlock 的 except 字段作用？",
      options: [
        "从允许的 CIDR 中排除部分子网/地址",
        "定义 DNS 名称",
        "指定 Pod 标签",
        "控制端口协议",
      ],
      answer: 0,
      rationale: "ipBlock 用于基于 CIDR 控制，except 做差集。",
    },
    {
      id: "w6-3-q8",
      question: "NetworkPolicy 是否会影响未被 podSelector 选中的 Pod？",
      options: [
        "不会，未被选中 Pod 仍遵循默认全放行行为",
        "会默认拒绝",
        "会自动允许",
        "取决于节点 taint",
      ],
      answer: 0,
      rationale: "策略只作用于被选中目标，其他 Pod 不受限。",
    },
    {
      id: "w6-3-q9",
      question: "要允许 DNS 出站通常需要？",
      options: [
        "在 egress 规则中放行 UDP/TCP 53 到 DNS 服务（如 kube-dns/CoreDNS IP）",
        "无需特殊处理",
        "在 Service 添加注解",
        "通过 RBAC 授权",
      ],
      answer: 0,
      rationale: "默认拒绝 Egress 时需显式放行 DNS 查询。",
    },
    {
      id: "w6-3-q10",
      question: "多个 NetworkPolicy 作用于同一 Pod 时如何处理？",
      options: [
        "规则累加（最严格生效），必须同时满足所有策略的允许条件",
        "按创建时间覆盖",
        "随机选择一个",
        "只取最后一个",
      ],
      answer: 0,
      rationale: "NetworkPolicy 是白名单叠加，需同时满足才能通信。",
    },
  ],
  "w6-4": [
    {
      id: "w6-4-q1",
      question: "CNI 规范规定插件需要实现哪些命令？",
      options: [
        "ADD/DEL（以及可选 CHECK），由 kubelet 调用配置容器网络",
        "start/stop",
        "apply/delete",
        "init/reset",
      ],
      answer: 0,
      rationale: "CNI 插件通过可执行文件响应 ADD/DEL 请求。",
    },
    {
      id: "w6-4-q2",
      question: "Flannel 默认使用哪种网络模式？",
      options: [
        "Overlay（VXLAN 或 host-gw）提供简单 L3 互通",
        "BGP 路由",
        "仅 L2 交换不需要隧道",
        "需要硬件 LB",
      ],
      answer: 0,
      rationale: "Flannel 以 VXLAN/host-gw 等模式封装 Pod 流量。",
    },
    {
      id: "w6-4-q3",
      question: "Calico 默认的路由模式是？",
      options: [
        "BGP 分发路由（也可配置 IPIP/VXLAN 封装）",
        "仅支持 VXLAN",
        "只支持 host-gw",
        "基于 HTTP 代理",
      ],
      answer: 0,
      rationale: "Calico 可用 BGP 原生路由，也能用隧道封装兼容环境。",
    },
    {
      id: "w6-4-q4",
      question: "NetworkPolicy 支持情况：",
      options: [
        "Calico 原生支持 NetworkPolicy，Flannel 需额外策略插件或不支持",
        "两者都不支持",
        "Flannel 完全支持，Calico 不支持",
        "与 CNI 无关",
      ],
      answer: 0,
      rationale: "Calico 提供策略引擎；Flannel 默认仅提供连通性。",
    },
    {
      id: "w6-4-q5",
      question: "CNI 配置文件通常位于？",
      options: ["/etc/cni/net.d", "/etc/kubernetes/cni", "/var/lib/cni", "/usr/local/cni/conf"],
      answer: 0,
      rationale: "kubelet 默认从 /etc/cni/net.d 读取网络配置。",
    },
    {
      id: "w6-4-q6",
      question: "kubelet 何时调用 CNI 插件？",
      options: [
        "在创建/删除 Pod 的 sandbox 时配置/回收网络",
        "在 API Server 写入对象时",
        "由 kube-proxy 调用",
        "仅节点启动时",
      ],
      answer: 0,
      rationale: "kubelet 在为 Pod 创建 sandBox 时执行 CNI ADD，删除时执行 DEL。",
    },
    {
      id: "w6-4-q7",
      question: "使用 overlay 网络的常见副作用是？",
      options: [
        "MTU 减少，可能导致大包分片或丢弃",
        "CPU 占用降低",
        "无需路由",
        "提高磁盘性能",
      ],
      answer: 0,
      rationale: "VXLAN/IPIP 封装会占用额外头部，需调整 MTU。",
    },
    {
      id: "w6-4-q8",
      question: "Calico 可以使用哪种数据存储？",
      options: [
        "Kubernetes API Server（Datastore）或独立 etcd",
        "仅支持本地文件",
        "必须使用 MySQL",
        "依赖 CoreDNS",
      ],
      answer: 0,
      rationale: "Calico 支持 K8s API Datastore 与外部 etcd 两种模式。",
    },
    {
      id: "w6-4-q9",
      question: "Flannel 组件 flanneld 的职责是？",
      options: [
        "分配子网给节点并配置后端（VXLAN/host-gw 等）",
        "提供 DNS",
        "运行 kube-proxy",
        "管理存储卷",
      ],
      answer: 0,
      rationale: "flanneld 负责分配网络与维护后端隧道配置。",
    },
    {
      id: "w6-4-q10",
      question: "CNI 插件返回的结果中最重要的是？",
      options: [
        "分配的 Pod IP/路由与接口信息",
        "镜像标签",
        "节点 CPU 数量",
        "Pod 调度日志",
      ],
      answer: 0,
      rationale: "CNI 需返回 IP/接口配置供 kubelet 写入容器网络命名空间。",
    },
  ],
  // Week 5
  "w5-1": [
    {
      id: "w5-1-q1",
      question: "ConfigMap 与 Secret 的主要区别是？",
      options: [
        "Secret 以 base64 方式存储敏感数据，API 默认限制输出；ConfigMap 用于非敏感配置",
        "两者完全相同",
        "Secret 只能挂载为环境变量",
        "ConfigMap 需要加密才能使用",
      ],
      answer: 0,
      rationale: "Secret 专为敏感信息设计，ConfigMap 适合普通配置。",
    },
    {
      id: "w5-1-q2",
      question: "通过环境变量注入 ConfigMap/Secret 有何特点？",
      options: [
        "值在容器启动时固定，后续更新不会自动刷新",
        "会自动热更新",
        "仅支持 Secret，不支持 ConfigMap",
        "必须配合 subPath",
      ],
      answer: 0,
      rationale: "Env 注入在容器启动时解析，后续变更不会更新已有进程环境。",
    },
    {
      id: "w5-1-q3",
      question: "作为 Volume 挂载 ConfigMap/Secret 的更新行为是？",
      options: [
        "挂载点会在短暂延迟后自动刷新内容（使用 subPath 则不会）",
        "永不更新，必须重启 Pod",
        "只在节点重启时刷新",
        "需要手动执行 kubectl rollout",
      ],
      answer: 0,
      rationale: "投射卷由 kubelet 周期刷新，subPath 会阻断更新。",
    },
    {
      id: "w5-1-q4",
      question: "单个 ConfigMap/Secret 官方建议的大小上限是？",
      options: ["约 1 MiB", "10 MiB", "无限制", "64 KiB"],
      answer: 0,
      rationale: "文档建议控制在 1MiB 内，超大对象应改用存储卷。",
    },
    {
      id: "w5-1-q5",
      question: "Secret 默认是否加密存储？",
      options: [
        "默认只做 base64 编码，需启用 EncryptionConfiguration 才加密",
        "默认开启强加密",
        "存储在 Pod 本地文件",
        "自动存入 HashiCorp Vault",
      ],
      answer: 0,
      rationale: "etcd 默认不加密 Secret，需要显式配置加密提供者。",
    },
    {
      id: "w5-1-q6",
      question: "docker-registry 登录凭证应使用哪种 Secret 类型？",
      options: [
        "kubernetes.io/dockerconfigjson",
        "Opaque",
        "tls",
        "service-account-token",
      ],
      answer: 0,
      rationale: "拉取私有镜像需 dockerconfigjson 类型 Secret。",
    },
    {
      id: "w5-1-q7",
      question: "ConfigMap 支持存储二进制内容吗？",
      options: [
        "支持，通过 binaryData 字段存放 base64 编码的二进制",
        "不支持，只能存文本",
        "需要转成 Secret",
        "只能用 CSI 驱动",
      ],
      answer: 0,
      rationale: "从 v1.10 起 ConfigMap 提供 binaryData 字段。",
    },
    {
      id: "w5-1-q8",
      question: "使用 subPath 挂载 ConfigMap/Secret 时的注意事项？",
      options: [
        "内容不会自动更新，需重新创建 Pod",
        "更新会自动同步",
        "只能挂载整个目录，不能单文件",
        "必须 root 权限",
      ],
      answer: 0,
      rationale: "subPath 将文件复制到宿主路径，不会随源更新。",
    },
    {
      id: "w5-1-q9",
      question: "以 Volume 挂载时如何控制文件权限？",
      options: [
        "通过 defaultMode 设置八进制文件模式",
        "只能用 chmod 处理",
        "权限固定为 777",
        "必须配合 Init 容器",
      ],
      answer: 0,
      rationale: "投射卷支持 defaultMode 字段控制文件权限。",
    },
    {
      id: "w5-1-q10",
      question: "创建 ConfigMap 的命令示例正确的是？",
      options: [
        "kubectl create configmap app-config --from-literal=key=value",
        "kubectl new cm app-config key=value",
        "kubectl apply secret app-config",
        "kubectl create cm --file-only",
      ],
      answer: 0,
      rationale: "官方示例使用 create configmap 并可用 --from-literal/--from-file。",
    },
  ],
  "w5-2": [
    {
      id: "w5-2-q1",
      question: "PersistentVolume（PV）的作用域与阶段是？",
      options: [
        "集群级资源，阶段包括 Available/Bound/Released/Failed",
        "命名空间内资源，仅有 Created/Deleted 阶段",
        "仅供 StatefulSet 使用",
        "必须与 Node 一一对应",
      ],
      answer: 0,
      rationale: "PV 是集群资源，生命周期包含多个阶段以反映绑定状态。",
    },
    {
      id: "w5-2-q2",
      question: "常见的访问模式包含？",
      options: [
        "ReadWriteOnce、ReadOnlyMany、ReadWriteMany",
        "ReadNever、WriteNever",
        "ReadWriteOnePerNodeOnly",
        "仅 RWX",
      ],
      answer: 0,
      rationale: "官方定义三种基础访问模式。",
    },
    {
      id: "w5-2-q3",
      question: "PVC 与 PV 的绑定关系是？",
      options: [
        "一对一绑定，PVC 绑定后只能使用一个 PV",
        "PVC 可同时绑定多个 PV",
        "PV 可绑定多个 PVC 共享",
        "绑定后仍保持 Available 状态",
      ],
      answer: 0,
      rationale: "每个 PVC 仅绑定一个 PV，PV 状态变为 Bound。",
    },
    {
      id: "w5-2-q4",
      question: "ReclaimPolicy 的取值及含义？",
      options: [
        "Retain/Recycle/Delete，决定 PVC 删除后底层卷如何处理",
        "Only Retain",
        "仅控制访问模式",
        "只影响动态供给",
      ],
      answer: 0,
      rationale: "策略控制释放后是否保留、简单清理或删除后端资源。",
    },
    {
      id: "w5-2-q5",
      question: "Pod 如何使用 PVC？",
      options: [
        "在 volume 中引用 persistentVolumeClaim.claimName，再挂载到容器",
        "直接写 PV 名称",
        "写入 StorageClass 名称即可",
        "通过 ConfigMap 引用",
      ],
      answer: 0,
      rationale: "Pod 需要通过 volume 声明 PVC，再在容器 mount。",
    },
    {
      id: "w5-2-q6",
      question: "PVC 与 StorageClass 的关系是？",
      options: [
        "PVC 指定 storageClassName，可匹配静态 PV 或触发动态供给",
        "必须为空",
        "只能指定一个固定值 default",
        "仅 PV 需要设置",
      ],
      answer: 0,
      rationale: "PVC 通过 storageClassName 选择合适 PV/SC。",
    },
    {
      id: "w5-2-q7",
      question: "PV/PVC 的命名空间分别是？",
      options: [
        "PV 是集群级无 namespace，PVC 属于某个 namespace",
        "两者都是集群级",
        "两者都在同一 namespace",
        "PV 属于节点",
      ],
      answer: 0,
      rationale: "PVC 与 Pod 同属 namespace，PV 为全局资源。",
    },
    {
      id: "w5-2-q8",
      question: "删除 PVC 后 PV 的行为取决于？",
      options: [
        "PV 的 reclaimPolicy（Retain/Recycle/Delete）",
        "StorageClass 名称",
        "节点数量",
        "探针类型",
      ],
      answer: 0,
      rationale: "回收策略决定释放后的处理方式。",
    },
    {
      id: "w5-2-q9",
      question: "PVC 请求的访问模式和容量必须？",
      options: [
        "与 PV 兼容且不超过 PV 容量",
        "可以大于 PV 容量",
        "访问模式可随意填写",
        "只需容量匹配，模式不影响",
      ],
      answer: 0,
      rationale: "绑定要求访问模式和容量满足 PV 能力。",
    },
    {
      id: "w5-2-q10",
      question: "回收策略 Retain 的效果是？",
      options: [
        "保留底层卷和数据，手动回收后方可再次使用",
        "立即删除底层卷",
        "格式化底层卷后重新绑定",
        "无任何作用",
      ],
      answer: 0,
      rationale: "Retain 需要管理员手工清理再重用或删除 PV。",
    },
  ],
  "w5-3": [
    {
      id: "w5-3-q1",
      question: "StorageClass 的核心字段是？",
      options: [
        "provisioner（驱动名称）与 parameters（传递给 provisioner 的配置）",
        "apiVersion 与 kind",
        "nodeSelector",
        "Replica 数量",
      ],
      answer: 0,
      rationale: "StorageClass 指定 provisioner 及参数来动态创建卷。",
    },
    {
      id: "w5-3-q2",
      question: "volumeBindingMode=WaitForFirstConsumer 的作用？",
      options: [
        "等待 Pod 调度到节点后再选择/创建卷，避免跨可用区问题",
        "立即创建 PV",
        "只适用于 NFS",
        "阻止卷绑定",
      ],
      answer: 0,
      rationale: "该模式确保调度考虑拓扑，再选择卷位置。",
    },
    {
      id: "w5-3-q3",
      question: "allowVolumeExpansion=true 的意义？",
      options: [
        "允许已绑定的 PVC 在线扩容（需底层存储支持）",
        "自动缩容卷",
        "允许动态删除卷",
        "启用快照",
      ],
      answer: 0,
      rationale: "StorageClass 打开扩容开关，PVC 才能扩容。",
    },
    {
      id: "w5-3-q4",
      question: "动态供给的 PV 默认 ReclaimPolicy 是？",
      options: ["Delete", "Retain", "Recycle", "None"],
      answer: 0,
      rationale: "未指定时动态创建的 PV 默认 Delete。",
    },
    {
      id: "w5-3-q5",
      question: "PVC 未指定 storageClassName 且无默认存储类时会？",
      options: [
        "保持 Pending，等待匹配的 PV 或默认类",
        "自动选择任意 StorageClass",
        "创建本地临时卷",
        "被立即拒绝",
      ],
      answer: 0,
      rationale: "没有默认 StorageClass 且未指定时不会自动供给。",
    },
    {
      id: "w5-3-q6",
      question: "storageclass.kubernetes.io/is-default-class=true 的作用？",
      options: [
        "标记该 StorageClass 为默认，PVC 未指定时选用",
        "禁止该类被使用",
        "指定回收策略",
        "强制使用 WaitForFirstConsumer",
      ],
      answer: 0,
      rationale: "官方注解用于声明默认存储类。",
    },
    {
      id: "w5-3-q7",
      question: "使用 CSI 驱动动态供给时，需要什么组件？",
      options: [
        "部署对应 CSI Controller/Node 插件及 StorageClass",
        "仅创建 StorageClass 即可",
        "必须使用 hostPath",
        "需要修改 kube-proxy",
      ],
      answer: 0,
      rationale: "CSI 需控制器与节点插件配合才能创建/挂载卷。",
    },
    {
      id: "w5-3-q8",
      question: "PV 选择具体节点/可用区的常见方式是？",
      options: [
        "结合 Topology（如 zone 标签）与 WaitForFirstConsumer，或使用 NodeAffinity",
        "手工在 Pod 里指定 nodeName",
        "通过 ConfigMap 绑定",
        "只能随机选择",
      ],
      answer: 0,
      rationale: "StorageClass/CSI 支持拓扑感知，或 PV 的 nodeAffinity 限制节点。",
    },
    {
      id: "w5-3-q9",
      question: "若需对 PVC 启用快照/克隆，应使用？",
      options: [
        "支持 VolumeSnapshot/Clone 的 CSI 驱动和相应 CRD",
        "ConfigMap",
        "ResourceQuota",
        "Admission Webhook",
      ],
      answer: 0,
      rationale: "快照/克隆功能由 CSI 扩展提供，并需 CRD 支持。",
    },
    {
      id: "w5-3-q10",
      question: "为什么 WaitForFirstConsumer 能避免跨区调度失败？",
      options: [
        "先确定 Pod 目标节点/可用区，再创建同区域的卷",
        "会忽略拓扑直接使用多区存储",
        "因为卷可自动跨区挂载",
        "与调度无关",
      ],
      answer: 0,
      rationale: "先调度后供给确保卷与 Pod 位于同一拓扑约束内。",
    },
  ],
  "w5-4": [
    {
      id: "w5-4-q1",
      question: "StatefulSet 赋予每个 Pod 的特性是？",
      options: [
        "稳定的网络身份（有序名称）与持久存储绑定",
        "随机名称且无顺序",
        "与 Deployment 完全一致",
        "自动横向扩容",
      ],
      answer: 0,
      rationale: "StatefulSet 通过有序 Pod 名与 Headless Service 提供稳定标识。",
    },
    {
      id: "w5-4-q2",
      question: "volumeClaimTemplates 的作用？",
      options: [
        "为每个副本自动创建独立的 PVC/PV",
        "共享同一个 PVC",
        "仅定义临时卷",
        "限制副本数",
      ],
      answer: 0,
      rationale: "模板按序生成 PVC，为每个 Pod 保留专属存储。",
    },
    {
      id: "w5-4-q3",
      question: "StatefulSet 默认的 Pod 启动顺序？",
      options: [
        "OrderedReady：按序创建并等待前一个就绪",
        "并行创建所有 Pod",
        "随机顺序",
        "由节点决定",
      ],
      answer: 0,
      rationale: "默认 OrderedReady，需设置 podManagementPolicy=Parallel 才并行。",
    },
    {
      id: "w5-4-q4",
      question: "RollingUpdate + partition 对 StatefulSet 的影响？",
      options: [
        "仅更新序号大于等于 partition 的 Pod，低序号保持旧版本",
        "更新全部 Pod",
        "停止更新",
        "只更新 PVC",
      ],
      answer: 0,
      rationale: "partition 可实现金丝雀/分批更新。",
    },
    {
      id: "w5-4-q5",
      question: "OnDelete 更新策略意味着？",
      options: [
        "不会自动滚动更新，需要手动删除 Pod 触发新版本",
        "立即删除全部 Pod 再重建",
        "与 RollingUpdate 相同",
        "阻止扩容",
      ],
      answer: 0,
      rationale: "OnDelete 要求运维手工删除以应用新模板。",
    },
    {
      id: "w5-4-q6",
      question: "StatefulSet Pod 名称格式通常是？",
      options: [
        "<statefulsetname>-<ordinal>",
        "<statefulsetname>-<random>",
        "node-<id>",
        "固定为 0-1-2 不含前缀",
      ],
      answer: 0,
      rationale: "官方示例：web-0、web-1 等，反映有序身份。",
    },
    {
      id: "w5-4-q7",
      question: "Headless Service 在 StatefulSet 中的作用是？",
      options: [
        "为每个 Pod 提供稳定的 DNS 记录（如 podname.servicename）",
        "提供负载均衡 VIP",
        "绑定节点亲和",
        "自动创建 PV",
      ],
      answer: 0,
      rationale: "clusterIP=None 的 Headless Service 使 Pod 有稳定解析。",
    },
    {
      id: "w5-4-q8",
      question: "缩容 StatefulSet 时 PVC 会怎样？",
      options: [
        "默认保留，不会自动删除 PVC",
        "与 Pod 一起删除",
        "自动回收并格式化",
        "迁移到其他 Pod",
      ],
      answer: 0,
      rationale: "PVC 需手动删除，防止数据丢失。",
    },
    {
      id: "w5-4-q9",
      question: "podManagementPolicy=Parallel 的效果？",
      options: [
        "允许并行创建/删除 Pod，不再等待有序就绪",
        "禁止扩容",
        "仅更新一个 Pod",
        "启用自动扩缩容",
      ],
      answer: 0,
      rationale: "Parallel 模式跳过有序限制，加快扩缩容。",
    },
    {
      id: "w5-4-q10",
      question: "StatefulSet 对 serviceName 字段的要求？",
      options: [
        "必须指定一个 Headless Service 名作为网络身份基础",
        "可以为空",
        "仅用于显示",
        "用于选择节点",
      ],
      answer: 0,
      rationale: "serviceName 提供 DNS 后缀与端点，必须存在。",
    },
  ],
  // Week 4
  "w4-1": [
    {
      id: "w4-1-q1",
      question: "Deployment 控制的对象是？",
      options: [
        "声明 ReplicaSet 与 Pod 模板，确保副本数与版本符合期望",
        "直接管理节点网络",
        "配置 Ingress 规则",
        "存储镜像",
      ],
      answer: 0,
      rationale: "Deployment 文档说明其负责创建/更新 ReplicaSet 与 Pod。",
    },
    {
      id: "w4-1-q2",
      question: "RollingUpdate 默认的 maxUnavailable 与 maxSurge 是？",
      options: ["25% / 25%", "0 / 0", "50% / 10%", "100% / 100%"],
      answer: 0,
      rationale: "官方默认滚动策略为最多 25% 不可用，最多 25% 额外副本。",
    },
    {
      id: "w4-1-q3",
      question: "progressDeadlineSeconds 默认值是多少？",
      options: ["600 秒", "60 秒", "3600 秒", "无默认值必须设置"],
      answer: 0,
      rationale: "Deployment spec 默认 progressDeadlineSeconds=600。",
    },
    {
      id: "w4-1-q4",
      question: "revisionHistoryLimit 的作用是？",
      options: [
        "限制保留的旧 ReplicaSet 数量",
        "控制探针超时",
        "设置滚动窗口",
        "指定镜像拉取策略",
      ],
      answer: 0,
      rationale: "用于避免历史 RS 无限增长并支持回滚。",
    },
    {
      id: "w4-1-q5",
      question: "如何回滚到上一版本？",
      options: [
        "kubectl rollout undo deployment/<name>",
        "直接编辑 Pod",
        "删除 Deployment 再创建",
        "重启 kubelet",
      ],
      answer: 0,
      rationale: "rollout undo 会切回上一修订并更新 RS。",
    },
    {
      id: "w4-1-q6",
      question: "Recreate 策略的特点是？",
      options: [
        "先删除所有旧 Pod 再创建新 Pod，会短暂中断",
        "与 RollingUpdate 相同",
        "一次只替换一个 Pod",
        "只允许镜像标签改变",
      ],
      answer: 0,
      rationale: "Recreate 会停掉旧版本再启动新版本，导致停机。",
    },
    {
      id: "w4-1-q7",
      question: "minReadySeconds 的作用？",
      options: [
        "新 Pod 连续就绪该时间后才算可用，影响滚动推进",
        "限制镜像下载时间",
        "决定重试次数",
        "控制探针端口",
      ],
      answer: 0,
      rationale: "确保就绪状态稳定一段时间再计入可用副本。",
    },
    {
      id: "w4-1-q8",
      question: "Deployment 如何暂停/恢复滚动？",
      options: [
        "kubectl rollout pause/resume deployment/<name>",
        "必须删除重建",
        "编辑 Pod 模板即可暂停",
        "通过 kube-proxy 控制",
      ],
      answer: 0,
      rationale: "rollout pause/resume 可暂停控制器推进，便于验证。",
    },
    {
      id: "w4-1-q9",
      question: "修改 Pod 模板会导致什么？",
      options: [
        "创建新的 ReplicaSet 并按策略替换旧 Pod",
        "直接在原 Pod 上热更新",
        "不产生任何影响",
        "只更新标签不更新容器",
      ],
      answer: 0,
      rationale: "Deployment 检测模板 hash 变化后新建 RS 进行滚动。",
    },
    {
      id: "w4-1-q10",
      question: "监控滚动进度的命令是？",
      options: [
        "kubectl rollout status deployment/<name>",
        "kubectl get nodes",
        "kubectl top pod",
        "kubectl cluster-info",
      ],
      answer: 0,
      rationale: "rollout status 会显示当前修订及可用副本进度。",
    },
  ],
  "w4-2": [
    {
      id: "w4-2-q1",
      question: "未指定 type 时 Service 默认类型是？",
      options: ["ClusterIP", "NodePort", "LoadBalancer", "ExternalName"],
      answer: 0,
      rationale: "Service type 默认 ClusterIP 仅集群内可访问。",
    },
    {
      id: "w4-2-q2",
      question: "NodePort 服务默认端口范围是？",
      options: ["30000-32767", "1-1023", "20000-29999", "40000-50000"],
      answer: 0,
      rationale: "官方默认 NodePort 范围 30000-32767（可配置）。",
    },
    {
      id: "w4-2-q3",
      question: "LoadBalancer 类型依赖什么能力？",
      options: [
        "云提供商/集群环境的外部负载均衡集成",
        "kube-proxy 自动创建",
        "etcd 提供",
        "kubectl 本地转发",
      ],
      answer: 0,
      rationale: "需要底层 LB 支持，如云厂商或 MetalLB。",
    },
    {
      id: "w4-2-q4",
      question: "kube-proxy iptables 与 ipvs 模式的关系是？",
      options: [
        "两者都是实现 Service 的数据面，ipvs 模式提供更好性能与特性",
        "ipvs 用于外部流量，iptables 仅内部",
        "只能二选一，功能不同",
        "ipvs 不支持会话保持",
      ],
      answer: 0,
      rationale: "kube-proxy 可选择 iptables 或 ipvs 实现，ipvs 更高效。",
    },
    {
      id: "w4-2-q5",
      question: "ExternalTrafficPolicy=Local 的效果是？",
      options: [
        "保持客户端源 IP，只转发到本节点上有后端的 Pod",
        "拒绝所有外部流量",
        "随机转发到任意节点",
        "关闭健康检查",
      ],
      answer: 0,
      rationale: "Local 模式保留源地址但只选本机端点，需配合健康检查。",
    },
    {
      id: "w4-2-q6",
      question: "SessionAffinity: ClientIP 的含义？",
      options: [
        "根据客户端 IP 将会话固定到同一后端 Pod",
        "按 Cookie 做粘性",
        "禁用 Service",
        "只能用于 ExternalName",
      ],
      answer: 0,
      rationale: "Service 支持 ClientIP 粘性会话，默认 None。",
    },
    {
      id: "w4-2-q7",
      question: "将 clusterIP 设为 None 的结果？",
      options: [
        "创建 Headless Service，不分配虚拟 IP，直接返回 Endpoint IP",
        "无法创建 Service",
        "强制创建 NodePort",
        "禁止 DNS 解析",
      ],
      answer: 0,
      rationale: "Headless Service 常用于 StatefulSet 提供直连。",
    },
    {
      id: "w4-2-q8",
      question: "EndpointSlice 的引入解决了什么问题？",
      options: [
        "替代旧 Endpoints，提升大规模服务的可伸缩性与性能",
        "替代 Service",
        "用于持久卷",
        "提供日志聚合",
      ],
      answer: 0,
      rationale: "EndpointSlice 拆分 Endpoint 列表，减少单对象过大。",
    },
    {
      id: "w4-2-q9",
      question: "NodePort 服务能否在未运行 Pod 的节点上访问？",
      options: [
        "可以，kube-proxy 会转发到真实后端",
        "不可以，只能访问有 Pod 的节点",
        "需要额外手工路由",
        "只能在主节点访问",
      ],
      answer: 0,
      rationale: "kube-proxy 在每个节点编程规则，允许任意节点转发。",
    },
    {
      id: "w4-2-q10",
      question: "kube-proxy 如何获知 Service/Endpoint 更新？",
      options: [
        "监听 API Server 的 watch 事件并更新本地规则",
        "定期扫描节点端口",
        "依赖 etcd 直接推送",
        "通过 DNS 查询",
      ],
      answer: 0,
      rationale: "kube-proxy 通过 watch API 实时调整 iptables/ipvs。",
    },
  ],
  "w4-3": [
    {
      id: "w4-3-q1",
      question: "使用 Ingress 需要的前提是？",
      options: [
        "集群中部署了 Ingress Controller（如 ingress-nginx）",
        "只需要创建 Ingress 资源即可自动生效",
        "必须使用 NodePort 服务",
        "需要关闭 kube-proxy",
      ],
      answer: 0,
      rationale: "Ingress 资源需由控制器实现具体数据面。",
    },
    {
      id: "w4-3-q2",
      question: "ingressClassName 字段的作用？",
      options: [
        "指定由哪个 IngressClass/Controller 处理该 Ingress",
        "设置默认后端",
        "控制 TLS 证书",
        "配置副本数",
      ],
      answer: 0,
      rationale: "ingressClassName 绑定到特定控制器实例。",
    },
    {
      id: "w4-3-q3",
      question: "pathType 可选值有哪些？",
      options: ["Prefix、Exact、ImplementationSpecific", "Regex、Prefix", "Only Exact", "Any 字符串"],
      answer: 0,
      rationale: "Ingress v1 定义三种 pathType。",
    },
    {
      id: "w4-3-q4",
      question: "TLS 配置需要什么类型的 Secret？",
      options: [
        "kubernetes.io/tls，包含 tls.crt 与 tls.key",
        "Opaque 任意键值",
        "docker-registry 类型",
        "service-account-token",
      ],
      answer: 0,
      rationale: "TLS 段引用的 Secret 必须是 tls 类型并包含证书与私钥。",
    },
    {
      id: "w4-3-q5",
      question: "未命中任何规则时请求将会？",
      options: [
        "转发到默认后端（若配置），否则返回 404",
        "随机分配到某个 Service",
        "丢弃连接",
        "重定向到 API Server",
      ],
      answer: 0,
      rationale: "Ingress 控制器会使用 default backend 处理未匹配流量。",
    },
    {
      id: "w4-3-q6",
      question: "Ingress 规则中的 backend 指向？",
      options: [
        "具体的 Service 名称和端口（号或名称）",
        "Pod IP",
        "节点 IP",
        "ConfigMap",
      ],
      answer: 0,
      rationale: "每个 path 必须指定 service/name 与 service/port。",
    },
    {
      id: "w4-3-q7",
      question: "在 Minikube 启用 ingress 控制器的命令是？",
      options: ["minikube addons enable ingress", "kubectl apply ingress", "minikube start --ingress-only", "需要手工编译内核"],
      answer: 0,
      rationale: "官方教程通过 addons enable ingress 来启动 ingress-nginx。",
    },
    {
      id: "w4-3-q8",
      question: "Ingress 与 Service 的主要区别？",
      options: [
        "Ingress 提供七层路由/主机名/路径规则，Service 提供四层虚拟 IP",
        "Ingress 也提供四层负载均衡",
        "Service 只能暴露 HTTP",
        "二者完全等价",
      ],
      answer: 0,
      rationale: "Ingress 是 L7 入口，Service 是集群内部 L4 负载均衡。",
    },
    {
      id: "w4-3-q9",
      question: "Nginx Ingress Controller 暴露服务常用的 Service 类型是？",
      options: ["NodePort 或 LoadBalancer", "Headless", "ExternalName", "ClusterIP（外部不可达）"],
      answer: 0,
      rationale: "ingress-nginx 默认以 NodePort/LoadBalancer 暴露 80/443 入口。",
    },
    {
      id: "w4-3-q10",
      question: "为什么建议使用 ingressClass 而非旧版 annotation？",
      options: [
        "ingressClass 是 GA 字段，避免注解歧义并支持多控制器共存",
        "注解性能更低",
        "注解无法被 API Server 解析",
        "ingressClass 会自动创建证书",
      ],
      answer: 0,
      rationale: "Ingress v1 推荐使用 ingressClassName 与 IngressClass 资源替代注解选择控制器。",
    },
  ],
  "w4-4": [
    {
      id: "w4-4-q1",
      question: "Namespace 的主要作用是？",
      options: [
        "提供名称作用域与多租户隔离边界（RBAC/配额等）",
        "隔离网络栈",
        "限制内核版本",
        "提高 Pod 性能",
      ],
      answer: 0,
      rationale: "官方文档：Namespace 用于逻辑隔离资源名和权限。",
    },
    {
      id: "w4-4-q2",
      question: "ResourceQuota 可限制哪些内容？",
      options: [
        "CPU/内存请求与上限、PVC 数量、对象数量等",
        "仅限制 Service",
        "仅限制镜像大小",
        "只能限制 Pod 数量",
      ],
      answer: 0,
      rationale: "ResourceQuota 支持计算资源及对象计数等多种维度。",
    },
    {
      id: "w4-4-q3",
      question: "LimitRange 的作用是？",
      options: [
        "为 Namespace 内的 Pod/Container 设置默认/最小/最大资源值",
        "创建网络策略",
        "管理 RBAC",
        "扩缩容 Deployment",
      ],
      answer: 0,
      rationale: "LimitRange 提供资源上下限与默认值，配合配额使用。",
    },
    {
      id: "w4-4-q4",
      question: "当配额要求声明 requests/limits 而 Pod 未设置时会怎样？",
      options: [
        "API Server 拒绝创建，提示需设置资源请求/限制",
        "自动填充为 0",
        "自动分配最大值",
        "忽略配额继续创建",
      ],
      answer: 0,
      rationale: "配额校验需要 Pod 提供 requests/limits 才能计算使用量。",
    },
    {
      id: "w4-4-q5",
      question: "默认 ServiceAccount 的作用范围是？",
      options: [
        "仅所在 Namespace 有效",
        "全局通用",
        "仅供 kube-system 使用",
        "只能用于 CronJob",
      ],
      answer: 0,
      rationale: "ServiceAccount 作用域为 namespace，默认每个 namespace 创建一个 default SA。",
    },
    {
      id: "w4-4-q6",
      question: "删除 Namespace 会发生什么？",
      options: [
        "触发级联删除其中资源，直到 finalizer 清理完成",
        "仅删除标签，不删除资源",
        "立即清空 etcd",
        "需要手工删除所有 Pod 才能删除 Namespace",
      ],
      answer: 0,
      rationale: "Namespace 带有 finalizer，删除时会级联清理资源。",
    },
    {
      id: "w4-4-q7",
      question: "查看配额使用情况的命令是？",
      options: ["kubectl describe quota", "kubectl get pods", "kubectl get csr", "kubectl top nodes"],
      answer: 0,
      rationale: "describe quota 能展示 hard/used 指标与作用域。",
    },
    {
      id: "w4-4-q8",
      question: "ResourceQuota 的作用范围？",
      options: ["限制单个 Namespace 内的资源使用", "限制整个集群", "限制节点数量", "限制存储类"],
      answer: 0,
      rationale: "配额是 namespace 级别，不影响其他命名空间。",
    },
    {
      id: "w4-4-q9",
      question: "ResourceQuota 可以基于哪些 scope 选择对象？",
      options: [
        "如 Terminating/NotTerminating、BestEffort/NotBestEffort 等 scopeSelector",
        "仅基于标签",
        "只能基于节点",
        "不能选择范围",
      ],
      answer: 0,
      rationale: "配额支持 scopeSelector，限制特定生命周期或 QoS 的对象。",
    },
    {
      id: "w4-4-q10",
      question: "为何建议为不同环境创建独立 Namespace？",
      options: [
        "便于 RBAC、配额与资源隔离，降低相互影响",
        "只是为了更好看",
        "避免使用 kube-proxy",
        "减少 etcd 大小",
      ],
      answer: 0,
      rationale: "将 dev/stage/prod 分离有助于权限与资源隔离，符合最佳实践。",
    },
  ],
  // Week 3
  "w3-1": [
    {
      id: "w3-1-q1",
      question: "API Server 的核心职责是？",
      options: [
        "统一入口，负责认证/鉴权/准入校验并持久化对象到 etcd",
        "直接调度 Pod 到节点",
        "拉取镜像并运行容器",
        "提供节点日志收集",
      ],
      answer: 0,
      rationale: "组件概览指出 API Server 是集群前门，处理所有 REST 请求并写入 etcd。",
    },
    {
      id: "w3-1-q2",
      question: "etcd 在集群中的作用是？",
      options: [
        "保存集群期望状态的分布式键值存储，需多数节点保证一致性",
        "作为容器镜像仓库",
        "提供 DNS 服务",
        "替代 kube-proxy 转发流量",
      ],
      answer: 0,
      rationale: "etcd 是唯一存储后端，官方建议奇数节点组成集群以保持 quorum。",
    },
    {
      id: "w3-1-q3",
      question: "kube-controller-manager 主要做什么？",
      options: [
        "运行 Deployment/Node/Job 等控制循环，驱动实际状态收敛到期望",
        "创建容器网络",
        "暴露 Dashboard",
        "负责日志采集",
      ],
      answer: 0,
      rationale: "Controller 模式章节说明它包含多种控制器实现调和循环。",
    },
    {
      id: "w3-1-q4",
      question: "kube-scheduler 的职责是？",
      options: [
        "选择合适节点绑定 Pod（未真正启动容器）",
        "直接拉起容器进程",
        "管理 etcd 备份",
        "生成 Ingress 规则",
      ],
      answer: 0,
      rationale: "调度器只负责绑定决策，具体运行由 kubelet 完成。",
    },
    {
      id: "w3-1-q5",
      question: "kubelet 在节点上做什么？",
      options: [
        "监控 PodSpec，调用容器运行时确保容器按照期望运行",
        "作为集群 DNS",
        "调度其他节点",
        "作为负载均衡器",
      ],
      answer: 0,
      rationale: "组件概览：kubelet 是节点代理，负责容器生命周期与探针上报。",
    },
    {
      id: "w3-1-q6",
      question: "kube-proxy 主要提供什么能力？",
      options: [
        "基于 iptables/ipvs 实现 Service 虚拟 IP 到后端 Pod 的转发",
        "存储镜像",
        "日志采集",
        "Pod 生命周期管理",
      ],
      answer: 0,
      rationale: "Service 文档解释 kube-proxy 监听 Service/Endpoint 并编程数据平面。",
    },
    {
      id: "w3-1-q7",
      question: "Admission Controller 位于哪一层？",
      options: [
        "API Server 内部，在认证/鉴权后对请求做变更或校验",
        "kubelet 插件",
        "etcd 内置功能",
        "kube-proxy 模块",
      ],
      answer: 0,
      rationale: "请求流经认证→鉴权→准入控制→持久化。",
    },
    {
      id: "w3-1-q8",
      question: "节点存活是如何被监测的？",
      options: [
        "kubelet 向 API Server 发送心跳，Node Controller 根据心跳与探活决定 NotReady",
        "依赖 Pod 访问",
        "通过 etcd 直接探测",
        "由 kube-proxy 定期 ping",
      ],
      answer: 0,
      rationale: "Node Controller 监听心跳与状态，心跳缺失会标记 NotReady 并触发驱逐。",
    },
    {
      id: "w3-1-q9",
      question: "CoreDNS 在架构中属于？",
      options: [
        "集群附加组件，通过 Deployment/Service 提供 DNS 解析",
        "控制平面必选组件",
        "容器运行时的一部分",
        "kube-proxy 的子模块",
      ],
      answer: 0,
      rationale: "DNS 是可选附加组件，通常以 Deployment 方式部署。",
    },
    {
      id: "w3-1-q10",
      question: "为什么控制平面通常运行在专用节点？",
      options: [
        "隔离资源与安全，避免工作负载干扰 API/etcd/scheduler",
        "因为需要 GPU",
        "与工作节点网络不兼容",
        "否则 kube-proxy 无法工作",
      ],
      answer: 0,
      rationale: "官方建议分离控制平面以保证可靠性和安全性。",
    },
    {
      id: "w3-1-q11",
      question: "在《Kubernetes Components》文档中，Kubernetes 集群由哪两大部分组成？",
      options: [
        "控制平面（Control Plane）+ 一个或多个工作节点（Worker Nodes）",
        "etcd + Docker",
        "Scheduler + Ingress Controller",
        "Pod + Service",
      ],
      answer: 0,
      rationale: "组件概览指出：A cluster consists of a control plane and one or more worker nodes。",
    },
    {
      id: "w3-1-q12",
      question: "在控制平面组件中，哪个被标注为可选（optional）并用于对接云厂商？",
      options: ["cloud-controller-manager", "kube-apiserver", "kube-scheduler", "etcd"],
      answer: 0,
      rationale: "组件概览：cloud-controller-manager（optional）用于集成底层 cloud provider。",
    },
    {
      id: "w3-1-q13",
      question: "在节点组件中，哪个被标注为可选（optional）并维护网络规则以实现 Service？",
      options: ["kube-proxy", "kubelet", "container runtime", "kube-controller-manager"],
      answer: 0,
      rationale: "组件概览：kube-proxy（optional）维护网络规则以实现 Services。",
    },
    {
      id: "w3-1-q14",
      question: "《Kubernetes Components》对 Node Components 的描述更接近哪一项？",
      options: [
        "运行在每个节点上，维护运行中的 Pods 并提供运行时环境",
        "只运行在控制平面节点上，负责调度",
        "只存储集群状态数据",
        "只负责镜像构建与推送",
      ],
      answer: 0,
      rationale: "组件概览：Node components run on every node, maintaining running pods and providing runtime environment。",
    },
    {
      id: "w3-1-q15",
      question: "组件概览中对 kube-scheduler 的一句话定义是？",
      options: [
        "寻找尚未绑定到节点的 Pod，并为其选择合适的节点",
        "负责所有 REST 请求并写入 etcd",
        "在每个节点上执行容器健康检查",
        "维护网络规则实现 Service",
      ],
      answer: 0,
      rationale: "组件概览：kube-scheduler looks for Pods not yet bound to a node, and assigns each Pod to a suitable node。",
    },
    {
      id: "w3-1-q16",
      question: "组件概览中对 kube-controller-manager 的一句话定义是？",
      options: [
        "运行控制器（controllers）以实现 Kubernetes API 的行为",
        "为集群提供 DNS",
        "负责存储所有 API server 数据",
        "负责为 Pod 分配节点",
      ],
      answer: 0,
      rationale: "组件概览：kube-controller-manager runs controllers to implement Kubernetes API behavior。",
    },
    {
      id: "w3-1-q17",
      question: "组件概览中对 etcd 的描述强调它是？",
      options: [
        "一致且高可用的键值存储，用于保存所有 API server 数据",
        "容器镜像分发系统",
        "节点上的日志采集代理",
        "Service 的四层负载均衡器",
      ],
      answer: 0,
      rationale: "组件概览：etcd 是 a consistent and highly-available key value store for all API server data。",
    },
    {
      id: "w3-1-q18",
      question: "组件概览的 Addons 中，DNS 的主要用途是？",
      options: ["为整个集群提供 DNS 解析", "为容器提供镜像扫描", "为 Pod 分配节点", "为控制平面提供高可用"],
      answer: 0,
      rationale: "Addons 示例：DNS for cluster-wide DNS resolution。",
    },
    {
      id: "w3-1-q19",
      question: "组件概览的 Addons 中，Web UI（Dashboard）的定位是？",
      options: ["通过 Web 界面进行集群管理", "保存容器日志到中心化存储", "实现容器运行时", "调和 Deployment 副本数"],
      answer: 0,
      rationale: "Addons 示例：Web UI（Dashboard）用于通过 Web 界面管理集群。",
    },
    {
      id: "w3-1-q20",
      question: "组件概览的 Addons 中，Container Resource Monitoring 主要用于？",
      options: ["收集并存储容器指标（metrics）", "提供 Pod 网络", "实现 RBAC 鉴权", "生成 kubeconfig"],
      answer: 0,
      rationale: "Addons 示例：Container Resource Monitoring for collecting and storing container metrics。",
    },
    {
      id: "w3-1-q21",
      question: "组件概览的 Addons 中，Cluster-level Logging 主要用于？",
      options: ["将容器日志保存到集中式日志存储", "替代 etcd 保存集群状态", "为节点提供心跳", "为 Pod 做健康检查"],
      answer: 0,
      rationale: "Addons 示例：Cluster-level Logging for saving container logs to a central log store。",
    },
    {
      id: "w3-1-q22",
      question: "《Controllers》文档中对 control loop（控制循环）的定义更接近？",
      options: ["一个不会终止的循环，用于调节系统状态", "一次性执行的初始化脚本", "只在集群启动时运行的任务", "只在故障时触发的中断处理"],
      answer: 0,
      rationale: "Controllers 文档：control loop 是 non-terminating loop that regulates the state of a system。",
    },
    {
      id: "w3-1-q23",
      question: "在 controller pattern 中，Kubernetes 对象的哪个字段代表 desired state？",
      options: ["spec", "status", "metadata", "kind"],
      answer: 0,
      rationale: "Controllers 文档：objects have a spec field that represents the desired state。",
    },
    {
      id: "w3-1-q24",
      question: "在 Kubernetes 中，更常见的控制器收敛方式是？",
      options: [
        "通过与 API server 交互（创建/更新对象）来产生副作用",
        "直接在每个节点上启动容器进程",
        "直接修改 etcd 数据绕过 API server",
        "只写日志，不改任何对象",
      ],
      answer: 0,
      rationale: "Controllers 文档强调：更常见的是 controller 通过 API server 触发一系列副作用以收敛状态。",
    },
    {
      id: "w3-1-q25",
      question: "《Controllers》文档以 Job 为例说明：Job controller 自己会直接运行 Pod/容器吗？",
      options: [
        "不会，它让 API server 创建/删除 Pods，由其他组件调度和运行",
        "会，它在控制器里直接拉起容器进程",
        "会，它直接调用 container runtime 并绕过 kubelet",
        "不会，它只更新 etcd，不会创建 Pods",
      ],
      answer: 0,
      rationale: "Controllers 文档：Job controller 不直接运行 Pods/containers，而是请求 API server 创建/删除 Pods。",
    },
    {
      id: "w3-1-q26",
      question: "Job 完成后，Job controller 通常会如何更新 Job 对象？",
      options: ["更新 Job 对象以标记为 Finished", "删除所有 Node 对象", "把 Pod 直接改成 Succeeded 而不执行任务", "只更新 Service 的 Endpoint"],
      answer: 0,
      rationale: "Controllers 文档：once the work is done, the Job controller updates that Job object to mark it Finished。",
    },
    {
      id: "w3-1-q27",
      question: "《Controllers》文档中提到的 “Direct control” 指的是？",
      options: [
        "控制器直接与集群外部系统通信，把 current state 拉近 desired state",
        "控制器通过 API server 创建对象，让其他控制循环处理",
        "kubelet 直接调度 Pod",
        "etcd 直接重启容器",
      ],
      answer: 0,
      rationale: "Controllers 文档：Direct control 的 controller 需要直接与外部系统交互，并把结果回报给 API server。",
    },
    {
      id: "w3-1-q28",
      question: "为什么《Controllers》文档说集群可能永远达不到稳定状态也没关系？",
      options: [
        "只要控制器在运行并能做出有用的修正，整体状态是否稳定并不关键",
        "因为 etcd 会自动把所有对象变成一致",
        "因为 kubelet 会忽略 spec",
        "因为调度器会停止调度",
      ],
      answer: 0,
      rationale: "Controllers 文档：As long as controllers are running and able to make useful changes, stability doesn't matter。",
    },
    {
      id: "w3-1-q29",
      question: "Controller pattern 中，一个 controller 至少会跟踪（track）什么？",
      options: ["至少一种 Kubernetes 资源类型", "至少一台物理机的温度传感器", "至少一个容器镜像仓库", "至少一个 DNS 服务器"],
      answer: 0,
      rationale: "Controllers 文档：A controller tracks at least one Kubernetes resource type。",
    },
    {
      id: "w3-1-q30",
      question: "《Controllers》文档提到：Pod 一旦被调度（scheduled），Pod 对象会成为哪个组件的 “desired state” 输入？",
      options: ["kubelet", "etcd", "kube-proxy", "coredns"],
      answer: 0,
      rationale: "Controllers 文档括注：Once scheduled, Pod objects become part of the desired state for a kubelet。",
    },
  ],
  "w3-2": [
    {
      id: "w3-2-q1",
      question: "使用 kubeadm init 后通常还需做什么步骤让 Pod 能通信？",
      options: [
        "安装 CNI 插件（如 Flannel/Calico），否则 Pod 处于 Pending",
        "重启全部节点",
        "手动创建 etcd 集群",
        "修改 kubelet.service",
      ],
      answer: 0,
      rationale: "kubeadm 文档要求部署网络插件以提供 Pod 网络。",
    },
    {
      id: "w3-2-q2",
      question: "kubeadm join 默认的 token 有效期是？",
      options: ["24 小时，可通过 kubeadm token create 再生成", "永久有效", "1 小时", "需要手工写入配置文件才有效"],
      answer: 0,
      rationale: "kubeadm 默认 token TTL 24h，过期需重新创建。",
    },
    {
      id: "w3-2-q3",
      question: "高可用控制平面常见的两种 etcd 部署方式是？",
      options: [
        "stacked etcd（与控制平面同节点）或 external etcd（独立集群）",
        "仅单节点 etcd",
        "使用 MySQL 代替 etcd",
        "使用 NFS 共享",
      ],
      answer: 0,
      rationale: "kubeadm HA 指南介绍 stacked 与 external 两种模式。",
    },
    {
      id: "w3-2-q4",
      question: "Kind 创建集群的特点是？",
      options: [
        "节点以容器形式运行，适合本地快速实验",
        "必须使用物理机",
        "仅支持多主多节点生产环境",
        "无法定制 kubelet 参数",
      ],
      answer: 0,
      rationale: "Kind 文档说明基于 Docker 容器模拟节点，便于本地测试。",
    },
    {
      id: "w3-2-q5",
      question: "Minikube 默认提供的是什么类型集群？",
      options: [
        "单节点集群，可选多种驱动（docker/hyperkit/virtualbox 等）",
        "必须三节点",
        "云上托管集群",
        "仅能使用 KVM",
      ],
      answer: 0,
      rationale: "minikube start 默认创建单节点，驱动可配置。",
    },
    {
      id: "w3-2-q6",
      question: "将新控制平面节点加入 kubeadm 集群需要什么？",
      options: [
        "使用 kubeadm join --control-plane 并提供 certificate-key",
        "仅运行 kubelet 即可自动加入",
        "拷贝 /etc/kubernetes/admin.conf 即可",
        "编辑 etcd 数据",
      ],
      answer: 0,
      rationale: "kubeadm HA 文档要求使用 certificate key 保护证书分发。",
    },
    {
      id: "w3-2-q7",
      question: "kubeadm init 默认生成的管理员 kubeconfig 位于？",
      options: ["/etc/kubernetes/admin.conf", "~/.kube/config", "/var/lib/kubelet/kubeconfig", "/etc/hosts"],
      answer: 0,
      rationale: "官方指南使用 admin.conf 拷贝到 ~/.kube/config 以使用 kubectl。",
    },
    {
      id: "w3-2-q8",
      question: "kubeadm reset 的作用是？",
      options: [
        "清理 kubeadm 部署的组件/配置，便于重新初始化",
        "扩容节点",
        "升级集群",
        "仅删除 etcd 数据",
      ],
      answer: 0,
      rationale: "reset 用于回滚节点状态，移除 kubeadm 安装的文件和容器。",
    },
    {
      id: "w3-2-q9",
      question: "kubeadm init --apiserver-advertise-address 用途是？",
      options: [
        "指定 API Server 对外可达的绑定地址",
        "设置 Service CIDR",
        "配置 etcd 监听端口",
        "开启 Ingress",
      ],
      answer: 0,
      rationale: "需指定主机实际 IP 供其他节点访问 API。",
    },
    {
      id: "w3-2-q10",
      question: "缺少 kube-proxy 或未加载 br_netfilter 模块可能导致？",
      options: ["Service/Pod 网络异常，DNS 解析失败", "kubeadm init 直接失败", "etcd 无法启动", "镜像拉取失败"],
      answer: 0,
      rationale: "网络前置条件未满足会导致 Service 不通或 DNS 失败。",
    },
    {
      id: "w3-2-q11",
      question: "kubeadm 文档对 kubeadm 的一句话定位是？",
      options: [
        "创建符合最佳实践的最小可用 Kubernetes 集群（minimum viable cluster）",
        "替代 kubelet 运行容器",
        "把 YAML 直接写入 etcd",
        "只用于管理 Ingress Controller",
      ],
      answer: 0,
      rationale: "kubeadm 文档开篇说明：Using kubeadm, you can create a minimum viable Kubernetes cluster that conforms to best practices。",
    },
    {
      id: "w3-2-q12",
      question: "kubeadm 文档提到 kubeadm 还支持哪些集群生命周期功能？",
      options: ["bootstrap tokens 与集群升级（upgrades）", "自动生成应用日志", "内置 CNI 插件（无需安装网络）", "自动部署 Ingress-NGINX"],
      answer: 0,
      rationale: "kubeadm 文档提到 kubeadm 支持 bootstrap tokens、cluster upgrades 等生命周期能力。",
    },
    {
      id: "w3-2-q13",
      question: "kubeadm 文档认为 kubeadm 适合用来？",
      options: [
        "自动化搭建集群并测试应用（也可作为更大安装器的构建块）",
        "替代容器镜像仓库",
        "替代 Service 的负载均衡",
        "替代 etcd 保存状态",
      ],
      answer: 0,
      rationale: "kubeadm 文档列举的场景包括：试用 Kubernetes、自动化搭建测试集群、作为其他安装器的 building block。",
    },
    {
      id: "w3-2-q14",
      question: "kubeadm 创建集群的 prerequisites 中，控制平面节点建议至少多少 CPU？",
      options: ["至少 2 个 CPU", "至少 1 个 CPU", "至少 8 个 CPU", "CPU 不重要"],
      answer: 0,
      rationale: "kubeadm prerequisites：At least 2 CPUs on the machine that you use as a control-plane node。",
    },
    {
      id: "w3-2-q15",
      question: "kubeadm prerequisites 中对每台机器的内存建议是？",
      options: ["2 GiB 或更多", "256 MiB", "64 GiB", "仅看磁盘，不看内存"],
      answer: 0,
      rationale: "kubeadm prerequisites：2 GiB or more of RAM per machine。",
    },
    {
      id: "w3-2-q16",
      question: "kubeadm 在 host 网络准备阶段，会优先从哪里挑选组件使用的 IP？",
      options: [
        "与默认网关关联的网络接口上的可用 IP（global unicast）",
        "随机选择任意网卡",
        "永远使用 127.0.0.1",
        "必须手工指定网卡名称，否则无法运行",
      ],
      answer: 0,
      rationale: "kubeadm 文档说明：组件会在与 default gateway 相关的接口上选择可用 IP 作为 advertise/listen 地址。",
    },
    {
      id: "w3-2-q17",
      question: "kubeadm 文档建议用哪个命令查看默认路由以判断组件可能选用的 IP？",
      options: ["`ip route show`（寻找以 `default via` 开头的行）", "`ifconfig -a`（只看 lo）", "`route -n | grep kubeadm`", "`kubectl get node -o wide`"],
      answer: 0,
      rationale: "kubeadm network setup 章节给出：ip route show # Look for a line starting with \"default via\"。",
    },
    {
      id: "w3-2-q18",
      question: "如果宿主机存在多个默认网关，kubeadm 文档提醒可能发生什么？",
      options: [
        "组件会尝试使用遇到的第一个具有合适 global unicast IP 的默认网关（顺序可能因 OS/内核不同而变）",
        "kubeadm 会直接拒绝初始化",
        "会自动创建额外的 CNI 网卡",
        "会强制使用最后一个默认网关",
      ],
      answer: 0,
      rationale: "kubeadm 文档 note：多个 default gateways 时，会尝试使用第一个合适的网关，顺序可能因系统而异。",
    },
    {
      id: "w3-2-q19",
      question: "为什么为控制平面组件显式指定 IP 地址（如 advertise address）可能带来后续麻烦？",
      options: [
        "这些 IP 会写入证书的 SAN，变更需要重新签发证书并重启组件",
        "会导致 kube-proxy 自动卸载",
        "会让 Pod 无法拉取镜像",
        "会让 Service CIDR 自动改变",
      ],
      answer: 0,
      rationale: "kubeadm 文档提示：组件 IP 会成为证书 SAN 的一部分，变更会牵涉证书与组件重启。",
    },
    {
      id: "w3-2-q20",
      question: "kubeadm 文档对“给所有组件都配置自定义 IP 地址”给出的建议是？",
      options: [
        "不推荐；更建议把宿主机网络配置好，让默认网关 IP 成为组件自动检测并使用的地址",
        "强烈推荐；这是生产唯一正确做法",
        "必须这么做，否则 etcd 无法启动",
        "只能在 Windows 上这么做",
      ],
      answer: 0,
      rationale: "kubeadm warning：项目不建议为所有组件配置自定义 IP，更推荐把 host network 配置到位。",
    },
    {
      id: "w3-2-q21",
      question: "离线（节点无互联网）初始化集群时，kubeadm 文档建议如何处理组件镜像？",
      options: [
        "使用 kubeadm 的预拉取能力或自定义镜像仓库，提前准备所需镜像",
        "把镜像写入 etcd",
        "让 kubelet 自动从 Docker Hub 下载（不需要网络）",
        "只能手工拷贝每个容器层文件到 /var/lib",
      ],
      answer: 0,
      rationale: "kubeadm 文档：可 pre-pull 所需镜像或配置 custom image repository，以支持无网环境。",
    },
    {
      id: "w3-2-q22",
      question: "kubeadm HA 拓扑中，stacked etcd 的关键特点是？",
      options: [
        "etcd 成员与控制平面组件同机部署，耦合更强但搭建更简单",
        "etcd 运行在独立三节点集群，与控制平面完全解耦",
        "etcd 被替换为 MySQL",
        "无需负载均衡器即可对外暴露 apiserver",
      ],
      answer: 0,
      rationale: "HA topology：stacked control plane nodes 上 colocate etcd，配置更简单但故障耦合更强。",
    },
    {
      id: "w3-2-q23",
      question: "stacked etcd 拓扑的主要风险是什么？",
      options: [
        "单个控制平面节点故障会同时丢失一个 etcd member 和一套控制平面实例，冗余被削弱",
        "网络延迟必然翻倍",
        "Pod 会被固定到同一节点无法漂移",
        "kubeadm join 会永久失效",
      ],
      answer: 0,
      rationale: "HA topology：stacked 拓扑存在 control plane 与 etcd 成员“耦合失效”的风险。",
    },
    {
      id: "w3-2-q24",
      question: "kubeadm HA 文档建议 stacked 控制平面最少运行多少个节点？",
      options: ["至少 3 个控制平面节点", "至少 1 个控制平面节点", "至少 2 个控制平面节点", "至少 10 个控制平面节点"],
      answer: 0,
      rationale: "HA topology：You should therefore run a minimum of three stacked control plane nodes for an HA cluster。",
    },
    {
      id: "w3-2-q25",
      question: "external etcd 拓扑下，文档建议的最小主机数量是？",
      options: ["至少 6 台（3 台控制平面 + 3 台 etcd）", "至少 3 台（都跑控制平面与 etcd）", "至少 4 台", "至少 2 台"],
      answer: 0,
      rationale: "HA topology：external etcd 需要 3 台 control plane + 3 台 etcd hosts 才能形成 HA。",
    },
    {
      id: "w3-2-q26",
      question: "kind 文档中，创建集群最基本的命令是？",
      options: ["`kind create cluster`", "`kind init`", "`kubectl create cluster`", "`kubeadm kind`"],
      answer: 0,
      rationale: "kind Quick Start：Creating a Kubernetes cluster is as simple as `kind create cluster`。",
    },
    {
      id: "w3-2-q27",
      question: "kind 文档中，`kind create cluster --wait 5m` 的作用是？",
      options: [
        "阻塞等待控制平面就绪，直到超时（必须写明时间单位，如 30s/5m）",
        "等待所有 Pod 都处于 Ready，否则无法创建集群",
        "只等待镜像下载完成",
        "只等待 kube-proxy 启动",
      ],
      answer: 0,
      rationale: "kind Quick Start：`--wait` 可让创建命令阻塞直到控制平面 ready，并可设置带单位的超时值。",
    },
    {
      id: "w3-2-q28",
      question: "kind 文档中，默认创建的集群名称/上下文（context）是什么？",
      options: ["`kind`", "`default`", "`kubernetes`", "`minikube`"],
      answer: 0,
      rationale: "kind Quick Start：By default, the cluster will be given the name `kind`（同时也作为默认 context 名称）。",
    },
    {
      id: "w3-2-q29",
      question: "kind 文档提到，如果想关闭 provider 自动探测并显式选择运行时，可用哪个环境变量？",
      options: ["`KIND_EXPERIMENTAL_PROVIDER`", "`KUBECONFIG`", "`KIND_PROVIDER`", "`DOCKER_HOST`"],
      answer: 0,
      rationale: "kind Quick Start：可用 `KIND_EXPERIMENTAL_PROVIDER=docker|podman|nerdctl` 显式选择 provider。",
    },
    {
      id: "w3-2-q30",
      question: "minikube start 文档给出的最低资源需求更接近？",
      options: ["至少 2 CPUs、2GB 内存、20GB 磁盘空间", "至少 8 CPUs、32GB 内存、200GB 磁盘空间", "至少 1 CPU、256MB 内存即可", "必须 GPU 才能启动"],
      answer: 0,
      rationale: "minikube 文档列出：2 CPUs、2GB free memory、20GB free disk space 等基本要求。",
    },
  ],
  "w3-3": [
    {
      id: "w3-3-q1",
      question: "Kubernetes YAML 的基本骨架包含？",
      options: [
        "apiVersion、kind、metadata、spec 四大字段",
        "version、type、name、body",
        "header、payload、footer",
        "仅 metadata 即可",
      ],
      answer: 0,
      rationale: "对象定义都包含 apiVersion/kind/metadata/spec（或 data）。",
    },
    {
      id: "w3-3-q2",
      question: "Reconciliation Loop 的含义是？",
      options: [
        "控制器持续对比期望状态与实际状态，直到收敛",
        "一次性命令式执行",
        "仅在集群启动时运行一次",
        "只针对 Deployment",
      ],
      answer: 0,
      rationale: "控制器模式文档强调声明式与持续调和。",
    },
    {
      id: "w3-3-q3",
      question: "kubectl apply 默认使用什么策略记录上次配置？",
      options: [
        "在对象上写入 last-applied-configuration 注解，便于后续三方合并",
        "不做记录",
        "保存在本地 ~/.kube/cache",
        "写入 etcd 另一个数据库",
      ],
      answer: 0,
      rationale: "kubectl apply 客户端存储 last-applied 注解用于 merge。",
    },
    {
      id: "w3-3-q4",
      question: "kubectl patch --type=json 使用的格式是？",
      options: [
        "JSON Patch（RFC 6902）操作列表",
        "YAML Patch",
        "二进制补丁",
        "策略合并补丁",
      ],
      answer: 0,
      rationale: "kubectl 支持 json/merge/strategic 三种 patch 类型。",
    },
    {
      id: "w3-3-q5",
      question: "kubectl replace 与 kubectl apply 的区别是？",
      options: [
        "replace 会删除重建对象，丢失集群侧修改；apply 进行合并",
        "两者完全相同",
        "replace 只能改 metadata",
        "apply 需要先 delete",
      ],
      answer: 0,
      rationale: "声明式推荐 apply，replace 更接近命令式替换。",
    },
    {
      id: "w3-3-q6",
      question: "labels/selectors 的作用是？",
      options: [
        "为对象分组/筛选，供 Service/Deployment 等选择 Pod",
        "控制节点心跳",
        "定义角色权限",
        "仅用于 UI 展示",
      ],
      answer: 0,
      rationale: "标签选择器是声明式 API 的核心关联机制。",
    },
    {
      id: "w3-3-q7",
      question: "kubectl explain 的用途是？",
      options: [
        "查看字段含义/类型，来自 OpenAPI 模式",
        "生成 RBAC 规则",
        "调试网络",
        "显示日志",
      ],
      answer: 0,
      rationale: "explain 提供文档化的字段说明，便于写 YAML。",
    },
    {
      id: "w3-3-q8",
      question: "server-side apply 的特点是？",
      options: [
        "由 apiserver 负责合并，记录 fieldManager，发生冲突会提示",
        "与客户端 apply 等价",
        "需要 kubelet 支持",
        "仅支持 ConfigMap",
      ],
      answer: 0,
      rationale: "SSA 在 apiserver 进行字段所有权管理，减少客户端冲突。",
    },
    {
      id: "w3-3-q9",
      question: "resourceVersion 在写请求中主要用于？",
      options: [
        "实现乐观锁，防止并发覆盖",
        "定义对象优先级",
        "控制日志级别",
        "标记所属命名空间",
      ],
      answer: 0,
      rationale: "使用 resourceVersion 条件写可避免误覆盖旧状态。",
    },
    {
      id: "w3-3-q10",
      question: "kubectl diff 的作用是？",
      options: [
        "预览本地清单与集群对象差异，不会真正应用",
        "比较两个文件的文本差异",
        "生成审计日志",
        "只能查看 labels 变化",
      ],
      answer: 0,
      rationale: "diff 命令帮助审查变更再 apply。",
    },
    {
      id: "w3-3-q11",
      question: "《Objects In Kubernetes》把 Kubernetes object 描述为“record of intent”意味着？",
      options: [
        "创建对象后，Kubernetes 会持续工作以确保对象存在并趋近你声明的期望状态",
        "对象只在 kubectl 运行时短暂存在",
        "对象只用于日志记录，不影响集群行为",
        "对象只存储在本地 YAML 文件中",
      ],
      answer: 0,
      rationale: "Objects 文档：object 是“意图记录”，创建后系统会持续确保对象存在并收敛到期望状态。",
    },
    {
      id: "w3-3-q12",
      question: "Kubernetes objects 可以描述的内容之一是？",
      options: ["正在运行的容器化应用以及它们运行在哪些节点上", "宿主机 BIOS 设置", "Dockerfile 构建缓存", "VPC 路由表规则（独立于集群）"],
      answer: 0,
      rationale: "Objects 文档列举：objects 可以描述应用运行情况（以及运行在哪些节点）等集群状态。",
    },
    {
      id: "w3-3-q13",
      question: "要创建/修改/删除 Kubernetes objects，权威方式是通过？",
      options: ["Kubernetes API（kubectl 本质上也是在调用 API）", "直接编辑 etcd 数据目录", "只改本地 YAML 文件即可自动生效", "重启 kubelet 即可自动生成对象"],
      answer: 0,
      rationale: "Objects 文档：要操作对象需要通过 Kubernetes API；kubectl 会发起对应的 API 调用。",
    },
    {
      id: "w3-3-q14",
      question: "几乎所有对象都有 spec 与 status，它们的关系是？",
      options: ["spec 描述期望状态，status 由系统组件更新并反映当前状态", "spec 由系统生成，status 由用户手工维护", "spec 与 status 完全等价", "spec 只用于日志，status 才决定行为"],
      answer: 0,
      rationale: "Objects 文档：spec 是 desired state；status 是 current state，由 Kubernetes 系统及组件持续更新。",
    },
    {
      id: "w3-3-q15",
      question: "文档中常说的 manifest（清单）更接近？",
      options: ["描述对象的配置文件（通常 YAML，也可 JSON），kubectl 会把它转换成请求体提交给 API", "Pod 的日志文件", "容器镜像的层列表", "etcd 的快照文件"],
      answer: 0,
      rationale: "Objects 文档：manifest 多为 YAML（也可 JSON），kubectl 会将其转换成 API 请求体提交。",
    },
    {
      id: "w3-3-q16",
      question: "在对象清单中，用于唯一标识对象、最常见且最关键的字段是？",
      options: ["metadata.name", "metadata.creationTimestamp", "metadata.resourceVersion", "metadata.uid（必须手工填写）"],
      answer: 0,
      rationale: "Objects 文档：创建对象时需要提供基本信息（如 name）；UID 由系统分配，不需要手工填写。",
    },
    {
      id: "w3-3-q17",
      question: "从 Kubernetes v1.25 起，API server 提供 server-side field validation，kubectl 用哪个参数设置校验级别？",
      options: ["`--validate`（ignore/warn/strict）", "`--dry-run`", "`--force-conflicts`", "`--field-manager`"],
      answer: 0,
      rationale: "Objects 文档：`kubectl --validate` 可设置 ignore/warn/strict（或 true/false）校验级别。",
    },
    {
      id: "w3-3-q18",
      question: "`kubectl` 默认的字段校验级别更接近？",
      options: ["strict（`--validate=true`）", "ignore（`--validate=false`）", "warn（默认只告警不失败）", "默认不做任何校验"],
      answer: 0,
      rationale: "Objects 文档：kubectl 默认 `--validate=true`，等价于 strict。",
    },
    {
      id: "w3-3-q19",
      question: "当 kubectl 连接到不支持 field validation 的 API server 时会？",
      options: ["回退到 client-side validation", "直接跳过所有校验并静默成功", "自动升级集群到 1.27", "强制改用 server-side apply"],
      answer: 0,
      rationale: "Objects 文档：kubectl 无法连接到支持 field validation 的 API server 时会回退到 client-side validation。",
    },
    {
      id: "w3-3-q20",
      question: "声明式管理文档中，`kubectl apply -f <directory>` 配合 `-R` 的含义是？",
      options: ["递归处理目录中的多个对象清单", "强制替换对象并删除重建", "仅打印对象而不创建", "只对 Namespace 生效"],
      answer: 0,
      rationale: "Declarative config 文档：`-R` 用于递归处理目录；结合 `apply -f <directory>` 批量管理对象。",
    },
    {
      id: "w3-3-q21",
      question: "`kubectl apply` 写入的 `kubectl.kubernetes.io/last-applied-configuration` 注解主要保存？",
      options: [
        "用于创建/更新该对象的配置文件内容（以 JSON 表示）",
        "上一次 kubectl 命令的 stdout",
        "容器日志最后 100 行",
        "etcd 的 key 前缀列表",
      ],
      answer: 0,
      rationale: "Declarative config 文档：该注解包含用于创建对象的配置文件内容（JSON 表示），便于后续合并。",
    },
    {
      id: "w3-3-q22",
      question: "声明式管理文档中，`kubectl diff` 预览差异依赖的机制是？",
      options: ["server-side dry-run（服务端 dry-run 的 apply 请求）", "本地把 YAML 做文本 diff", "读取 etcd 直接对比 key", "只比较 metadata.labels"],
      answer: 0,
      rationale: "Declarative config 文档：`diff` 使用 server-side dry-run（以 dry-run 的 server-side apply 请求预览差异）。",
    },
    {
      id: "w3-3-q23",
      question: "文档提示：`kubectl diff` 因为执行 dry-run 的 server-side apply，通常需要授予哪些权限？",
      options: ["PATCH、CREATE、UPDATE", "GET、LIST", "DELETE", "WATCH（仅 watch 就够）"],
      answer: 0,
      rationale: "Declarative config 文档：`diff` 会发起 server-side apply 的 dry-run 请求，需要 PATCH/CREATE/UPDATE 权限。",
    },
    {
      id: "w3-3-q24",
      question: "声明式管理文档中，使用 `kubectl apply` 更新对象时，对从配置文件中删除的字段会？",
      options: ["在 live configuration 中清理/清空这些字段", "保留集群侧旧值不变", "把字段移动到 metadata.annotations", "直接拒绝更新"],
      answer: 0,
      rationale: "Declarative config 文档：apply 更新会设置文件中出现的字段，并清理从文件中移除的字段。",
    },
    {
      id: "w3-3-q25",
      question: "在 kubectl patch 文档示例中，strategic merge patch 对 `spec.template.spec.containers` 列表的行为通常是？",
      options: ["按 `name` 合并/追加容器条目（merge），而不是整表替换", "无论如何都整表替换", "只能修改镜像 tag", "只能修改 metadata"],
      answer: 0,
      rationale: "kubectl patch 文档：containers 字段有 merge 策略（merge key 为 name），strategic merge patch 会合并列表。",
    },
    {
      id: "w3-3-q26",
      question: "为什么示例中对 `tolerations` 的 strategic merge patch 会“替换整个列表”？",
      options: ["因为该字段没有声明 patchStrategy，默认策略是 replace", "因为 tolerations 只能有 1 条", "因为 YAML 不支持数组合并", "因为 kubeadm 会重写该字段"],
      answer: 0,
      rationale: "kubectl patch 文档：未声明 patchStrategy 的列表字段默认 replace，因此 tolerations 会被整体替换。",
    },
    {
      id: "w3-3-q27",
      question: "在 JSON merge patch（RFC 7386）中，如果要更新列表字段，正确做法是？",
      options: ["提供完整的新列表，新的列表会完全替换旧列表", "只提供要追加的 1 条元素即可自动合并", "使用 `--type strategic` 才能替换列表", "必须先 delete 再 create"],
      answer: 0,
      rationale: "kubectl patch 文档：JSON merge patch 更新列表需要提供完整新列表，并会替换旧列表。",
    },
    {
      id: "w3-3-q28",
      question: "`kubectl patch` 的 `--type` 可选值包含？默认是哪一个？",
      options: ["json / merge / strategic，默认 strategic", "apply / replace / diff，默认 apply", "http / tcp / grpc，默认 http", "create / update / delete，默认 update"],
      answer: 0,
      rationale: "kubectl patch 文档表格：`--type` 支持 json/merge/strategic，默认 strategic。",
    },
    {
      id: "w3-3-q29",
      question: "关于 `--validate=warn` 的行为，哪个说法更准确？",
      options: ["执行字段校验，但把校验错误以 warning 形式暴露，不直接失败请求", "完全跳过字段校验", "遇到未知字段会立刻失败（等同 strict）", "只校验 metadata.name"],
      answer: 0,
      rationale: "Objects 文档：Warn 模式会执行校验，但把错误作为 warning 暴露而非直接失败请求。",
    },
    {
      id: "w3-3-q30",
      question: "kubectl patch 默认使用哪种 patch 类型？",
      options: ["strategic merge patch", "json patch（RFC 6902）", "json merge patch（RFC 7386）", "只能使用一种固定补丁格式"],
      answer: 0,
      rationale: "kubectl patch 文档：`--type` 默认值是 strategic。",
    },
  ],
  "w3-4": [
    {
      id: "w3-4-q1",
      question: "Pod 可能的 Phase 包括？",
      options: [
        "Pending/Running/Succeeded/Failed/Unknown",
        "Starting/Stop/Restart",
        "Created/Destroyed/Paused",
        "Only Running and Failed",
      ],
      answer: 0,
      rationale: "Pod 生命周期文档列出五种 Phase。",
    },
    {
      id: "w3-4-q2",
      question: "Init Containers 的执行特点是？",
      options: [
        "按顺序依次执行，全部成功后才启动主容器",
        "与主容器并行执行",
        "失败会直接忽略",
        "与 liveness 探针相同",
      ],
      answer: 0,
      rationale: "Init 容器必须全部完成，且按声明顺序运行。",
    },
    {
      id: "w3-4-q3",
      question: "Liveness 与 Readiness Probe 的区别是？",
      options: [
        "Liveness 决定是否重启容器，Readiness 决定是否接收流量",
        "两者完全相同",
        "Readiness 更频繁重启容器",
        "Liveness 只能使用 HTTP",
      ],
      answer: 0,
      rationale: "官方文档区分存活与就绪探针职责。",
    },
    {
      id: "w3-4-q4",
      question: "CrashLoopBackOff 表示什么？",
      options: [
        "容器启动后反复崩溃，kubelet 进入指数退避重启",
        "镜像拉取失败",
        "节点宕机",
        "探针超时导致无重启",
      ],
      answer: 0,
      rationale: "当容器异常退出，kubelet 会等待更长时间再重启，状态显示 CrashLoopBackOff。",
    },
    {
      id: "w3-4-q5",
      question: "Pod 终止的默认流程是？",
      options: [
        "发送 SIGTERM 给容器，等待 terminationGracePeriodSeconds，超时后 SIGKILL",
        "直接 SIGKILL",
        "立刻删除 Pod 记录",
        "先关闭 kube-proxy",
      ],
      answer: 0,
      rationale: "终止流程包括预停止 hook、优雅等待后再强杀。",
    },
    {
      id: "w3-4-q6",
      question: "restartPolicy=OnFailure 通常用于哪类工作负载？",
      options: ["Job", "Deployment", "DaemonSet", "StatefulSet"],
      answer: 0,
      rationale: "Job 默认使用 OnFailure 或 Never，Deployment 只能使用 Always。",
    },
    {
      id: "w3-4-q7",
      question: "Readiness Gate 的作用是？",
      options: [
        "允许自定义条件参与 Pod Ready 判定",
        "替代 liveness 探针",
        "控制 HPA",
        "只用于 StatefulSet",
      ],
      answer: 0,
      rationale: "ReadinessGate 允许外部条件（如注入的条件）控制 Ready 状态。",
    },
    {
      id: "w3-4-q8",
      question: "ImagePullBackOff 状态通常意味着？",
      options: [
        "镜像拉取失败（认证/网络/镜像不存在），kubelet 正在退避重试",
        "容器内应用崩溃",
        "节点磁盘满",
        "探针失败",
      ],
      answer: 0,
      rationale: "事件中通常可见 ErrImagePull，需检查 registry 访问或凭证。",
    },
    {
      id: "w3-4-q9",
      question: "Ephemeral Container 用于？",
      options: [
        "调试现有 Pod，不会参与就绪判定，也不会自动重启",
        "提供存储卷",
        "承担主要业务",
        "替代 Init 容器",
      ],
      answer: 0,
      rationale: "调试容器是临时的，只用于排查问题。",
    },
    {
      id: "w3-4-q10",
      question: "PostStart/PreStop Hook 与探针的区别是？",
      options: [
        "Hook 是一次性回调，探针是周期性健康检查",
        "Hook 只在调试时可用",
        "探针只在 Pod 终止时执行",
        "两者完全相同",
      ],
      answer: 0,
      rationale: "生命周期钩子在特定事件触发一次，与周期性探针用途不同。",
    },
    {
      id: "w3-4-q11",
      question: "Pod 在其生命周期内会被重新调度（reschedule）到其他节点吗？",
      options: [
        "不会；Pod 只会被调度一次，若需迁移通常是创建一个新的替代 Pod（UID 不同）",
        "会；scheduler 会定期把 Pod 迁移到更空闲的节点",
        "会；kubelet 会在节点间搬迁 Pod",
        "不会；但 UID 会保持不变并且 Pod 名称必然改变",
      ],
      answer: 0,
      rationale: "Pod lifecycle 文档：Pods are only scheduled once；同一个 UID 的 Pod 不会被 reschedule，只会被新 Pod 替代。",
    },
    {
      id: "w3-4-q12",
      question: "将 Pod 分配到一个具体 Node 的动作在文档中称为？",
      options: ["Binding", "Proxying", "Tainting", "Leasing"],
      answer: 0,
      rationale: "Pod lifecycle 文档：assigning a Pod to a specific node is called binding。",
    },
    {
      id: "w3-4-q13",
      question: "选择要使用哪个 Node 来运行 Pod 的过程称为？",
      options: ["Scheduling", "Binding", "Draining", "Checkpointing"],
      answer: 0,
      rationale: "Pod lifecycle 文档：the process of selecting which node to use is called scheduling。",
    },
    {
      id: "w3-4-q14",
      question: "如果一个 Node 宕机，运行在该 Node 上的 Pod 通常会？",
      options: [
        "被视为不健康并最终被删除，由上层控制器创建新的 Pod 来替代",
        "自动迁移到另一个 Node，UID 不变",
        "继续在 etcd 中运行并提供服务",
        "永远保持 Running 状态",
      ],
      answer: 0,
      rationale: "Pod lifecycle 文档：Node 失败后相关 Pods 会被标记并最终删除，通常由更高层 controller 负责重建替代。",
    },
    {
      id: "w3-4-q15",
      question: "Pod 的 `status` 中包含的一组条件（conditions）主要用于？",
      options: [
        "反映 Pod 的当前状态信号（如 Ready/Initialized 等），供系统与用户判断",
        "声明期望副本数",
        "保存上一次 apply 的清单内容",
        "指定镜像仓库凭证",
      ],
      answer: 0,
      rationale: "Pod lifecycle 文档：Pod status 包含一组 Pod conditions，可用于表达 Ready 等状态信号。",
    },
    {
      id: "w3-4-q16",
      question: "Pod 生命周期文档中提到的容器三种状态是？",
      options: ["Waiting / Running / Terminated", "Pending / Running / Succeeded", "Init / Ready / Live", "Created / Paused / Deleted"],
      answer: 0,
      rationale: "Pod lifecycle 文档：There are three possible container states: Waiting, Running, and Terminated。",
    },
    {
      id: "w3-4-q17",
      question: "容器处于 Waiting 状态时，文档给出的典型原因是？",
      options: ["拉取镜像或应用 Secret 等启动前操作仍在进行", "Service 没有 Endpoint", "kube-scheduler 未安装", "etcd 磁盘满导致容器直接退出"],
      answer: 0,
      rationale: "Pod lifecycle 文档：Waiting 常见原因包括 pulling image、applying Secret data 等启动前操作。",
    },
    {
      id: "w3-4-q18",
      question: "若配置了 `preStop` hook，它会在容器进入哪种状态前执行？",
      options: ["Terminated", "Waiting", "Running", "Pending"],
      answer: 0,
      rationale: "Pod lifecycle 文档：If a container has a preStop hook configured, it runs before the container enters Terminated state。",
    },
    {
      id: "w3-4-q19",
      question: "Pod 生命周期文档描述的 CrashLoopBackOff 退避机制在什么情况下会被重置（reset）？",
      options: [
        "容器稳定运行一段时间后（例如约 10 分钟），新的崩溃会被当作第一次崩溃处理",
        "每次重启都会立即重置",
        "只有手工删除 Pod 才会重置",
        "只要修改镜像就会重置",
      ],
      answer: 0,
      rationale: "Pod lifecycle 文档：容器成功运行一段时间（例如 10 分钟）后，backoff 会被重置。",
    },
    {
      id: "w3-4-q20",
      question: "Readiness Probe 最直接影响的是？",
      options: ["Pod 是否会被加入/移出 Service 的负载均衡后端", "容器是否会被 kubelet 重启", "节点是否会被标记 NotReady", "etcd 的选主速度"],
      answer: 0,
      rationale: "Probes 文档：Readiness 用于判断是否接收流量，不 ready 的 Pod 会从 Service load balancers 移除。",
    },
    {
      id: "w3-4-q21",
      question: "文档中，Pod 的 Ready condition 可能为 false 的原因之一是？",
      options: ["Node 的 Ready condition 不为 true", "容器镜像体积过大", "Deployment 副本数太多", "Service 没有 selector"],
      answer: 0,
      rationale: "Probes 文档：Pod Ready condition 会因 Node Ready 不为 true、readinessGates 为 false 等原因变为 false。",
    },
    {
      id: "w3-4-q22",
      question: "配置了 startupProbe 后，liveness/readiness probes 的启动时机是？",
      options: ["startupProbe 成功之前不会开始执行 liveness/readiness", "三者同时开始执行", "startupProbe 只在 Pod 终止时执行一次", "startupProbe 会替代 readinessProbe"],
      answer: 0,
      rationale: "Probes 文档：配置 startupProbe 后，liveness/readiness probes 会等待 startupProbe 成功后才开始执行。",
    },
    {
      id: "w3-4-q23",
      question: "HTTP 探针（httpGet）判定成功的状态码范围是？",
      options: ["200-399（>=200 且 <400）", "仅 200", "100-199", "400-599"],
      answer: 0,
      rationale: "Probes 文档：HTTP probe 返回码 >=200 且 <400 判定为 success。",
    },
    {
      id: "w3-4-q24",
      question: "为什么文档强调 liveness probes 需要谨慎配置？",
      options: [
        "配置不当可能引发级联故障：高负载下频繁重启、请求失败、剩余 Pod 压力上升",
        "因为 liveness probes 会降低 etcd 一致性",
        "因为 liveness probes 会让 Scheduler 停止工作",
        "因为 liveness probes 会禁止滚动升级",
      ],
      answer: 0,
      rationale: "Probes 文档 note/caution：错误的 liveness 配置可能导致级联故障与更多重启/请求失败。",
    },
    {
      id: "w3-4-q25",
      question: "排查 Pod 问题时，Debug Pods 文档建议首先运行的命令是？",
      options: ["`kubectl describe pods <pod-name>`", "`kubectl delete pod <pod-name>`", "`kubectl reset cluster`", "`docker system prune -a`"],
      answer: 0,
      rationale: "Debug Pods 文档：第一步查看 Pod 状态与事件，建议使用 `kubectl describe pods ${POD_NAME}`。",
    },
    {
      id: "w3-4-q26",
      question: "Pod 长时间处于 Pending 通常意味着？",
      options: ["无法被调度到某个节点（如资源不足、约束条件不满足）", "镜像拉取失败", "容器已启动但探针失败", "已经完成并退出"],
      answer: 0,
      rationale: "Debug Pods 文档：Pending 代表 Pod 不能被调度到节点，常见原因是资源不足或约束导致 FailedScheduling。",
    },
    {
      id: "w3-4-q27",
      question: "Pod 长时间处于 Waiting，Debug Pods 文档指出最常见的原因是？",
      options: ["镜像拉取失败（名称不对/未推送/registry 不可达等）", "Service 没有 Ingress", "etcd leader 选举中", "kubelet 不支持 CNI"],
      answer: 0,
      rationale: "Debug Pods 文档：Waiting 最常见原因是 image pull 失败（检查镜像名、是否推送、网络与认证）。",
    },
    {
      id: "w3-4-q28",
      question: "Pod 卡在 Terminating，Debug Pods 文档提到的一个典型原因是？",
      options: ["Pod 带 finalizer 且集群中某个 admission webhook 阻止移除 finalizer", "Pod 处于 Running", "镜像拉取太慢", "探针成功导致无法删除"],
      answer: 0,
      rationale: "Debug Pods 文档：可能因 finalizer + admission webhook 阻止更新导致控制平面无法删除 Pod 对象。",
    },
    {
      id: "w3-4-q29",
      question: "容器终止信息（termination message）默认写入的文件路径是？",
      options: ["/dev/termination-log", "/var/log/termination.log", "/tmp/termination-log", "/etc/termination-log"],
      answer: 0,
      rationale: "Determine the Reason for Pod Failure 文档：terminationMessagePath 默认是 /dev/termination-log。",
    },
    {
      id: "w3-4-q30",
      question: "将 `terminationMessagePolicy` 设置为 `FallbackToLogsOnError` 的含义是？",
      options: [
        "当终止消息文件为空且容器异常退出时，使用最后一段容器日志作为终止消息回退来源",
        "永远忽略终止消息文件，只读全量日志",
        "只在容器正常退出时才读取日志",
        "把终止消息写回到镜像中",
      ],
      answer: 0,
      rationale: "Determine the Reason for Pod Failure 文档：FallbackToLogsOnError 会在错误退出且文件为空时回退读取最后一段日志作为 message。",
    },
  ],
  "w1-2": [
    {
      id: "w1-2-q1",
      question: "在 cgroup v2 中，关于控制器（controller）启用方式，哪个说法正确？",
      options: [
        "默认不启用；可用控制器在 cgroup.controllers；通过向父 cgroup 的 cgroup.subtree_control 写入 +cpu/+memory 等启用",
        "控制器默认对所有 cgroup 启用，无需配置",
        "只能在叶子 cgroup 的 cgroup.controllers 中写入来启用",
        "每个控制器必须挂载到单独层级（每个控制器一棵树）",
      ],
      answer: 0,
      rationale: "cgroup v2 文档说明：控制器可用性在 cgroup.controllers，且需在父级 cgroup.subtree_control 显式启用。",
    },
    {
      id: "w1-2-q2",
      question: "cgroup v2 的 Top-down constraint 指的是？",
      options: [
        "子 cgroup 只能启用父 cgroup 已启用的控制器；若子已启用，父不能关闭",
        "父 cgroup 必须比子 cgroup 资源更少",
        "限制只能自下而上配置",
        "root cgroup 不能启用任何控制器",
      ],
      answer: 0,
      rationale: "cgroup v2 文档的 Top-down constraint：资源分配自上而下，子层级只能继承并细分父层级已启用的控制器。",
    },
    {
      id: "w1-2-q3",
      question: "要在非 root cgroup 的 cgroup.subtree_control 启用 domain controller（如 cpu/memory），必须满足哪条规则？",
      options: [
        "该 cgroup 自身不能直接包含进程（需先把进程迁移到子 cgroup）",
        "该 cgroup 必须至少包含一个进程",
        "只要创建了子 cgroup 就能启用，无需迁移进程",
        "只有 threaded 子树才有此限制",
      ],
      answer: 0,
      rationale: "cgroup v2 的 No Internal Process Constraint：非 root 的 domain cgroup 要启用控制器必须把进程放到叶子节点。",
    },
    {
      id: "w1-2-q4",
      question: "关于 cgroup.procs 的写入行为，哪个说法符合 cgroup v2 文档？",
      options: [
        "一次 write 只能迁移一个进程；写入任一线程的 PID 会迁移整个进程的所有线程",
        "一次 write 可以写多个 PID（多行）批量迁移",
        "写入僵尸进程 PID 也能迁移",
        "只有 root cgroup 才有 cgroup.procs 文件",
      ],
      answer: 0,
      rationale: "cgroup v2 文档说明：写 cgroup.procs 一次只能迁移一个进程，且写入任一线程 PID 会迁移整个进程。",
    },
    {
      id: "w1-2-q5",
      question: "在启用 cgroup v2 的系统中，/proc/<pid>/cgroup 里 v2 的条目格式通常是？",
      options: ["0::<cgroup 路径>", "2:<controller>:<path>", "v2:<path>:<controller>", "只显示 PID，没有路径"],
      answer: 0,
      rationale: "cgroup v2 文档示例：/proc/<pid>/cgroup 的 v2 行格式为 0::<path>。",
    },
    {
      id: "w1-2-q6",
      question: "cpu.max 文件的格式与含义正确的是？",
      options: [
        "两个值：$MAX $PERIOD（单位微秒）；表示每个周期最多消耗 $MAX；$MAX=max 表示不限制",
        "一个值：0/1 表示是否禁用 CPU",
        "三个值：shares/quota/period，且单位毫秒",
        "只对实时调度生效，不影响 CFS",
      ],
      answer: 0,
      rationale: "cgroup v2 文档：cpu.max 以 $MAX $PERIOD（微秒）定义带宽上限，$MAX 可为 max 表示无限制。",
    },
    {
      id: "w1-2-q7",
      question: "关于 memory.high 与 memory.max 的区别，哪个描述符合 cgroup v2 文档？",
      options: [
        "memory.high 是节流/回收压力阈值，超出不会触发 OOM；memory.max 是硬上限，无法回收时会在该 cgroup 内触发 OOM killer",
        "memory.high 是硬上限；memory.max 是软阈值",
        "两者只影响 page cache，不影响匿名内存",
        "memory.max 只在 root cgroup 有效",
      ],
      answer: 0,
      rationale: "cgroup v2 文档：memory.high 超出会 throttling 但不触发 OOM；memory.max 是硬限制，无法回收时会触发 OOM。",
    },
    {
      id: "w1-2-q8",
      question: "Docker 文档中 `--cpus=\"1.5\"` 与 CFS 配额参数的等价关系是？",
      options: [
        "等价于 `--cpu-period=100000 --cpu-quota=150000`（单位微秒）",
        "等价于 `--cpu-period=150000 --cpu-quota=100000`",
        "等价于 `--cpu-shares=1.5`",
        "等价于 `--cpuset-cpus=1,5`",
      ],
      answer: 0,
      rationale: "Docker resource_constraints 文档：--cpus 是对 --cpu-period/--cpu-quota 的更便捷封装，并给出等价示例。",
    },
    {
      id: "w1-2-q9",
      question: "根据 Docker resource_constraints 文档，要防止容器使用 swap，应如何设置？",
      options: ["`--memory` 与 `--memory-swap` 设为相同值", "只设置 `--memory-swap=0`", "只设置 `--memory`，不设置 `--memory-swap`", "设置 `--memory-swap=-1`"],
      answer: 0,
      rationale: "Docker 文档：--memory-swap 表示“内存+swap”的总额度，把它设为与 --memory 相同可防止使用 swap。",
    },
    {
      id: "w1-2-q10",
      question: "Docker 文档为什么强调仅在同时设置了 `-m/--memory` 时才考虑 `--oom-kill-disable`？",
      options: [
        "不设内存上限时禁用 OOM killer 可能导致宿主机内存耗尽并被迫杀宿主进程",
        "因为 `--oom-kill-disable` 会自动提升容器 CPU 配额",
        "因为它会关闭容器网络",
        "因为它会让容器变成只读文件系统",
      ],
      answer: 0,
      rationale: "Docker 文档提示：禁用容器 OOM killer 必须配合内存硬限制，否则可能把宿主机拖到 OOM。",
    },
    {
      id: "w1-2-q11",
      question: "cgroup v2 文档提到：系统启动后最初只有哪个 cgroup 存在？",
      options: ["root cgroup（所有进程初始都属于它）", "kubelet cgroup", "docker cgroup", "system.slice"],
      answer: 0,
      rationale: "cgroup v2 文档说明：Initially, only the root cgroup exists to which all processes belong。",
    },
    {
      id: "w1-2-q12",
      question: "在 cgroup v2 中创建一个子 cgroup 的方式是？",
      options: ["在父 cgroup 目录下创建子目录", "向 cgroup.procs 写入目录名", "执行 `cgroupctl create`", "重启 kubelet 自动生成"],
      answer: 0,
      rationale: "cgroup v2 文档示例：child cgroup 通过创建一个子目录（mkdir）来建立。",
    },
    {
      id: "w1-2-q13",
      question: "读取 `cgroup.procs` 时，cgroup v2 文档提示哪项现象是可能出现的？",
      options: [
        "PID 不保证有序，同一 PID 可能因迁移/回迁或 PID 回收而在读取时重复出现",
        "PID 永远按从小到大排序",
        "每个 PID 只会出现一次且不会复用",
        "只会列出线程 ID（TID），不会列出进程 ID（PID）",
      ],
      answer: 0,
      rationale: "cgroup v2 文档指出：cgroup.procs 的 PID 不排序，且读取过程中可能因迁移/回收出现重复。",
    },
    {
      id: "w1-2-q14",
      question: "向目标 cgroup 的 `cgroup.procs` 写入 PID 迁移进程时，一次 write(2) 最多迁移多少个进程？",
      options: ["1 个进程", "任意多个进程（多行）", "最多 10 个", "取决于 CPU 核数"],
      answer: 0,
      rationale: "cgroup v2 文档：Only one process can be migrated on a single write(2) call。",
    },
    {
      id: "w1-2-q15",
      question: "为什么 zombie 进程无法通过 `cgroup.procs` 迁移到另一个 cgroup？",
      options: ["因为 zombie 不会出现在 cgroup.procs 中，因此无法被移动", "因为 zombie 不能写文件", "因为 zombie 只存在于 root cgroup", "因为 zombie 会自动被 OOM kill"],
      answer: 0,
      rationale: "cgroup v2 文档说明：zombie process does not appear in cgroup.procs and thus can't be moved。",
    },
    {
      id: "w1-2-q16",
      question: "cgroup v2 文档提到：一个没有任何子 cgroup 且没有活进程的 cgroup 如何删除？",
      options: ["直接删除该 cgroup 目录（rmdir）", "向 cgroup.kill 写 1", "kill -9 该目录的 PID", "只能重启主机删除"],
      answer: 0,
      rationale: "cgroup v2 文档：没有 children 或 live processes 的 cgroup 可通过 rmdir 删除。",
    },
    {
      id: "w1-2-q17",
      question: "cgroup v2 文档提到：若一个 cgroup 只关联 zombie 进程（无 live processes），它能否被 rmdir？",
      options: ["可以，被视为 empty（空）cgroup", "不可以，必须等 zombie 消失后才能删除", "不可以，必须先禁用所有 controller", "只有 root cgroup 才允许"],
      answer: 0,
      rationale: "cgroup v2 文档指出：仅与 zombie 相关联的 cgroup 被视为 empty，可以移除。",
    },
    {
      id: "w1-2-q18",
      question: "cgroup v2 文档提到：当一个进程 fork 出子进程时，新进程默认出生在哪个 cgroup？",
      options: ["fork 时父进程所在的 cgroup", "root cgroup", "由子进程自己选择", "由 systemd 自动分配到随机 cgroup"],
      answer: 0,
      rationale: "cgroup v2 文档：child process is born into the cgroup that the forking process belongs to at the time of the operation。",
    },
    {
      id: "w1-2-q19",
      question: "cgroup v2 文档对“controller interface files（如 cpu.*、memory.*）归属”的描述是？",
      options: [
        "由父 cgroup 拥有：在父上启用 controller 会在子 cgroup 中出现对应接口文件",
        "由子 cgroup 自己拥有：启用 controller 只影响本目录，不影响子目录",
        "由内核全局拥有：所有 cgroup 都默认出现全部接口文件",
        "由 systemd 拥有：只有 systemd 才能创建这些文件",
      ],
      answer: 0,
      rationale: "cgroup v2 文档说明：controller 接口文件由父级控制，启用后在子 cgroup 中出现。",
    },
    {
      id: "w1-2-q20",
      question: "在 `cgroup.subtree_control` 一次写入多个操作（如 `+cpu +memory -io`）时，cgroup v2 文档说明其规则是？",
      options: ["要么全部成功要么全部失败", "只要有一个成功就算成功", "会逐条部分成功并忽略失败项", "失败会自动回滚到 root"],
      answer: 0,
      rationale: "cgroup v2 文档：当一次写入包含多个 controller 操作时，either they all succeed or fail。",
    },
    {
      id: "w1-2-q21",
      question: "如果在同一次写入中对同一 controller 指定多次操作（例如 `+cpu -cpu`），cgroup v2 文档指出最终以哪个为准？",
      options: ["最后一个操作生效", "第一个操作生效", "随机生效", "两者会相互抵消并报错"],
      answer: 0,
      rationale: "cgroup v2 文档说明：如果同一 controller 被指定多次，最后一个操作生效。",
    },
    {
      id: "w1-2-q22",
      question: "cgroup v2 文档指出：即使 cpu controller 未启用，`cpu.stat` 也总会报告哪些统计？",
      options: ["usage_usec / user_usec / system_usec", "nr_throttled / throttled_usec", "iops / bps", "rss / cache"],
      answer: 0,
      rationale: "cgroup v2 文档：cpu.stat always reports usage_usec/user_usec/system_usec even if controller disabled。",
    },
    {
      id: "w1-2-q23",
      question: "当 cpu controller 启用后，`cpu.stat` 会额外包含哪组统计（针对 fair-class scheduler）？",
      options: [
        "nr_periods / nr_throttled / throttled_usec（以及 burst 相关字段）",
        "tx_bytes / rx_bytes",
        "oom / oom_kill",
        "read_iops / write_iops",
      ],
      answer: 0,
      rationale: "cgroup v2 文档：启用后 cpu.stat 额外记录 period/throttle/burst 等统计。",
    },
    {
      id: "w1-2-q24",
      question: "cgroup v2 文档中，`cpu.weight` 的默认值与范围（非 idle groups）正确的是？",
      options: ["默认 100，范围 1-10000", "默认 1024，范围 2-65535", "默认 1，范围 1-100", "默认 0，范围 0-1"],
      answer: 0,
      rationale: "cgroup v2 文档：cpu.weight 默认 100，非 idle groups 的范围为 [1, 10000]。",
    },
    {
      id: "w1-2-q25",
      question: "cgroup v2 文档中，`cpu.weight.nice` 的可设置范围是？",
      options: ["-20 到 19", "0 到 100", "1 到 10000", "0 到 1024"],
      answer: 0,
      rationale: "cgroup v2 文档：cpu.weight.nice 使用与 nice(2) 相同的 [-20, 19] 范围。",
    },
    {
      id: "w1-2-q26",
      question: "cgroup v2 文档中，`memory.high` 的默认值通常是？",
      options: ["max", "0", "与 memory.max 相同的硬上限", "与系统总内存相同的字节数"],
      answer: 0,
      rationale: "cgroup v2 文档：memory.high 默认值为 “max”。",
    },
    {
      id: "w1-2-q27",
      question: "Docker resource_constraints 文档对 `--memory-reservation` 的描述哪个正确？",
      options: [
        "它是 soft limit，通常在内存紧张/竞争时生效，且必须小于 `--memory`；不保证容器一定不超过",
        "它是硬上限，超出会立即 OOM kill",
        "它会自动关闭 swap",
        "它会把容器固定在单核 CPU 上",
      ],
      answer: 0,
      rationale: "Docker 文档：--memory-reservation 是软限制，触发条件与 host 低内存/竞争相关，且必须低于 --memory。",
    },
    {
      id: "w1-2-q28",
      question: "Docker resource_constraints 文档中，`--memory-swappiness` 的取值范围是？",
      options: ["0 到 100", "-1 到 1", "0 到 10", "1 到 10000"],
      answer: 0,
      rationale: "Docker 文档：--memory-swappiness 可设为 0-100，用于调整匿名页可被 swap 的比例。",
    },
    {
      id: "w1-2-q29",
      question: "Docker resource_constraints 文档对 `--memory-swap=0` 的解释是？",
      options: ["该设置会被忽略，并被当作未设置（unset）", "表示禁止 swap", "表示只允许 swap 不允许内存", "表示 swap 上限为 0 字节但仍可使用 zswap"],
      answer: 0,
      rationale: "Docker 文档：--memory-swap 设置为 0 时会被忽略，等价于未设置。",
    },
    {
      id: "w1-2-q30",
      question: "Docker resource_constraints 文档对 `--memory-swap=-1` 的解释是？",
      options: ["允许使用无限 swap（上限取决于宿主机可用 swap）", "禁止使用 swap", "将 swap 上限设为 1 字节", "只对 Windows 容器有效"],
      answer: 0,
      rationale: "Docker 文档：--memory-swap 显式设为 -1 时允许 unlimited swap，受宿主机可用 swap 约束。",
    },
  ],
  "w1-3": [
    {
      id: "w1-3-q1",
      question: "Docker 文档中对 OverlayFS 与 overlay2 的关系描述正确的是？",
      options: [
        "OverlayFS 是 Linux 内核文件系统；overlay2 是 Docker 基于 OverlayFS 的存储驱动",
        "overlay2 是内核模块；OverlayFS 是 Docker 的用户态实现",
        "OverlayFS 负责网络隔离；overlay2 负责进程隔离",
        "overlay2 只在 Windows 上可用",
      ],
      answer: 0,
      rationale: "Docker OverlayFS 存储驱动文档明确区分：OverlayFS（内核）与 overlay2（Docker 存储驱动）。",
    },
    {
      id: "w1-3-q2",
      question: "Docker 文档指出，overlay2 在 xfs backing filesystem 上的关键要求是？",
      options: [
        "必须开启 d_type=true（即 ftype=1）",
        "必须关闭 journal",
        "必须使用 4K block size",
        "必须把分区挂载为 noatime 才能工作",
      ],
      answer: 0,
      rationale: "Docker 文档：overlay2 支持 xfs，但要求 Supports d_type 为 true（xfs ftype=1）。",
    },
    {
      id: "w1-3-q3",
      question: "overlay2 驱动原生支持最多叠加多少个 lower（镜像）层？",
      options: ["8", "32", "128", "无限制"],
      answer: 2,
      rationale: "Docker OverlayFS 存储驱动文档指出 overlay2 原生支持最多 128 个 lower layers。",
    },
    {
      id: "w1-3-q4",
      question: "在 overlay 挂载参数中 lowerdir/upperdir/workdir/merged 的角色分别是？",
      options: [
        "lower 只读层，upper 可写层，work 用于内部操作，merged 为最终视图",
        "lower 可写，upper 只读，work 保存日志，merged 为 upper",
        "只有 lower 和 merged 必需，其它可省略",
        "merged 只是缓存目录，可删除",
      ],
      answer: 0,
      rationale: "内核 overlayfs 文档给出典型挂载示例并解释 lowerdir/upperdir/workdir 与 merged 的职责。",
    },
    {
      id: "w1-3-q5",
      question: "内核 overlayfs 文档对 upperdir 与 workdir 的要求是？",
      options: [
        "必须位于同一文件系统且 workdir 为空目录",
        "可以在不同文件系统上",
        "允许与 lowerdir 相同",
        "workdir 可在挂载完成后删除",
      ],
      answer: 0,
      rationale: "overlayfs 文档明确：workdir 需要与 upperdir 位于同一文件系统并且为空目录。",
    },
    {
      id: "w1-3-q6",
      question: "当容器写入一个只存在于 lowerdir（镜像层）的文件时，overlay2/OverlayFS 会发生什么？",
      options: ["触发 copy-up，把文件拷贝到 upperdir 再修改", "直接在 lowerdir 原地写入", "写操作被拒绝", "自动创建新的 lowerdir 层"],
      answer: 0,
      rationale: "Docker overlay2 文档说明写入会先执行 copy_up，把文件从 lower 复制到 upper，再对 upper 写入。",
    },
    {
      id: "w1-3-q7",
      question: "根据 Docker overlay2 文档，容器内删除一个来自 lowerdir 的文件会怎样？",
      options: [
        "在 upperdir 创建 whiteout 文件来隐藏 lowerdir 的同名文件（lowerdir 本身不被删除）",
        "直接删除 lowerdir 的原文件",
        "只删除 upperdir 的文件，因此 lowerdir 文件仍可见",
        "删除操作会失败，因为 lowerdir 只读",
      ],
      answer: 0,
      rationale: "Docker overlay2 文档：删除文件会创建 whiteout 来屏蔽 lower 层的同名文件。",
    },
    {
      id: "w1-3-q8",
      question: "根据 Docker overlay2 文档，容器内删除一个目录（来自 lowerdir）通常会导致？",
      options: [
        "在 upperdir 创建 opaque directory，隐藏 lowerdir 的目录内容",
        "直接递归删除 lowerdir 的目录",
        "把 lowerdir 的目录提升为 upperdir",
        "只影响容器内视图，不会产生任何额外标记",
      ],
      answer: 0,
      rationale: "Docker overlay2 文档：删除目录会创建 opaque directory，效果类似 whiteout，阻止访问 lower 的目录内容。",
    },
    {
      id: "w1-3-q9",
      question: "Docker 概览文档对镜像层（layer）的描述，哪个正确？",
      options: [
        "Dockerfile 每条指令会创建一个镜像层；重建时仅重建变化的层",
        "镜像层是运行时生成，与 Dockerfile 无关",
        "每次构建都会重新生成所有层，无缓存",
        "镜像只有一个层，不分层",
      ],
      answer: 0,
      rationale: "Docker 概览文档说明：每条 Dockerfile 指令形成一层，变更后重建会复用未变化的缓存层。",
    },
    {
      id: "w1-3-q10",
      question: "Docker overlay2 文档提到的 copy-up 可能带来的文件描述符陷阱是？",
      options: [
        "同一文件两个 fd 可能在 copy-up 后分别指向 lower 与 upper 的不同副本；可通过提前触发 copy-up（例如 touch）规避",
        "copy-up 会导致内核崩溃",
        "copy-up 会自动把两个 fd 的写入合并到同一底层文件",
        "copy-up 只发生在删除文件时，与写无关",
      ],
      answer: 0,
      rationale: "Docker overlay2 文档给出示例：copy-up 后两个 fd 可能不再指向同一底层对象，建议提前触发 copy-up 避免混用。",
    },
    {
      id: "w1-3-q11",
      question: "内核 overlayfs 文档指出：lower filesystem 是否必须可写？",
      options: ["不必须，lower 可以是只读，甚至可以是另一个 overlayfs", "必须可写，否则无法挂载", "必须是 tmpfs", "必须与 upper 同一文件系统且可写"],
      answer: 0,
      rationale: "overlayfs 文档说明：lower filesystem 不需要可写，甚至可以是另一个 overlayfs。",
    },
    {
      id: "w1-3-q12",
      question: "内核 overlayfs 文档指出：为什么 NFS 不适合作为常见的 upper filesystem？",
      options: [
        "upper 通常需要支持 trusted.* / user.* xattr 且 readdir 必须提供有效 d_type，NFS 不满足这些要求",
        "NFS 不支持目录",
        "NFS 只能只读",
        "NFS 会强制关闭 copy-up",
      ],
      answer: 0,
      rationale: "overlayfs 文档说明 upper 需要支持 xattr 与 valid d_type，因此 NFS 不适合作为 upper。",
    },
    {
      id: "w1-3-q13",
      question: "overlayfs 文档指出：当同名条目同时出现在 upper 与 lower，且任一层中该条目是非目录时，最终名称解析到哪里？",
      options: ["只解析到 upper 对象，lower 对象被隐藏", "只解析到 lower 对象，upper 被忽略", "两者合并为一个新文件", "解析结果随机"],
      answer: 0,
      rationale: "overlayfs 文档：如果 upper/lower 任一为非目录，同名条目最终只指向 upper，lower 被隐藏。",
    },
    {
      id: "w1-3-q14",
      question: "overlayfs 文档指出：在 merged directory 中，哪些信息通常只会报告 upper directory 的？",
      options: [
        "目录的元数据与扩展属性（metadata/xattr）",
        "文件名列表（readdir 返回的名字）",
        "lowerdir 的 inode 号",
        "所有内容都会合并展示",
      ],
      answer: 0,
      rationale: "overlayfs 文档：目录名列表会合并，但 metadata/xattr 只报告 upper directory 的，lower 的被隐藏。",
    },
    {
      id: "w1-3-q15",
      question: "内核 overlayfs 文档中对“whiteout”的定义正确的是？",
      options: [
        "字符设备 0/0，或带 `trusted.overlay.whiteout` xattr 的零字节普通文件",
        "一个指向 lower 文件的符号链接",
        "一个以 `.wh.` 开头的隐藏文件（无任何额外标记）",
        "只能用 overlay2 驱动才存在，内核 overlayfs 不支持",
      ],
      answer: 0,
      rationale: "overlayfs 文档：whiteout 可是 0/0 字符设备，或零字节文件并设置 trusted.overlay.whiteout xattr。",
    },
    {
      id: "w1-3-q16",
      question: "overlayfs 文档指出：当 merged directory 的 upper 层存在 whiteout 时会发生什么？",
      options: [
        "lower 层同名条目被忽略，whiteout 本身也会对视图隐藏",
        "lower 层同名条目仍然可见",
        "whiteout 会自动同步删除 lower 条目",
        "overlayfs 会拒绝挂载",
      ],
      answer: 0,
      rationale: "overlayfs 文档：upper 的 whiteout 会屏蔽 lower 同名条目，同时 whiteout 自身也隐藏。",
    },
    {
      id: "w1-3-q17",
      question: "内核 overlayfs 文档指出：把目录标记为 opaque 的方式是？",
      options: [
        "在目录上设置 xattr `trusted.overlay.opaque` 为 `y`，从而忽略 lower 中的同名目录",
        "把目录权限改为 000",
        "创建一个 whiteout 文件并放在目录内",
        "把目录重命名为 `.opaque` 前缀",
      ],
      answer: 0,
      rationale: "overlayfs 文档：opaque directory 通过设置 trusted.overlay.opaque=y，屏蔽 lower 同名目录内容。",
    },
    {
      id: "w1-3-q18",
      question: "overlayfs 文档描述 merged directory 的 readdir 合并顺序是？",
      options: ["先读 upper，再读 lower（已存在名字不重复加入）", "先读 lower，再读 upper", "随机", "只读 upper，不读 lower"],
      answer: 0,
      rationale: "overlayfs 文档：readdir 先读取 upper 名单，再读取 lower，避免重复条目。",
    },
    {
      id: "w1-3-q19",
      question: "overlayfs 文档提到 readdir 的缓存行为：哪项描述正确？",
      options: [
        "合并后的 name list 会缓存到 file 结构，目录保持打开时变更可能不可见；seek 到 offset 0 后 readdir 会丢弃并重建缓存",
        "每次 readdir 都会重新扫描 upper+lower，不存在缓存",
        "缓存仅对 lower 生效，upper 永远实时",
        "缓存只在 root 用户访问时生效",
      ],
      answer: 0,
      rationale: "overlayfs 文档：合并 name list 会缓存，目录打开期间变更可能不出现；seekdir(0) 可触发重建。",
    },
    {
      id: "w1-3-q20",
      question: "overlayfs 文档指出：对 lower 或 merged 上的目录执行 rename(2) 默认可能返回什么错误？在什么情况下可避免？",
      options: [
        "默认返回 EXDEV；启用 redirect_dir 后可通过 copy-up 目录并设置 `trusted.overlay.redirect` 来处理",
        "默认返回 EACCES；启用 noatime 后可避免",
        "默认返回 ENOSPC；扩大磁盘即可避免",
        "默认返回 EBUSY；关闭所有进程即可避免",
      ],
      answer: 0,
      rationale: "overlayfs 文档：重命名 lower/merged 目录默认按跨设备处理（EXDEV）；redirect_dir 可改变行为并设置 trusted.overlay.redirect。",
    },
    {
      id: "w1-3-q21",
      question: "overlayfs 文档指出：多个 lowerdir（如 `lowerdir=/l1:/l2:/l3`）的堆叠关系正确的是？",
      options: [
        "从右到左堆叠：右侧更底层，左侧更靠上（/l1 为 top，/l3 为 bottom）",
        "从左到右堆叠：左侧更底层，右侧更靠上",
        "顺序无关",
        "只会使用最右侧目录，其它忽略",
      ],
      answer: 0,
      rationale: "overlayfs 文档：多个 lower 从右到左堆叠，示例中 lower1 为 top、lower3 为 bottom。",
    },
    {
      id: "w1-3-q22",
      question: "overlayfs 文档指出：省略 `upperdir=` 和 `workdir=` 时，overlay 挂载会变成什么模式？",
      options: ["read-only overlay（只读）", "read-write overlay（可写）", "会报错无法挂载", "自动创建临时 upper/work"],
      answer: 0,
      rationale: "overlayfs 文档：省略 upperdir/workdir 时 overlay 为只读挂载。",
    },
    {
      id: "w1-3-q23",
      question: "overlayfs 文档指出：如果 lowerdir 的目录名本身包含冒号（:），在 mount 选项里常见的处理方式是？",
      options: ["用反斜杠转义冒号（\\:）", "用 URL 编码（%3A）", "用双引号包起来即可", "必须改名，不允许包含冒号"],
      answer: 0,
      rationale: "overlayfs 文档：lowerdir 列表用冒号分隔，目录名含冒号时需用单个反斜杠转义。",
    },
    {
      id: "w1-3-q24",
      question: "overlayfs 的 metacopy 特性描述正确的是？",
      options: [
        "对 chmod/chown 等元数据操作仅 copy-up 元数据并打上 `trusted.overlayfs.metacopy`；当文件以写方式打开时再延迟 copy-up 数据并移除该 xattr",
        "启用后写入永远不触发 copy-up",
        "启用后所有文件都会立即完整 copy-up",
        "metacopy 只对目录有效，对文件无效",
      ],
      answer: 0,
      rationale: "overlayfs 文档：metacopy 允许先只 copy-up 元数据（标记 trusted.overlayfs.metacopy），在需要写数据时再延迟复制数据。",
    },
    {
      id: "w1-3-q25",
      question: "Docker overlay2 文档提到：Docker Engine 29.0 及之后默认使用什么作为 image store？",
      options: ["containerd image store", "aufs image store", "etcd image store", "overlay2 image store（必须）"],
      answer: 0,
      rationale: "Docker overlay2 文档备注：Docker Engine 29.0+ 默认使用 containerd image store，overlay2 被新的 snapshotter 方案取代。",
    },
    {
      id: "w1-3-q26",
      question: "Docker overlay2 文档指出：更换 storage driver 的直接影响是什么？",
      options: [
        "本地已有容器与镜像会变得不可访问，应先 docker save 或推送到 registry 以便迁移",
        "只影响网络，不影响镜像与容器",
        "只会让镜像体积变大，不影响可用性",
        "会自动把旧数据无缝迁移到新 driver",
      ],
      answer: 0,
      rationale: "Docker overlay2 文档：Changing the storage driver makes existing containers and images inaccessible，建议先保存/推送镜像。",
    },
    {
      id: "w1-3-q27",
      question: "Docker overlay2 文档强调不要直接操作哪个目录下的文件？",
      options: ["/var/lib/docker", "/etc/docker", "/usr/bin", "/proc"],
      answer: 0,
      rationale: "Docker overlay2 文档 Warning：不要直接修改 /var/lib/docker/ 下的文件与目录，它们由 Docker 管理。",
    },
    {
      id: "w1-3-q28",
      question: "Docker overlay2 文档指出：OverlayFS 的 copy_up 是文件级别（file-level）而非块级别（block-level），意味着？",
      options: [
        "首次写入会复制整个文件，即使只改动很小一部分，可能影响写性能",
        "写入只会复制被修改的块，几乎没有性能开销",
        "copy_up 只发生在删除文件时",
        "copy_up 只对小文件生效，大文件直接原地写",
      ],
      answer: 0,
      rationale: "Docker overlay2 文档：OverlayFS 在 copy_up 时复制整个文件，可能带来明显的写放大与延迟。",
    },
    {
      id: "w1-3-q29",
      question: "Docker overlay2 文档指出：copy_up 触发频率的描述哪个正确？",
      options: ["同一文件只在首次写入时 copy_up，后续写入都在 upper 层进行", "每次写入都会 copy_up", "只有读操作才会 copy_up", "copy_up 只在镜像构建时发生，运行时不会发生"],
      answer: 0,
      rationale: "Docker overlay2 文档：copy_up 只发生在给定文件第一次被写入时，之后写都在 upper 层副本上进行。",
    },
    {
      id: "w1-3-q30",
      question: "Docker overlay2 文档指出：为什么应用需要能处理目录 rename 返回的 EXDEV？",
      options: [
        "因为 directory rename 只有在源与目标都在 top layer 时才允许，否则返回 EXDEV，应用需回退到 copy+unlink 策略",
        "因为 EXDEV 表示磁盘坏了必须立刻重启",
        "因为 EXDEV 表示权限不足，必须 sudo",
        "因为 EXDEV 表示网络不通，需要配置 DNS",
      ],
      answer: 0,
      rationale: "Docker overlay2 文档：rename(2) 在非 top layer 场景会返回 EXDEV，需按文档建议实现 copy/unlink 回退。",
    },
  ],
  "w1-4": [
    {
      id: "w1-4-q1",
      question: "根据 veth(4)，关于 veth 设备对（pair）的描述正确的是？",
      options: [
        "总是成对创建；一端发包另一端立即收到；任一端 down 则链路状态为 down",
        "只能单端存在，不支持成对",
        "必须依赖物理网卡才能创建",
        "只能在同一个 network namespace 内使用",
      ],
      answer: 0,
      rationale: "veth(4) 说明 veth 总是成对出现，任一端 down 会导致 pair 链路状态 down，且一端发送另一端接收。",
    },
    {
      id: "w1-4-q2",
      question: "创建一对 veth 的标准命令是？",
      options: [
        "`ip link add <p1> type veth peer name <p2>`",
        "`ip netns add <p1> peer <p2>`",
        "`brctl addif <p1> <p2>`",
        "`ethtool -S <p1> --create-peer <p2>`",
      ],
      answer: 0,
      rationale: "veth(4) 给出创建 veth pair 的 ip 命令示例：ip link add ... type veth peer name ...。",
    },
    {
      id: "w1-4-q3",
      question: "把现有 veth 的一端移动到指定网络命名空间，常用命令是？",
      options: [
        "`ip link set <p2> netns <ns>`",
        "`ip link set <p2> up <ns>`",
        "`ip netns exec <ns> ip link del <p2>`",
        "`sysctl -w netns=<ns>`",
      ],
      answer: 0,
      rationale: "veth(4) 说明可用 ip link set <ifname> netns <ns> 把一端移动到另一个 network namespace。",
    },
    {
      id: "w1-4-q4",
      question: "关于 Docker bridge 网络，哪项描述符合官方文档？",
      options: [
        "同一 bridge 网络内容器可互通；不同 bridge 网络通常仅能通过发布端口互通",
        "不同 bridge 网络默认完全互通",
        "bridge 网络不支持端口发布（-p）",
        "bridge 网络只能用于 Swarm overlay",
      ],
      answer: 0,
      rationale: "Docker bridge 文档：同一 bridge 内可互通，不同 bridge 网络间通常只能通过 published ports 建立连通。",
    },
    {
      id: "w1-4-q5",
      question: "Docker 文档提到 user-defined bridge 相比默认 bridge（docker0）的关键优势之一是？",
      options: [
        "容器间自动 DNS 解析，可用容器名互访",
        "默认 bridge 才支持 DNS，user-defined 不支持",
        "user-defined bridge 无法隔离不同应用栈",
        "user-defined bridge 不能发布端口",
      ],
      answer: 0,
      rationale: "Docker bridge 文档：user-defined bridge 提供自动 DNS 解析，默认 bridge 只能通过 IP 或 legacy link 互访。",
    },
    {
      id: "w1-4-q6",
      question: "Docker bridge 文档对“运行中容器连接/断开网络”的结论是？",
      options: [
        "运行中容器可 attach/detach 到 user-defined 网络；默认 bridge 想移除需停止并重建容器",
        "任何网络都必须停止容器才能连接/断开",
        "只能连接默认 bridge，user-defined 不支持",
        "attach 网络会自动重启容器",
      ],
      answer: 0,
      rationale: "Docker bridge 文档：user-defined 网络支持运行时 attach/detach；默认 bridge 的变更通常需要重建容器。",
    },
    {
      id: "w1-4-q7",
      question: "端口发布时如果使用 `-p 8080:80` 未指定 host 地址，Docker 默认会？",
      options: [
        "把容器端口发布到所有主机地址（默认绑定地址可配置）",
        "只绑定到 127.0.0.1",
        "只绑定到容器 IP，不会暴露到宿主",
        "默认不发布端口，需额外参数启用",
      ],
      answer: 0,
      rationale: "Docker bridge 文档：未指定 host 地址时，published port 默认绑定到主机所有地址（可通过配置调整默认绑定地址）。",
    },
    {
      id: "w1-4-q8",
      question: "根据 Docker 的 packet-filtering/firewalls 文档，Docker 会为哪些网络模式创建防火墙规则？",
      options: [
        "为 bridge 网络创建；ipvlan/macvlan/host networking 不创建对应规则",
        "所有网络模式都会创建相同规则",
        "只为 host networking 创建规则",
        "只要容器运行就会创建规则，与网络无关",
      ],
      answer: 0,
      rationale: "Docker 文档指出：Docker 为 bridge 网络创建防火墙规则；ipvlan/macvlan/host networking 不创建规则。",
    },
    {
      id: "w1-4-q9",
      question: "在 Linux 上 Docker 关于 IP Forwarding 的默认行为，哪个说法正确？",
      options: [
        "如未开启会启用 net.ipv4.ip_forward 和 net.ipv6.conf.all.forwarding，并把转发默认策略设为 drop（可用 ip-forward-no-drop 关闭）",
        "永远不改 sysctl，也不改转发策略",
        "只启用 IPv6 转发",
        "把转发策略设为 accept 以便充当路由器",
      ],
      answer: 0,
      rationale: "Docker packet-filtering/firewalls 文档说明：Docker 需要 IP 转发，并默认设置转发策略为 drop；可通过 ip-forward-no-drop 调整。",
    },
    {
      id: "w1-4-q10",
      question: "启用 firewalld 且 Docker 的 iptables/ip6tables 选项为 true 时，Docker 会做什么？",
      options: [
        "创建 docker zone（target ACCEPT），把 docker0 等 bridge 接口加入该 zone，并创建 docker-forwarding 转发策略",
        "自动关闭 firewalld",
        "把所有接口加入 public zone",
        "禁用端口发布",
      ],
      answer: 0,
      rationale: "Docker 文档：启用 firewalld 时会创建 docker zone 并添加 Docker bridge 接口，同时配置 docker-forwarding 转发策略。",
    },
    {
      id: "w1-4-q11",
      question: "veth(4) 对 veth 设备的典型用途描述正确的是？",
      options: [
        "可作为 network namespaces 之间的“隧道”，也可用于把一个 namespace 的网络桥接到另一个 namespace 的物理网卡",
        "只能用于同一 namespace 内部通信",
        "只能用于 overlay 网络，bridge 网络不使用",
        "只能用在容器里，宿主机无法创建",
      ],
      answer: 0,
      rationale: "veth(4) 说明：veth 可在 network namespaces 之间通信，也可用于桥接到另一命名空间的物理网络设备。",
    },
    {
      id: "w1-4-q12",
      question: "veth(4) 给出的“创建时就把两端放入不同 netns”的命令形式是？",
      options: [
        "`ip link add <p1> netns <p1-ns> type veth peer <p2> netns <p2-ns>`",
        "`ip netns add <p1-ns> peer <p2-ns>`",
        "`brctl addbr <p1-ns> <p2-ns>`",
        "`ethtool -S <p1> netns <p1-ns>`",
      ],
      answer: 0,
      rationale: "veth(4) 给出示例：创建 veth pair 时可用 netns 参数把两端分别放入不同 network namespace。",
    },
    {
      id: "w1-4-q13",
      question: "根据 veth(4)，如何用 ethtool 找到 veth 接口的 peer 端？",
      options: [
        "先 `ethtool -S <if>` 查看 `peer_ifindex`，再用 `ip link` 通过 ifindex 定位对端",
        "只能通过查看 `/etc/hosts`",
        "必须重启网卡才能看到对端",
        "只能在容器内通过 `docker inspect` 获取",
      ],
      answer: 0,
      rationale: "veth(4) 给出思路：`ethtool -S` 可显示 `peer_ifindex`，再用 `ip link` 查到对应接口。",
    },
    {
      id: "w1-4-q14",
      question: "Docker bridge 文档指出，bridge 网络默认具备哪些行为？",
      options: [
        "同一 bridge 内互通、外部默认不可直接访问、通过 masquerading 出站、支持端口发布",
        "默认所有端口对外网全开放且不做 NAT",
        "默认容器无法访问宿主机",
        "默认 bridge 只支持 IPv6，不支持 IPv4",
      ],
      answer: 0,
      rationale: "Docker bridge 文档概述：允许同网互通、阻止外部直接访问、通过 IP masquerading 出网，并支持 port publishing。",
    },
    {
      id: "w1-4-q15",
      question: "Docker bridge 文档提到 bridge 网络的“masquerading”主要带来的效果是？",
      options: [
        "容器访问外部网络时，外部只看到 Docker host 的 IP 地址",
        "容器获得公网 IP，外部直接看到容器 IP",
        "关闭所有出站流量",
        "让容器共享宿主机网络命名空间",
      ],
      answer: 0,
      rationale: "Docker bridge 文档：bridge 网络 uses masquerading，外部网络只看到 Docker host 的 IP。",
    },
    {
      id: "w1-4-q16",
      question: "Docker bridge 文档指出 bridge 网络的适用范围是？",
      options: [
        "同一 Docker daemon host 内的容器通信；跨主机需要 OS 路由或 overlay network",
        "天然支持跨主机通信，不需要额外网络",
        "只能用于单容器，不能多容器互通",
        "只能用于 Swarm mode",
      ],
      answer: 0,
      rationale: "Docker bridge 文档：bridge networks apply to containers on the same Docker daemon host，跨主机需 OS routing 或 overlay network。",
    },
    {
      id: "w1-4-q17",
      question: "Docker bridge 文档指出默认 bridge 网络（也叫 bridge）何时创建？",
      options: ["启动 Docker 时自动创建，新容器默认连接它", "安装 Linux 内核时创建", "每次 docker run 都创建一个新的默认 bridge", "只有执行 docker network create 才会创建"],
      answer: 0,
      rationale: "Docker bridge 文档：启动 Docker 后会自动创建默认 bridge 网络，新启动容器默认连接它。",
    },
    {
      id: "w1-4-q18",
      question: "在默认 bridge 网络上，容器想通过名字互访通常需要什么（文档称为 legacy）？",
      options: ["`--link`（legacy）或改用 user-defined bridge 的自动 DNS", "必须手工配置 iptables DNAT", "必须把容器切到 host network", "必须关闭 IP forwarding"],
      answer: 0,
      rationale: "Docker bridge 文档：默认 bridge 只能用 IP 互访，除非使用 legacy 的 --link；user-defined bridge 则可直接 DNS 解析。",
    },
    {
      id: "w1-4-q19",
      question: "Docker bridge 文档为什么不推荐用手工修改容器 `/etc/hosts` 来实现名字互访？",
      options: ["会带来难以调试的问题（difficult to debug）", "因为 /etc/hosts 是只读的", "因为会导致内核 panic", "因为会强制容器无法出网"],
      answer: 0,
      rationale: "Docker bridge 文档：手工操作 /etc/hosts 会产生难以排查的问题，推荐使用 user-defined network 的 DNS。",
    },
    {
      id: "w1-4-q20",
      question: "Docker bridge 文档说 user-defined bridge 比默认 bridge 隔离更好，主要原因是？",
      options: [
        "默认 bridge 会把未指定 --network 的容器都挂上去，导致不相关服务也能互通；user-defined 网络提供 scoped 隔离域",
        "user-defined bridge 会关闭所有网络访问",
        "默认 bridge 只支持 IPv4",
        "user-defined bridge 不能发布端口",
      ],
      answer: 0,
      rationale: "Docker bridge 文档：默认 bridge 容易把不相关容器放在同一网络导致互通风险；user-defined 网络提供更好的隔离。",
    },
    {
      id: "w1-4-q21",
      question: "Docker bridge 文档对 `--link` 的定位是？",
      options: ["legacy（不推荐的新项目依赖它）", "必须开启的安全特性", "Kubernetes 专用参数", "只能在 Windows 使用"],
      answer: 0,
      rationale: "Docker bridge 文档明确把 --link 标记为 legacy，并推荐使用 user-defined bridge 的 DNS。",
    },
    {
      id: "w1-4-q22",
      question: "Docker bridge 文档提到在 user-defined networks 上不再通过 `--link` 共享环境变量，但推荐用哪些方式替代？",
      options: ["使用 Docker volume / docker-compose / Swarm secrets & configs 等", "只修改 /etc/hosts", "把环境变量写进镜像层并强制重建", "只能通过 SSH 登录容器手工 export"],
      answer: 0,
      rationale: "Docker bridge 文档列举更优方案：volume 共享文件、compose 定义变量、Swarm secrets/configs 等。",
    },
    {
      id: "w1-4-q23",
      question: "Docker bridge 文档指出：连接到同一 user-defined bridge 网络的容器之间端口可见性通常是？",
      options: ["基本等同于彼此暴露所有端口（无需 publish 也可互访）", "默认全拒绝互访", "必须 publish 才能互访", "只能互访 80/443"],
      answer: 0,
      rationale: "Docker bridge 文档：同一 user-defined bridge 内的容器有效地对彼此暴露所有端口。",
    },
    {
      id: "w1-4-q24",
      question: "Docker bridge 文档指出：要让端口对不同网络的容器或非 Docker 主机可访问，必须？",
      options: ["用 `-p/--publish` 发布端口", "把容器加入默认 bridge", "关闭 iptables", "把网桥 MTU 设为 9000"],
      answer: 0,
      rationale: "Docker bridge 文档：跨网络/对外访问需要 publish ports（-p/--publish）。",
    },
    {
      id: "w1-4-q25",
      question: "Docker bridge 文档指出：默认 published ports 的“默认绑定地址”可通过哪个选项修改？",
      options: ["`com.docker.network.bridge.host_binding_ipv4`", "`com.docker.network.bridge.enable_icc`", "`com.docker.network.driver.mtu`", "`com.docker.network.bridge.enable_ip_masquerade`"],
      answer: 0,
      rationale: "Docker bridge 文档：host_binding_ipv4 选项可修改默认发布端口的绑定地址。",
    },
    {
      id: "w1-4-q26",
      question: "Docker bridge 文档指出：尽管选项名叫 `host_binding_ipv4`，它实际上也可以设置为？",
      options: ["IPv6 地址", "只能是 0.0.0.0", "只能是 127.0.0.1", "只能是容器 IP"],
      answer: 0,
      rationale: "Docker bridge 文档：Despite the option's name, it is possible to specify an IPv6 address。",
    },
    {
      id: "w1-4-q27",
      question: "Docker bridge 文档指出：把默认 binding address 设为 `::` 的效果是？",
      options: ["published ports 只在宿主机 IPv6 地址上可用", "published ports 只在 IPv4 地址上可用", "禁用端口发布", "强制所有端口仅对容器内可见"],
      answer: 0,
      rationale: "Docker bridge 文档：将默认绑定地址设为 :: 时，published ports 仅在宿主 IPv6 地址上可用。",
    },
    {
      id: "w1-4-q28",
      question: "Docker packet-filtering/firewalls 文档指出：若把 daemon 配置中的 iptables/ip6tables 设为 false 且不补充替代规则，可能导致什么结果？",
      options: [
        "bridge 网络容器无法通过 masquerading 访问互联网，但容器端口可能对本地网络主机全部可达",
        "容器仍能正常出网且端口更安全",
        "只影响日志，不影响网络",
        "会自动切换到 host networking 并保持等价行为",
      ],
      answer: 0,
      rationale: "Docker 文档：禁用 firewall 规则会破坏 bridge 网络正确性，容器可能失去出网 masquerading 且端口暴露给本地网络。",
    },
    {
      id: "w1-4-q29",
      question: "Docker packet-filtering/firewalls 文档解释 Docker 与 ufw 不兼容的关键原因是？",
      options: [
        "Docker 把容器流量走 nat 表，published ports 的流量在到达 ufw 使用的 INPUT/OUTPUT 链之前就被改写/分流",
        "ufw 会自动删除 Docker 网络接口",
        "Docker 会禁止 ufw 启动",
        "ufw 只能管理 IPv6 规则",
      ],
      answer: 0,
      rationale: "Docker 文档：published ports 流量会在 nat 表中被路由/改写，可能绕过 ufw 的 INPUT/OUTPUT 规则。",
    },
    {
      id: "w1-4-q30",
      question: "Docker packet-filtering/firewalls 文档对“不要修改 Docker 创建的防火墙规则”的理由是？",
      options: [
        "这些规则用于 bridge 网络隔离、端口发布与过滤，修改可能导致容器网络异常或安全暴露",
        "因为规则都写在容器镜像里，无法修改",
        "因为修改规则会导致 Dockerfile 构建失败",
        "因为规则只影响 Windows 容器",
      ],
      answer: 0,
      rationale: "Docker 文档强调：bridge 网络依赖 Docker 自动创建的防火墙规则实现隔离与端口发布，手工修改易破坏正确性。",
    },
  ],
  // Week 2
  "w2-1": [
    {
      id: "w2-1-q1",
      question: "Docker CLI 与 Daemon 的通信方式是？",
      options: [
        "通过 REST API（默认 Unix socket /var/run/docker.sock）",
        "直接操作 runc 二进制",
        "写入 etcd",
        "通过 systemd journal",
      ],
      answer: 0,
      rationale: "官方概览描述 CLI 调用 dockerd 暴露的 HTTP API。",
    },
    {
      id: "w2-1-q2",
      question: "dockerd 与 containerd、runc 的关系是？",
      options: [
        "dockerd 作为上层，调用 containerd 管理容器，后者使用 runc 运行 OCI 容器",
        "三者无关联，独立运行",
        "runc 管理 daemon，dockerd 只负责 CLI",
        "containerd 仅用于镜像存储，不运行容器",
      ],
      answer: 0,
      rationale: "Docker 架构图展示 dockerd→containerd→runc 的调用链。",
    },
    {
      id: "w2-1-q3",
      question: "containerd-shim 的作用是？",
      options: [
        "在 daemon 重启时保持容器存活并持有 stdio/状态",
        "负责构建镜像",
        "提供日志采集",
        "作为 kubectl 的代理",
      ],
      answer: 0,
      rationale: "containerd 文档：shim 断开 daemon 依赖，使容器生命周期独立。",
    },
    {
      id: "w2-1-q4",
      question: "镜像与快照在 containerd 中由谁管理？",
      options: [
        "内容存储（content store）和 snapshotter 负责层与文件系统挂载",
        "runc 直接管理镜像",
        "Docker CLI 持久化镜像",
        "etcd 存储镜像元数据",
      ],
      answer: 0,
      rationale: "containerd 架构描述 content store+snapshotter 分别管理 blob 与文件系统视图。",
    },
    {
      id: "w2-1-q5",
      question: "Docker Daemon 还负责哪类功能？",
      options: ["网络/卷管理、日志驱动与安全策略等", "只负责 API 转发", "仅管理 systemd unit", "只管理镜像拉取"],
      answer: 0,
      rationale: "Docker 文档将网络、卷、日志驱动等都归为 dockerd 组件职责。",
    },
    {
      id: "w2-1-q6",
      question: "在 Kubernetes 中直接使用 containerd 时，kubelet 调用接口是？",
      options: ["CRI gRPC 接口，由 containerd-cri 插件提供", "Docker CLI", "systemd DBus", "直接调用 runc 命令"],
      answer: 0,
      rationale: "Kubelet 通过 CRI 与 containerd 交互，而非 Docker API。",
    },
    {
      id: "w2-1-q7",
      question: "runc 的定位是？",
      options: [
        "OCI Runtime 参考实现，负责根据 config.json 创建容器进程",
        "镜像构建器",
        "网络插件",
        "日志采集器",
      ],
      answer: 0,
      rationale: "OCI runtime spec 参考实现正是 runc，用于低层执行。",
    },
    {
      id: "w2-1-q8",
      question: "Docker CLI 发起 docker ps 等查询时，信息来源是？",
      options: ["从 dockerd 获取状态", "直接读取 /var/lib/docker", "查询 etcd", "从内核自动采样"],
      answer: 0,
      rationale: "CLI 通过 API 从 daemon 获取容器状态与元数据。",
    },
    {
      id: "w2-1-q9",
      question: "为什么 dockerd 重启后容器通常不会中断？",
      options: [
        "containerd/shim 维持容器进程与 IO，daemon 重连后继续管理",
        "因为系统会暂停所有容器",
        "镜像层被锁定",
        "runc 会自动重新创建容器",
      ],
      answer: 0,
      rationale: "shim 设计保证容器独立于 dockerd 生命周期。",
    },
    {
      id: "w2-1-q10",
      question: "Containerd 提供哪些接口便于集成？",
      options: [
        "gRPC API 与 ctr/nerdctl 等客户端，可直接管理镜像和容器",
        "只有 REST API",
        "必须通过 docker CLI",
        "仅能通过 systemd 控制",
      ],
      answer: 0,
      rationale: "containerd 官方文档提供 gRPC API，ctr/nerdctl 是常见客户端。",
    },
    {
      id: "w2-1-q11",
      question: "Docker 官方概览指出，Docker client 与 daemon 的部署方式哪项正确？",
      options: [
        "client 与 daemon 可在同一系统运行，也可连接到远程 daemon",
        "必须同机运行，远程连接不支持",
        "必须远程运行，本地不支持",
        "client 必须以容器形式运行，否则无法通信",
      ],
      answer: 0,
      rationale: "Docker 官方概览在 Docker architecture 中说明：client/daemon 可同机，也可连接远程 daemon。",
    },
    {
      id: "w2-1-q12",
      question: "在 Docker 官方概览的架构描述中，哪一个也被称为 “another Docker client”？",
      options: ["Docker Compose", "Docker Hub", "containerd", "runc"],
      answer: 0,
      rationale: "Docker 官方概览在 Docker architecture 段落明确提到：Another Docker client is Docker Compose。",
    },
    {
      id: "w2-1-q13",
      question: "Docker 官方概览中，dockerd 的职责描述最贴近哪项？",
      options: [
        "监听 Docker API 请求并管理 images/containers/networks/volumes 等对象",
        "仅提供 CLI 命令补全与参数解析",
        "只负责运行 OCI runtime（直接替代 runc）",
        "仅存储镜像层，不管理容器生命周期",
      ],
      answer: 0,
      rationale: "Docker 官方概览在 The Docker daemon 部分描述 dockerd 监听 API 并管理 Docker objects。",
    },
    {
      id: "w2-1-q14",
      question: "Docker 官方概览中，关于 Docker registry 的说法哪项正确？",
      options: [
        "Registry 用来存储 Docker images；Docker Hub 是默认的公共 registry，也可以自建私有 registry",
        "Registry 用来存储容器日志与事件",
        "Registry 只在 Kubernetes 中使用，Docker 不需要",
        "Registry 负责运行容器进程（替代 daemon）",
      ],
      answer: 0,
      rationale: "Docker 官方概览在 Docker registries 部分说明：registry 存储镜像，Docker Hub 默认，亦可自建私有 registry。",
    },
    {
      id: "w2-1-q15",
      question: "根据 Docker 官方概览，docker pull / docker run / docker push 与 registry 的关系是？",
      options: [
        "pull/run 会从配置的 registry 拉取所需镜像；push 会把镜像推送到配置的 registry",
        "pull/run 只读本地镜像；push 会从 registry 下载镜像",
        "pull 会删除 registry 中旧镜像；push 会删除本地镜像",
        "三者都只操作 /var/lib/docker，不涉及 registry",
      ],
      answer: 0,
      rationale: "Docker 官方概览明确：docker pull/run 从 registry 拉取，docker push 推送到 registry。",
    },
    {
      id: "w2-1-q16",
      question: "Docker 官方概览对 image 的定义是？",
      options: ["只读模板，包含用于创建容器的指令", "运行中的容器进程本身", "用于替代 Volume 的持久化存储", "用于替代 Network 的虚拟交换机"],
      answer: 0,
      rationale: "Docker 官方概览在 Docker objects 的 Images 小节：image 是 read-only template with instructions。",
    },
    {
      id: "w2-1-q17",
      question: "Docker 官方概览中，关于 Dockerfile 与镜像 layer 的描述哪项正确？",
      options: [
        "Dockerfile 每条指令都会创建一个 layer；重建时通常只重建发生变化的 layers",
        "Dockerfile 只在运行时生效，不影响镜像层",
        "镜像层与 Dockerfile 无关，完全由内核决定",
        "每次 build 都会全量重建所有 layers，无法缓存",
      ],
      answer: 0,
      rationale: "Docker 官方概览提到：Each instruction creates a layer，且 rebuild 时仅变化的 layers 需要重建。",
    },
    {
      id: "w2-1-q18",
      question: "Docker 官方概览对 container 的定义最贴近哪项？",
      options: [
        "image 的可运行实例（runnable instance），可通过 API/CLI 创建、启动、停止与删除",
        "只读文件系统的快照，无法启动",
        "一组 Linux namespaces 的集合但不包含进程",
        "仅用于拉取镜像的缓存对象",
      ],
      answer: 0,
      rationale: "Docker 官方概览在 Containers 小节：container 是 runnable instance of an image，可通过 API/CLI 管理生命周期。",
    },
    {
      id: "w2-1-q19",
      question: "Docker 官方概览提到，默认情况下容器与宿主机/其他容器的隔离关系是？",
      options: [
        "相对隔离；可以控制网络、存储等子系统与宿主/其他容器的隔离程度",
        "完全不隔离，所有容器共享同一网络与文件系统",
        "完全隔离且不可配置，网络/存储隔离无法更改",
        "隔离只由 Dockerfile 决定，与运行参数无关",
      ],
      answer: 0,
      rationale: "Docker 官方概览指出：By default 容器相对隔离，并可控制 network/storage 等子系统的隔离。",
    },
    {
      id: "w2-1-q20",
      question: "Docker 官方概览中，关于容器删除后的数据说法哪项正确？",
      options: [
        "容器被删除后，未写入持久化存储的状态变更会消失",
        "容器被删除后，所有变更都会自动写回镜像",
        "容器被删除后，变更会自动同步到 registry",
        "容器被删除后，变更会永久保留在 host 的 read-only layer",
      ],
      answer: 0,
      rationale: "Docker 官方概览指出：当 container 被 removed，未存入 persistent storage 的状态变更会消失。",
    },
    {
      id: "w2-1-q21",
      question: "在 Docker 官方概览给出的 `docker run -i -t ubuntu /bin/bash` 示例流程中，第一步是什么？",
      options: [
        "如果本地没有 ubuntu 镜像，则从配置的 registry 拉取（等价于先 docker pull）",
        "先创建容器并直接启动网络，再决定是否拉取镜像",
        "先推送镜像到 registry，再从 registry 拉取回来",
        "跳过镜像步骤，直接运行 /bin/bash",
      ],
      answer: 0,
      rationale: "Docker 官方概览在示例步骤 1 说明：若本地无镜像，Docker 会从 registry 拉取。",
    },
    {
      id: "w2-1-q22",
      question: "Docker 官方概览示例中，哪一步解释了运行中的容器为何可以在其文件系统内创建/修改文件？",
      options: [
        "Docker 为容器分配一个可读写的文件系统作为最终 layer（read-write filesystem）",
        "Docker 把镜像的只读层强制改写为可写",
        "Docker 把所有写入重定向到 registry",
        "Docker 通过 systemd-journald 保存写入内容",
      ],
      answer: 0,
      rationale: "Docker 官方概览在示例步骤 3：分配 read-write filesystem 作为最终层，使运行中可写。",
    },
    {
      id: "w2-1-q23",
      question: "Docker 官方概览示例中，关于网络的描述哪项正确？",
      options: [
        "Docker 会创建网络接口把容器连接到默认网络，并为容器分配 IP 地址",
        "容器默认不具备任何网络，必须手工配置才可出网",
        "容器默认使用 hostNetwork，与宿主共享 IP",
        "容器只能访问同一镜像的其他容器，不能访问外网",
      ],
      answer: 0,
      rationale: "Docker 官方概览在示例步骤 4：创建网络接口连接默认网络并分配 IP，默认可通过宿主网络连接外网。",
    },
    {
      id: "w2-1-q24",
      question: "Docker 官方概览示例中，执行 exit 退出 /bin/bash 后容器会怎样？",
      options: [
        "容器停止但不会自动删除，可再次启动或手动删除",
        "容器会被自动删除（等价于 docker run --rm）",
        "容器会转换为镜像并自动 push",
        "容器会保持 running，但 shell 退出不影响",
      ],
      answer: 0,
      rationale: "Docker 官方概览在示例步骤 6：exit 后容器停止但不移除。",
    },
    {
      id: "w2-1-q25",
      question: "Docker 官方概览在 “The underlying technology” 中指出，Docker 利用 Linux 的什么机制为容器提供隔离工作空间？",
      options: ["namespaces（为容器创建一组 namespaces）", "BIOS 虚拟化扩展", "Java 虚拟机字节码隔离", "仅靠 chroot(2) 完成全部隔离"],
      answer: 0,
      rationale: "Docker 官方概览指出 Docker 使用 Linux namespaces，并为每个容器创建一组 namespaces 提供隔离。",
    },
    {
      id: "w2-1-q26",
      question: "containerd 的 PLUGINS.md 提到 Smart Client Model：下列哪项被明确举例为“由 client 完成的高层交互”？",
      options: ["从 tar 包加载镜像（loading an image from tar）", "在 daemon 内部直接编译应用二进制", "在内核中实现 snapshotter", "把容器 stdout 自动写入 registry"],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md 指出：不需要 daemon 的高层功能由 client 完成，示例包含从 tar 加载镜像。",
    },
    {
      id: "w2-1-q27",
      question: "containerd 的 PLUGINS.md 中，External plugins 扩展 containerd 的两种方式分别是？",
      options: [
        "PATH 中提供插件二进制；或通过配置让 containerd proxy 到另一个 gRPC service",
        "修改 kubelet 源码；或修改 Linux 内核",
        "仅支持静态编译进 containerd（二进制方式不支持）",
        "只能通过 Dockerfile 的 ARG/ENV 注入",
      ],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md：External plugins 支持二进制在 PATH 与 proxy gRPC 两种扩展方式。",
    },
    {
      id: "w2-1-q28",
      question: "按照 containerd 的 PLUGINS.md，proxy plugin 当前支持的 type 不包括哪个？",
      options: ["runtime", "snapshot", "content", "diff"],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md 指出 proxy plugin 当前支持 types 为 snapshot/content/diff。",
    },
    {
      id: "w2-1-q29",
      question: "containerd 的 PLUGINS.md 描述了 CRI 下如何选择不同运行时：哪项说法正确？",
      options: [
        "可在 containerd 配置中定义 named runtimes；通过 CRI 的 runtime handler 选择；未指定则用默认 runtime",
        "CRI 不支持多运行时，所有容器固定使用同一个 runtime",
        "只能通过修改镜像 manifest 指定运行时",
        "只能在 runc 的 config.json 内指定运行时",
      ],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md 在 V2 Runtimes 章节说明：CRI 可配置 named runtimes，并通过 runtime handler 选择，默认 runtime 兜底。",
    },
    {
      id: "w2-1-q30",
      question: "containerd 的 PLUGINS.md 提到，想查看当前 containerd 拥有哪些插件，应使用哪个命令？",
      options: ["ctr plugins ls", "docker system info", "kubectl get plugins", "runc list"],
      answer: 0,
      rationale: "containerd 的 PLUGINS.md 在 Built-in Plugins 章节给出：使用 `ctr plugins ls` 查看插件列表与状态。",
    },
  ],
  "w2-2": [
    {
      id: "w2-2-q1",
      question: "多阶段构建的核心收益是？",
      options: [
        "将构建与运行环境分离，减少最终镜像体积与攻击面",
        "让镜像构建更慢",
        "只能用于调试",
        "必须在生产禁用",
      ],
      answer: 0,
      rationale: "官方最佳实践强调使用多阶段拷贝最小产物到最终镜像。",
    },
    {
      id: "w2-2-q2",
      question: "为何要合并 apt-get update 与 install 到同一 RUN？",
      options: [
        "避免缓存过期并减少层数",
        "提升镜像可读性",
        "与安全无关，仅为美观",
        "否则镜像无法启动",
      ],
      answer: 0,
      rationale: "官方建议将更新与安装放同一层，防止缓存失效导致失败。",
    },
    {
      id: "w2-2-q3",
      question: ".dockerignore 的作用是？",
      options: [
        "减少构建上下文大小，避免不必要文件进入镜像",
        "控制容器日志",
        "限制容器网络访问",
        "设置运行时环境变量",
      ],
      answer: 0,
      rationale: "忽略文件可加速构建并减少泄露风险。",
    },
    {
      id: "w2-2-q4",
      question: "使用 COPY --chown 的好处是？",
      options: [
        "在构建阶段即写入正确的文件所有者，避免额外 chown 层",
        "提高镜像拉取速度",
        "只影响运行时权限，不影响文件",
        "必须与 ADD 一起使用",
      ],
      answer: 0,
      rationale: "最佳实践建议在 COPY 时设置权限，减少额外层。",
    },
    {
      id: "w2-2-q5",
      question: "为何推荐固定基础镜像的 tag 或 digest？",
      options: [
        "保证可重复构建与安全可追溯性",
        "让镜像更大",
        "防止 docker build 失败",
        "便于自动删除镜像",
      ],
      answer: 0,
      rationale: "锁定版本避免 latest 漂移导致行为变化。",
    },
    {
      id: "w2-2-q6",
      question: "ADD 与 COPY 的使用建议是？",
      options: [
        "默认用 COPY，只有需要解压本地 tar 或 URL 下载时再用 ADD",
        "总是使用 ADD",
        "两者无差别，随意使用",
        "ADD 必须与 RUN 一起用",
      ],
      answer: 0,
      rationale: "官方最佳实践建议优先 COPY，避免 ADD 的隐式行为。",
    },
    {
      id: "w2-2-q7",
      question: "为什么 ENTRYPOINT/CMD 推荐使用 exec 形式（JSON 数组）？",
      options: [
        "可正确接收信号并避免 shell 展开副作用",
        "写起来更短",
        "能自动开启 TTY",
        "避免 HEALTHCHECK 失败",
      ],
      answer: 0,
      rationale: "exec 形式直接作为 PID1，信号不会被 /bin/sh 截留。",
    },
    {
      id: "w2-2-q8",
      question: "如何利用层缓存加速构建？",
      options: [
        "将变动频繁的步骤放在 Dockerfile 末尾，前面尽量稳定",
        "随机排列指令",
        "频繁清理缓存",
        "禁用 multi-stage",
      ],
      answer: 0,
      rationale: "指令顺序决定缓存命中率，官方建议把易变部分靠后。",
    },
    {
      id: "w2-2-q9",
      question: "为何建议在镜像中设置非 root 用户？",
      options: [
        "减少潜在攻击面并符合最小权限原则",
        "会导致容器无法启动",
        "只为美观",
        "为了让镜像更大",
      ],
      answer: 0,
      rationale: "最佳实践强调使用 USER 降权运行应用。",
    },
    {
      id: "w2-2-q10",
      question: "HEALTHCHECK 指令的作用是？",
      options: [
        "让引擎探测容器健康，失败时可标记为 unhealthy 或配合编排器重启",
        "限制 CPU 使用率",
        "自动扩缩容",
        "替代 ENTRYPOINT",
      ],
      answer: 0,
      rationale: "Dockerfile 文档建议提供健康检查以便上层编排处理异常。",
    },
    {
      id: "w2-2-q11",
      question: "多阶段构建文档指出，每条 FROM 指令的作用是？",
      options: ["开始一个新的 build stage（可使用不同 base image）", "把上一层缓存清空", "只用于声明镜像作者信息", "只在 docker run 时生效"],
      answer: 0,
      rationale: "Multi-stage builds 文档：每条 FROM 指令都会开启一个新的 stage，并且可以使用不同的基础镜像。",
    },
    {
      id: "w2-2-q12",
      question: "多阶段构建文档：如果没有给 stage 命名，COPY --from 应如何引用 stage？",
      options: ["用整数编号引用，从 0 表示第一条 FROM", "只能用镜像 tag 引用", "只能用 stage 的 WORKDIR 引用", "不能引用，只能复制本地文件"],
      answer: 0,
      rationale: "多阶段构建文档说明：默认 stage 不命名时按整数编号引用，第一条 FROM 为 0。",
    },
    {
      id: "w2-2-q13",
      question: "在多阶段构建中，如何给 stage 命名以便后续引用？",
      options: [
        "在 FROM 后使用 `AS <name>`（例如 `FROM golang:1.24 AS build`）",
        "在 RUN 中写 `NAME=build`",
        "在 Dockerfile 顶部写 `STAGE build`",
        "只能通过 docker build 的 -t 命名",
      ],
      answer: 0,
      rationale: "多阶段构建文档：可用 FROM ... AS <NAME> 命名 stage，并在 COPY --from 使用该名称。",
    },
    {
      id: "w2-2-q14",
      question: "多阶段构建文档强调命名 build stage 的主要好处是？",
      options: ["即使 Dockerfile 指令重排，COPY --from=... 也不易因编号变化而失效", "命名后会自动开启多平台构建", "命名后会强制禁用缓存", "命名后会自动生成镜像签名"],
      answer: 0,
      rationale: "多阶段构建文档指出：用名称引用 stage 比编号更稳健，避免重排导致 COPY 断裂。",
    },
    {
      id: "w2-2-q15",
      question: "多阶段构建文档：要在指定 stage 结束构建，应使用哪个命令参数？",
      options: ["`docker build --target <stageName> ...`", "`docker run --target <stageName> ...`", "`docker build --stage <stageName> ...`", "`docker compose up --target <stageName> ...`"],
      answer: 0,
      rationale: "多阶段构建文档示例：`docker build --target build -t hello .` 可停在指定 stage。",
    },
    {
      id: "w2-2-q16",
      question: "多阶段构建文档：`COPY --from` 除了引用前面的 stage，还可以从哪里复制？",
      options: ["从一个外部 image（本地或 registry 上的 tag/ID，例如 `--from=nginx:latest`）", "只能从同一个 stage 内复制", "只能从宿主机 /etc 目录复制", "只能从 Docker Desktop 内置镜像复制"],
      answer: 0,
      rationale: "多阶段构建文档说明：`COPY --from` 也可引用单独的 image；需要时 Docker client 会拉取该 image。",
    },
    {
      id: "w2-2-q17",
      question: "多阶段构建文档：如何“从之前的 stage 继续”创建一个新的 stage？",
      options: ["在新的 FROM 中引用之前的 stage（例如 `FROM builder AS build1`）", "用 `COPY --from` 自动继承所有 RUN 结果", "用 `ARG --from=builder` 指定", "必须把之前 stage 推送到 registry 再拉取"],
      answer: 0,
      rationale: "多阶段构建文档示例展示：可在 FROM 指令中引用之前 stage 作为新 stage 的 base。",
    },
    {
      id: "w2-2-q18",
      question: "多阶段构建文档中，BuildKit 与 legacy builder 的差异哪项正确？",
      options: ["BuildKit 只构建目标 stage 依赖的 stages；legacy builder 会处理到目标前的所有 stages", "BuildKit 总是比 legacy 构建更多 stages", "legacy builder 才支持 --target，BuildKit 不支持", "两者完全一致，没有差异"],
      answer: 0,
      rationale: "多阶段构建文档在 Differences between legacy builder and BuildKit 中说明：BuildKit 会跳过与目标无依赖的 stage。",
    },
    {
      id: "w2-2-q19",
      question: "Dockerfile 最佳实践中，想避免命中构建缓存、强制重新执行指令，应使用哪个 build 选项？",
      options: ["`docker build --no-cache ...`", "`docker build --no-layer-cache ...`", "`docker build --rebuild ...`", "`docker build --fresh ...`"],
      answer: 0,
      rationale: "Dockerfile Best practices 文档：可用 `--no-cache` 避免 cache hits。",
    },
    {
      id: "w2-2-q20",
      question: "最佳实践文档解释：为什么不建议把 `RUN apt-get update` 与后续 `RUN apt-get install` 分开写？",
      options: [
        "容易复用缓存导致 update 不执行，后续 install 可能使用过期索引甚至失败",
        "因为 update 会自动删除已安装包",
        "因为 install 只能在容器运行时执行",
        "因为 update 与 install 会互相抵消",
      ],
      answer: 0,
      rationale: "Best practices 的 apt-get 章节指出：update 单独一层会被缓存，后续 install 复用缓存导致索引过期/失败。",
    },
    {
      id: "w2-2-q21",
      question: "最佳实践文档中，为减少镜像体积，apt-get 安装后通常建议清理哪个目录？",
      options: ["/var/lib/apt/lists", "/var/log", "/usr/src", "/etc/apt/sources.list.d"],
      answer: 0,
      rationale: "Best practices 文档提到移除 /var/lib/apt/lists 可减少镜像层体积（避免把 apt cache 存进 layer）。",
    },
    {
      id: "w2-2-q22",
      question: "最佳实践文档对 ENTRYPOINT 与 CMD 的组合建议更贴近哪项？",
      options: [
        "用 ENTRYPOINT 设置镜像的主命令，用 CMD 提供默认参数/可覆盖参数",
        "CMD 用来设置镜像主命令，ENTRYPOINT 只用于健康检查",
        "ENTRYPOINT 与 CMD 只能二选一，不能同时使用",
        "ENTRYPOINT 必须写成 shell 形式，CMD 必须写成 exec 形式",
      ],
      answer: 0,
      rationale: "Best practices 文档在 ENTRYPOINT 章节：ENTRYPOINT 设定主命令，CMD 作为默认参数（示例 ENTRYPOINT + CMD）。",
    },
    {
      id: "w2-2-q23",
      question: "最佳实践文档对 CMD 的推荐写法是？",
      options: ["通常使用 exec 形式：`CMD [\"executable\", \"param1\", ...]`", "总是使用 shell 形式：`CMD executable param`", "只写参数：`CMD [\"--flag\"]`（不配 ENTRYPOINT）", "必须为空，由运行时注入"],
      answer: 0,
      rationale: "Best practices 文档指出：CMD 应几乎总是使用 JSON 数组的 exec 形式。",
    },
    {
      id: "w2-2-q24",
      question: "最佳实践文档中，若希望容器运行时默认带有某个环境变量，应使用哪条指令？",
      options: ["ENV", "RUN export", "ARG", "LABEL"],
      answer: 0,
      rationale: "Best practices 的 ENV 示例：ENV 写入镜像的默认环境，运行容器仍可见。",
    },
    {
      id: "w2-2-q25",
      question: "最佳实践文档示例：如果只是构建过程中临时用变量且不希望运行时仍存在，更贴近哪种做法？",
      options: ["在同一个 RUN 中 export→使用→unset（不要用 ENV 持久化）", "用 ENV 设置后再在下一条 RUN 里 unset", "把变量写入镜像 label", "在 docker run 时用 --rm 自动清理环境变量"],
      answer: 0,
      rationale: "Best practices 示例说明：ENV 会持久化；临时变量可在同一 RUN 中 export 并在结束前 unset。",
    },
    {
      id: "w2-2-q26",
      question: "最佳实践文档提到，使用 ADD 下载远程 artifact 时，可以用哪个参数做校验？",
      options: ["`ADD --checksum=sha256:<hash> ...`", "`ADD --verify ...`", "`COPY --checksum ...`", "`RUN curl --checksum ...`"],
      answer: 0,
      rationale: "Best practices 的 ADD/COPY 章节给出：ADD 支持 `--checksum=sha256:...` 校验远程下载。",
    },
    {
      id: "w2-2-q27",
      question: "最佳实践文档的 apt-get 示例里，通常推荐加哪个选项以避免安装推荐包、减少体积？",
      options: ["--no-install-recommends", "--with-recommends", "--only-upgrade", "--dry-run"],
      answer: 0,
      rationale: "Best practices 的 apt-get 示例多次使用 `apt-get install -y --no-install-recommends ...` 控制安装体积。",
    },
    {
      id: "w2-2-q28",
      question: "最佳实践文档提到一种 cache busting 的方式是？",
      options: ["在 apt-get install 中指定包版本（版本变化会触发缓存失效并重新执行 update）", "把 Dockerfile 中所有 RUN 都合并成一条", "把所有依赖都写进 ENTRYPOINT", "只要写了 .dockerignore 就会自动 cache bust"],
      answer: 0,
      rationale: "Best practices 的 apt-get 章节提到：通过指定包版本可触发 cache bust，确保安装到新版本。",
    },
    {
      id: "w2-2-q29",
      question: "Docker CI 文档中，为什么推荐在 CI 中用 Docker 容器作为 build/test 环境？",
      options: ["容器提供可复现、隔离的环境，能带来更可预测的构建/测试结果", "因为容器能绕过所有单元测试", "因为 CI 只能在容器里运行", "因为容器会自动生成发布说明"],
      answer: 0,
      rationale: "Docker CI 文档指出：containers 是可复现、隔离的环境，能带来更可预测的结果。",
    },
    {
      id: "w2-2-q30",
      question: "CI 文档中提到的 “Docker in Docker” 指的是？",
      options: ["在容器内运行 Docker 用于构建镜像（把构建环境容器化）", "在容器里运行 Kubernetes 集群", "在镜像里嵌套另一个 Dockerfile", "在 registry 里运行 Docker daemon"],
      answer: 0,
      rationale: "Docker CI 文档说明：在容器化的构建环境里进行 Docker builds，这就是 Docker in Docker。",
    },
  ],
  "w2-3": [
    {
      id: "w2-3-q1",
      question: "Kubernetes 与容器运行时交互的官方接口是？",
      options: ["CRI（Container Runtime Interface）gRPC API", "Docker Remote API", "systemd API", "RESTful CNI"],
      answer: 0,
      rationale: "Dockershim 被移除后，所有运行时需实现 CRI。",
    },
    {
      id: "w2-3-q2",
      question: "Dockershim 在哪个版本被移除？",
      options: ["v1.24 起正式移除", "v1.18 起移除", "尚未移除", "需要手动编译内核才能移除"],
      answer: 0,
      rationale: "K8s 1.24 release notes 宣布移除 dockershim。",
    },
    {
      id: "w2-3-q3",
      question: "containerd 与 CRI-O 的共同点是？",
      options: [
        "均实现 CRI，并依赖 OCI runtime（通常是 runc）执行容器",
        "都依赖 Docker Daemon",
        "不支持 OCI 镜像",
        "仅能运行在 Windows",
      ],
      answer: 0,
      rationale: "二者都是符合 CRI 的运行时，底层调用 runc/OCI 规范。",
    },
    {
      id: "w2-3-q4",
      question: "为什么社区决定弃用 dockershim？",
      options: [
        "维护成本高且与 CRI 重复，鼓励直接使用 OCI 运行时",
        "Docker 镜像不再受支持",
        "安全原因禁用 CRI",
        "因为 kubectl 无法连接 Docker",
      ],
      answer: 0,
      rationale: "官方 FAQ 提到维护负担与重复抽象是主要原因。",
    },
    {
      id: "w2-3-q5",
      question: "Pod Sandbox（pause 容器）的作用是？",
      options: [
        "为同一 Pod 提供共享的网络/IPC/UTS 命名空间",
        "运行业务逻辑",
        "存储镜像层",
        "调试用的临时容器",
      ],
      answer: 0,
      rationale: "CRI 规范定义 sandbox 容器建立共享命名空间环境。",
    },
    {
      id: "w2-3-q6",
      question: "迁移到 containerd 后，镜像格式的影响是？",
      options: [
        "仍支持 OCI/Docker 镜像，无需重新构建",
        "必须重建为 cri 镜像格式",
        "只支持 tar 包",
        "只支持私有镜像仓库",
      ],
      answer: 0,
      rationale: "OCI 镜像兼容 containerd，无需变更构建流程。",
    },
    {
      id: "w2-3-q7",
      question: "CRI gRPC 服务的主要两类 API 是？",
      options: ["RuntimeService 与 ImageService", "Scheduler 与 Controller", "CoreDNS 与 kube-proxy", "CSI 与 CNI"],
      answer: 0,
      rationale: "CRI 定义运行时与镜像管理两组接口。",
    },
    {
      id: "w2-3-q8",
      question: "CRIO/containerd 如何拉取镜像？",
      options: [
        "遵循 OCI Distribution 规范，通过 ImageService 实现镜像拉取与存储",
        "必须依赖 Docker CLI 拉取",
        "只能从本地目录读取",
        "需要在 kubelet 中编写插件",
      ],
      answer: 0,
      rationale: "CRI 镜像服务直接对接 registry，不依赖 Docker Daemon。",
    },
    {
      id: "w2-3-q9",
      question: "kubectl 日志/exec 在 dockershim 移除后依赖什么？",
      options: [
        "kubelet 通过 CRI 提供的 streaming API（如 CRI streaming server）",
        "直接调用 docker logs",
        "访问 etcd",
        "需要安装额外代理",
      ],
      answer: 0,
      rationale: "流式操作由 CRI streaming 端点处理，与 Docker 无关。",
    },
    {
      id: "w2-3-q10",
      question: "运行时必须实现哪个插件才能让 Pod 具备网络？",
      options: ["CNI 插件由 kubelet 调用，与运行时配合完成网络配置", "无需插件，kubelet 自行配置", "CRI 已包含网络能力", "仅需 CSI"],
      answer: 0,
      rationale: "网络仍由 kubelet 调用 CNI 完成，运行时负责容器生命周期。",
    },
    {
      id: "w2-3-q11",
      question: "Dockershim Deprecation FAQ 指出，Kubernetes 1.20 对“使用 Docker 作为 runtime”的变化是什么？",
      options: [
        "kubelet 启动时打印一条警告日志（warning log），除此之外行为不变",
        "立即移除 dockershim，无法再用 Docker runtime",
        "强制把 Docker 镜像转换为 OCI 镜像",
        "必须把所有节点切换到 Windows",
      ],
      answer: 0,
      rationale: "Dockershim FAQ：1.20 的变化是 kubelet 启动时会打印一条 warning log。",
    },
    {
      id: "w2-3-q12",
      question: "Dockershim Deprecation FAQ 中说明 dockershim 被弃用的直接原因之一是？",
      options: [
        "Docker 本身不实现 CRI，Kubernetes 需要通过 dockershim 适配，维护负担大",
        "Docker 镜像格式与 OCI 不兼容",
        "CRI 标准已废弃",
        "containerd 不再维护",
      ],
      answer: 0,
      rationale: "FAQ：CRI 为减轻负担而生，但 Docker 不实现 CRI，导致 dockershim 维护成本高。",
    },
    {
      id: "w2-3-q13",
      question: "Dockershim Deprecation FAQ 对 dockershim 的定位更接近哪项？",
      options: [
        "本来就是临时过渡方案（shim），用于在 CRI 生态成熟前适配 Docker",
        "Kubernetes 永久且唯一推荐的运行时实现",
        "用于把 kubelet 的 gRPC 转换为 HTTP 的长期组件",
        "用于实现 CNI 的网络插件",
      ],
      answer: 0,
      rationale: "FAQ：Dockershim was always intended to be a temporary solution (shim)。",
    },
    {
      id: "w2-3-q14",
      question: "Dockershim Deprecation FAQ 提到，哪些与 dockershim 大量不兼容的特性正在新 CRI runtimes 中实现？",
      options: ["cgroups v2 与 user namespaces", "Helm 与 Operator", "Ingress 与 Service", "etcd watch 与 leader election"],
      answer: 0,
      rationale: "FAQ：提到 cgroups v2 与 user namespaces 等特性在新 CRI runtimes 中实现，移除 dockershim 有利于推进。",
    },
    {
      id: "w2-3-q15",
      question: "CRI-O 官方文档对 CRI-O 的定位更贴近哪项？",
      options: [
        "实现 Kubernetes CRI 的运行时，使用 OCI 兼容 runtime 运行 Pods，作为 Docker runtime 的轻量替代",
        "Kubernetes 的网络插件（CNI）实现",
        "镜像仓库协议（Distribution spec）实现",
        "仅用于 Windows Hyper-V 容器的运行时",
      ],
      answer: 0,
      rationale: "CRI-O 官方站点：CRI-O 是 Kubernetes CRI 的实现，用于使用 OCI 兼容 runtimes 运行 Pods，作为 Docker 的轻量替代。",
    },
    {
      id: "w2-3-q16",
      question: "Dockershim Deprecation FAQ 更新中提到，dockershim 从 Kubernetes 移除后由谁承诺继续维护？",
      options: ["Mirantis 和 Docker", "Canonical 和 VMware", "Red Hat 和 SUSE", "Google 和 Amazon"],
      answer: 0,
      rationale: "FAQ Update：Mirantis and Docker have committed to maintaining the dockershim after it is removed from Kubernetes。",
    },
    {
      id: "w2-3-q17",
      question: "Dockershim Deprecation FAQ：dockershim 移除后，现有通过 `docker build` 构建的镜像会怎样？",
      options: [
        "仍可被所有 CRI 实现运行，镜像不会因此失效",
        "必须全部重建为新的 CRI 镜像格式",
        "只能在 Docker Hub 上运行",
        "只能在 Windows 节点运行",
      ],
      answer: 0,
      rationale: "FAQ：images produced from docker build will work with all CRI implementations。",
    },
    {
      id: "w2-3-q18",
      question: "Dockershim Deprecation FAQ：关于私有镜像（private images）在 CRI runtime 下的拉取，哪项正确？",
      options: [
        "仍可使用 Kubernetes 的 pull secrets（通过 PodSpec 或 ServiceAccount）",
        "必须把私有仓库改造成 Docker Hub",
        "只能通过在节点上手工 docker login",
        "只能关闭镜像鉴权才能拉取",
      ],
      answer: 0,
      rationale: "FAQ：All CRI runtimes support the same pull secrets configuration used in Kubernetes。",
    },
    {
      id: "w2-3-q19",
      question: "Dockershim Deprecation FAQ 对 OCI 的解释里，哪项说法正确？",
      options: [
        "OCI 标准化了镜像与运行时等接口；runc 是 runtime-spec 的实现，也是 containerd/CRI-O 的默认底层 runtime",
        "OCI 是 Kubernetes 专属的网络标准",
        "OCI 只定义 CNI 插件 API",
        "runc 是镜像仓库协议的实现",
      ],
      answer: 0,
      rationale: "FAQ：OCI 维护 image-spec/runtime-spec；runc 实现 runtime-spec，并是 containerd 与 CRI-O 的默认底层 runtime。",
    },
    {
      id: "w2-3-q20",
      question: "Dockershim Deprecation FAQ 给出的“生产中使用其他 runtimes 的例子”中，哪项匹配？",
      options: [
        "OpenShift 4.x 自 2019 年 6 月起在生产使用 CRI-O；kind 长期使用 containerd",
        "Kubernetes 只在生产使用 dockershim，从未验证其他运行时",
        "OpenShift 4.x 使用 Docker Engine 并内置 dockershim",
        "kind 只能使用 Docker Desktop 作为运行时",
      ],
      answer: 0,
      rationale: "FAQ 提到：kind 使用 containerd；OpenShift 4.x 自 2019 年 6 月起在生产使用 CRI-O。",
    },
    {
      id: "w2-3-q21",
      question: "Dockershim Deprecation FAQ 在选择 CRI 实现的建议中提到：如果你现在用 Docker 没问题，迁移到哪个运行时通常更容易？",
      options: ["containerd", "只能继续使用 dockershim", "必须迁移到 Docker Desktop", "必须迁移到 rkt"],
      answer: 0,
      rationale: "FAQ：If Docker is working for you, moving to containerd should be a relatively easy swap。",
    },
    {
      id: "w2-3-q22",
      question: "Dockershim Deprecation FAQ 列出的迁移注意点中，哪一项被明确提到需要评估/调整？",
      options: ["节点脚本是否依赖 docker CLI 或 Docker socket", "必须修改所有 Pod 的 apiVersion", "必须把所有 Deployment 改为 StatefulSet", "必须关闭 RBAC"],
      answer: 0,
      rationale: "FAQ 的迁移注意点列表提到：node provisioning scripts 可能调用 docker 或使用 control socket。",
    },
    {
      id: "w2-3-q23",
      question: "CRI-O 架构说明中，CRI-O 拉取镜像主要使用哪个库？",
      options: ["containers/image", "containerd/content", "Docker Registry V1 client", "etcd clientv3"],
      answer: 0,
      rationale: "CRI-O 官方文档 Architecture：CRI-O uses the containers/image library to pull the image from a container registry。",
    },
    {
      id: "w2-3-q24",
      question: "Dockershim Deprecation FAQ：如果你有系统维护脚本依赖 docker CLI，文档建议用什么工具作为替代？",
      options: ["crictl", "kubectl", "helm", "etcdctl"],
      answer: 0,
      rationale: "FAQ：For system maintenance, you can use the crictl tool as a drop-in replacement。",
    },
    {
      id: "w2-3-q25",
      question: "Dockershim Deprecation FAQ：如果你需要在没有 Docker 的环境里构建镜像，文档列出的可选工具包括？",
      options: ["buildah/kaniko/img 等（不依赖 Docker daemon）", "必须使用 docker build", "只能使用 kubectl apply", "只能使用 runc build"],
      answer: 0,
      rationale: "FAQ 提到：可使用 img、buildah、kaniko、buildkit-cli-for-kubectl 等不依赖 Docker 的构建方案。",
    },
    {
      id: "w2-3-q26",
      question: "Kubelet CRI 文档中，CRI 的定位是？",
      options: ["一个插件接口，使 kubelet 可使用多种运行时而无需重新编译集群组件", "一个新的 CNI 网络模型", "一个替代 etcd 的存储层", "一个用于生成 YAML 的模板语言"],
      answer: 0,
      rationale: "CRI 文档：CRI 是 plugin interface，使 kubelet 可使用多种运行时而无需重新编译集群组件。",
    },
    {
      id: "w2-3-q27",
      question: "CRI 文档指出，kubelet 与容器运行时的通信方式是？",
      options: ["kubelet 作为 gRPC client 连接运行时提供的 endpoint", "kubelet 通过 SSH 执行 docker 命令", "kubelet 通过 HTTP 轮询 registry", "kubelet 直接读写 /var/lib/docker"],
      answer: 0,
      rationale: "CRI 文档：The kubelet acts as a client when connecting to the container runtime via gRPC。",
    },
    {
      id: "w2-3-q28",
      question: "CRI 文档提到，kubelet 通过哪个参数配置容器运行时 endpoint？",
      options: ["--container-runtime-endpoint", "--runtime-class", "--container-runtime", "--cri-endpoint"],
      answer: 0,
      rationale: "CRI 文档：runtime/image service endpoints 可通过 kubelet 的 `--container-runtime-endpoint` 配置。",
    },
    {
      id: "w2-3-q29",
      question: "CRI 文档指出，从 Kubernetes v1.26 起，如果运行时不支持哪一版 CRI API，会导致 kubelet 不注册节点？",
      options: ["v1 CRI API", "v1beta1 CRI API", "v2 CRI API", "HTTP/1.1 CRI API"],
      answer: 0,
      rationale: "CRI 文档：Kubernetes v1.26+ 要求运行时支持 v1 CRI API，否则 kubelet 不会注册节点。",
    },
    {
      id: "w2-3-q30",
      question: "CRI-O 架构中，conmon 进程的作用是？",
      options: [
        "每个容器一个 conmon，用于监控容器、持有 PID1 的 pty、处理日志并记录退出码",
        "用于把镜像 push 到 registry",
        "作为 kubelet 的 gRPC server",
        "作为 CNI 的网络控制器",
      ],
      answer: 0,
      rationale: "CRI-O 官方文档 Architecture：每个容器由独立 conmon 监控，处理日志并记录容器进程退出码。",
    },
  ],
  "w2-4": [
    {
      id: "w2-4-q1",
      question: "OCI Image Specification 主要定义了什么？",
      options: [
        "镜像 manifest/config/layer 的格式与 mediatype",
        "容器运行时的 syscalls 列表",
        "Kubernetes Pod API",
        "系统日志格式",
      ],
      answer: 0,
      rationale: "Image Spec 规定 manifest/config/rootfs 层的描述方式。",
    },
    {
      id: "w2-4-q2",
      question: "OCI Runtime Specification 的核心产物是？",
      options: [
        "config.json 与 rootfs bundle，供 runtime 执行",
        "镜像仓库 API",
        "Helm Chart 定义",
        "CNI 插件列表",
      ],
      answer: 0,
      rationale: "Runtime Spec 描述 bundle 结构与容器进程配置。",
    },
    {
      id: "w2-4-q3",
      question: "OCI Distribution 规范的作用是？",
      options: [
        "定义镜像推送/拉取的 registry HTTP API（兼容 Docker Registry v2）",
        "描述容器日志",
        "提供调度算法",
        "规范 Cgroups",
      ],
      answer: 0,
      rationale: "Distribution 负责 registry 协议，确保镜像分发互操作。",
    },
    {
      id: "w2-4-q4",
      question: "多架构镜像在 OCI 中如何表示？",
      options: [
        "通过 Image Index/Manifest List 聚合不同架构的 manifest",
        "需要单独 tag，无法聚合",
        "使用 Helm Charts",
        "在 config.json 中写多个 os/arch",
      ],
      answer: 0,
      rationale: "Image Index（mediatype application/vnd.oci.image.index.v1+json）用于多架构。",
    },
    {
      id: "w2-4-q5",
      question: "manifest 中的 layer 描述包含哪些字段？",
      options: [
        "mediaType、size、digest 等",
        "CPU/内存限制",
        "容器环境变量",
        "CNI 配置",
      ],
      answer: 0,
      rationale: "Image Spec 定义 layer 描述需包含 mediatype、size、digest。",
    },
    {
      id: "w2-4-q6",
      question: "config.json 的 process 字段主要描述什么？",
      options: [
        "入口命令、环境变量、用户、rlimit 等进程相关配置",
        "镜像仓库地址",
        "日志驱动",
        "Kubernetes Service",
      ],
      answer: 0,
      rationale: "Runtime Spec 的 process 章节涵盖执行参数与权限设置。",
    },
    {
      id: "w2-4-q7",
      question: "OCI 中使用的 digest 通常是哪种算法？",
      options: ["sha256:<hash>", "md5:<hash>", "crc32", "sha1:<hash>"],
      answer: 0,
      rationale: "规范使用 sha256 表达内容寻址。",
    },
    {
      id: "w2-4-q8",
      question: "运行时执行 OCI bundle 的典型步骤是？",
      options: [
        "准备 rootfs，读取 config.json，调用 OCI runtime（如 runc run）创建进程",
        "先推送镜像到 registry 再运行",
        "必须连接 Kubernetes",
        "写入 etcd 后自动运行",
      ],
      answer: 0,
      rationale: "Runtime Spec 描述 runtime 根据 bundle 直接创建容器。",
    },
    {
      id: "w2-4-q9",
      question: "annotations 在 OCI 中的作用是？",
      options: [
        "携带可选元数据键值对，供工具链或平台使用",
        "控制容器 CPU 上限",
        "配置网络策略",
        "替代 manifest 字段",
      ],
      answer: 0,
      rationale: "三大规范均允许 annotations 扩展非标准信息。",
    },
    {
      id: "w2-4-q10",
      question: "为什么 OCI 规范重要？",
      options: [
        "确保镜像、运行时、分发的互操作性，促进生态兼容",
        "用于定义 Kubernetes API",
        "限制容器必须用某个发行版",
        "只为调试用途",
      ],
      answer: 0,
      rationale: "遵循 OCI 使不同工具链可互换，避免厂商锁定。",
    },
    {
      id: "w2-4-q11",
      question: "OCI Image Manifest 规范中，schemaVersion 必须是多少？",
      options: ["2", "1", "3", "由实现自定义"],
      answer: 0,
      rationale: "OCI Image Manifest Specification：schemaVersion MUST be 2。",
    },
    {
      id: "w2-4-q12",
      question: "当 OCI image manifest 显式包含 mediaType 字段时，其值必须是？",
      options: [
        "application/vnd.oci.image.manifest.v1+json",
        "application/vnd.oci.image.index.v1+json",
        "application/vnd.oci.descriptor.v1+json",
        "application/vnd.docker.distribution.manifest.v1+json",
      ],
      answer: 0,
      rationale: "OCI Image Manifest Specification：mediaType 字段（若使用）MUST 为 application/vnd.oci.image.manifest.v1+json。",
    },
    {
      id: "w2-4-q13",
      question: "OCI Image Index 的 mediaType 是？",
      options: [
        "application/vnd.oci.image.index.v1+json",
        "application/vnd.oci.image.manifest.v1+json",
        "application/vnd.oci.image.config.v1+json",
        "application/vnd.oci.descriptor.v1+json",
      ],
      answer: 0,
      rationale: "OCI Image Index Specification：该结构定义的 media type 为 application/vnd.oci.image.index.v1+json。",
    },
    {
      id: "w2-4-q14",
      question: "在 OCI Image Index 的 manifests 条目里，如果提供 platform，对应哪些字段是必需的？",
      options: ["architecture 与 os", "variant 与 features", "os.version 与 os.features", "cpu 与 memory"],
      answer: 0,
      rationale: "OCI Image Index Specification：platform 中 architecture 与 os 为 REQUIRED，其余多为 OPTIONAL/保留字段。",
    },
    {
      id: "w2-4-q15",
      question: "OCI Image Manifest 对 layers 的顺序要求是？",
      options: [
        "layers[0] 必须是 base layer，后续 layers 按堆叠顺序依次排列",
        "layers 顺序无关，运行时会自动排序",
        "layers 必须按大小排序",
        "layers 必须按 digest 字典序排序",
      ],
      answer: 0,
      rationale: "OCI Image Manifest Specification：要求 base layer 在 index 0，后续按 stack order 排列。",
    },
    {
      id: "w2-4-q16",
      question: "OCI Descriptor 规范中，一个 descriptor 的必需字段组合是？",
      options: ["mediaType、digest、size", "name、tag、digest", "url、checksum、size", "platform、os、arch"],
      answer: 0,
      rationale: "OCI Descriptor 规范：mediaType、digest、size 都是 REQUIRED properties。",
    },
    {
      id: "w2-4-q17",
      question: "OCI Descriptor 的 digest 字符串格式要求更贴近哪项？",
      options: ["<algorithm>:<encoded>", "<encoded>@<algorithm>", "<hash>", "<repo>:<tag>"],
      answer: 0,
      rationale: "OCI Descriptor 规范：digest grammar 为 algorithm \":\" encoded。",
    },
    {
      id: "w2-4-q18",
      question: "OCI Descriptor 的 Registered algorithms 中，哪项是实现必须支持用于校验的？",
      options: ["sha256", "sha1", "md5", "crc32"],
      answer: 0,
      rationale: "OCI Descriptor 规范：Implementations MUST implement SHA-256 digest verification。",
    },
    {
      id: "w2-4-q19",
      question: "当算法标识为 sha256 时，digest 的编码部分（encoded）必须满足什么形式？",
      options: ["64 位小写十六进制（[a-f0-9]{64}）", "32 位十六进制（允许大写）", "64 位 base64", "任意长度字符串均可"],
      answer: 0,
      rationale: "OCI Descriptor 规范：sha256 的 encoded MUST match /[a-f0-9]{64}/，且 MUST NOT 使用大写 A-F。",
    },
    {
      id: "w2-4-q20",
      question: "关于 OCI Descriptor 的 data 字段，哪项符合规范的 Embedded Content 说明？",
      options: [
        "data 必须是 base64，解码后内容需与被引用内容一致；registry 不应擅自填充已上传 manifest 的 data 以免改变内容标识",
        "data 用于存放明文密码，运行时自动注入",
        "data 可以是任意 JSON，digest 无需校验",
        "data 只能由 registry 在 pull 时追加，client 不能写",
      ],
      answer: 0,
      rationale: "OCI Descriptor 规范：data 为 base64；registry MUST NOT 随意填充 uploaded manifests 的 data，否则会改变 content identifier。",
    },
    {
      id: "w2-4-q21",
      question: "OCI annotations 的通用规则中，哪项正确？",
      options: [
        "annotations 是 string→string 的 map；键应使用反向域名命名；未知 key 不能导致报错",
        "annotations 只能是数组，元素必须是 URL",
        "annotations 允许重复 key 以表达优先级",
        "annotations 的 value 必须是非空字符串",
      ],
      answer: 0,
      rationale: "OCI Annotations 规范：annotations 为字符串键值对，键唯一；value 可为空；消费者 MUST NOT 因未知 key 报错。",
    },
    {
      id: "w2-4-q22",
      question: "OCI annotations 规范中，哪个前缀是保留给 OCI 规范定义键的，扩展方不得占用？",
      options: ["org.opencontainers", "com.example", "io.kubernetes", "cn.example"],
      answer: 0,
      rationale: "OCI Annotations 规范：前缀 org.opencontainers（以及 org.opencontainers.image 子命名空间）为 OCI 保留。",
    },
    {
      id: "w2-4-q23",
      question: "以下哪个是 OCI 预定义的 annotation key，用于表示镜像构建时间（RFC 3339）？",
      options: [
        "org.opencontainers.image.created",
        "org.opencontainers.image.built_at",
        "org.opencontainers.image.timestamp",
        "org.opencontainers.created",
      ],
      answer: 0,
      rationale: "OCI Annotations 规范：org.opencontainers.image.created 表示镜像构建时间，需符合 RFC 3339。",
    },
    {
      id: "w2-4-q24",
      question: "OCI Image Config 的 Env 字段中，每个条目的格式是？",
      options: ["VARNAME=VARVALUE", "VARNAME:VARVALUE", "export VARNAME VARVALUE", "{\"name\":\"VARNAME\",\"value\":\"VARVALUE\"}"],
      answer: 0,
      rationale: "OCI Image Config 规范：Env entries are in the format of VARNAME=VARVALUE。",
    },
    {
      id: "w2-4-q25",
      question: "OCI Image Config 关于 Cmd/Entrypoint 的语义：如果 Entrypoint 未指定，Cmd 应如何解释？",
      options: ["Cmd 的第一个元素应被视为要执行的可执行文件", "Cmd 会被忽略，必须由运行时指定可执行文件", "Cmd 只能包含环境变量，不能包含命令", "Cmd 必须是单个字符串并由 shell 解析"],
      answer: 0,
      rationale: "OCI Image Config 规范：If an Entrypoint is not specified, first entry of Cmd SHOULD be interpreted as executable to run。",
    },
    {
      id: "w2-4-q26",
      question: "OCI Image Config 的 rootfs.type 必须是什么值？",
      options: ["layers", "overlay", "unionfs", "snapshot"],
      answer: 0,
      rationale: "OCI Image Config 规范：rootfs.type MUST be set to layers，遇到未知值实现 MUST 报错。",
    },
    {
      id: "w2-4-q27",
      question: "OCI Distribution Spec：拉取 manifest 的 URL 形如 `/v2/<name>/manifests/<reference>`，其中 <reference> 必须是？",
      options: ["digest 或 tag", "任意 URL", "仅能是 tag", "仅能是镜像 ID（无算法前缀）"],
      answer: 0,
      rationale: "OCI Distribution Spec：<reference> MUST be either the digest of the manifest or a tag。",
    },
    {
      id: "w2-4-q28",
      question: "OCI Distribution Spec 对拉取 manifest 的内容协商建议是？",
      options: [
        "client 应在 Accept 里声明支持的 manifest 类型；若返回 manifest 含 mediaType 字段，client 应校验其与 Content-Type 一致",
        "client 不应发送 Accept；registry 固定返回一种类型",
        "Content-Type 只用于展示，client 不应校验",
        "manifest 的 mediaType 必须与 Accept 不同以触发降级",
      ],
      answer: 0,
      rationale: "OCI Distribution Spec：client SHOULD include Accept；且 manifest 有 mediaType 时，client SHOULD reject unless it matches Content-Type。",
    },
    {
      id: "w2-4-q29",
      question: "OCI Distribution Spec：对一个存在的 manifest 执行 GET 成功时，响应码与建议返回的 digest 头分别是？",
      options: ["200 OK；Docker-Content-Digest", "201 Created；ETag", "204 No Content；Content-MD5", "302 Found；Location"],
      answer: 0,
      rationale: "OCI Distribution Spec：GET existing manifest MUST return 200 OK，成功响应 SHOULD contain Docker-Content-Digest。",
    },
    {
      id: "w2-4-q30",
      question: "OCI Runtime Spec 的 runtime state 中，status 可能的标准值包括？",
      options: ["creating/created/running/stopped", "pending/succeeded/failed/unknown", "init/ready/terminated", "starting/healthy/unhealthy/stopped"],
      answer: 0,
      rationale: "OCI Runtime Spec：status MAY be one of creating, created, running, stopped（实现也可扩展其他值）。",
    },
  ],
}
